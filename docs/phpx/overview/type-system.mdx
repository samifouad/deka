---
title: "Type System"
description: "How to model data with interfaces, structs, and typed functions in PHPX."
section: "phpx"
category: "overview"
categoryLabel: "Overview"
categoryOrder: 0
---

PHPX typing is designed to make contracts explicit at boundaries and keep runtime behavior predictable.

## Where to add types first

Start with:

- function parameters and return types
- component props
- interfaces for public contracts
- structs for data models

This gives the best signal in LSP and catches most migration mistakes early.

## Function boundary typing

```phpx
function add($a: int, $b: int): int {
  return $a + $b
}

echo add(20, 22)
```

Expected output:

```text
42
```

Common mistake:

```phpx
echo add("20", 22)
```

Expected behavior:

```text
Type error: parameter $a expects int.
```

## Interface contracts for props/objects

```phpx
interface FullNameProps {
  $first: string
  $last: string
  $age: int
}

function FullName({ $first, $last, $age }: FullNameProps): string {
  return $first . " " . $last . " (" . $age . ")"
}

echo FullName({ first: "Sami", last: "Fouad", age: 31 })
```

Expected output:

```text
Sami Fouad (31)
```

Common mistake:

```phpx
echo FullName({ first: "Sami", last: "Fouad" })
```

Expected behavior:

```text
Type error: missing required prop 'age'.
```

## Structs for data modeling

```phpx
struct Package {
  $name: string
  $downloads: int = 0
  $owner: string
}

$pkg = Package { name: "router", downloads: 12, owner: "@samifou.ad" }
echo $pkg.name . ":" . $pkg.downloads . ":" . $pkg.owner
```

Expected output:

```text
router:12:@samifou.ad
```

## Optional and fallible values

Use `Option<T>` for maybe-present values and `Result<T, E>` for operations that can fail.

```phpx
function displayEmail($value: Option<string>): string {
  return match ($value) {
    Some($email) => $email
    None => "no-email"
  }
}

echo displayEmail(None)
```

Expected output:

```text
no-email
```

```phpx
function parsePort($value: string): Result<int, string> {
  if (!isNumeric($value)) {
    return Err("invalid-port")
  }
  return Ok(toInt($value))
}
```

## Inference vs explicit annotation

Use inference for obvious locals:

```phpx
$total = 3 + 4
```

Use explicit annotations at boundaries:

```phpx
function run($port: int): Result<string, string> {
  return Ok("ready")
}
```

PHPX enforces parameter typing in user files. Untyped parameters (for example `function run($port)`) are rejected; use `'$name: Type'` syntax.

## Migration pattern from PHP

PHP:

```php
function user_label($u) {
  return $u["name"];
}
```

PHPX:

```phpx
interface UserProps {
  $name: string
}

function userLabel({ $name }: UserProps): string {
  return $name
}
```

## Why this helps

- errors move earlier from runtime to authoring time
- signatures become stable refactor points
- prop/key mismatches are surfaced where they are called
