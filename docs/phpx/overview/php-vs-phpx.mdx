---
title: "PHP vs PHPX Differences"
description: "A detailed comparison guide for PHP developers moving to PHPX."
section: "phpx"
category: "overview"
categoryLabel: "Overview"
categoryOrder: 0
---


This page is a practical migration reference from PHP to PHPX.
It focuses on day-to-day differences you will hit first: data modeling, typing, modules, error handling, rendering, and database usage.

## 1) Modules and global scope

PHP commonly uses `include`/`require` and file-level globals.
PHPX uses explicit `import`/`export` and does not assume symbols are global.

PHP:

```php
require "helpers.php";
echo format_name($name);
```

PHPX:

```phpx
import { formatName } from "@/helpers/name"
echo formatName($name)
```

Why this matters:

- dependencies are explicit
- dead imports can be validated
- refactors are safer because usage is discoverable

## 2) Data modeling: class-style OOP vs structs + interfaces

PHP traditionally leans on classes, inheritance, and nullable fields.
PHPX is designed around structs, interfaces, and composition.

PHP class model:

```php
class User {
  public function __construct(
    public string $name,
    public ?string $email = null
  ) {}
}
```

PHPX struct + interface model:

```phpx
interface UserShape {
  $name: string
  $email: Option<string>
}

struct User {
  $name: string
  $email: Option<string> = None
}
```

Why this matters:

- struct fields define stable data shape
- interfaces define function/component contracts
- composition is preferred over class inheritance

## 3) Nullability: `null` vs `Option<T>`

PHP uses `null` heavily.
PHPX prefers explicit optionality with `Option<T>` (`Some`/`None`).

PHP:

```php
$email = $user["email"] ?? null;
if ($email === null) {
  echo "missing";
}
```

PHPX:

```phpx
$email: Option<string> = $user.email

match ($email) {
  Some($value) => echo $value
  None => echo "missing"
}
```

Why this matters:

- call sites must handle missing values
- fewer hidden null bugs

## 4) Typing model and coercion

PHP often allows coercion unless strict mode is enabled.
PHPX expects typed boundaries and catches mismatches earlier.

PHP:

```php
function total($a, $b) { return $a + $b; }
echo total("1", 2); // typically coerced
```

PHPX:

```phpx
function total($a: int, $b: int): int {
  return $a + $b
}
```

Expected behavior:

```text
Passing string where int is required is a type error.
```

## 5) Error handling: exceptions vs `Result<T, E>`

PHP frequently throws/catches exceptions.
PHPX prefers `Result` flows so success/failure is explicit.

PHP:

```php
function parseVersion(string $v): int {
  if (!is_numeric($v)) {
    throw new Exception("invalid version");
  }
  return (int)$v;
}
```

```phpx
function parseVersion($value: string): Result<int, string> {
  if (!isNumeric($value)) {
    return Err("invalid version")
  }
  return Ok(toInt($value))
}

$result = parseVersion("v1")
if (isErr($result)) {
  echo "invalid version"
  return
}
echo unwrap($result)
```

Why this matters:

- failures are handled in normal control flow
- fewer hidden throw paths

## 6) Functions and components receive typed objects

In PHPX component-style code, props are a typed object and can be destructured in parameters.

```phpx
interface NameProps {
  $name: string
  $age: int
}

function FullName({ $name, $age }: NameProps): string {
  return $name . " (" . $age . ")"
}
```

JSX usage:

```phpx
<FullName name="Sami" age={31} />
```

If `name` or `age` is missing/wrong type, diagnostics should point to that call site.

## 7) Rendering model: PHP templates vs PHPX components

PHP often mixes template and server code with direct `echo`.
PHPX supports frontmatter + JSX/components and explicit hydration when needed.

PHP style:

```php
<h1><?= htmlspecialchars($title) ?></h1>
```

PHPX style:

```phpx
---
interface HeroProps { $title: string }
function Hero({ $title }: HeroProps) {
  return <h1>{$title}</h1>
}
---
<Hero title="Linkhash" />
```

## 8) Arrays and object shapes

PHP arrays are often used as mixed maps/lists.
PHPX supports arrays, but strongly typed shapes are preferred for contracts.

PHP:

```php
$pkg = ["name" => "router", "downloads" => 42];
echo $pkg["name"];
```

PHPX:

```phpx
interface PackageProps {
  $name: string
  $downloads: int
}

function label({ $name, $downloads }: PackageProps): string {
  return $name . ":" . $downloads
}
```

## 9) Database model direction

PHP ecosystems often use ActiveRecord/class-heavy ORMs.
PHPX direction is typed model definitions + generated client APIs.

Example usage:

```phpx
import { db } from "@/db"

$packages = db.package.findMany({
  where: { visibility: "public" },
  orderBy: { downloads: "desc" },
  limit: 20
})
```

## 10) Concurrency model: sync PHP vs async-first PHPX

PHP request code is typically synchronous and blocking.
PHPX is designed for `async`/`await` and `Promise<T>`.

PHP:

```php
$rows = $db->query("select * from packages");
foreach ($rows as $row) {
  echo $row["name"];
}
```

PHPX:

```phpx
import { query } from "db/postgres"

$result = await query($db, "select name from packages")
if (isErr($result)) {
  echo "query failed"
  return
}

foreach ($result.value.rows as $row) {
  echo $row.name
}
```

Runtime rule:

- `.phpx` supports `async`/`await` (including top-level await).
- `.php` remains synchronous for compatibility.

## Migration checklist

1. Move leaf modules to PHPX first.
2. Replace implicit globals with explicit imports.
3. Introduce interfaces for function/component boundaries.
4. Replace nullable contracts with `Option<T>`.
5. Replace exception-first flows with `Result`.
6. Move class-style data carriers to structs.
7. Enable LSP diagnostics and fix missing/wrong props early.
