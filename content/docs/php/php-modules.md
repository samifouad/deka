---
category: "php-modules"
categoryLabel: "General"
categoryOrder: 90
---
# PHP Module System (php_modules + .phpx)

This document defines the intended behavior for the PHP module system in deka.

## Goals
- Keep default PHP behavior intact for normal `.php` files.
- Add a separate, ESM-style module system for `.phpx`.
- Expose a single, explicit bridge to userland via `php_modules/deka.php`.
- Allow privileged APIs only inside `.phpx`.
- Make tree-shaking possible by relying on static `import`/`export`.

## Non-goals
- No Composer-style autoloading inside `php_modules/`.
- No implicit scanning of userland `.php` for module exports.

## Terms
- **Userland**: traditional `.php` executed by the runtime.
- **Module world**: `.phpx` files under `php_modules/`.
- **Bridge**: `php_modules/deka.php`, the only public entry for userland.
- **Privileged APIs**: host-backed APIs available only to `.phpx`.

## Runtime behavior
1) The runtime always auto-includes `php_modules/deka.php` before user code.
   - This is the only magic. No other autoload system exists.
2) Module mode is enabled for `.phpx` entrypoints or when a `.php` file uses `import`.
3) The project root is discovered by locating `deka.lock`.
   - `php_modules/` must live alongside `deka.lock`.
   - Set `PHPX_MODULE_ROOT=/path/to/project` for a global user-level lock+modules root.
4) When module mode is enabled, the runtime always keeps a cache updated.
   - `.phpx` files are parsed and compiled into a module registry.
   - Compiled artifacts are stored under `php_modules/.cache/phpx/`.
   - Cache metadata (hash + paths) is written into `deka.lock` under `php.cache`.
   - The registry maps module exports to callable functions (lazy-loaded).
4) The stdlib module list comes from `php_modules/stdlib.json` (hand-maintained).
   - Used to build a lazy registry even when module mode is disabled.

## Module resolution (phpx only)
- Relative paths: `import { foo } from './string.phpx'`
- Package-style: `import { foo } from 'string'` resolves to
  `php_modules/string/index.phpx`
- Import/export is only valid in `.phpx`, except `.php` may opt-in with top-of-file `import`.
- Re-exports are supported: `export { foo } from './bar.phpx'`.
- Wasm imports opt in via `as wasm`: `import { greet } from '@user/hello' as wasm;`
- Wasm modules may ship `module.d.phpx` type stubs (generated by `wit-phpx`) for PHPX tooling.

## Wasm module manifest (deka.json)
For wasm modules under `php_modules/`, `deka.json` is required.

**Runtime fields (used by the host loader):**
- `module`: wasm filename (default `module.wasm`).
- `instance`: only `per_request` is supported right now.
- `abi`: currently `deka-json` (JSON-in/JSON-out).

**Tooling fields (used by stub generator + PHPX typecheck):**
- `wit`: WIT file path (for stub generation).
- `records`: `struct` or `object` for WIT record mapping in stubs.
- `world`: select a WIT world when multiple exist.
- `interfacePrefix`: when false, exported interface functions are flattened.
- `stubs`: output path for `.d.phpx` (relative to module root).

## Wasm quickstart (recommended)
```sh
deka wasm init @user/hello
deka wasm build @user/hello
```

```php
import { greet } from '@user/hello' as wasm;
echo greet("Sami");
```

## Bridge behavior (deka.php)
`deka.php` defines public namespaces and functions that delegate to `.phpx`.

Example sketch:
```php
<?php
// php_modules/deka.php
namespace Deka\String;

function get_str_func($value) {
    return __deka_call('string/get_str_func', [$value]);
}
```

The `__deka_call` builtin is only available inside the bridge or in `.phpx`.

Bridge notes:
- Global stdlib functions are declared from `$GLOBALS['__DEKA_PHPX_STDLIB']`.
- The list is explicit and versioned; update it when adding new stdlib modules
  (json, mysql, pgsql, etc).
- Internal helpers (e.g., `__deka_*`) stay unexposed.
- PHPâ†”PHPX boundary coercions (lenient for legacy PHP):
  - `null` maps to `Option::None` for `Option<T>` parameters.
  - Arrays / stdClass are accepted for `Object`/object-shape and `struct` params
    (extra keys are ignored).
  - `Option<T>` return values map to `null` (None) or the inner value (Some).
  - `Result<T,E>` return values map to `T` on Ok or
    `['ok' => false, 'error' => ...]` on Err.

## Privileged APIs
Only `.phpx` can access privileged host APIs. Normal `.php` cannot.

Initial categories (Node-like):
- fs
- net/http
- process
- env
- timers
- crypto

## Error behavior
- Missing `php_modules/deka.php` => hard error + `deka init` hint.
- `import`/`export` in `.php` => syntax error unless the `import` is at the very
  top of the file (before any code, `namespace`, `use`, `include`, or `require`).
- Privileged API from `.php` => runtime error.
- `phpx_import()` failures route through `__phpx_fail()`:
  - `panic($msg)` if available (PHPX)
  - otherwise `trigger_error($msg)`
  - otherwise `echo $msg`
  - returns `null` in all cases

## Build/dev pipeline (intended)
- Dev/run: compile `.phpx` on first use and auto-refresh the cache.
- Cache artifacts live in `php_modules/.cache/phpx/` and are tracked in `deka.lock`.
- Build: precompile `.phpx` and ship a module registry alongside runtime (later).

## Example layout
```
project/
  index.php
  php_modules/
    deka.php
    string/
      index.phpx
```

## Prototype notes (current)
- Module discovery scans `php_modules/` for `.phpx` files at runtime.
- .phpx supports `import { foo } from './bar.phpx'` and `export function foo()`.
- Imports are validated and a simple dependency graph is built (cycles error).
- .phpx exports compile into per-module namespaces (php-rs namespace + `use` resolution now supported).
- The bridge file `php_modules/deka.php` is auto-included and binds the stdlib list.
- The JSON extension is now provided in `php_modules/json/index.phpx` with a pure phpx parser/encoder.
- Result helpers live in `php_modules/core/result.phpx`, and `json_decode_result` uses them.
- Option helpers live in `php_modules/core/option.phpx`, and `panic()` is provided by `php_modules/deka.php`.
- Core primitives are now available in `php_modules/core/` (reader, byte, bytes, num).
- phpx function signatures may include type annotations, which are stripped at runtime (see `PHPX_TYPES.md`).
- Namespace resolution matches PHP semantics (imports + unqualified function/const fallback to global).
