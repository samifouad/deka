---
title: "Async and Await"
description: "Use Promise<T>, await, top-level await, and Suspense in PHPX."
section: "phpx"
category: "general"
categoryLabel: "Language"
categoryOrder: 2
version: "latest"
---

PHPX is async-first. Use `async`/`await` and `Promise<T>` for I/O-heavy code.

## Basic async function

```phpx
async function loadVersion(): Promise<string> {
  return "1.0.0"
}

$v = await loadVersion()
echo $v
```

Expected output:

```text
1.0.0
```

## Top-level await

Top-level await is allowed in `.phpx` modules and frontmatter.

```phpx
import { readFile } from "fs"

$result = await readFile("package.json")
if (isErr($result)) {
  echo "failed"
  return
}
echo "ok"
```

### Cycle caveat

If two modules depend on each other and both use top-level await in initialization, module loading fails with a deterministic cycle error.

Keep initialization acyclic, or move async setup behind explicit functions.

## Promise and Result together

Recoverable async failures should use `Promise<Result<T, E>>`.

```phpx
import { queryOne } from "db/postgres"

async function findPackage($db, $name: string): Promise<Result<Object, string>> {
  return await queryOne($db, "select * from packages where name = $1", [$name])
}
```

## Async JSX with Suspense

```phpx
import { jsx, jsxs, Suspense } from "component/core"
import { renderToString, renderToStringAsync } from "component/dom"

async function Hero($props): Promise<mixed> {
  return <h1>{$props.title}</h1>
}

$sync = renderToString(
  <Suspense fallback={<p>Loading</p>}>
    <Hero title="Hello" />
  </Suspense>
)
echo $sync . "\n"

$full = await renderToStringAsync(
  <Suspense fallback={<p>Loading</p>}>
    <Hero title="Hello" />
  </Suspense>
)
echo $full . "\n"
```

Expected output:

```text
<p>Loading</p>
<h1>Hello</h1>
```

## PHP vs PHPX behavior

- `.phpx`: async/await + top-level await are supported.
- `.php`: async/await and top-level await are not supported.

This keeps regular PHP compatibility while enabling async-first workflows in PHPX.
