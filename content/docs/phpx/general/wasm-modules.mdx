---
title: "Wasm Modules and `import ... as wasm`"
description: "Use Wasm modules from PHPX with a WIT ABI contract to call code written in other languages."
section: "phpx"
category: "general"
categoryLabel: "Language"
categoryOrder: 1
version: "latest"
---

PHPX supports importing Wasm modules directly.
This enables modules authored in Rust (and other languages targeting Wasm) while keeping PHPX app code clean.

## Why this exists

- lets PHPX use high-performance native logic
- supports multi-language module authoring
- keeps app-level API ergonomic in PHPX

## Syntax

```phpx
import { hashPackage } from "@user/package-hasher" as wasm

echo hashPackage("router")
```

The `as wasm` clause tells the runtime to resolve and invoke the import through the Wasm bridge instead of a PHPX source module.

## ABI model

The intended interface contract is WIT-based:

- module exports are described by a WIT interface
- host/runtime maps PHPX values to ABI values
- return values are converted back to native PHPX values

This gives typed boundaries across languages without exposing low-level host internals to user code.

## Practical flow

1. Write module code in Rust (or another Wasm-target language).
2. Define exported interface with WIT.
3. Build `.wasm` artifact and package metadata.
4. Import in PHPX with `as wasm`.

## Example: hash helper from Wasm

```phpx
import { sha256Hex } from "@user/crypto-kit" as wasm

$digest = sha256Hex("linkhash")
echo $digest
```

Expected output:

```text
<64-char hex digest>
```

## End-to-end hello world (Rust -> Wasm -> PHPX)

This is a minimal flow you can adapt for real modules.

### 1) Rust source

`src/lib.rs`

```rust
#[unsafe(no_mangle)]
pub extern "C" fn hello_len() -> i32 {
    11
}

#[unsafe(no_mangle)]
pub extern "C" fn hello_ptr() -> *const u8 {
    b"hello world".as_ptr()
}
```

### 2) WIT interface (contract)

`wit/world.wit`

```wit
package deka:hello

world hello-world {
  export hello: func() -> string
}
```

The runtime uses this interface contract to map ABI values to PHPX values.

### 3) Build Wasm artifact

```bash
cargo build --release --target wasm32-unknown-unknown
```

Output artifact:

```text
target/wasm32-unknown-unknown/release/hello_world.wasm
```

### 4) Publish/place module for resolver

Example project-local module path:

```text
php_modules/@user/hello-world/module.wasm
php_modules/@user/hello-world/module.wit
```

Exact package layout can vary by your module registry conventions, but the resolver must find both artifact and interface metadata.

### 5) Import and call from PHPX

```phpx
import { hello } from "@user/hello-world" as wasm

echo hello()
```

Expected output:

```text
hello world
```

### 6) Optional PHPX wrapper

You can wrap Wasm imports in a normal PHPX module to keep app code stable:

```phpx
import { hello } from "@user/hello-world" as wasm

export function greeting(): string {
  return hello()
}
```

## Notes

- Keep Wasm modules stateless where possible for safer request isolation.
- Prefer explicit typed signatures in exported functions.
- Use PHPX wrappers if you want to expose a more domain-specific API to app code.
