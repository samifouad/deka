import { result_ok, result_err } from 'core/result';
import { byte_is_digit, byte_is_hex, byte_is_whitespace } from 'core/byte';
import { num_parse_int, num_parse_float } from 'core/num';
import { bridge } from 'core/bridge';

const __DEKA_JSON_ERROR_KEY = '__deka_json_last_error';
const __DEKA_JSON_ERROR_MSG_KEY = '__deka_json_last_error_msg';

function reader_new($input) {
    return [
        'input' => '' . $input,
        'pos' => 0,
        'len' => strlen('' . $input),
    ];
}

function reader_eof($reader) {
    return $reader['pos'] >= $reader['len'];
}

function reader_peek_byte($reader) {
    if (reader_eof($reader)) {
        return null;
    }
    return ord($reader['input'][$reader['pos']]);
}

function reader_next_byte(&$reader) {
    $byte = reader_peek_byte($reader);
    if ($byte !== null) {
        $reader['pos'] += 1;
    }
    return $byte;
}

function reader_skip_ws(&$reader) {
    while (!reader_eof($reader)) {
        $byte = reader_peek_byte($reader);
        if ($byte === null || !byte_is_whitespace($byte)) {
            return;
        }
        $reader['pos'] += 1;
    }
}

function __deka_json_to_assoc($value) {
    $current = $value;
    for ($i = 0; $i < 16; $i += 1) {
        if (is_object($current)) {
            $arr = (array) $current;
            if (count($arr) === 1 && array_key_exists(0, $arr) && (is_object($arr[0]) || is_array($arr[0]))) {
                $current = $arr[0];
                continue;
            }
            if (count($arr) === 1 && array_key_exists('0', $arr) && (is_object($arr['0']) || is_array($arr['0']))) {
                $current = $arr['0'];
                continue;
            }
            $current = $arr;
            continue;
        }
        if (is_array($current)) {
            $out = [];
            $is_entries = true;
            foreach ($current as $entry) {
                if (!is_array($entry) || count($entry) !== 2 || !is_string($entry[0])) {
                    $is_entries = false;
                    break;
                }
                $out[$entry[0]] = $entry[1];
            }
            if ($is_entries) {
                return $out;
            }
            return $current;
        }
        return null;
    }
    return null;
}

/// docid: phpx/json/json_encode()
/// <Function name="json_encode">
///   <Description>
///     Encodes a PHP value into a JSON string. Returns false when encoding fails
///     (for example, unsupported types or NaN/Infinity).
///   </Description>
///   <Parameter name="$value" type="mixed" required="true" typeLink="/docs/php/types/mixed">
///     The value to encode.
///   </Parameter>
///   <Parameter name="$flags" type="int" required="false" typeLink="/docs/php/types/int">
///     The value to encode.
///   </Parameter>
///   <Parameter name="$depth" type="int" required="false" typeLink="/docs/php/types/int">
///     The value to encode.
///   </Parameter>
///   <ReturnType type="string" typeLink="/docs/php/types/string" />
/// </Function>
export function json_encode($value, $flags = 0, $depth = 512) {
    __deka_json_reset_error();
    $host = __deka_json_to_assoc(bridge('json', 'encode', { value: $value, flags: $flags, depth: $depth }));
    if (is_array($host) && array_key_exists('ok', $host)) {
        if ($host['ok'] && array_key_exists('json', $host) && is_string($host['json'])) {
            return $host['json'];
        }
        __deka_json_fail(JSON_ERROR_SYNTAX);
        return false;
    }
    $out = __deka_json_encode_value($value, $depth);
    if (__deka_json_has_error()) {
        return false;
    }
    return $out;
}

/// docid: phpx/json/json_decode()
/// <Function name="json_decode">
///   <Description>
///     Decodes a JSON string into a PHP value. Returns null on failure and
///     sets the JSON error code/message.
///   </Description>
///   <Parameter name="$json" type="string" typeLink="/docs/php/types/string">
///     The JSON input string.
///   </Parameter>
///   <Parameter name="$assoc" type="bool" typeLink="/docs/php/types/bool">
///     When true, objects are returned as associative arrays.
///   </Parameter>
///   <Parameter name="$depth" type="int" typeLink="/docs/php/types/int">
///     Maximum nesting depth.
///   </Parameter>
///   <ReturnType type="mixed" typeLink="/docs/php/types/mixed" />
/// </Function>
export function json_decode($json, $assoc = false, $depth = 512, $flags = 0) {
    __deka_json_reset_error();
    $host = __deka_json_to_assoc(bridge('json', 'decode', { json: '' . $json, assoc: $assoc, depth: $depth, flags: $flags }));
    if (is_array($host) && array_key_exists('ok', $host)) {
        if ($host['ok']) {
            if (array_key_exists('value', $host)) {
                return $host['value'];
            }
            return null;
        }
        __deka_json_fail(JSON_ERROR_SYNTAX);
        return null;
    }
    $json = '' . $json;
    $reader = reader_new($json);
    reader_skip_ws($reader);
    $value = __deka_json_parse_value($reader, $assoc, $depth);
    if (__deka_json_has_error()) {
        return null;
    }
    reader_skip_ws($reader);
    if (!reader_eof($reader)) {
        __deka_json_fail(JSON_ERROR_SYNTAX);
        return null;
    }
    return $value;
}

/// docid: phpx/json/json_decode_result()
/// <Function name="json_decode_result">
///   <Description>
///     Decodes JSON and returns a Result-style array with ok/value or ok/error.
///   </Description>
///   <Parameter name="$json" type="string" typeLink="/docs/php/types/string">
///     The JSON input string.
///   </Parameter>
///   <Parameter name="$assoc" type="bool" typeLink="/docs/php/types/bool">
///     When true, objects are returned as associative arrays.
///   </Parameter>
///   <Parameter name="$depth" type="int" typeLink="/docs/php/types/int">
///     Maximum nesting depth.
///   </Parameter>
///   <ReturnType type="array" typeLink="/docs/php/types/array" />
/// </Function>
export function json_decode_result($json, $assoc = false, $depth = 512, $flags = 0) {
    $value = json_decode($json, $assoc, $depth, $flags);
    $code = json_last_error();
    if ($code === JSON_ERROR_NONE) {
        return result_ok($value);
    }
    return result_err([
        'code' => $code,
        'message' => json_last_error_msg(),
    ]);
}

/// docid: phpx/json/json_last_error()
/// <Function name="json_last_error">
///   <Description>
///     Returns the last JSON error code.
///   </Description>
///   <ReturnType type="int" typeLink="/docs/php/types/int" />
/// </Function>
export function json_last_error() {
    if (array_key_exists(__DEKA_JSON_ERROR_KEY, $GLOBALS)) {
        return $GLOBALS[__DEKA_JSON_ERROR_KEY];
    }
    return defined('JSON_ERROR_NONE') ? JSON_ERROR_NONE : 0;
}

/// docid: phpx/json/json_last_error_msg()
/// <Function name="json_last_error_msg">
///   <Description>
///     Returns the last JSON error message.
///   </Description>
///   <ReturnType type="string" typeLink="/docs/php/types/string" />
/// </Function>
export function json_last_error_msg() {
    if (array_key_exists(__DEKA_JSON_ERROR_MSG_KEY, $GLOBALS)) {
        return $GLOBALS[__DEKA_JSON_ERROR_MSG_KEY];
    }
    return __deka_json_error_message(json_last_error());
}

/// docid: phpx/json/json_validate()
/// <Function name="json_validate">
///   <Description>
///     Validates a JSON string without returning the decoded value.
///   </Description>
///   <Parameter name="$json" type="string" typeLink="/docs/php/types/string">
///     The JSON input string.
///   </Parameter>
///   <Parameter name="$depth" type="int" typeLink="/docs/php/types/int">
///     Maximum nesting depth.
///   </Parameter>
///   <ReturnType type="bool" typeLink="/docs/php/types/bool" />
/// </Function>
export function json_validate($json, $depth = 512, $flags = 0) {
    __deka_json_reset_error();
    $host = __deka_json_to_assoc(bridge('json', 'validate', { json: '' . $json, depth: $depth, flags: $flags }));
    if (is_array($host) && array_key_exists('ok', $host) && $host['ok']) {
        if (array_key_exists('valid', $host) && $host['valid']) {
            return true;
        }
        __deka_json_fail(JSON_ERROR_SYNTAX);
        return false;
    }
    $json = '' . $json;
    $reader = reader_new($json);
    reader_skip_ws($reader);
    $value = __deka_json_parse_value($reader, true, $depth);
    if (__deka_json_has_error()) {
        return false;
    }
    reader_skip_ws($reader);
    if (!reader_eof($reader)) {
        __deka_json_fail(JSON_ERROR_SYNTAX);
        return false;
    }
    return $value !== null || json_last_error() === JSON_ERROR_NONE;
}

function __deka_json_has_error() {
    return json_last_error() !== (defined('JSON_ERROR_NONE') ? JSON_ERROR_NONE : 0);
}

function __deka_json_reset_error() {
    $GLOBALS[__DEKA_JSON_ERROR_KEY] = defined('JSON_ERROR_NONE') ? JSON_ERROR_NONE : 0;
    $GLOBALS[__DEKA_JSON_ERROR_MSG_KEY] = __deka_json_error_message($GLOBALS[__DEKA_JSON_ERROR_KEY]);
}

function __deka_json_set_error($code) {
    $GLOBALS[__DEKA_JSON_ERROR_KEY] = $code;
    $GLOBALS[__DEKA_JSON_ERROR_MSG_KEY] = __deka_json_error_message($code);
}

function __deka_json_fail($code) {
    __deka_json_set_error($code);
    return null;
}

function __deka_json_error_message($code) {
    switch ($code) {
        case JSON_ERROR_NONE:
            return 'No error';
        case JSON_ERROR_DEPTH:
            return 'Maximum stack depth exceeded';
        case JSON_ERROR_STATE_MISMATCH:
            return 'State mismatch (invalid or malformed JSON)';
        case JSON_ERROR_CTRL_CHAR:
            return 'Control character error, possibly incorrectly encoded';
        case JSON_ERROR_SYNTAX:
            return 'Syntax error';
        case JSON_ERROR_UTF8:
            return 'Malformed UTF-8 characters, possibly incorrectly encoded';
        case JSON_ERROR_RECURSION:
            return 'Recursion detected';
        case JSON_ERROR_INF_OR_NAN:
            return 'Inf and NaN cannot be JSON encoded';
        case JSON_ERROR_UNSUPPORTED_TYPE:
            return 'Type is not supported';
        case JSON_ERROR_INVALID_PROPERTY_NAME:
            return 'The decoded property name is invalid';
        case JSON_ERROR_UTF16:
            return 'Single unpaired UTF-16 surrogate in unicode escape';
        default:
            return 'Unknown error';
    }
}

function __deka_json_parse_value(&$reader, $assoc, $depth) {
    if ($depth <= 0) {
        return __deka_json_fail(JSON_ERROR_DEPTH);
    }
    reader_skip_ws($reader);
    $byte = reader_peek_byte($reader);
    if ($byte === null) {
        return __deka_json_fail(JSON_ERROR_SYNTAX);
    }
    if ($byte === 123) {
        return __deka_json_parse_object($reader, $assoc, $depth - 1);
    }
    if ($byte === 91) {
        return __deka_json_parse_array($reader, $assoc, $depth - 1);
    }
    if ($byte === 34) {
        return __deka_json_parse_string($reader);
    }
    if ($byte === 116) {
        return __deka_json_expect_literal($reader, 'true', true);
    }
    if ($byte === 102) {
        return __deka_json_expect_literal($reader, 'false', false);
    }
    if ($byte === 110) {
        return __deka_json_expect_literal($reader, 'null', null);
    }
    if ($byte === 45 || byte_is_digit($byte)) {
        return __deka_json_parse_number($reader);
    }
    return __deka_json_fail(JSON_ERROR_SYNTAX);
}

function __deka_json_expect_literal(&$reader, $literal, $value) {
    $len = strlen($literal);
    for ($i = 0; $i < $len; $i += 1) {
        $byte = reader_next_byte($reader);
        if ($byte === null || chr($byte) !== $literal[$i]) {
            return __deka_json_fail(JSON_ERROR_SYNTAX);
        }
    }
    return $value;
}

function __deka_json_parse_array(&$reader, $assoc, $depth) {
    reader_next_byte($reader);
    $items = [];
    reader_skip_ws($reader);
    $byte = reader_peek_byte($reader);
    if ($byte === 93) {
        reader_next_byte($reader);
        return $items;
    }
    while (true) {
        $value = __deka_json_parse_value($reader, $assoc, $depth);
        if (__deka_json_has_error()) {
            return null;
        }
        $items[] = $value;
        reader_skip_ws($reader);
        $byte = reader_peek_byte($reader);
        if ($byte === 44) {
            reader_next_byte($reader);
            reader_skip_ws($reader);
            continue;
        }
        if ($byte === 93) {
            reader_next_byte($reader);
            break;
        }
        return __deka_json_fail(JSON_ERROR_SYNTAX);
    }
    return $items;
}

function __deka_json_parse_object(&$reader, $assoc, $depth) {
    reader_next_byte($reader);
    $object = $assoc ? [] : {};
    reader_skip_ws($reader);
    $byte = reader_peek_byte($reader);
    if ($byte === 125) {
        reader_next_byte($reader);
        return $object;
    }
    while (true) {
        $key = __deka_json_parse_string($reader);
        if (__deka_json_has_error()) {
            return null;
        }
        reader_skip_ws($reader);
        $byte = reader_next_byte($reader);
        if ($byte !== 58) {
            return __deka_json_fail(JSON_ERROR_SYNTAX);
        }
        reader_skip_ws($reader);
        $value = __deka_json_parse_value($reader, $assoc, $depth);
        if (__deka_json_has_error()) {
            return null;
        }
        if ($assoc) {
            $object[$key] = $value;
        } else {
            __deka_object_set($object, $key, $value);
        }
        reader_skip_ws($reader);
        $byte = reader_peek_byte($reader);
        if ($byte === 44) {
            reader_next_byte($reader);
            reader_skip_ws($reader);
            continue;
        }
        if ($byte === 125) {
            reader_next_byte($reader);
            break;
        }
        return __deka_json_fail(JSON_ERROR_SYNTAX);
    }
    return $object;
}

function __deka_json_parse_string(&$reader) {
    $byte = reader_next_byte($reader);
    if ($byte !== 34) {
        return __deka_json_fail(JSON_ERROR_SYNTAX);
    }
    $out = '';
    while (!reader_eof($reader)) {
        $byte = reader_next_byte($reader);
        if ($byte === null) {
            return __deka_json_fail(JSON_ERROR_SYNTAX);
        }
        if ($byte === 34) {
            return $out;
        }
        if ($byte === 92) {
            $escape = reader_next_byte($reader);
            if ($escape === null) {
                return __deka_json_fail(JSON_ERROR_SYNTAX);
            }
            $out .= __deka_json_escape_value($reader, $escape);
            if (__deka_json_has_error()) {
                return null;
            }
            continue;
        }
        if ($byte < 32) {
            return __deka_json_fail(JSON_ERROR_CTRL_CHAR);
        }
        $out .= chr($byte);
    }
    return __deka_json_fail(JSON_ERROR_SYNTAX);
}

function __deka_json_escape_value(&$reader, $escape) {
    switch ($escape) {
        case 34:
            return '"';
        case 92:
            return '\\';
        case 47:
            return '/';
        case 98:
            return "\b";
        case 102:
            return "\f";
        case 110:
            return "\n";
        case 114:
            return "\r";
        case 116:
            return "\t";
        case 117:
            return __deka_json_parse_unicode_escape($reader);
        default:
            __deka_json_set_error(JSON_ERROR_SYNTAX);
            return '';
    }
}

function __deka_json_parse_unicode_escape(&$reader) {
    $hex = '';
    for ($i = 0; $i < 4; $i += 1) {
        $byte = reader_next_byte($reader);
        if ($byte === null || !byte_is_hex($byte)) {
            __deka_json_set_error(JSON_ERROR_UTF8);
            return '';
        }
        $hex .= chr($byte);
    }
    $code = hexdec($hex);
    if ($code >= 0xD800 && $code <= 0xDBFF) {
        $nextSlash = reader_next_byte($reader);
        $nextU = reader_next_byte($reader);
        if ($nextSlash !== 92 || $nextU !== 117) {
            __deka_json_set_error(JSON_ERROR_UTF16);
            return '';
        }
        $lowHex = '';
        for ($i = 0; $i < 4; $i += 1) {
            $byte = reader_next_byte($reader);
            if ($byte === null || !byte_is_hex($byte)) {
                __deka_json_set_error(JSON_ERROR_UTF16);
                return '';
            }
            $lowHex .= chr($byte);
        }
        $low = hexdec($lowHex);
        if ($low < 0xDC00 || $low > 0xDFFF) {
            __deka_json_set_error(JSON_ERROR_UTF16);
            return '';
        }
        $code = 0x10000 + (($code - 0xD800) << 10) + ($low - 0xDC00);
    }
    return __deka_json_codepoint_to_utf8($code);
}

function __deka_json_codepoint_to_utf8($code) {
    if ($code <= 0x7F) {
        return chr($code);
    }
    if ($code <= 0x7FF) {
        return chr(0xC0 | ($code >> 6)) . chr(0x80 | ($code & 0x3F));
    }
    if ($code <= 0xFFFF) {
        return chr(0xE0 | ($code >> 12)) . chr(0x80 | (($code >> 6) & 0x3F)) . chr(0x80 | ($code & 0x3F));
    }
    if ($code <= 0x10FFFF) {
        return chr(0xF0 | ($code >> 18)) . chr(0x80 | (($code >> 12) & 0x3F)) . chr(0x80 | (($code >> 6) & 0x3F)) . chr(0x80 | ($code & 0x3F));
    }
    __deka_json_set_error(JSON_ERROR_UTF8);
    return '';
}

function __deka_json_parse_number(&$reader) {
    $num = '';
    $byte = reader_peek_byte($reader);
    if ($byte === 45) {
        $num .= '-';
        reader_next_byte($reader);
        $byte = reader_peek_byte($reader);
    }
    if ($byte === null) {
        return __deka_json_fail(JSON_ERROR_SYNTAX);
    }
    if ($byte === 48) {
        $num .= '0';
        reader_next_byte($reader);
        $next = reader_peek_byte($reader);
        if ($next !== null && byte_is_digit($next)) {
            return __deka_json_fail(JSON_ERROR_SYNTAX);
        }
    } else {
        if (!byte_is_digit($byte)) {
            return __deka_json_fail(JSON_ERROR_SYNTAX);
        }
        while (true) {
            $byte = reader_peek_byte($reader);
            if ($byte === null || !byte_is_digit($byte)) {
                break;
            }
            $num .= chr(reader_next_byte($reader));
        }
    }
    $byte = reader_peek_byte($reader);
    if ($byte === 46) {
        $num .= '.';
        reader_next_byte($reader);
        $byte = reader_peek_byte($reader);
        if ($byte === null || !byte_is_digit($byte)) {
            return __deka_json_fail(JSON_ERROR_SYNTAX);
        }
        while (true) {
            $byte = reader_peek_byte($reader);
            if ($byte === null || !byte_is_digit($byte)) {
                break;
            }
            $num .= chr(reader_next_byte($reader));
        }
    }
    $byte = reader_peek_byte($reader);
    if ($byte === 69 || $byte === 101) {
        $num .= chr(reader_next_byte($reader));
        $byte = reader_peek_byte($reader);
        if ($byte === 43 || $byte === 45) {
            $num .= chr(reader_next_byte($reader));
        }
        $byte = reader_peek_byte($reader);
        if ($byte === null || !byte_is_digit($byte)) {
            return __deka_json_fail(JSON_ERROR_SYNTAX);
        }
        while (true) {
            $byte = reader_peek_byte($reader);
            if ($byte === null || !byte_is_digit($byte)) {
                break;
            }
            $num .= chr(reader_next_byte($reader));
        }
    }
    if (strpos($num, '.') !== false || strpos(strtolower($num), 'e') !== false) {
        return num_parse_float($num);
    }
    return num_parse_int($num);
}

function __deka_json_encode_value($value, $depth) {
    if ($depth <= 0) {
        return __deka_json_fail(JSON_ERROR_DEPTH);
    }
    if ($value === null) {
        return 'null';
    }
    if (is_bool($value)) {
        return $value ? 'true' : 'false';
    }
    if (is_int($value)) {
        return '' . $value;
    }
    if (is_float($value)) {
        if (is_nan($value) || is_infinite($value)) {
            return __deka_json_fail(JSON_ERROR_INF_OR_NAN);
        }
        return '' . $value;
    }
    if (is_string($value)) {
        return __deka_json_escape_string($value);
    }
    if (is_array($value)) {
        if (__deka_json_is_list_array($value)) {
            $items = [];
            foreach ($value as $item) {
                $encoded = __deka_json_encode_value($item, $depth - 1);
                if (__deka_json_has_error()) {
                    return null;
                }
                $items[] = $encoded;
            }
            return '[' . implode(',', $items) . ']';
        }
        $pairs = [];
        foreach ($value as $key => $item) {
            $encodedValue = __deka_json_encode_value($item, $depth - 1);
            if (__deka_json_has_error()) {
                return null;
            }
            $pairs[] = __deka_json_escape_string('' . $key) . ':' . $encodedValue;
        }
        return '{' . implode(',', $pairs) . '}';
    }
    if (is_object($value)) {
        $pairs = [];
        foreach (get_object_vars($value) as $key => $item) {
            $encodedValue = __deka_json_encode_value($item, $depth - 1);
            if (__deka_json_has_error()) {
                return null;
            }
            $pairs[] = __deka_json_escape_string('' . $key) . ':' . $encodedValue;
        }
        return '{' . implode(',', $pairs) . '}';
    }
    return __deka_json_fail(JSON_ERROR_UNSUPPORTED_TYPE);
}

function __deka_json_is_list_array($value) {
    $expected = 0;
    foreach ($value as $key => $_) {
        if ($key !== $expected) {
            return false;
        }
        $expected += 1;
    }
    return true;
}

function __deka_json_escape_string($value) {
    $out = '"';
    $len = strlen($value);
    for ($i = 0; $i < $len; $i += 1) {
        $byte = ord($value[$i]);
        switch ($byte) {
            case 34:
                $out .= '\\"';
                break;
            case 92:
                $out .= '\\\\';
                break;
            case 8:
                $out .= '\\b';
                break;
            case 12:
                $out .= '\\f';
                break;
            case 10:
                $out .= '\\n';
                break;
            case 13:
                $out .= '\\r';
                break;
            case 9:
                $out .= '\\t';
                break;
            default:
                if ($byte < 32) {
                    $out .= sprintf('\\u%04x', $byte);
                } else {
                    $out .= chr($byte);
                }
        }
    }
    $out .= '"';
    return $out;
}
