import { result_ok, result_err, result_is_ok } from 'core/result'
import { open_handle, query as db_query, query_one as db_query_one, exec as db_exec, begin as db_begin, commit as db_commit, rollback as db_rollback, close as db_close } from 'db'
import { tcp_connect, tcp_read_exact, tcp_write, tcp_close, tcp_set_deadline } from 'tcp'
import { tls_upgrade, tls_read_exact, tls_write, tls_close } from 'tls'
import { bytes_get } from 'core/bytes'

function __pg_i32($value) {
    $v = (int) $value
    return chr(($v >> 24) & 255) . chr(($v >> 16) & 255) . chr(($v >> 8) & 255) . chr($v & 255)
}

function __pg_i16($value) {
    $v = (int) $value
    return chr(($v >> 8) & 255) . chr($v & 255)
}

function __pg_u32_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    $b2 = bytes_get($bytes, $offset + 2)
    $b3 = bytes_get($bytes, $offset + 3)
    if ($b0 === null || $b1 === null || $b2 === null || $b3 === null) {
        return 0
    }
    return (($b0 << 24) | ($b1 << 16) | ($b2 << 8) | $b3)
}

function __pg_u16_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    if ($b0 === null || $b1 === null) {
        return 0
    }
    return (($b0 << 8) | $b1)
}

function __pg_cstring_at($bytes, &$offset) {
    $start = $offset
    $len = strlen($bytes)
    while ($offset < $len) {
        $byte = bytes_get($bytes, $offset)
        if ($byte === 0) {
            $str = substr($bytes, $start, $offset - $start)
            $offset += 1
            return $str
        }
        $offset += 1
    }
    return ''
}

function __pg_send($conn, $payload) {
    if ($conn.transport === 'tls') {
        return tls_write($conn.handle, $payload)
    }
    return tcp_write($conn.handle, $payload)
}

function __pg_read_exact($conn, $n) {
    if ($conn.transport === 'tls') {
        return tls_read_exact($conn.handle, $n)
    }
    return tcp_read_exact($conn.handle, $n)
}

function __pg_close_conn($conn) {
    if (!is_object($conn) || !isset($conn.transport) || !isset($conn.handle)) {
        return result_ok({ ok: true })
    }
    if ($conn.transport === 'tls') {
        return tls_close($conn.handle)
    }
    return tcp_close($conn.handle)
}

function __pg_error_from_payload($payload) {
    $offset = 0
    $parts = []
    while ($offset < strlen($payload)) {
        $kind = bytes_get($payload, $offset)
        $offset += 1
        if ($kind === null || $kind === 0) {
            break
        }
        $text = __pg_cstring_at($payload, $offset)
        $parts[] = $text
    }
    if (count($parts) === 0) {
        return 'postgres error'
    }
    return implode(' | ', $parts)
}

function __pg_read_message($conn) {
    $head = __pg_read_exact($conn, 5)
    if (!result_is_ok($head)) {
        return result_err($head.error)
    }
    $type = $head.value[0]
    $len = __pg_u32_at(substr($head.value, 1), 0)
    if ($len < 4) {
        return result_err('wire invalid message length')
    }
    $payload_len = $len - 4
    $payload = ''
    if ($payload_len > 0) {
        $body = __pg_read_exact($conn, $payload_len)
        if (!result_is_ok($body)) {
            return result_err($body.error)
        }
        $payload = $body.value
    }
    return result_ok({ type: $type, payload: $payload })
}

function __pg_send_password($conn, $password) {
    $payload = '' . $password . "\0"
    $packet = 'p' . __pg_i32(strlen($payload) + 4) . $payload
    return __pg_send($conn, $packet)
}

function __pg_md5_password($user, $password, $salt4) {
    $first = md5('' . $password . '' . $user)
    $second = md5($first . $salt4)
    return 'md5' . $second
}

function __pg_xor_bytes($a, $b) {
    $n = min(strlen($a), strlen($b))
    $out = ''
    for ($i = 0; $i < $n; $i += 1) {
        $out .= chr(bytes_get($a, $i) ^ bytes_get($b, $i))
    }
    return $out
}

function __pg_scram_username($user) {
    $u = '' . $user
    $u = str_replace('=', '=3D', $u)
    $u = str_replace(',', '=2C', $u)
    return $u
}

function __pg_scram_nonce($user, $database) {
    $seed = '' . $user . ':' . $database . ':' . microtime(true) . ':' . uniqid('', true)
    return rtrim(base64_encode(hash('sha256', $seed, true)), '=')
}

function __pg_scram_attrs($text) {
    $attrs = []
    $parts = explode(',', '' . $text)
    foreach ($parts as $part) {
        if ($part === '') {
            continue
        }
        $eq = strpos($part, '=')
        if ($eq === false) {
            continue
        }
        $k = substr($part, 0, $eq)
        $v = substr($part, $eq + 1)
        $attrs[$k] = $v
    }
    return $attrs
}

function __pg_scram_hi($password, $salt_raw, $iterations) {
    $u = hash_hmac('sha256', $salt_raw . __pg_i32(1), '' . $password, true)
    $out = $u
    for ($i = 1; $i < (int) $iterations; $i += 1) {
        $u = hash_hmac('sha256', $u, '' . $password, true)
        $out = __pg_xor_bytes($out, $u)
    }
    return $out
}

function __pg_scram_send_client_first($conn, $state, $user) {
    $nonce = __pg_scram_nonce($user, $conn.database)
    $first_bare = 'n=' . __pg_scram_username($user) . ',r=' . $nonce
    $first = 'n,,' . $first_bare
    $payload = 'SCRAM-SHA-256' . "\0" . __pg_i32(strlen($first)) . $first
    $packet = 'p' . __pg_i32(strlen($payload) + 4) . $payload
    $sent = __pg_send($conn, $packet)
    if (!result_is_ok($sent)) {
        return result_err($sent.error)
    }
    $state['scram'] = {
        nonce: $nonce,
        first_bare: $first_bare
    }
    return result_ok($state)
}

function __pg_scram_send_client_final($conn, $state, $password, $payload) {
    if (!is_array($state) || !array_key_exists('scram', $state) || !is_array($state['scram'])) {
        return result_err('wire scram missing state')
    }
    if (strlen($payload) < 4) {
        return result_err('wire scram invalid continue payload')
    }

    $server_first = substr($payload, 4)
    $attrs = __pg_scram_attrs($server_first)
    if (!array_key_exists('r', $attrs) || !array_key_exists('s', $attrs) || !array_key_exists('i', $attrs)) {
        return result_err('wire scram invalid server-first message')
    }

    $nonce = $state['scram']['nonce']
    if (substr($attrs['r'], 0, strlen($nonce)) !== $nonce) {
        return result_err('wire scram nonce mismatch')
    }

    $salt_raw = base64_decode($attrs['s'])
    if (!is_string($salt_raw) || $salt_raw === '') {
        return result_err('wire scram invalid salt')
    }

    $iters = (int) $attrs['i']
    if ($iters <= 0) {
        return result_err('wire scram invalid iteration count')
    }

    $client_final_no_proof = 'c=biws,r=' . $attrs['r']
    $salted_password = __pg_scram_hi($password, $salt_raw, $iters)
    $client_key = hash_hmac('sha256', 'Client Key', $salted_password, true)
    $stored_key = hash('sha256', $client_key, true)
    $auth_message = $state['scram']['first_bare'] . ',' . $server_first . ',' . $client_final_no_proof
    $client_signature = hash_hmac('sha256', $auth_message, $stored_key, true)
    $client_proof = base64_encode(__pg_xor_bytes($client_key, $client_signature))
    $server_key = hash_hmac('sha256', 'Server Key', $salted_password, true)
    $state['scram_server_sig'] = base64_encode(hash_hmac('sha256', $auth_message, $server_key, true))

    $client_final = $client_final_no_proof . ',p=' . $client_proof
    $packet = 'p' . __pg_i32(strlen($client_final) + 4) . $client_final
    $sent = __pg_send($conn, $packet)
    if (!result_is_ok($sent)) {
        return result_err($sent.error)
    }

    return result_ok($state)
}

function __pg_scram_verify_server_final($state, $payload) {
    if (strlen($payload) < 4) {
        return result_err('wire scram invalid final payload')
    }
    $server_final = substr($payload, 4)
    $attrs = __pg_scram_attrs($server_final)
    if (array_key_exists('e', $attrs)) {
        return result_err('wire scram server error: ' . $attrs['e'])
    }
    if (array_key_exists('v', $attrs) && is_array($state) && array_key_exists('scram_server_sig', $state)) {
        if ($attrs['v'] !== $state['scram_server_sig']) {
            return result_err('wire scram server signature mismatch')
        }
    }
    return result_ok('ok')
}

function __pg_auth_step($conn, $payload, $user, $password, $state) {
    $code = __pg_u32_at($payload, 0)
    if ($code === 0) {
        return result_ok($state)
    }
    if ($code === 3) {
        $sent = __pg_send_password($conn, $password)
        if (!result_is_ok($sent)) {
            return result_err($sent.error)
        }
        return result_ok($state)
    }
    if ($code === 5) {
        $salt4 = substr($payload, 4, 4)
        $pass = __pg_md5_password($user, $password, $salt4)
        $sent = __pg_send_password($conn, $pass)
        if (!result_is_ok($sent)) {
            return result_err($sent.error)
        }
        return result_ok($state)
    }
    if ($code === 10) {
        $mechs = substr($payload, 4)
        if (strpos($mechs, 'SCRAM-SHA-256') === false) {
            return result_err('wire_unsupported_auth:sasl')
        }
        return __pg_scram_send_client_first($conn, $state, $user)
    }
    if ($code === 11) {
        return __pg_scram_send_client_final($conn, $state, $password, $payload)
    }
    if ($code === 12) {
        $ok = __pg_scram_verify_server_final($state, $payload)
        if (!result_is_ok($ok)) {
            return result_err($ok.error)
        }
        return result_ok($state)
    }
    return result_err('wire_unsupported_auth:' . $code)
}

function __pg_ssl_upgrade($conn, $host) {
    $sslreq = __pg_i32(8) . __pg_i32(80877103)
    $sent = __pg_send($conn, $sslreq)
    if (!result_is_ok($sent)) {
        return result_err($sent.error)
    }
    $resp = __pg_read_exact($conn, 1)
    if (!result_is_ok($resp)) {
        return result_err($resp.error)
    }
    if ($resp.value !== 'S') {
        return result_err('server refused ssl')
    }
    $up = tls_upgrade($conn.handle, $host)
    if (!result_is_ok($up)) {
        return result_err($up.error)
    }
    return result_ok({ transport: 'tls', handle: $up.value })
}

function __pg_connect_wire($config) {
    $host = '127.0.0.1'
    $port = 5432
    $user = 'postgres'
    $password = ''
    $database = 'postgres'
    $timeout_ms = 5000
    $use_ssl = false

    if (is_array($config)) {
        if (array_key_exists('host', $config)) {
            $host = '' . $config['host']
        }
        if (array_key_exists('port', $config)) {
            $port = (int) $config['port']
        }
        if (array_key_exists('user', $config)) {
            $user = '' . $config['user']
        }
        if (array_key_exists('password', $config)) {
            $password = '' . $config['password']
        }
        if (array_key_exists('database', $config)) {
            $database = '' . $config['database']
        }
        if (array_key_exists('dbname', $config)) {
            $database = '' . $config['dbname']
        }
        if (array_key_exists('timeout_ms', $config)) {
            $timeout_ms = (int) $config['timeout_ms']
        }
        if (array_key_exists('ssl', $config)) {
            $use_ssl = !!$config['ssl']
        }
    } else if (is_object($config)) {
        if (isset($config.host)) {
            $host = '' . $config.host
        }
        if (isset($config.port)) {
            $port = (int) $config.port
        }
        if (isset($config.user)) {
            $user = '' . $config.user
        }
        if (isset($config.password)) {
            $password = '' . $config.password
        }
        if (isset($config.database)) {
            $database = '' . $config.database
        }
        if (isset($config.dbname)) {
            $database = '' . $config.dbname
        }
        if (isset($config.timeout_ms)) {
            $timeout_ms = (int) $config.timeout_ms
        }
        if (isset($config.ssl)) {
            $use_ssl = !!$config.ssl
        }
    }

    $open = tcp_connect($host, $port, { timeout_ms: $timeout_ms })
    if (!result_is_ok($open)) {
        return result_err('wire connect failed: ' . $open.error)
    }

    $conn = {
        kind: 'wire',
        transport: 'tcp',
        handle: $open.value,
        host: $host,
        user: $user,
        database: $database
    }

    $deadline = tcp_set_deadline($conn.handle, $timeout_ms)
    if (!result_is_ok($deadline)) {
        __pg_close_conn($conn)
        return result_err('wire deadline failed: ' . $deadline.error)
    }

    if ($use_ssl) {
        $up = __pg_ssl_upgrade($conn, $host)
        if (!result_is_ok($up)) {
            __pg_close_conn($conn)
            return result_err('wire ssl failed: ' . $up.error)
        }
        $conn.transport = $up.value.transport
        $conn.handle = $up.value.handle
    }

    $startup_payload = __pg_i32(196608) . 'user' . "\0" . $user . "\0" . 'database' . "\0" . $database . "\0" . 'client_encoding' . "\0" . 'UTF8' . "\0\0"
    $startup = __pg_i32(strlen($startup_payload) + 4) . $startup_payload

    $sent = __pg_send($conn, $startup)
    if (!result_is_ok($sent)) {
        __pg_close_conn($conn)
        return result_err('wire startup send failed: ' . $sent.error)
    }

    $auth_state = []
    while (true) {
        $msg = __pg_read_message($conn)
        if (!result_is_ok($msg)) {
            __pg_close_conn($conn)
            return result_err('wire startup read failed: ' . $msg.error)
        }

        if ($msg.value.type === 'R') {
            $auth = __pg_auth_step($conn, $msg.value.payload, $user, $password, $auth_state)
            if (!result_is_ok($auth)) {
                __pg_close_conn($conn)
                return result_err($auth.error)
            }
            $auth_state = $auth.value
            continue
        }

        if ($msg.value.type === 'S' || $msg.value.type === 'K' || $msg.value.type === 'N') {
            continue
        }

        if ($msg.value.type === 'E') {
            $err = __pg_error_from_payload($msg.value.payload)
            __pg_close_conn($conn)
            return result_err('wire startup error: ' . $err)
        }

        if ($msg.value.type === 'Z') {
            return result_ok($conn)
        }
    }
}

function __pg_is_wire_handle($handle) {
    return is_object($handle) && isset($handle.kind) && $handle.kind === 'wire' && isset($handle.transport) && isset($handle.handle)
}

function __pg_parse_row_desc($payload) {
    $offset = 0
    $count = __pg_u16_at($payload, $offset)
    $offset += 2
    $cols = []
    for ($i = 0; $i < $count; $i += 1) {
        $name = __pg_cstring_at($payload, $offset)
        $offset += 18
        $cols[] = $name
    }
    return $cols
}

function __pg_parse_data_row($payload, $cols) {
    $offset = 0
    $count = __pg_u16_at($payload, $offset)
    $offset += 2
    $row = []
    for ($i = 0; $i < $count; $i += 1) {
        $len = __pg_u32_at($payload, $offset)
        $offset += 4
        $name = $i < count($cols) ? $cols[$i] : ('col_' . $i)
        if ($len === 4294967295) {
            $row[$name] = null
            continue
        }
        $val = substr($payload, $offset, $len)
        $offset += $len
        $row[$name] = $val
    }
    return $row
}

function __pg_command_affected_rows($cmd) {
    $parts = explode(' ', trim($cmd))
    if (count($parts) === 0) {
        return 0
    }
    $last = $parts[count($parts) - 1]
    if (is_numeric($last)) {
        return (int) $last
    }
    return 0
}

function __pg_param_value($value, $idx) {
    if ($value === null) {
        return result_ok({ is_null: true, data: '' })
    }
    if (is_bool($value)) {
        return result_ok({ is_null: false, data: $value ? 't' : 'f' })
    }
    if (is_int($value) || is_float($value) || is_string($value)) {
        return result_ok({ is_null: false, data: '' . $value })
    }
    return result_err('wire unsupported param type at index ' . $idx)
}

function __pg_params_list($params) {
    if ($params === null) {
        return []
    }
    if (is_array($params)) {
        return array_values($params)
    }
    if (is_object($params)) {
        $vals = []
        foreach ($params as $v) {
            $vals[] = $v
        }
        return $vals
    }
    return [$params]
}

function __pg_collect_query_result($conn) {
    $cols = []
    $rows = []
    $command = ''
    $affected = 0

    while (true) {
        $msg = __pg_read_message($conn)
        if (!result_is_ok($msg)) {
            return result_err('wire query read failed: ' . $msg.error)
        }

        if ($msg.value.type === '1' || $msg.value.type === '2' || $msg.value.type === '3' || $msg.value.type === 'n') {
            continue
        }

        if ($msg.value.type === 'T') {
            $cols = __pg_parse_row_desc($msg.value.payload)
            continue
        }

        if ($msg.value.type === 'D') {
            $rows[] = __pg_parse_data_row($msg.value.payload, $cols)
            continue
        }

        if ($msg.value.type === 'C') {
            $tmp = 0
            $command = __pg_cstring_at($msg.value.payload, $tmp)
            $affected = __pg_command_affected_rows($command)
            continue
        }

        if ($msg.value.type === 'E') {
            return result_err('wire query error: ' . __pg_error_from_payload($msg.value.payload))
        }

        if ($msg.value.type === 'N') {
            continue
        }

        if ($msg.value.type === 'Z') {
            return result_ok({ rows: $rows, command: $command, affected_rows: $affected })
        }
    }
}

function __pg_query_wire_simple($conn, $sql) {
    $payload = '' . $sql . "\0"
    $packet = 'Q' . __pg_i32(strlen($payload) + 4) . $payload
    $sent = __pg_send($conn, $packet)
    if (!result_is_ok($sent)) {
        return result_err('wire query send failed: ' . $sent.error)
    }
    return __pg_collect_query_result($conn)
}

function __pg_query_wire_extended($conn, $sql, $params) {
    $values = __pg_params_list($params)
    $param_count = count($values)

    $parse_payload = "\0" . $sql . "\0" . __pg_i16($param_count)
    for ($i = 0; $i < $param_count; $i += 1) {
        $parse_payload .= __pg_i32(0)
    }
    $parse = 'P' . __pg_i32(strlen($parse_payload) + 4) . $parse_payload

    $bind_payload = "\0\0" . __pg_i16(0) . __pg_i16($param_count)
    for ($i = 0; $i < $param_count; $i += 1) {
        $pv = __pg_param_value($values[$i], $i)
        if (!result_is_ok($pv)) {
            return result_err($pv.error)
        }
        if ($pv.value.is_null) {
            $bind_payload .= __pg_i32(-1)
            continue
        }
        $bytes = $pv.value.data
        $bind_payload .= __pg_i32(strlen($bytes)) . $bytes
    }
    $bind_payload .= __pg_i16(0)
    $bind = 'B' . __pg_i32(strlen($bind_payload) + 4) . $bind_payload

    $describe_payload = 'P' . "\0"
    $describe = 'D' . __pg_i32(strlen($describe_payload) + 4) . $describe_payload

    $execute_payload = "\0" . __pg_i32(0)
    $execute = 'E' . __pg_i32(strlen($execute_payload) + 4) . $execute_payload

    $sync = 'S' . __pg_i32(4)
    $packet = $parse . $bind . $describe . $execute . $sync

    $sent = __pg_send($conn, $packet)
    if (!result_is_ok($sent)) {
        return result_err('wire query send failed: ' . $sent.error)
    }

    return __pg_collect_query_result($conn)
}

function __pg_query_wire($conn, $sql, $params = []) {
    $values = __pg_params_list($params)
    if (count($values) > 0) {
        return __pg_query_wire_extended($conn, $sql, $values)
    }
    return __pg_query_wire_simple($conn, $sql)
}

export function connect($config) {
    $wire = __pg_connect_wire($config)
    if (result_is_ok($wire)) {
        return $wire
    }

    $fallback_native = true
    if (is_array($config) && array_key_exists('fallback_native', $config)) {
        $fallback_native = !!$config['fallback_native']
    } else if (is_object($config) && isset($config.fallback_native)) {
        $fallback_native = !!$config.fallback_native
    }
    if (!$fallback_native) {
        return $wire
    }

    return open_handle('postgres', $config)
}

export function query($handle, $sql, $params = []) {
    $safe_params = __pg_params_list($params)
    if (__pg_is_wire_handle($handle)) {
        $res = __pg_query_wire($handle, $sql, $safe_params)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ rows: $res.value.rows })
    }
    return db_query($handle, $sql, $safe_params)
}

export function query_one($handle, $sql, $params = []) {
    $safe_params = __pg_params_list($params)
    if (__pg_is_wire_handle($handle)) {
        $res = __pg_query_wire($handle, $sql, $safe_params)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        if (count($res.value.rows) === 0) {
            return result_err('no rows')
        }
        return result_ok($res.value.rows[0])
    }
    return db_query_one($handle, $sql, $safe_params)
}

export function exec($handle, $sql, $params = []) {
    $safe_params = __pg_params_list($params)
    if (__pg_is_wire_handle($handle)) {
        $res = __pg_query_wire($handle, $sql, $safe_params)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ affected_rows: $res.value.affected_rows })
    }
    return db_exec($handle, $sql, $safe_params)
}

export function begin($handle) {
    if (__pg_is_wire_handle($handle)) {
        $res = exec($handle, 'BEGIN', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_begin($handle)
}

export function commit($handle) {
    if (__pg_is_wire_handle($handle)) {
        $res = exec($handle, 'COMMIT', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_commit($handle)
}

export function rollback($handle) {
    if (__pg_is_wire_handle($handle)) {
        $res = exec($handle, 'ROLLBACK', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_rollback($handle)
}

export function close($handle) {
    if (__pg_is_wire_handle($handle)) {
        $term = 'X' . __pg_i32(4)
        __pg_send($handle, $term)
        return __pg_close_conn($handle)
    }
    return db_close($handle)
}
