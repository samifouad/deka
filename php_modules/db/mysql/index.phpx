import { result_ok, result_err, result_is_ok } from 'core/result'
import { db_open_handle, db_query, db_query_one, db_exec, db_begin, db_commit, db_rollback, db_close } from 'db'
import { tcp_connect, tcp_read_exact, tcp_write, tcp_close, tcp_set_deadline } from 'tcp'
import { bytes_get } from 'core/bytes'

const CLIENT_LONG_PASSWORD = 0x00000001
const CLIENT_LONG_FLAG = 0x00000004
const CLIENT_CONNECT_WITH_DB = 0x00000008
const CLIENT_PROTOCOL_41 = 0x00000200
const CLIENT_TRANSACTIONS = 0x00002000
const CLIENT_SECURE_CONNECTION = 0x00008000
const CLIENT_MULTI_RESULTS = 0x00020000
const CLIENT_PLUGIN_AUTH = 0x00080000
const CLIENT_DEPRECATE_EOF = 0x01000000

function __my_u16le_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    if ($b0 === null || $b1 === null) {
        return 0
    }
    return ($b0 | ($b1 << 8))
}

function __my_u24le_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    $b2 = bytes_get($bytes, $offset + 2)
    if ($b0 === null || $b1 === null || $b2 === null) {
        return 0
    }
    return ($b0 | ($b1 << 8) | ($b2 << 16))
}

function __my_u32le_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    $b2 = bytes_get($bytes, $offset + 2)
    $b3 = bytes_get($bytes, $offset + 3)
    if ($b0 === null || $b1 === null || $b2 === null || $b3 === null) {
        return 0
    }
    return ($b0 | ($b1 << 8) | ($b2 << 16) | ($b3 << 24))
}

function __my_i16le($v) {
    $n = (int) $v
    return chr($n & 255) . chr(($n >> 8) & 255)
}

function __my_i24le($v) {
    $n = (int) $v
    return chr($n & 255) . chr(($n >> 8) & 255) . chr(($n >> 16) & 255)
}

function __my_i32le($v) {
    $n = (int) $v
    return chr($n & 255) . chr(($n >> 8) & 255) . chr(($n >> 16) & 255) . chr(($n >> 24) & 255)
}

function __my_cstring_at($bytes, &$offset) {
    $start = $offset
    $len = strlen($bytes)
    while ($offset < $len) {
        $b = bytes_get($bytes, $offset)
        if ($b === 0) {
            $s = substr($bytes, $start, $offset - $start)
            $offset += 1
            return $s
        }
        $offset += 1
    }
    return substr($bytes, $start)
}

function __my_read_lenenc_int($bytes, &$offset) {
    $first = bytes_get($bytes, $offset)
    if ($first === null) {
        return 0
    }
    $offset += 1
    if ($first < 251) {
        return $first
    }
    if ($first === 252) {
        $v = __my_u16le_at($bytes, $offset)
        $offset += 2
        return $v
    }
    if ($first === 253) {
        $v = __my_u24le_at($bytes, $offset)
        $offset += 3
        return $v
    }
    if ($first === 254) {
        $low = __my_u32le_at($bytes, $offset)
        $high = __my_u32le_at($bytes, $offset + 4)
        $offset += 8
        return $low + ($high * 4294967296)
    }
    return 0
}

function __my_read_lenenc_str($bytes, &$offset) {
    $first = bytes_get($bytes, $offset)
    if ($first === null) {
        return ''
    }
    if ($first === 251) {
        $offset += 1
        return null
    }
    $len = __my_read_lenenc_int($bytes, $offset)
    $s = substr($bytes, $offset, $len)
    $offset += $len
    return $s
}

function __my_send_packet($conn, $payload) {
    $header = __my_i24le(strlen($payload)) . chr($conn.seq & 255)
    $conn.seq = ($conn.seq + 1) & 255
    return tcp_write($conn.sock, $header . $payload)
}

function __my_read_packet($conn) {
    $h = tcp_read_exact($conn.sock, 4)
    if (!result_is_ok($h)) {
        return result_err($h.error)
    }
    $len = __my_u24le_at($h.value, 0)
    $seq = bytes_get($h.value, 3)
    if ($seq === null) {
        return result_err('mysql bad header')
    }
    $conn.seq = ($seq + 1) & 255
    if ($len === 0) {
        return result_ok('')
    }
    $b = tcp_read_exact($conn.sock, $len)
    if (!result_is_ok($b)) {
        return result_err($b.error)
    }
    return result_ok($b.value)
}

function __my_err($payload) {
    if (!is_string($payload) || strlen($payload) < 3) {
        return 'mysql protocol error'
    }
    $msg = ''
    if (strlen($payload) >= 9 && $payload[3] === '#') {
        $msg = substr($payload, 9)
    } else {
        $msg = substr($payload, 3)
    }
    if ($msg === '') {
        return 'mysql error'
    }
    return $msg
}

function __my_sha1_raw($s) {
    return sha1($s, true)
}

function __my_native_token($password, $seed) {
    if ($password === '') {
        return ''
    }
    $s1 = __my_sha1_raw($password)
    $s2 = __my_sha1_raw($s1)
    $s3 = __my_sha1_raw($seed . $s2)
    $out = ''
    for ($i = 0; $i < 20; $i += 1) {
        $out .= chr(bytes_get($s1, $i) ^ bytes_get($s3, $i))
    }
    return $out
}

function __my_parse_handshake($payload) {
    $offset = 0
    $protocol = bytes_get($payload, $offset)
    $offset += 1
    if ($protocol === null || $protocol < 10) {
        return result_err('mysql unsupported protocol')
    }

    __my_cstring_at($payload, $offset)
    $offset += 4

    $part1 = substr($payload, $offset, 8)
    $offset += 8
    $offset += 1

    $cap_low = __my_u16le_at($payload, $offset)
    $offset += 2
    $charset = bytes_get($payload, $offset)
    if ($charset === null) {
        $charset = 33
    }
    $offset += 1
    $offset += 2
    $cap_high = __my_u16le_at($payload, $offset)
    $offset += 2
    $caps = $cap_low | ($cap_high << 16)

    $auth_len = 0
    if (($caps & CLIENT_PLUGIN_AUTH) !== 0) {
        $auth_len = bytes_get($payload, $offset)
        if ($auth_len === null) {
            $auth_len = 0
        }
    }
    $offset += 1
    $offset += 10

    $part2_len = max(13, $auth_len - 8)
    $part2 = substr($payload, $offset, $part2_len)
    $offset += $part2_len

    $seed = $part1 . rtrim($part2, "\0")
    $plugin = 'mysql_native_password'
    if (($caps & CLIENT_PLUGIN_AUTH) !== 0 && $offset < strlen($payload)) {
        $plugin = __my_cstring_at($payload, $offset)
        if ($plugin === '') {
            $plugin = 'mysql_native_password'
        }
    }

    return result_ok({ caps: $caps, charset: $charset, seed: $seed, plugin: $plugin })
}

function __my_connect_wire($config) {
    $host = '127.0.0.1'
    $port = 3306
    $user = 'root'
    $password = ''
    $database = ''
    $timeout_ms = 5000

    if (is_array($config)) {
        if (array_key_exists('host', $config)) {
            $host = '' . $config['host']
        }
        if (array_key_exists('port', $config)) {
            $port = (int) $config['port']
        }
        if (array_key_exists('user', $config)) {
            $user = '' . $config['user']
        }
        if (array_key_exists('password', $config)) {
            $password = '' . $config['password']
        }
        if (array_key_exists('database', $config)) {
            $database = '' . $config['database']
        }
        if (array_key_exists('dbname', $config)) {
            $database = '' . $config['dbname']
        }
        if (array_key_exists('timeout_ms', $config)) {
            $timeout_ms = (int) $config['timeout_ms']
        }
    } else if (is_object($config)) {
        if (isset($config.host)) {
            $host = '' . $config.host
        }
        if (isset($config.port)) {
            $port = (int) $config.port
        }
        if (isset($config.user)) {
            $user = '' . $config.user
        }
        if (isset($config.password)) {
            $password = '' . $config.password
        }
        if (isset($config.database)) {
            $database = '' . $config.database
        }
        if (isset($config.dbname)) {
            $database = '' . $config.dbname
        }
        if (isset($config.timeout_ms)) {
            $timeout_ms = (int) $config.timeout_ms
        }
    }

    $open = tcp_connect($host, $port, { timeout_ms: $timeout_ms })
    if (!result_is_ok($open)) {
        return result_err('wire connect failed: ' . $open.error)
    }

    $conn = { kind: 'wire', driver: 'mysql', sock: $open.value, seq: 0 }
    $deadline = tcp_set_deadline($conn.sock, $timeout_ms)
    if (!result_is_ok($deadline)) {
        tcp_close($conn.sock)
        return result_err('wire deadline failed: ' . $deadline.error)
    }

    $hello = __my_read_packet($conn)
    if (!result_is_ok($hello)) {
        tcp_close($conn.sock)
        return result_err('wire handshake read failed: ' . $hello.error)
    }

    if (strlen($hello.value) > 0 && bytes_get($hello.value, 0) === 255) {
        tcp_close($conn.sock)
        return result_err('wire handshake error: ' . __my_err($hello.value))
    }

    $hs = __my_parse_handshake($hello.value)
    if (!result_is_ok($hs)) {
        tcp_close($conn.sock)
        return result_err($hs.error)
    }

    if ($hs.value.plugin !== 'mysql_native_password') {
        tcp_close($conn.sock)
        return result_err('wire_unsupported_auth:' . $hs.value.plugin)
    }

    $want = CLIENT_LONG_PASSWORD | CLIENT_LONG_FLAG | CLIENT_PROTOCOL_41 | CLIENT_TRANSACTIONS | CLIENT_SECURE_CONNECTION | CLIENT_MULTI_RESULTS | CLIENT_PLUGIN_AUTH | CLIENT_DEPRECATE_EOF
    if ($database !== '') {
        $want |= CLIENT_CONNECT_WITH_DB
    }
    $caps = $want & $hs.value.caps
    $token = __my_native_token($password, $hs.value.seed)

    $resp = __my_i32le($caps)
    $resp .= __my_i32le(1024 * 1024 * 16)
    $resp .= chr($hs.value.charset)
    $resp .= str_repeat("\0", 23)
    $resp .= $user . "\0"
    $resp .= chr(strlen($token)) . $token
    if (($caps & CLIENT_CONNECT_WITH_DB) !== 0) {
        $resp .= $database . "\0"
    }
    if (($caps & CLIENT_PLUGIN_AUTH) !== 0) {
        $resp .= 'mysql_native_password' . "\0"
    }

    $conn.seq = 1
    $sent = __my_send_packet($conn, $resp)
    if (!result_is_ok($sent)) {
        tcp_close($conn.sock)
        return result_err('wire handshake send failed: ' . $sent.error)
    }

    $auth = __my_read_packet($conn)
    if (!result_is_ok($auth)) {
        tcp_close($conn.sock)
        return result_err('wire auth read failed: ' . $auth.error)
    }

    $kind = bytes_get($auth.value, 0)
    if ($kind === 0) {
        return result_ok($conn)
    }
    if ($kind === 255) {
        tcp_close($conn.sock)
        return result_err('wire auth error: ' . __my_err($auth.value))
    }

    tcp_close($conn.sock)
    return result_err('wire auth unsupported response')
}

function __my_is_wire_handle($handle) {
    return is_object($handle) && isset($handle.kind) && $handle.kind === 'wire' && isset($handle.driver) && $handle.driver === 'mysql' && isset($handle.sock)
}

function __my_parse_columns($count, $conn) {
    $cols = []
    for ($i = 0; $i < $count; $i += 1) {
        $p = __my_read_packet($conn)
        if (!result_is_ok($p)) {
            return result_err($p.error)
        }
        if (strlen($p.value) > 0 && bytes_get($p.value, 0) === 255) {
            return result_err(__my_err($p.value))
        }
        $o = 0
        __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        $name = __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        if (!is_string($name) || $name === '') {
            $name = 'col_' . $i
        }
        $cols[] = $name
    }

    $after_cols = __my_read_packet($conn)
    if (!result_is_ok($after_cols)) {
        return result_err($after_cols.error)
    }
    $marker = bytes_get($after_cols.value, 0)
    if ($marker !== 254 || strlen($after_cols.value) >= 9) {
        return result_err('mysql expected column EOF')
    }

    return result_ok($cols)
}

function __my_parse_rows($cols, $conn) {
    $rows = []
    while (true) {
        $p = __my_read_packet($conn)
        if (!result_is_ok($p)) {
            return result_err($p.error)
        }
        $kind = bytes_get($p.value, 0)
        if ($kind === 255) {
            return result_err(__my_err($p.value))
        }
        if ($kind === 254 && strlen($p.value) < 9) {
            return result_ok($rows)
        }

        $o = 0
        $row = []
        for ($i = 0; $i < count($cols); $i += 1) {
            $val = __my_read_lenenc_str($p.value, $o)
            $row[$cols[$i]] = $val
        }
        $rows[] = $row
    }
}

function __my_query_wire($conn, $sql) {
    $conn.seq = 0
    $sent = __my_send_packet($conn, chr(0x03) . $sql)
    if (!result_is_ok($sent)) {
        return result_err('wire query send failed: ' . $sent.error)
    }

    $first = __my_read_packet($conn)
    if (!result_is_ok($first)) {
        return result_err('wire query read failed: ' . $first.error)
    }

    if (strlen($first.value) === 0) {
        return result_ok({ rows: [], affected_rows: 0 })
    }

    $kind = bytes_get($first.value, 0)
    if ($kind === 255) {
        return result_err(__my_err($first.value))
    }

    if ($kind === 0) {
        $o = 1
        $affected = __my_read_lenenc_int($first.value, $o)
        return result_ok({ rows: [], affected_rows: $affected })
    }

    $o = 0
    $col_count = __my_read_lenenc_int($first.value, $o)
    $cols = __my_parse_columns($col_count, $conn)
    if (!result_is_ok($cols)) {
        return result_err('wire column parse failed: ' . $cols.error)
    }

    $rows = __my_parse_rows($cols.value, $conn)
    if (!result_is_ok($rows)) {
        return result_err('wire row parse failed: ' . $rows.error)
    }

    return result_ok({ rows: $rows.value, affected_rows: count($rows.value) })
}

export function connect($config) {
    $wire = __my_connect_wire($config)
    if (result_is_ok($wire)) {
        return $wire
    }

    $fallback_native = true
    if (is_array($config) && array_key_exists('fallback_native', $config)) {
        $fallback_native = !!$config['fallback_native']
    } else if (is_object($config) && isset($config.fallback_native)) {
        $fallback_native = !!$config.fallback_native
    }

    if (!$fallback_native) {
        return $wire
    }

    return db_open_handle('mysql', $config)
}

export function query($handle, $sql, $params = []) {
    if (__my_is_wire_handle($handle)) {
        if (is_array($params) && count($params) > 0) {
            return result_err('wire mysql params are not implemented yet')
        }
        $res = __my_query_wire($handle, $sql)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ rows: $res.value.rows })
    }
    return db_query($handle, $sql, $params)
}

export function query_one($handle, $sql, $params = []) {
    if (__my_is_wire_handle($handle)) {
        $res = query($handle, $sql, $params)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        if (!is_array($res.value.rows) || count($res.value.rows) === 0) {
            return result_err('no rows')
        }
        return result_ok($res.value.rows[0])
    }
    return db_query_one($handle, $sql, $params)
}

export function exec($handle, $sql, $params = []) {
    if (__my_is_wire_handle($handle)) {
        if (is_array($params) && count($params) > 0) {
            return result_err('wire mysql params are not implemented yet')
        }
        $res = __my_query_wire($handle, $sql)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ affected_rows: $res.value.affected_rows })
    }
    return db_exec($handle, $sql, $params)
}

export function begin($handle) {
    if (__my_is_wire_handle($handle)) {
        $res = exec($handle, 'START TRANSACTION', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_begin($handle)
}

export function commit($handle) {
    if (__my_is_wire_handle($handle)) {
        $res = exec($handle, 'COMMIT', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_commit($handle)
}

export function rollback($handle) {
    if (__my_is_wire_handle($handle)) {
        $res = exec($handle, 'ROLLBACK', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_rollback($handle)
}

export function close($handle) {
    if (__my_is_wire_handle($handle)) {
        $handle.seq = 0
        __my_send_packet($handle, chr(0x01))
        return tcp_close($handle.sock)
    }
    return db_close($handle)
}
