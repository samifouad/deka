import { result_ok, result_err, result_is_ok } from 'core/result'
import { open_handle, query as db_query, query_one as db_query_one, exec as db_exec, begin as db_begin, commit as db_commit, rollback as db_rollback, close as db_close } from 'db'
import { tcp_connect, tcp_read_exact, tcp_write, tcp_close, tcp_set_deadline } from 'tcp'
import { bytes_get } from 'core/bytes'

const CLIENT_LONG_PASSWORD = 0x00000001
const CLIENT_LONG_FLAG = 0x00000004
const CLIENT_CONNECT_WITH_DB = 0x00000008
const CLIENT_PROTOCOL_41 = 0x00000200
const CLIENT_TRANSACTIONS = 0x00002000
const CLIENT_SECURE_CONNECTION = 0x00008000
const CLIENT_MULTI_RESULTS = 0x00020000
const CLIENT_PLUGIN_AUTH = 0x00080000
const CLIENT_DEPRECATE_EOF = 0x01000000

function __my_u16le_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    if ($b0 === null || $b1 === null) {
        return 0
    }
    return ($b0 | ($b1 << 8))
}

function __my_u24le_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    $b2 = bytes_get($bytes, $offset + 2)
    if ($b0 === null || $b1 === null || $b2 === null) {
        return 0
    }
    return ($b0 | ($b1 << 8) | ($b2 << 16))
}

function __my_u32le_at($bytes, $offset) {
    $b0 = bytes_get($bytes, $offset)
    $b1 = bytes_get($bytes, $offset + 1)
    $b2 = bytes_get($bytes, $offset + 2)
    $b3 = bytes_get($bytes, $offset + 3)
    if ($b0 === null || $b1 === null || $b2 === null || $b3 === null) {
        return 0
    }
    return ($b0 | ($b1 << 8) | ($b2 << 16) | ($b3 << 24))
}

function __my_i16le($v) {
    $n = (int) $v
    return chr($n & 255) . chr(($n >> 8) & 255)
}

function __my_i24le($v) {
    $n = (int) $v
    return chr($n & 255) . chr(($n >> 8) & 255) . chr(($n >> 16) & 255)
}

function __my_i32le($v) {
    $n = (int) $v
    return chr($n & 255) . chr(($n >> 8) & 255) . chr(($n >> 16) & 255) . chr(($n >> 24) & 255)
}

function __my_cstring_at($bytes, &$offset) {
    $start = $offset
    $len = strlen($bytes)
    while ($offset < $len) {
        $b = bytes_get($bytes, $offset)
        if ($b === 0) {
            $s = substr($bytes, $start, $offset - $start)
            $offset += 1
            return $s
        }
        $offset += 1
    }
    return substr($bytes, $start)
}

function __my_read_lenenc_int($bytes, &$offset) {
    $first = bytes_get($bytes, $offset)
    if ($first === null) {
        return 0
    }
    $offset += 1
    if ($first < 251) {
        return $first
    }
    if ($first === 252) {
        $v = __my_u16le_at($bytes, $offset)
        $offset += 2
        return $v
    }
    if ($first === 253) {
        $v = __my_u24le_at($bytes, $offset)
        $offset += 3
        return $v
    }
    if ($first === 254) {
        $low = __my_u32le_at($bytes, $offset)
        $high = __my_u32le_at($bytes, $offset + 4)
        $offset += 8
        return $low + ($high * 4294967296)
    }
    return 0
}

function __my_read_lenenc_str($bytes, &$offset) {
    $first = bytes_get($bytes, $offset)
    if ($first === null) {
        return ''
    }
    if ($first === 251) {
        $offset += 1
        return null
    }
    $len = __my_read_lenenc_int($bytes, $offset)
    $s = substr($bytes, $offset, $len)
    $offset += $len
    return $s
}

function __my_send_packet($conn, $payload) {
    $header = __my_i24le(strlen($payload)) . chr($conn.seq & 255)
    $conn.seq = ($conn.seq + 1) & 255
    return tcp_write($conn.sock, $header . $payload)
}

function __my_read_packet($conn) {
    $h = tcp_read_exact($conn.sock, 4)
    if (!result_is_ok($h)) {
        return result_err($h.error)
    }
    $len = __my_u24le_at($h.value, 0)
    $seq = bytes_get($h.value, 3)
    if ($seq === null) {
        return result_err('mysql bad header')
    }
    $conn.seq = ($seq + 1) & 255
    if ($len === 0) {
        return result_ok('')
    }
    $b = tcp_read_exact($conn.sock, $len)
    if (!result_is_ok($b)) {
        return result_err($b.error)
    }
    return result_ok($b.value)
}

function __my_err($payload) {
    if (!is_string($payload) || strlen($payload) < 3) {
        return 'mysql protocol error'
    }
    $msg = ''
    if (strlen($payload) >= 9 && $payload[3] === '#') {
        $msg = substr($payload, 9)
    } else {
        $msg = substr($payload, 3)
    }
    if ($msg === '') {
        return 'mysql error'
    }
    return $msg
}

function __my_sha1_raw($s) {
    return sha1($s, true)
}

function __my_native_token($password, $seed) {
    if ($password === '') {
        return ''
    }
    $s1 = __my_sha1_raw($password)
    $s2 = __my_sha1_raw($s1)
    $s3 = __my_sha1_raw($seed . $s2)
    $out = ''
    for ($i = 0; $i < 20; $i += 1) {
        $out .= chr(bytes_get($s1, $i) ^ bytes_get($s3, $i))
    }
    return $out
}

function __my_parse_handshake($payload) {
    $offset = 0
    $protocol = bytes_get($payload, $offset)
    $offset += 1
    if ($protocol === null || $protocol < 10) {
        return result_err('mysql unsupported protocol')
    }

    __my_cstring_at($payload, $offset)
    $offset += 4

    $part1 = substr($payload, $offset, 8)
    $offset += 8
    $offset += 1

    $cap_low = __my_u16le_at($payload, $offset)
    $offset += 2
    $charset = bytes_get($payload, $offset)
    if ($charset === null) {
        $charset = 33
    }
    $offset += 1
    $offset += 2
    $cap_high = __my_u16le_at($payload, $offset)
    $offset += 2
    $caps = $cap_low | ($cap_high << 16)

    $auth_len = 0
    if (($caps & CLIENT_PLUGIN_AUTH) !== 0) {
        $auth_len = bytes_get($payload, $offset)
        if ($auth_len === null) {
            $auth_len = 0
        }
    }
    $offset += 1
    $offset += 10

    $part2_len = max(13, $auth_len - 8)
    $part2 = substr($payload, $offset, $part2_len)
    $offset += $part2_len

    $seed = $part1 . rtrim($part2, "\0")
    $plugin = 'mysql_native_password'
    if (($caps & CLIENT_PLUGIN_AUTH) !== 0 && $offset < strlen($payload)) {
        $plugin = __my_cstring_at($payload, $offset)
        if ($plugin === '') {
            $plugin = 'mysql_native_password'
        }
    }

    return result_ok({ caps: $caps, charset: $charset, seed: $seed, plugin: $plugin })
}

function __my_connect_wire($config) {
    $host = '127.0.0.1'
    $port = 3306
    $user = 'root'
    $password = ''
    $database = ''
    $timeout_ms = 5000
    $fallback_native = true

    if (is_array($config)) {
        if (array_key_exists('host', $config)) {
            $host = '' . $config['host']
        }
        if (array_key_exists('port', $config)) {
            $port = (int) $config['port']
        }
        if (array_key_exists('user', $config)) {
            $user = '' . $config['user']
        }
        if (array_key_exists('password', $config)) {
            $password = '' . $config['password']
        }
        if (array_key_exists('database', $config)) {
            $database = '' . $config['database']
        }
        if (array_key_exists('dbname', $config)) {
            $database = '' . $config['dbname']
        }
        if (array_key_exists('timeout_ms', $config)) {
            $timeout_ms = (int) $config['timeout_ms']
        }
        if (array_key_exists('fallback_native', $config)) {
            $fallback_native = !!$config['fallback_native']
        }
    } else if (is_object($config)) {
        if (isset($config.host)) {
            $host = '' . $config.host
        }
        if (isset($config.port)) {
            $port = (int) $config.port
        }
        if (isset($config.user)) {
            $user = '' . $config.user
        }
        if (isset($config.password)) {
            $password = '' . $config.password
        }
        if (isset($config.database)) {
            $database = '' . $config.database
        }
        if (isset($config.dbname)) {
            $database = '' . $config.dbname
        }
        if (isset($config.timeout_ms)) {
            $timeout_ms = (int) $config.timeout_ms
        }
        if (isset($config.fallback_native)) {
            $fallback_native = !!$config.fallback_native
        }
    }

    $open = tcp_connect($host, $port, { timeout_ms: $timeout_ms })
    if (!result_is_ok($open)) {
        return result_err('wire connect failed: ' . $open.error)
    }

    $conn = {
        kind: 'wire',
        driver: 'mysql',
        sock: $open.value,
        seq: 0,
        native_config: $config,
        allow_native_fallback: $fallback_native
    }
    $deadline = tcp_set_deadline($conn.sock, $timeout_ms)
    if (!result_is_ok($deadline)) {
        tcp_close($conn.sock)
        return result_err('wire deadline failed: ' . $deadline.error)
    }

    $hello = __my_read_packet($conn)
    if (!result_is_ok($hello)) {
        tcp_close($conn.sock)
        return result_err('wire handshake read failed: ' . $hello.error)
    }

    if (strlen($hello.value) > 0 && bytes_get($hello.value, 0) === 255) {
        tcp_close($conn.sock)
        return result_err('wire handshake error: ' . __my_err($hello.value))
    }

    $hs = __my_parse_handshake($hello.value)
    if (!result_is_ok($hs)) {
        tcp_close($conn.sock)
        return result_err($hs.error)
    }

    if ($hs.value.plugin !== 'mysql_native_password') {
        tcp_close($conn.sock)
        return result_err('wire_unsupported_auth:' . $hs.value.plugin)
    }

    $want = CLIENT_LONG_PASSWORD | CLIENT_LONG_FLAG | CLIENT_PROTOCOL_41 | CLIENT_TRANSACTIONS | CLIENT_SECURE_CONNECTION | CLIENT_MULTI_RESULTS | CLIENT_PLUGIN_AUTH | CLIENT_DEPRECATE_EOF
    if ($database !== '') {
        $want |= CLIENT_CONNECT_WITH_DB
    }
    $caps = $want & $hs.value.caps
    $token = __my_native_token($password, $hs.value.seed)

    $resp = __my_i32le($caps)
    $resp .= __my_i32le(1024 * 1024 * 16)
    $resp .= chr($hs.value.charset)
    $resp .= str_repeat("\0", 23)
    $resp .= $user . "\0"
    $resp .= chr(strlen($token)) . $token
    if (($caps & CLIENT_CONNECT_WITH_DB) !== 0) {
        $resp .= $database . "\0"
    }
    if (($caps & CLIENT_PLUGIN_AUTH) !== 0) {
        $resp .= 'mysql_native_password' . "\0"
    }

    $conn.seq = 1
    $sent = __my_send_packet($conn, $resp)
    if (!result_is_ok($sent)) {
        tcp_close($conn.sock)
        return result_err('wire handshake send failed: ' . $sent.error)
    }

    $auth = __my_read_packet($conn)
    if (!result_is_ok($auth)) {
        tcp_close($conn.sock)
        return result_err('wire auth read failed: ' . $auth.error)
    }

    $kind = bytes_get($auth.value, 0)
    if ($kind === 0) {
        return result_ok($conn)
    }
    if ($kind === 255) {
        tcp_close($conn.sock)
        return result_err('wire auth error: ' . __my_err($auth.value))
    }

    tcp_close($conn.sock)
    return result_err('wire auth unsupported response')
}

function __my_is_wire_handle($handle) {
    return is_object($handle) && isset($handle.kind) && $handle.kind === 'wire' && isset($handle.driver) && $handle.driver === 'mysql' && isset($handle.sock)
}

function __my_query_native_once($handle, $sql, $params = []) {
    if (is_object($handle) && isset($handle.allow_native_fallback) && !$handle.allow_native_fallback) {
        return result_err('wire mysql native fallback disabled')
    }
    if (!is_object($handle) || !isset($handle.native_config)) {
        return result_err('wire mysql missing native fallback config')
    }
    $native = open_handle('mysql', $handle.native_config)
    if (!result_is_ok($native)) {
        return result_err($native.error)
    }
    $run = db_query($native.value, $sql, $params)
    db_close($native.value)
    return $run
}

function __my_exec_native_once($handle, $sql, $params = []) {
    if (is_object($handle) && isset($handle.allow_native_fallback) && !$handle.allow_native_fallback) {
        return result_err('wire mysql native fallback disabled')
    }
    if (!is_object($handle) || !isset($handle.native_config)) {
        return result_err('wire mysql missing native fallback config')
    }
    $native = open_handle('mysql', $handle.native_config)
    if (!result_is_ok($native)) {
        return result_err($native.error)
    }
    $run = db_exec($native.value, $sql, $params)
    db_close($native.value)
    return $run
}

function __my_query_one_native_once($handle, $sql, $params = []) {
    if (is_object($handle) && isset($handle.allow_native_fallback) && !$handle.allow_native_fallback) {
        return result_err('wire mysql native fallback disabled')
    }
    if (!is_object($handle) || !isset($handle.native_config)) {
        return result_err('wire mysql missing native fallback config')
    }
    $native = open_handle('mysql', $handle.native_config)
    if (!result_is_ok($native)) {
        return result_err($native.error)
    }
    $run = db_query_one($native.value, $sql, $params)
    db_close($native.value)
    return $run
}

function __my_parse_columns($count, $conn) {
    $cols = []
    $types = []
    for ($i = 0; $i < $count; $i += 1) {
        $p = __my_read_packet($conn)
        if (!result_is_ok($p)) {
            return result_err($p.error)
        }
        if (strlen($p.value) > 0 && bytes_get($p.value, 0) === 255) {
            return result_err(__my_err($p.value))
        }
        $o = 0
        __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        $name = __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_str($p.value, $o)
        __my_read_lenenc_int($p.value, $o)
        $o += 2
        $o += 4
        $typ = bytes_get($p.value, $o)
        if ($typ === null) {
            $typ = 253
        }
        $types[] = $typ
        if (!is_string($name) || $name === '') {
            $name = 'col_' . $i
        }
        $cols[] = $name
    }

    $after_cols = __my_read_packet($conn)
    if (!result_is_ok($after_cols)) {
        return result_err($after_cols.error)
    }
    $marker = bytes_get($after_cols.value, 0)
    if ($marker !== 254 || strlen($after_cols.value) >= 9) {
        return result_err('mysql expected column EOF')
    }

    return result_ok({ names: $cols, types: $types })
}

function __my_parse_rows($cols, $conn) {
    $rows = []
    while (true) {
        $p = __my_read_packet($conn)
        if (!result_is_ok($p)) {
            return result_err($p.error)
        }
        $kind = bytes_get($p.value, 0)
        if ($kind === 255) {
            return result_err(__my_err($p.value))
        }
        if ($kind === 254 && strlen($p.value) < 9) {
            return result_ok($rows)
        }

        $o = 0
        $row = []
        for ($i = 0; $i < count($cols); $i += 1) {
            $val = __my_read_lenenc_str($p.value, $o)
            $row[$cols[$i]] = $val
        }
        $rows[] = $row
    }
}

function __my_lenenc_encode($n) {
    $v = (int) $n
    if ($v < 251) {
        return chr($v)
    }
    if ($v <= 65535) {
        return chr(252) . __my_i16le($v)
    }
    if ($v <= 16777215) {
        return chr(253) . __my_i24le($v)
    }
    return chr(254) . __my_i32le($v) . __my_i32le((int) floor($v / 4294967296))
}

function __my_i64le($n) {
    $v = (int) $n
    $out = ''
    for ($i = 0; $i < 8; $i += 1) {
        $out .= chr($v & 255)
        $v = ($v >> 8)
    }
    return $out
}

function __my_u64le_at($bytes, $offset) {
    $v = 0
    $shift = 1
    for ($i = 0; $i < 8; $i += 1) {
        $b = bytes_get($bytes, $offset + $i)
        if ($b === null) {
            return 0
        }
        $v += ($b * $shift)
        $shift *= 256
    }
    return $v
}

function __my_stmt_prepare($conn, $sql) {
    $conn.seq = 0
    $sent = __my_send_packet($conn, chr(0x16) . $sql)
    if (!result_is_ok($sent)) {
        return result_err('wire stmt prepare send failed: ' . $sent.error)
    }

    $resp = __my_read_packet($conn)
    if (!result_is_ok($resp)) {
        return result_err('wire stmt prepare read failed: ' . $resp.error)
    }
    if (strlen($resp.value) === 0) {
        return result_err('wire stmt prepare empty response')
    }

    $kind = bytes_get($resp.value, 0)
    if ($kind === 255) {
        return result_err(__my_err($resp.value))
    }
    if ($kind !== 0) {
        return result_err('wire stmt prepare invalid response')
    }

    $stmt_id = __my_u32le_at($resp.value, 1)
    $num_cols = __my_u16le_at($resp.value, 5)
    $num_params = __my_u16le_at($resp.value, 7)

    for ($i = 0; $i < $num_params; $i += 1) {
        $p = __my_read_packet($conn)
        if (!result_is_ok($p)) {
            return result_err($p.error)
        }
        if (strlen($p.value) > 0 && bytes_get($p.value, 0) === 255) {
            return result_err(__my_err($p.value))
        }
    }
    if ($num_params > 0) {
        $e = __my_read_packet($conn)
        if (!result_is_ok($e)) {
            return result_err($e.error)
        }
    }

    for ($i = 0; $i < $num_cols; $i += 1) {
        $c = __my_read_packet($conn)
        if (!result_is_ok($c)) {
            return result_err($c.error)
        }
        if (strlen($c.value) > 0 && bytes_get($c.value, 0) === 255) {
            return result_err(__my_err($c.value))
        }
    }
    if ($num_cols > 0) {
        $e = __my_read_packet($conn)
        if (!result_is_ok($e)) {
            return result_err($e.error)
        }
    }

    return result_ok({ stmt_id: $stmt_id, num_cols: $num_cols, num_params: $num_params })
}

function __my_stmt_close($conn, $stmt_id) {
    $conn.seq = 0
    __my_send_packet($conn, chr(0x19) . __my_i32le($stmt_id))
    return result_ok({ ok: true })
}

function __my_stmt_param_encode($value) {
    if ($value === null) {
        return result_ok({ typ: 6, bytes: '', is_null: true })
    }
    if (is_bool($value)) {
        return result_ok({ typ: 1, bytes: chr($value ? 1 : 0), is_null: false })
    }
    if (is_int($value)) {
        return result_ok({ typ: 8, bytes: __my_i64le($value), is_null: false })
    }
    if (is_float($value)) {
        return result_ok({ typ: 253, bytes: __my_lenenc_encode(strlen('' . $value)) . ('' . $value), is_null: false })
    }
    if (is_string($value)) {
        return result_ok({ typ: 253, bytes: __my_lenenc_encode(strlen($value)) . $value, is_null: false })
    }
    return result_err('wire mysql unsupported param type')
}

function __my_is_param_type_error($msg) {
    return is_string($msg) && strpos($msg, 'wire mysql unsupported param type') === 0
}

function __my_stmt_execute_payload($stmt_id, $params) {
    $values = is_array($params) ? array_values($params) : []
    $n = count($values)
    $payload = chr(0x17) . __my_i32le($stmt_id) . chr(0) . __my_i32le(1)
    if ($n === 0) {
        return result_ok($payload)
    }

    $null_bitmap_len = (int) floor(($n + 7) / 8)
    $null_bitmap = str_repeat("\0", $null_bitmap_len)
    $types = ''
    $vals = ''
    for ($i = 0; $i < $n; $i += 1) {
        $enc = __my_stmt_param_encode($values[$i])
        if (!result_is_ok($enc)) {
            return result_err($enc.error . ' at index ' . $i)
        }
        if ($enc.value.is_null) {
            $byte = (int) floor($i / 8)
            $bit = $i % 8
            $cur = bytes_get($null_bitmap, $byte)
            if ($cur === null) {
                $cur = 0
            }
            $cur = $cur | (1 << $bit)
            $null_bitmap = substr($null_bitmap, 0, $byte) . chr($cur) . substr($null_bitmap, $byte + 1)
        }
        $types .= chr($enc.value.typ) . chr(0)
        $vals .= $enc.value.bytes
    }

    $payload .= $null_bitmap . chr(1) . $types . $vals
    return result_ok($payload)
}

function __my_binary_read_cell($bytes, &$offset, $typ) {
    if ($typ === 1) {
        $v = bytes_get($bytes, $offset)
        $offset += 1
        return '' . $v
    }
    if ($typ === 2) {
        $v = __my_u16le_at($bytes, $offset)
        $offset += 2
        return '' . $v
    }
    if ($typ === 3) {
        $v = __my_u32le_at($bytes, $offset)
        $offset += 4
        return '' . $v
    }
    if ($typ === 8) {
        $v = __my_u64le_at($bytes, $offset)
        $offset += 8
        return '' . $v
    }
    if ($typ === 4) {
        $raw = substr($bytes, $offset, 4)
        $offset += 4
        $u = unpack('f', $raw)
        return '' . (is_array($u) ? $u[1] : 0)
    }
    if ($typ === 5) {
        $raw = substr($bytes, $offset, 8)
        $offset += 8
        $u = unpack('d', $raw)
        return '' . (is_array($u) ? $u[1] : 0)
    }
    return __my_read_lenenc_str($bytes, $offset)
}

function __my_parse_rows_binary($names, $types, $conn) {
    $rows = []
    $col_count = count($names)
    $bitmap_len = (int) floor(($col_count + 7 + 2) / 8)

    while (true) {
        $p = __my_read_packet($conn)
        if (!result_is_ok($p)) {
            return result_err($p.error)
        }
        if (strlen($p.value) === 0) {
            continue
        }
        $kind = bytes_get($p.value, 0)
        if ($kind === 255) {
            return result_err(__my_err($p.value))
        }
        if ($kind === 254 && strlen($p.value) < 9) {
            return result_ok($rows)
        }
        if ($kind !== 0) {
            return result_err('mysql unexpected binary row packet')
        }

        $bitmap = substr($p.value, 1, $bitmap_len)
        $offset = 1 + $bitmap_len
        $row = []
        for ($i = 0; $i < $col_count; $i += 1) {
            $byte = bytes_get($bitmap, (int) floor(($i + 2) / 8))
            if ($byte === null) {
                $byte = 0
            }
            $bit = ($i + 2) % 8
            $is_null = (($byte >> $bit) & 1) === 1
            $name = $names[$i]
            if ($is_null) {
                $row[$name] = null
                continue
            }
            $typ = $i < count($types) ? $types[$i] : 253
            $row[$name] = __my_binary_read_cell($p.value, $offset, $typ)
        }
        $rows[] = $row
    }
}

function __my_query_wire_prepared($conn, $sql, $params) {
    $prep = __my_stmt_prepare($conn, $sql)
    if (!result_is_ok($prep)) {
        return result_err($prep.error)
    }
    $stmt_id = $prep.value.stmt_id

    $payload = __my_stmt_execute_payload($stmt_id, $params)
    if (!result_is_ok($payload)) {
        __my_stmt_close($conn, $stmt_id)
        return result_err($payload.error)
    }

    $conn.seq = 0
    $sent = __my_send_packet($conn, $payload.value)
    if (!result_is_ok($sent)) {
        __my_stmt_close($conn, $stmt_id)
        return result_err('wire stmt execute send failed: ' . $sent.error)
    }

    $first = __my_read_packet($conn)
    if (!result_is_ok($first)) {
        __my_stmt_close($conn, $stmt_id)
        return result_err('wire stmt execute read failed: ' . $first.error)
    }

    if (strlen($first.value) === 0) {
        __my_stmt_close($conn, $stmt_id)
        return result_ok({ rows: [], affected_rows: 0 })
    }

    $kind = bytes_get($first.value, 0)
    if ($kind === 255) {
        __my_stmt_close($conn, $stmt_id)
        return result_err(__my_err($first.value))
    }

    if ($kind === 0) {
        $o = 1
        $affected = __my_read_lenenc_int($first.value, $o)
        __my_stmt_close($conn, $stmt_id)
        return result_ok({ rows: [], affected_rows: $affected })
    }

    $o = 0
    $col_count = __my_read_lenenc_int($first.value, $o)
    $cols = __my_parse_columns($col_count, $conn)
    if (!result_is_ok($cols)) {
        __my_stmt_close($conn, $stmt_id)
        return result_err('wire stmt columns parse failed: ' . $cols.error)
    }

    $rows = __my_parse_rows_binary($cols.value.names, $cols.value.types, $conn)
    __my_stmt_close($conn, $stmt_id)
    if (!result_is_ok($rows)) {
        return result_err('wire stmt rows parse failed: ' . $rows.error)
    }
    return result_ok({ rows: $rows.value, affected_rows: count($rows.value) })
}

function __my_query_wire($conn, $sql) {
    $conn.seq = 0
    $sent = __my_send_packet($conn, chr(0x03) . $sql)
    if (!result_is_ok($sent)) {
        return result_err('wire query send failed: ' . $sent.error)
    }

    $first = __my_read_packet($conn)
    if (!result_is_ok($first)) {
        return result_err('wire query read failed: ' . $first.error)
    }

    if (strlen($first.value) === 0) {
        return result_ok({ rows: [], affected_rows: 0 })
    }

    $kind = bytes_get($first.value, 0)
    if ($kind === 255) {
        return result_err(__my_err($first.value))
    }

    if ($kind === 0) {
        $o = 1
        $affected = __my_read_lenenc_int($first.value, $o)
        return result_ok({ rows: [], affected_rows: $affected })
    }

    $o = 0
    $col_count = __my_read_lenenc_int($first.value, $o)
    $cols = __my_parse_columns($col_count, $conn)
    if (!result_is_ok($cols)) {
        return result_err('wire column parse failed: ' . $cols.error)
    }

    $rows = __my_parse_rows($cols.value.names, $conn)
    if (!result_is_ok($rows)) {
        return result_err('wire row parse failed: ' . $rows.error)
    }

    return result_ok({ rows: $rows.value, affected_rows: count($rows.value) })
}

export function connect($config) {
    $wire = __my_connect_wire($config)
    if (result_is_ok($wire)) {
        return $wire
    }

    $fallback_native = true
    if (is_array($config) && array_key_exists('fallback_native', $config)) {
        $fallback_native = !!$config['fallback_native']
    } else if (is_object($config) && isset($config.fallback_native)) {
        $fallback_native = !!$config.fallback_native
    }

    if (!$fallback_native) {
        return $wire
    }

    return open_handle('mysql', $config)
}

export function query($handle, $sql, $params = []) {
    if (__my_is_wire_handle($handle)) {
        if (is_array($params) && count($params) > 0) {
            $res = __my_query_wire_prepared($handle, $sql, $params)
            if (result_is_ok($res)) {
                return result_ok({ rows: $res.value.rows })
            }
            if (__my_is_param_type_error($res.error)) {
                return result_err($res.error)
            }
            if (is_object($handle) && isset($handle.allow_native_fallback) && !$handle.allow_native_fallback) {
                return result_err($res.error)
            }
            return __my_query_native_once($handle, $sql, $params)
        }
        $res = __my_query_wire($handle, $sql)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ rows: $res.value.rows })
    }
    return db_query($handle, $sql, $params)
}

export function query_one($handle, $sql, $params = []) {
    if (__my_is_wire_handle($handle)) {
        if (is_array($params) && count($params) > 0) {
            $res = __my_query_wire_prepared($handle, $sql, $params)
            if (result_is_ok($res)) {
                if (!is_array($res.value.rows) || count($res.value.rows) === 0) {
                    return result_err('no rows')
                }
                return result_ok($res.value.rows[0])
            }
            if (__my_is_param_type_error($res.error)) {
                return result_err($res.error)
            }
            if (is_object($handle) && isset($handle.allow_native_fallback) && !$handle.allow_native_fallback) {
                return result_err($res.error)
            }
            return __my_query_one_native_once($handle, $sql, $params)
        }
        $res = query($handle, $sql, $params)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        if (!is_array($res.value.rows) || count($res.value.rows) === 0) {
            return result_err('no rows')
        }
        return result_ok($res.value.rows[0])
    }
    return db_query_one($handle, $sql, $params)
}

export function exec($handle, $sql, $params = []) {
    if (__my_is_wire_handle($handle)) {
        if (is_array($params) && count($params) > 0) {
            $res = __my_query_wire_prepared($handle, $sql, $params)
            if (result_is_ok($res)) {
                return result_ok({ affected_rows: $res.value.affected_rows })
            }
            if (__my_is_param_type_error($res.error)) {
                return result_err($res.error)
            }
            if (is_object($handle) && isset($handle.allow_native_fallback) && !$handle.allow_native_fallback) {
                return result_err($res.error)
            }
            return __my_exec_native_once($handle, $sql, $params)
        }
        $res = __my_query_wire($handle, $sql)
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ affected_rows: $res.value.affected_rows })
    }
    return db_exec($handle, $sql, $params)
}

export function begin($handle) {
    if (__my_is_wire_handle($handle)) {
        $res = exec($handle, 'START TRANSACTION', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_begin($handle)
}

export function commit($handle) {
    if (__my_is_wire_handle($handle)) {
        $res = exec($handle, 'COMMIT', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_commit($handle)
}

export function rollback($handle) {
    if (__my_is_wire_handle($handle)) {
        $res = exec($handle, 'ROLLBACK', [])
        if (!result_is_ok($res)) {
            return result_err($res.error)
        }
        return result_ok({ ok: true })
    }
    return db_rollback($handle)
}

export function close($handle) {
    if (__my_is_wire_handle($handle)) {
        $handle.seq = 0
        __my_send_packet($handle, chr(0x01))
        return tcp_close($handle.sock)
    }
    return db_close($handle)
}
