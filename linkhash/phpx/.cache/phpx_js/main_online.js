// Generated by deka build. Do not edit manually.
// Target semantics: JavaScript runtime semantics.
export const phpxBuildMode = "subset-ast";
export const phpxTargetSemantics = "js";

if (!globalThis.panic) { globalThis.panic = (msg) => { throw new Error(String(msg)); }; }
if (!globalThis.function_exists) { globalThis.function_exists = (name) => typeof globalThis[name] === 'function'; }
if (!globalThis.class_exists) { globalThis.class_exists = (name) => typeof globalThis[name] === 'function' || typeof globalThis[name] === 'object'; }
if (!globalThis.class_alias) { globalThis.class_alias = () => false; }

if (!globalThis.defined) { globalThis.defined = (name) => Object.prototype.hasOwnProperty.call(globalThis, String(name)); }

if (!globalThis.__phpx_is_struct) { globalThis.__phpx_is_struct = (value, name) => Boolean(value && typeof value === 'object' && value.__struct === name); }

if (!globalThis.__phpx_func_num_args) { globalThis.__phpx_func_num_args = (args) => args.length; }
if (!globalThis.__phpx_func_get_args) { globalThis.__phpx_func_get_args = (args) => Array.prototype.slice.call(args); }
if (!globalThis.__phpx_func_get_arg) { globalThis.__phpx_func_get_arg = (args, idx) => (idx >= 0 && idx < args.length ? args[idx] : null); }

if (!globalThis.__deka_chr) { globalThis.__deka_chr = (code) => String.fromCharCode((Number(code) || 0) & 0xff); }
if (!globalThis.__deka_ord) { globalThis.__deka_ord = (value) => { const str = String(value ?? ''); return str.length ? str.charCodeAt(0) : 0; }; }
if (!globalThis.chr) { globalThis.chr = globalThis.__deka_chr; }
if (!globalThis.ord) { globalThis.ord = globalThis.__deka_ord; }
if (!globalThis.strlen) { globalThis.strlen = (value) => String(value ?? '').length; }
if (!globalThis.substr) { globalThis.substr = (value, start, length = null) => { const src = String(value ?? ''); let s = Number(start) || 0; if (s < 0) s = Math.max(src.length + s, 0); if (length === null || length === undefined) return src.slice(s); let l = Number(length) || 0; if (l < 0) return src.slice(s, Math.max(src.length + l, s)); return src.slice(s, s + l); }; }
if (!globalThis.ltrim) { globalThis.ltrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/^\s+/, ''); const set = new Set(String(chars)); let i = 0; while (i < src.length && set.has(src[i])) i += 1; return src.slice(i); }; }
if (!globalThis.rtrim) { globalThis.rtrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/\s+$/, ''); const set = new Set(String(chars)); let i = src.length - 1; while (i >= 0 && set.has(src[i])) i -= 1; return src.slice(0, i + 1); }; }
if (!globalThis.trim) { globalThis.trim = (value, chars = null) => globalThis.ltrim(globalThis.rtrim(value, chars), chars); }
if (!globalThis.strpos) { globalThis.strpos = (haystack, needle, offset = 0) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = h.indexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }
if (!globalThis.strrpos) { globalThis.strrpos = (haystack, needle, offset = null) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = offset === null || offset === undefined ? h.lastIndexOf(n) : h.lastIndexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }
if (!globalThis.str_starts_with) { globalThis.str_starts_with = (haystack, needle) => String(haystack ?? '').startsWith(String(needle ?? '')); }
if (!globalThis.str_ends_with) { globalThis.str_ends_with = (haystack, needle) => String(haystack ?? '').endsWith(String(needle ?? '')); }
if (!globalThis.str_contains) { globalThis.str_contains = (haystack, needle) => String(haystack ?? '').includes(String(needle ?? '')); }
if (!globalThis.strtolower) { globalThis.strtolower = (value) => String(value ?? '').toLowerCase(); }
if (!globalThis.strtoupper) { globalThis.strtoupper = (value) => String(value ?? '').toUpperCase(); }
if (!globalThis.array_key_exists) { globalThis.array_key_exists = (key, value) => { if (value === null || value === undefined) return false; if (Array.isArray(value)) { const idx = Number(key); return Number.isInteger(idx) && idx >= 0 && idx < value.length; } if (typeof value === 'object') return Object.prototype.hasOwnProperty.call(value, key); return false; }; }
if (!globalThis.in_array) { globalThis.in_array = (needle, haystack, strict = false) => { if (!Array.isArray(haystack)) return false; for (const item of haystack) { if (strict ? item === needle : item == needle) return true; } return false; }; }
if (!globalThis.explode) { globalThis.explode = (sep, value, limit = null) => { const s = String(value ?? ''); const parts = s.split(String(sep ?? '')); if (limit === null || limit === undefined || Number(limit) === 0) return parts; const n = Number(limit); if (!Number.isInteger(n)) return parts; if (n > 0) { if (parts.length <= n) return parts; const head = parts.slice(0, n - 1); head.push(parts.slice(n - 1).join(String(sep ?? ''))); return head; } return parts; }; }
if (!globalThis.implode) { globalThis.implode = (glue, pieces = null) => { if (pieces === null || pieces === undefined) { pieces = glue; glue = ''; } if (!Array.isArray(pieces)) return ''; return pieces.map((v) => String(v ?? '')).join(String(glue ?? '')); }; }
if (!globalThis.count) { globalThis.count = (value) => { if (Array.isArray(value) || typeof value === 'string') return value.length; if (value && typeof value === 'object') return Object.keys(value).length; return 0; }; }
if (!globalThis.time) { globalThis.time = () => Math.floor(Date.now() / 1000); }
if (!globalThis.getenv) { globalThis.getenv = (name) => { const key = String(name ?? ''); const env = globalThis.process && globalThis.process.env ? globalThis.process.env : null; if (!env || !Object.prototype.hasOwnProperty.call(env, key)) return false; const value = env[key]; return value === undefined || value === null ? false : String(value); }; }
if (!globalThis.is_promise) { globalThis.is_promise = (value) => Boolean(value && typeof value === 'object' && typeof value.then === 'function'); }
if (!globalThis.GLOBALS || typeof globalThis.GLOBALS !== 'object') { globalThis.GLOBALS = {}; }
if (typeof globalThis.JSON_ERROR_NONE !== 'number') { globalThis.JSON_ERROR_NONE = 0; }
if (typeof globalThis.JSON_ERROR_DEPTH !== 'number') { globalThis.JSON_ERROR_DEPTH = 1; }
if (typeof globalThis.JSON_ERROR_STATE_MISMATCH !== 'number') { globalThis.JSON_ERROR_STATE_MISMATCH = 2; }
if (typeof globalThis.JSON_ERROR_CTRL_CHAR !== 'number') { globalThis.JSON_ERROR_CTRL_CHAR = 3; }
if (typeof globalThis.JSON_ERROR_SYNTAX !== 'number') { globalThis.JSON_ERROR_SYNTAX = 4; }
if (typeof globalThis.JSON_ERROR_UTF8 !== 'number') { globalThis.JSON_ERROR_UTF8 = 5; }
if (typeof globalThis.JSON_ERROR_RECURSION !== 'number') { globalThis.JSON_ERROR_RECURSION = 6; }
if (typeof globalThis.JSON_ERROR_INF_OR_NAN !== 'number') { globalThis.JSON_ERROR_INF_OR_NAN = 7; }
if (typeof globalThis.JSON_ERROR_UNSUPPORTED_TYPE !== 'number') { globalThis.JSON_ERROR_UNSUPPORTED_TYPE = 8; }
if (typeof globalThis.JSON_ERROR_INVALID_PROPERTY_NAME !== 'number') { globalThis.JSON_ERROR_INVALID_PROPERTY_NAME = 9; }
if (typeof globalThis.JSON_ERROR_UTF16 !== 'number') { globalThis.JSON_ERROR_UTF16 = 10; }
if (!globalThis.__deka_object_set) { globalThis.__deka_object_set = (obj, key, value) => { if (obj && typeof obj === 'object') { obj[key] = value; } return obj; }; }
if (!globalThis.__phpx_base64_table) { globalThis.__phpx_base64_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; }
if (!globalThis.base64_encode) { globalThis.base64_encode = (input) => { const str = String(input ?? ''); const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < str.length; i += 3) { const b0 = str.charCodeAt(i) & 0xff; const b1 = i + 1 < str.length ? str.charCodeAt(i + 1) & 0xff : NaN; const b2 = i + 2 < str.length ? str.charCodeAt(i + 2) & 0xff : NaN; const n = (b0 << 16) | ((Number.isNaN(b1) ? 0 : b1) << 8) | (Number.isNaN(b2) ? 0 : b2); out += tbl[(n >> 18) & 63]; out += tbl[(n >> 12) & 63]; out += Number.isNaN(b1) ? '=' : tbl[(n >> 6) & 63]; out += Number.isNaN(b2) ? '=' : tbl[n & 63]; } return out; }; }
if (!globalThis.base64_decode) { globalThis.base64_decode = (input, strict = false) => { const src = String(input ?? '').replace(/\s+/g, ''); if (src.length % 4 !== 0) return strict ? false : ''; const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < src.length; i += 4) { const c0 = src[i], c1 = src[i + 1], c2 = src[i + 2], c3 = src[i + 3]; const n0 = tbl.indexOf(c0), n1 = tbl.indexOf(c1); const n2 = c2 === '=' ? -1 : tbl.indexOf(c2); const n3 = c3 === '=' ? -1 : tbl.indexOf(c3); if (n0 < 0 || n1 < 0 || n2 < -1 || n3 < -1) return strict ? false : ''; const n = (n0 << 18) | (n1 << 12) | ((n2 < 0 ? 0 : n2) << 6) | (n3 < 0 ? 0 : n3); out += String.fromCharCode((n >> 16) & 0xff); if (c2 !== '=') out += String.fromCharCode((n >> 8) & 0xff); if (c3 !== '=') out += String.fromCharCode(n & 0xff); } return out; }; }
if (!globalThis.__phpx_sha256_hex) { globalThis.__phpx_sha256_hex = (input) => { const K = [1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]; const bytes = []; const src = String(input ?? ''); for (let i = 0; i < src.length; i += 1) bytes.push(src.charCodeAt(i) & 0xff); const bitLen = bytes.length * 8; bytes.push(0x80); while ((bytes.length % 64) !== 56) bytes.push(0); for (let i = 7; i >= 0; i -= 1) bytes.push((bitLen >>> (i * 8)) & 0xff); let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a, h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19; const rotr = (x, n) => ((x >>> n) | (x << (32 - n))) >>> 0; for (let i = 0; i < bytes.length; i += 64) { const w = new Array(64); for (let j = 0; j < 16; j += 1) { const k = i + (j * 4); w[j] = (((bytes[k] << 24) | (bytes[k + 1] << 16) | (bytes[k + 2] << 8) | bytes[k + 3]) >>> 0); } for (let j = 16; j < 64; j += 1) { const s0 = (rotr(w[j - 15], 7) ^ rotr(w[j - 15], 18) ^ (w[j - 15] >>> 3)) >>> 0; const s1 = (rotr(w[j - 2], 17) ^ rotr(w[j - 2], 19) ^ (w[j - 2] >>> 10)) >>> 0; w[j] = (((w[j - 16] + s0) >>> 0) + ((w[j - 7] + s1) >>> 0)) >>> 0; } let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7; for (let j = 0; j < 64; j += 1) { const S1 = (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) >>> 0; const ch = ((e & f) ^ ((~e) & g)) >>> 0; const t1 = (((((h + S1) >>> 0) + ch) >>> 0) + ((K[j] + w[j]) >>> 0)) >>> 0; const S0 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) >>> 0; const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0; const t2 = (S0 + maj) >>> 0; h = g; g = f; f = e; e = (d + t1) >>> 0; d = c; c = b; b = a; a = (t1 + t2) >>> 0; } h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0; h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0; } const words = [h0, h1, h2, h3, h4, h5, h6, h7]; let out = ''; for (const w of words) { out += (w >>> 0).toString(16).padStart(8, '0'); } return out; }; }
if (!globalThis.__phpx_hex_to_binary) { globalThis.__phpx_hex_to_binary = (hex) => { const src = String(hex ?? ''); let out = ''; for (let i = 0; i < src.length; i += 2) out += String.fromCharCode(parseInt(src.slice(i, i + 2), 16) & 0xff); return out; }; }
if (!globalThis.__phpx_hmac_sha256_hex) { globalThis.__phpx_hmac_sha256_hex = (data, key) => { const toBytes = (s) => { const out = []; const src = String(s ?? ''); for (let i = 0; i < src.length; i += 1) out.push(src.charCodeAt(i) & 0xff); return out; }; const fromBytes = (arr) => arr.map((v) => String.fromCharCode(v & 0xff)).join(''); let k = toBytes(key); if (k.length > 64) { const kh = globalThis.__phpx_sha256_hex(fromBytes(k)); k = toBytes(globalThis.__phpx_hex_to_binary(kh)); } while (k.length < 64) k.push(0); const o = [], i = []; for (let n = 0; n < 64; n += 1) { o.push(k[n] ^ 0x5c); i.push(k[n] ^ 0x36); } const innerHex = globalThis.__phpx_sha256_hex(fromBytes(i) + String(data ?? '')); const outerHex = globalThis.__phpx_sha256_hex(fromBytes(o) + globalThis.__phpx_hex_to_binary(innerHex)); return outerHex; }; }
if (!globalThis.__phpx_node_crypto) { globalThis.__phpx_node_crypto = (() => { try { if (typeof require === 'function') { return require('node:crypto'); } } catch (_err) {} try { if (typeof require === 'function') { return require('crypto'); } } catch (_err) {} return null; })(); }
if (!globalThis.hash) { globalThis.hash = (algo, data, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_sha256_hex(String(data ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHash !== 'function') throw new Error('hash() requires crypto support'); const digest = mod.createHash(name).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }
if (!globalThis.hash_hmac) { globalThis.hash_hmac = (algo, data, key, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_hmac_sha256_hex(String(data ?? ''), String(key ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHmac !== 'function') throw new Error('hash_hmac() requires crypto support'); const digest = mod.createHmac(name, String(key ?? '')).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }
if (!globalThis.hash_equals) { globalThis.hash_equals = (a, b) => { const left = String(a ?? ''); const right = String(b ?? ''); if (left.length !== right.length) return false; let out = 0; for (let i = 0; i < left.length; i += 1) out |= left.charCodeAt(i) ^ right.charCodeAt(i); return out === 0; }; }
if (!globalThis.__phpx_symbol_table) { globalThis.__phpx_symbol_table = Object.create(null); }
if (!globalThis.__deka_symbol_set) { globalThis.__deka_symbol_set = (name, value) => { const key = String(name); globalThis.__phpx_symbol_table[key] = value; return true; }; }
if (!globalThis.__deka_symbol_get) { globalThis.__deka_symbol_get = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key) ? globalThis.__phpx_symbol_table[key] : null; }; }
if (!globalThis.__deka_symbol_exists) { globalThis.__deka_symbol_exists = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key); }; }
if (!globalThis.__phpx_array_cursor) { globalThis.__phpx_array_cursor = new WeakMap(); }
if (!globalThis.__deka_array_cursor) { globalThis.__deka_array_cursor = (arr, action) => { if (!arr || (typeof arr !== 'object' && !Array.isArray(arr))) return null; const map = globalThis.__phpx_array_cursor; let state = map.get(arr); if (!state) { state = { idx: 0 }; map.set(arr, state); } const keys = Object.keys(arr); if (keys.length === 0) return null; const clamp = () => { if (state.idx < 0) state.idx = 0; if (state.idx >= keys.length) state.idx = keys.length - 1; }; switch (String(action)) { case 'reset': state.idx = 0; break; case 'end': state.idx = keys.length - 1; break; case 'next': state.idx += 1; if (state.idx >= keys.length) return null; break; case 'prev': state.idx -= 1; if (state.idx < 0) return null; break; case 'pos': case 'current': break; case 'key': break; default: return null; } clamp(); const key = keys[state.idx]; if (String(action) === 'key') return key; return arr[key]; }; }

if (!globalThis.is_array || !globalThis.is_array.__deka_polyfill) { const __isArray = (value) => { if (Array.isArray(value)) return true; if (!(value !== null && typeof value === 'object' && Object.getPrototypeOf(value) === Object.prototype)) return false; if (Object.prototype.hasOwnProperty.call(value, '__struct')) return false; return true; }; __isArray.__deka_polyfill = true; globalThis.is_array = __isArray; }

import { bridge } from 'core/bridge';
import { connect as tcp_connect, read as tcp_read, write as tcp_write, close as tcp_close } from 'tcp';
import { result_is_ok } from 'core/result';
import { json_decode } from 'encoding/json';

if (!globalThis.__phpxStructMethods) { globalThis.__phpxStructMethods = Object.create(null); }
function pathFromUrl(url) {
let base = url;
let q = globalThis.strpos(base, "?");
if ((q !== false)) {
base = globalThis.substr(base, 0, q);
}
if ((globalThis.strpos(base, "://") !== false)) {
let scheme = globalThis.strpos(base, "://");
let slash = globalThis.strpos(base, "/", (scheme + 3));
if ((slash === false)) {
return "/";
}
base = globalThis.substr(base, slash);
}
if ((base === "")) {
return "/";
}
return ("" + base);
}

function to_assoc(value) {
if (globalThis.is_array(value)) {
let out = [];
let is_entries = true;
for (const entry of (Array.isArray(value) ? value : Object.values((value ?? {})))) {
if ((((!globalThis.is_array(entry)) || (globalThis.count(entry) !== 2)) || (!globalThis.is_string(entry[0])))) {
is_entries = false;
break;
}
(out[entry[0]] = entry[1]);
}
if (is_entries) {
return out;
}
return value;
}
if (globalThis.is_object(value)) {
let out = [];
if (((value.ok !== undefined && value.ok !== null))) {
(out["ok"] = value.ok);
}
if (((value.error !== undefined && value.error !== null))) {
(out["error"] = value.error);
}
if (((value.entries !== undefined && value.entries !== null))) {
(out["entries"] = value.entries);
}
if ((globalThis.count(out) > 0)) {
return out;
}
}
return value;
}

function to_assoc_deep(value) {
let current = value;
for (let i = 0; (i < 8); (i = (i + 1))) {
let next = to_assoc(current);
if ((next === current)) {
return current;
}
current = next;
}
return current;
}

function entryName(entry) {
if ((globalThis.is_object(entry) && ((entry.name !== undefined && entry.name !== null)))) {
return ("" + entry.name);
}
if ((globalThis.is_array(entry) && globalThis.array_key_exists("name", entry))) {
return ("" + entry["name"]);
}
let assoc = to_assoc_deep(entry);
if ((globalThis.is_object(assoc) && ((assoc.name !== undefined && assoc.name !== null)))) {
return ("" + assoc.name);
}
if ((globalThis.is_array(assoc) && globalThis.array_key_exists("name", assoc))) {
return ("" + assoc["name"]);
}
return "";
}

function readDirEntries(path) {
let raw = bridge("fs", "read_dir", {"path": path, "with_types": true});
let map = to_assoc_deep(raw);
if ((globalThis.is_array(map) && globalThis.array_key_exists("ok", map))) {
if ((!map["ok"])) {
let err = (globalThis.array_key_exists("error", map) ? ("" + map["error"]) : "read_dir failed");
return {"ok": false, "error": err, "entries": []};
}
if (((!globalThis.array_key_exists("entries", map)) || (!globalThis.is_array(map["entries"])))) {
return {"ok": false, "error": "invalid read_dir payload", "entries": []};
}
return {"ok": true, "entries": map["entries"]};
}
if (globalThis.is_array(map)) {
return {"ok": true, "entries": map};
}
return {"ok": false, "error": ((("read_dir failed raw=" + globalThis.gettype(raw)) + " map=") + globalThis.gettype(map)), "entries": []};
}

function reposRoot() {
let env = globalThis.getenv("LINKHASH_REPOS_DIR");
if (((env !== false) && (("" + env) !== ""))) {
return ("" + env);
}
return "/Users/sami/Projects/deka/linkhash/rust/deka-git/repos";
}

function mapLookup(value, key) {
if ((globalThis.is_array(value) && globalThis.array_key_exists(key, value))) {
return value[key];
}
if (globalThis.is_array(value)) {
for (const [k , v] of Object.entries(value)) {
if ((("" + k) === key)) {
return v;
}
}
}
if ((globalThis.is_object(value) && ((value.key !== undefined && value.key !== null)))) {
return value.key;
}
if (globalThis.is_object(value)) {
for (const [k , v] of Object.entries(value)) {
if ((("" + k) === key)) {
return v;
}
}
}
return null;
}

function readAll(handle) {
let buf = "";
while (true) {
let chunk = tcp_read(handle, 8192);
if ((!result_is_ok(chunk))) {
break;
}
let text = ("" + chunk.value);
if ((text === "")) {
break;
}
buf = (buf + text);
if ((globalThis.strlen(text) < 8192)) {
break;
}
}
return buf;
}

function parseHttpBody(raw) {
let sep = globalThis.strpos(raw, "\r\n\r\n");
if ((sep === false)) {
return "";
}
return globalThis.substr(raw, (sep + 4));
}

function fetchPackagesFromApi() {
let host = globalThis.getenv("LINKHASH_GIT_HOST");
if (((host === false) || (("" + host) === ""))) {
host = "127.0.0.1";
}
let port = globalThis.getenv("LINKHASH_GIT_PORT");
if (((port === false) || (("" + port) === ""))) {
port = "8608";
}
let token = globalThis.getenv("LINKHASH_GIT_TOKEN");
if (((token === false) || (("" + token) === ""))) {
token = "test-token";
}
let conn = tcp_connect(("" + host), Number.parseInt(port, 10), {"timeout_ms": 1500});
if ((!result_is_ok(conn))) {
return {"ok": false, "error": ("connect failed: " + ("" + conn.error)), "packages": []};
}
let handle = Number.parseInt(conn.value, 10);
let request = ("GET /api/repos HTTP/1.1" + "\r\n");
request = (((((request + "Host: ") + ("" + host)) + ":") + ("" + port)) + "\r\n");
request = ((request + "Accept: application/json") + "\r\n");
request = (((request + "Authorization: Bearer ") + ("" + token)) + "\r\n");
request = ((request + "Connection: close") + "\r\n\r\n");
let written = tcp_write(handle, request);
if ((!result_is_ok(written))) {
tcp_close(handle);
return {"ok": false, "error": ("write failed: " + ("" + written.error)), "packages": []};
}
let raw = readAll(handle);
tcp_close(handle);
let body = parseHttpBody(raw);
if ((body === "")) {
return {"ok": false, "error": "empty response body from deka-git", "packages": []};
}
let decoded = json_decode(body, true);
let owner = mapLookup(decoded, "owner");
let repos = mapLookup(decoded, "repos");
if ((((!globalThis.is_string(owner)) && (!globalThis.is_numeric(owner))) || ((!globalThis.is_array(repos)) && (!globalThis.is_object(repos))))) {
return {"ok": false, "error": "invalid /api/repos payload", "packages": []};
}
let packages = [];
for (const repo of (Array.isArray(repos) ? repos : Object.values((repos ?? {})))) {
if (((!globalThis.is_string(repo)) && (!globalThis.is_numeric(repo)))) {
continue;
}
let repoName = ("" + repo);
if ((repoName === "")) {
continue;
}
(() => { const __arr = packages; const __val = {"name": ((("@" + ("" + owner)) + "/") + repoName), "owner": ("" + owner), "repo": repoName}; __arr.push(__val); return __val; })();
}
return {"ok": true, "packages": packages};
}

function fetchPackages() {
let api = fetchPackagesFromApi();
if (api["ok"]) {
return api;
}
let root = reposRoot();
let ownersRes = readDirEntries(root);
if ((!ownersRes["ok"])) {
return {"ok": false, "error": ownersRes["error"], "packages": []};
}
let packages = [];
for (const ownerEntry of (Array.isArray(ownersRes["entries"]) ? ownersRes["entries"] : Object.values((ownersRes["entries"] ?? {})))) {
let owner = entryName(ownerEntry);
if ((owner === "")) {
continue;
}
let ownerPath = ((root + "/") + owner);
let reposRes = readDirEntries(ownerPath);
if ((!reposRes["ok"])) {
continue;
}
for (const repoEntry of (Array.isArray(reposRes["entries"]) ? reposRes["entries"] : Object.values((reposRes["entries"] ?? {})))) {
let repoRaw = entryName(repoEntry);
if ((repoRaw === "")) {
continue;
}
if ((!globalThis.str_ends_with(repoRaw, ".git"))) {
continue;
}
let repo = globalThis.substr(repoRaw, 0, (globalThis.strlen(repoRaw) - 4));
(() => { const __arr = packages; const __val = {"name": ((("@" + owner) + "/") + repo), "owner": owner, "repo": repo}; __arr.push(__val); return __val; })();
}
}
return {"ok": true, "packages": packages};
}

function debugJson() {
let root = reposRoot();
let ownersRes = readDirEntries(root);
let apiRes = fetchPackagesFromApi();
let cwd = (globalThis.function_exists("getcwd") ? ("" + globalThis.getcwd()) : "(no getcwd)");
let ownersCount = 0;
if (((globalThis.is_array(ownersRes) && globalThis.array_key_exists("entries", ownersRes)) && globalThis.is_array(ownersRes["entries"]))) {
ownersCount = globalThis.count(ownersRes["entries"]);
}
let status = (((globalThis.is_array(ownersRes) && globalThis.array_key_exists("ok", ownersRes)) && ownersRes["ok"]) ? "true" : "false");
let first = "";
if ((ownersCount > 0)) {
first = entryName(ownersRes["entries"][0]);
}
let err = "";
if ((globalThis.is_array(ownersRes) && globalThis.array_key_exists("error", ownersRes))) {
err = ("" + ownersRes["error"]);
}
let apiStatus = (apiRes["ok"] ? "true" : "false");
let apiCount = globalThis.count(apiRes["packages"]);
let apiErr = (apiRes["ok"] ? "" : ("" + apiRes["error"]));
return (((((((((((((((((("{\"cwd\":\"" + cwd) + "\",\"root\":\"") + root) + "\",\"owners_ok\":") + status) + ",\"owners_count\":") + ("" + ownersCount)) + ",\"first_owner\":\"") + first) + "\",\"error\":\"") + err) + "\",\"api_ok\":") + apiStatus) + ",\"api_count\":") + ("" + apiCount)) + ",\"api_error\":\"") + apiErr) + "\"}");
}

function jsonEscape(value) {
return value;
}

function packagesJson(result) {
if ((!result["ok"])) {
return (("{\"ok\":false,\"error\":\"" + jsonEscape(("" + result["error"]))) + "\",\"packages\":[]}");
}
let items = [];
for (const pkg of (Array.isArray(result["packages"]) ? result["packages"] : Object.values((result["packages"] ?? {})))) {
(() => { const __arr = items; const __val = (((((("{\"name\":\"" + jsonEscape(("" + pkg.name))) + "\",\"owner\":\"") + jsonEscape(("" + pkg.owner))) + "\",\"repo\":\"") + jsonEscape(("" + pkg.repo))) + "\"}"); __arr.push(__val); return __val; })();
}
return (("{\"ok\":true,\"packages\":[" + globalThis.implode(",", items)) + "]}");
}

function statsJson(result) {
if ((!result["ok"])) {
return (("{\"ok\":false,\"error\":\"" + jsonEscape(("" + result["error"]))) + "\",\"packages\":0}");
}
return (("{\"ok\":true,\"packages\":" + ("" + globalThis.count(result["packages"]))) + "}");
}

function renderHome(result) {
let body = "<!doctype html><html><head><meta charset=\"utf-8\" /><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /><title>linkha.sh</title>";
body = (body + "<style>body{font-family:ui-monospace,Menlo,monospace;margin:32px;background:#f7f7f7}main{max-width:920px;margin:0 auto;background:#fff;border:1px solid #ddd;border-radius:10px;padding:20px}a{color:#0b57d0}code{background:#f0f0f0;padding:2px 6px;border-radius:6px}</style>");
body = (body + "</head><body><main>");
body = (body + "<h1>linkha.sh</h1><p>Registry listing is online.</p>");
body = (body + "<p><a href=\"/api/packages\">/api/packages</a> Â· <a href=\"/api/stats/packages\">/api/stats/packages</a></p>");
if ((!result["ok"])) {
body = (((body + "<p>error: ") + ("" + result["error"])) + "</p>");
} else {
body = (((body + "<h2>Published packages (") + ("" + globalThis.count(result["packages"]))) + ")</h2><ul>");
for (const pkg of (Array.isArray(result["packages"]) ? result["packages"] : Object.values((result["packages"] ?? {})))) {
body = (((body + "<li><code>") + ("" + pkg.name)) + "</code></li>");
}
body = (body + "</ul>");
}
body = (body + "</main></body></html>");
return body;
}


const __phpx_main = async () => {
let app = function(req) {
let path = "/";
if ((globalThis.is_object(req) && ((req.url !== undefined && req.url !== null)))) {
path = pathFromUrl(("" + req.url));
} else {
if (((((globalThis._SERVER !== undefined && globalThis._SERVER !== null)) && globalThis.is_array(globalThis._SERVER)) && globalThis.array_key_exists("REQUEST_URI", globalThis._SERVER))) {
path = pathFromUrl(("" + globalThis._SERVER["REQUEST_URI"]));
}
}
let result = fetchPackages();
if ((path === "/api/packages")) {
return packagesJson(result);
}
if ((path === "/api/stats/packages")) {
return statsJson(result);
}
if ((path === "/api/debug")) {
return debugJson();
}
return renderHome(result);
 };
globalThis.app = app;
};
await __phpx_main();
