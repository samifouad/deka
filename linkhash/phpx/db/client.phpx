/*
* AUTO-GENERATED FILE - DO NOT EDIT
* Generated by deka db generate
* Changes will be overwritten.
*/

import { open_handle, close as db_close, query as db_query, exec as db_exec, rows as db_rows, begin as db_begin, commit as db_commit, rollback as db_rollback } from 'db'
import { result_ok, result_err, result_is_ok } from 'core/result'

function quote_ident($name: mixed) {
return '"' . str_replace('"', '""', '' . $name) . '"'
}

function model_name($model: mixed) {
if (is_string($model)) {
return $model
}
if (is_object($model) && isset($model->name)) {
return '' . $model->name
}
if (is_array($model) && array_key_exists('name', $model)) {
return '' . $model['name']
}
return null
}

function to_snake_case($name: mixed) {
$out = ''
$len = strlen($name)
for ($i = 0; $i < $len; $i = $i + 1) {
$ch = $name[$i]
$is_upper = ($ch >= 'A' && $ch <= 'Z')
if ($is_upper && $i > 0) {
$prev = $name[$i - 1]
$prev_lower = ($prev >= 'a' && $prev <= 'z') || ($prev >= '0' && $prev <= '9')
if ($prev_lower) {
$out = $out . '_'
}
}
$out = $out . strtolower($ch)
}
return $out
}

function model_table($model: mixed) {
$name = model_name($model)
if ($name === null || $name === '') {
return null
}
$table = to_snake_case($name)
if (substr($table, -1) !== 's') {
$table = $table . 's'
}
return $table
}

function field_value($obj: mixed, $key: mixed, $fallback: mixed = null) {
if (is_array($obj) && array_key_exists($key, $obj)) {
return $obj[$key]
}
if (is_object($obj) && isset($obj->{$key})) {
return $obj->{$key}
}
if (isset($obj[$key])) {
return $obj[$key]
}
return $fallback
}

function compile_predicate($expr: mixed, &$params: mixed) {
if ($expr === null) {
return ''
}
$kind = field_value($expr, 'kind', null)
if (!is_string($kind) || $kind === '') {
return ''
}
if ($kind === 'eq') {
$column = field_value($expr, 'column', null)
if (!is_string($column) || $column === '') {
return ''
}
$params[] = field_value($expr, 'value', null)
return quote_ident($column) . ' = $' . count($params)
}
if ($kind === 'and' || $kind === 'or') {
$parts = field_value($expr, 'parts', [])
$parts_sql = []
foreach ($parts as $part) {
$inner = compile_predicate($part, $params)
if ($inner !== '') {
$parts_sql[] = '(' . $inner . ')'
}
}
if (count($parts_sql) === 0) {
return ''
}
return implode($kind === 'and' ? ' AND ' : ' OR ', $parts_sql)
}
if ($kind === 'ilike') {
$column = field_value($expr, 'column', null)
if (!is_string($column) || $column === '') {
return ''
}
$params[] = field_value($expr, 'value', null)
return quote_ident($column) . ' ILIKE $' . count($params)
}
if ($kind === 'isNull') {
$column = field_value($expr, 'column', null)
if (!is_string($column) || $column === '') {
return ''
}
return quote_ident($column) . ' IS NULL'
}
return ''
}

export function eq($column: mixed, $value: mixed) {
return [ 'kind' => 'eq', 'column' => $column, 'value' => $value ]
}

export function ilike($column: mixed, $value: mixed) {
return [ 'kind' => 'ilike', 'column' => $column, 'value' => $value ]
}

export function isNull($column: mixed) {
return [ 'kind' => 'isNull', 'column' => $column ]
}

export function andWhere(...$parts: mixed) {
return [ 'kind' => 'and', 'parts' => $parts ]
}

export function orWhere(...$parts: mixed) {
return [ 'kind' => 'or', 'parts' => $parts ]
}

export function asc($column: mixed) {
return [ 'column' => $column, 'dir' => 'ASC' ]
}

export function desc($column: mixed) {
return [ 'column' => $column, 'dir' => 'DESC' ]
}

export function limit($value: mixed) {
return (int) $value
}

export function offset($value: mixed) {
return (int) $value
}

export function connect($driver: mixed, $config: mixed) {
return open_handle($driver, $config)
}

export function close($handle: mixed) {
return db_close($handle)
}

function normalize_includes($includes: mixed) {
if ($includes === null) {
return []
}
if (is_string($includes) && $includes !== '') {
return [$includes]
}
if (is_array($includes)) {
return $includes
}
return []
}

function apply_includes_to_row($handle: mixed, $meta: mixed, $model: mixed, $row: mixed, $includes: mixed) {
if (!is_array($row)) {
return result_err('include expects row array')
}
$out = $row
foreach (normalize_includes($includes) as $field) {
$loaded = loadRelation($handle, $meta, $model, $row, $field)
if (!result_is_ok($loaded)) {
return $loaded
}
$out[$field] = $loaded->value
}
return result_ok($out)
}

function apply_includes_to_rows($handle: mixed, $meta: mixed, $model: mixed, $rows: mixed, $includes: mixed) {
$fields = normalize_includes($includes)
if (count($fields) === 0) {
return result_ok($rows)
}
$out = []
foreach ($rows as $row) {
$one = apply_includes_to_row($handle, $meta, $model, $row, $fields)
if (!result_is_ok($one)) {
return $one
}
$out[] = $one->value
}
return result_ok($out)
}

export function selectMany($handle: mixed, $meta: mixed, $model: mixed, $where: mixed = null, $order: mixed = null, $limit: mixed = null, $offset: mixed = null, $includes: mixed = null) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
$sql = 'SELECT * FROM ' . quote_ident($table)
$params = []
$where_sql = compile_predicate($where, $params)
if ($where_sql !== '') {
$sql = $sql . ' WHERE ' . $where_sql
}
if ($order !== null && (is_array($order) || is_object($order)) && field_value($order, 'column', null) !== null) {
$dir = 'ASC'
if (strtoupper('' . field_value($order, 'dir', 'ASC')) === 'DESC') {
$dir = 'DESC'
}
$sql = $sql . ' ORDER BY ' . quote_ident('' . field_value($order, 'column', '')) . ' ' . $dir
}
if ($limit !== null) {
$sql = $sql . ' LIMIT ' . (int) $limit
}
if ($offset !== null) {
$sql = $sql . ' OFFSET ' . (int) $offset
}
$rows = db_rows(db_query($handle, $sql, $params))
if (!result_is_ok($rows)) {
return $rows
}
return apply_includes_to_rows($handle, $meta, $model, $rows->value, $includes)
}

export function selectOne($handle: mixed, $meta: mixed, $model: mixed, $where: mixed = null, $includes: mixed = null) {
$rows = selectMany($handle, $meta, $model, $where, null, 1, null, $includes)
if (!result_is_ok($rows)) {
return $rows
}
if (count($rows->value) === 0) {
return result_err('no rows')
}
return result_ok($rows->value[0])
}

export function insertOne($handle: mixed, $model: mixed, $row: mixed, $returning: mixed = false) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
if (!is_array($row) && !is_object($row)) {
return result_err('insert row must be non-empty array|object')
}
$cols = []
$values = []
$holders = []
$quoted = []
$idx = 1
foreach ($row as $col => $value) {
$cols[] = $col
$quoted[] = quote_ident($col)
$holders[] = '$' . $idx
$values[] = $value
$idx += 1
}
if (count($cols) === 0) {
return result_err('insert row must be non-empty array|object')
}
$sql = 'INSERT INTO ' . quote_ident($table) . ' (' . implode(', ', $quoted) . ') VALUES (' . implode(', ', $holders) . ')'
if ($returning) {
$sql = $sql . ' RETURNING *'
return db_rows(db_query($handle, $sql, $values))
}
return db_exec($handle, $sql, $values)
}

export function updateWhere($handle: mixed, $model: mixed, $patch: mixed, $where: mixed = null, $returning: mixed = false) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
if (!is_array($patch) && !is_object($patch)) {
return result_err('update patch must be non-empty array|object')
}
$params = []
$sets = []
foreach ($patch as $col => $value) {
$params[] = $value
$sets[] = quote_ident($col) . ' = $' . count($params)
}
if (count($sets) === 0) {
return result_err('update patch must be non-empty array|object')
}
$sql = 'UPDATE ' . quote_ident($table) . ' SET ' . implode(', ', $sets)
$where_sql = compile_predicate($where, $params)
if ($where_sql !== '') {
$sql = $sql . ' WHERE ' . $where_sql
}
if ($returning) {
$sql = $sql . ' RETURNING *'
return db_rows(db_query($handle, $sql, $params))
}
return db_exec($handle, $sql, $params)
}

export function deleteWhere($handle: mixed, $model: mixed, $where: mixed = null) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
$params = []
$sql = 'DELETE FROM ' . quote_ident($table)
$where_sql = compile_predicate($where, $params)
if ($where_sql !== '') {
$sql = $sql . ' WHERE ' . $where_sql
}
return db_exec($handle, $sql, $params)
}

function insert_values_builder($handle: mixed, $model: mixed, $row: mixed) {
return {
'exec': fn() => insertOne($handle, $model, $row),
'returning': fn() => insert_returning_builder($handle, $model, $row)
}
}

function insert_returning_many($handle: mixed, $model: mixed, $row: mixed) {
return insertOne($handle, $model, $row, true)
}

function insert_returning_one($handle: mixed, $model: mixed, $row: mixed) {
$rows = insertOne($handle, $model, $row, true)
if (!result_is_ok($rows)) {
return $rows
}
if (count($rows->value) === 0) {
return result_err('no rows')
}
return result_ok($rows->value[0])
}

function insert_returning_builder($handle: mixed, $model: mixed, $row: mixed) {
return {
'many': fn() => insert_returning_many($handle, $model, $row),
'one': fn() => insert_returning_one($handle, $model, $row)
}
}

export function insert($handle: mixed, $model: mixed) {
return {
'values': fn($row: mixed) => insert_values_builder($handle, $model, $row)
}
}

function select_builder($handle: mixed, $meta: mixed, $model: mixed, $where: mixed, $order: mixed, $take: mixed, $skip: mixed, $includes: mixed) {
return {
'where': fn($expr: mixed) => select_builder($handle, $meta, $model, $expr, $order, $take, $skip, $includes),
'orderBy': fn($expr: mixed) => select_builder($handle, $meta, $model, $where, $expr, $take, $skip, $includes),
'limit': fn($value: mixed) => select_builder($handle, $meta, $model, $where, $order, $value, $skip, $includes),
'offset': fn($value: mixed) => select_builder($handle, $meta, $model, $where, $order, $take, $value, $includes),
'include': fn($fields: mixed) => select_builder($handle, $meta, $model, $where, $order, $take, $skip, $fields),
'many': fn() => selectMany($handle, $meta, $model, $where, $order, $take, $skip, $includes),
'one': fn() => selectOne($handle, $meta, $model, $where, $includes)
}
}

export function select($handle: mixed, $meta: mixed) {
return {
'from': fn($model: mixed) => select_builder($handle, $meta, $model, null, null, null, null, null)
}
}

function update_set_builder($handle: mixed, $model: mixed, $patch: mixed, $where: mixed, $returning: mixed) {
return {
'where': fn($expr: mixed) => update_set_builder($handle, $model, $patch, $expr, $returning),
'returning': fn() => update_set_builder($handle, $model, $patch, $where, true),
'exec': fn() => updateWhere($handle, $model, $patch, $where, false),
'many': fn() => updateWhere($handle, $model, $patch, $where, $returning),
'one': fn() => update_returning_one($handle, $model, $patch, $where)
}
}

function update_returning_one($handle: mixed, $model: mixed, $patch: mixed, $where: mixed) {
$rows = updateWhere($handle, $model, $patch, $where, true)
if (!result_is_ok($rows)) {
return $rows
}
if (count($rows->value) === 0) {
return result_err('no rows')
}
return result_ok($rows->value[0])
}

export function update($handle: mixed, $model: mixed) {
return {
'set': fn($patch: mixed) => update_set_builder($handle, $model, $patch, null, false)
}
}

function delete_builder($handle: mixed, $model: mixed, $where: mixed) {
return {
'where': fn($expr: mixed) => delete_builder($handle, $model, $expr),
'exec': fn() => deleteWhere($handle, $model, $where)
}
}

export function deleteQuery($handle: mixed, $model: mixed) {
return delete_builder($handle, $model, null)
}

function model_meta($meta: mixed, $model: mixed) {
if (!is_array($meta) || !array_key_exists('models', $meta)) {
return null
}
$name = model_name($model)
if ($name === null || !array_key_exists($name, $meta['models'])) {
return null
}
return $meta['models'][$name]
}

function relation_meta($meta: mixed, $model: mixed, $field: mixed) {
$m = model_meta($meta, $model)
if ($m === null || !is_array($m) || !array_key_exists('relations', $m) || !is_array($m['relations'])) {
return null
}
foreach ($m['relations'] as $rel) {
if (is_array($rel) && array_key_exists('field', $rel) && $rel['field'] === $field) {
return $rel
}
}
return null
}

export function loadRelation($handle: mixed, $meta: mixed, $model: mixed, $row: mixed, $field: mixed) {
if (!is_array($row)) {
return result_err('loadRelation expects row array')
}
$rel = relation_meta($meta, $model, $field)
if ($rel === null) {
return result_err('unknown relation')
}
if (!array_key_exists('kind', $rel) || !array_key_exists('model', $rel) || !array_key_exists('foreignKey', $rel)) {
return result_err('invalid relation metadata')
}
$kind = $rel['kind']
$target = $rel['model']
$fk = $rel['foreignKey']
if ($kind === 'hasMany') {
if (!array_key_exists('id', $row)) {
return result_err('source row missing id')
}
return selectMany($handle, $meta, $target, eq($fk, $row['id']), null, null, null, null)
}
if ($kind === 'belongsTo' || $kind === 'hasOne') {
if (!array_key_exists($fk, $row)) {
return result_err('source row missing foreign key')
}
return selectOne($handle, $meta, $target, eq('id', $row[$fk]), null)
}
return result_err('unsupported relation kind')
}

export function transaction($handle: mixed, $fn: mixed) {
$started = db_begin($handle)
if (!result_is_ok($started)) {
return $started
}
$result = $fn($handle)
if (is_object($result) && isset($result->ok) && !$result->ok) {
db_rollback($handle)
return $result
}
$committed = db_commit($handle)
if (!result_is_ok($committed)) {
db_rollback($handle)
return $committed
}
return result_ok($result)
}

export function createClient($meta: mixed, $handle: mixed = null) {
return {
meta: $meta,
handle: $handle,
models: {
        RuntimeProbeLog: { name: 'RuntimeProbeLog' },
        LhUser: { name: 'LhUser' },
        LhSession: { name: 'LhSession' },
        LhApiToken: { name: 'LhApiToken' },
        LhOrg: { name: 'LhOrg' },
        LhOrgMember: { name: 'LhOrgMember' },
        LhRateLimitHit: { name: 'LhRateLimitHit' },
        LhEventLog: { name: 'LhEventLog' },
        LhAuditLog: { name: 'LhAuditLog' },
        Package: { name: 'Package' },
        PackageVersion: { name: 'PackageVersion' },
        Download: { name: 'Download' },
        },
withHandle: fn($nextHandle: mixed) => createClient($meta, $nextHandle),
connect: fn($driver: mixed, $config: mixed) => connect($driver, $config),
close: fn() => close($handle),
select: fn() => select($handle, $meta),
selectMany: fn($model: mixed, $where: mixed = null, $order: mixed = null, $limit: mixed = null, $offset: mixed = null, $includes: mixed = null) => selectMany($handle, $meta, $model, $where, $order, $limit, $offset, $includes),
selectOne: fn($model: mixed, $where: mixed = null, $includes: mixed = null) => selectOne($handle, $meta, $model, $where, $includes),
insert: fn($model: mixed) => insert($handle, $model),
insertOne: fn($model: mixed, $row: mixed, $returning: mixed = false) => insertOne($handle, $model, $row, $returning),
update: fn($model: mixed) => update($handle, $model),
updateWhere: fn($model: mixed, $where: mixed, $values: mixed, $returning: mixed = false) => updateWhere($handle, $model, $where, $values, $returning),
'delete': fn($model: mixed) => deleteQuery($handle, $model),
deleteWhere: fn($model: mixed, $where: mixed, $returning: mixed = false) => deleteWhere($handle, $model, $where, $returning),
loadRelation: fn($model: mixed, $row: mixed, $field: mixed) => loadRelation($handle, $meta, $model, $row, $field),
transaction: fn($fn: mixed) => transaction($handle, $fn),
eq: fn($column: mixed, $value: mixed) => eq($column, $value),
ilike: fn($column: mixed, $value: mixed) => ilike($column, $value),
isNull: fn($column: mixed) => isNull($column),
andWhere: fn(...$parts: mixed) => andWhere(...$parts),
orWhere: fn(...$parts: mixed) => orWhere(...$parts),
asc: fn($column: mixed) => asc($column),
desc: fn($column: mixed) => desc($column),
limit: fn($value: mixed) => limit($value),
offset: fn($value: mixed) => offset($value)
}
}
