/*
* AUTO-GENERATED FILE - DO NOT EDIT
* Generated by deka db generate
* Changes will be overwritten.
*/

import { open_handle, close as db_close, query as db_query, exec as db_exec, rows as db_rows, begin as db_begin, commit as db_commit, rollback as db_rollback } from 'db'
import { result_ok, result_err, result_is_ok } from 'core/result'

function quote_ident($name) {
return '"' . str_replace('"', '""', '' . $name) . '"'
}

function model_name($model) {
if (is_string($model)) {
return $model
}
if (is_object($model) && isset($model->name)) {
return '' . $model->name
}
if (is_array($model) && array_key_exists('name', $model)) {
return '' . $model['name']
}
return null
}

function model_table($model) {
$name = model_name($model)
if ($name === null || $name === '') {
return null
}
$table = preg_replace('/([a-z0-9])([A-Z])/', '$1_$2', $name)
if ($table === null) {
$table = $name
}
$table = strtolower($table)
if (substr($table, -1) !== 's') {
$table = $table . 's'
}
return $table
}

function compile_predicate($expr, &$params) {
if ($expr === null || !is_array($expr) || !array_key_exists('kind', $expr)) {
return ''
}
$kind = $expr['kind']
if ($kind === 'eq') {
$params[] = $expr['value']
return quote_ident($expr['column']) . ' = $' . count($params)
}
if ($kind === 'and' || $kind === 'or') {
$parts_sql = []
foreach ($expr['parts'] as $part) {
$inner = compile_predicate($part, $params)
if ($inner !== '') {
$parts_sql[] = '(' . $inner . ')'
}
}
if (count($parts_sql) === 0) {
return ''
}
return implode($kind === 'and' ? ' AND ' : ' OR ', $parts_sql)
}
if ($kind === 'ilike') {
$params[] = $expr['value']
return quote_ident($expr['column']) . ' ILIKE $' . count($params)
}
if ($kind === 'isNull') {
return quote_ident($expr['column']) . ' IS NULL'
}
return ''
}

export function eq($column, $value) {
return { kind: 'eq', column: $column, value: $value }
}

export function ilike($column, $value) {
return { kind: 'ilike', column: $column, value: $value }
}

export function isNull($column) {
return { kind: 'isNull', column: $column }
}

export function andWhere(...$parts) {
return { kind: 'and', parts: $parts }
}

export function orWhere(...$parts) {
return { kind: 'or', parts: $parts }
}

export function asc($column) {
return { column: $column, dir: 'ASC' }
}

export function desc($column) {
return { column: $column, dir: 'DESC' }
}

export function limit($value) {
return (int) $value
}

export function offset($value) {
return (int) $value
}

export function connect($driver, $config) {
return open_handle($driver, $config)
}

export function close($handle) {
return db_close($handle)
}

export function selectMany($handle, $model, $where = null, $order = null, $limit = null, $offset = null) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
$sql = 'SELECT * FROM ' . quote_ident($table)
$params = []
$where_sql = compile_predicate($where, $params)
if ($where_sql !== '') {
$sql = $sql . ' WHERE ' . $where_sql
}
if ($order !== null && is_array($order) && array_key_exists('column', $order)) {
$dir = 'ASC'
if (array_key_exists('dir', $order) && strtoupper($order['dir']) === 'DESC') {
$dir = 'DESC'
}
$sql = $sql . ' ORDER BY ' . quote_ident($order['column']) . ' ' . $dir
}
if ($limit !== null) {
$sql = $sql . ' LIMIT ' . (int) $limit
}
if ($offset !== null) {
$sql = $sql . ' OFFSET ' . (int) $offset
}
return db_rows(db_query($handle, $sql, $params))
}

export function selectOne($handle, $model, $where = null) {
$rows = selectMany($handle, $model, $where, null, 1, null)
if (!result_is_ok($rows)) {
return $rows
}
if (count($rows->value) === 0) {
return result_err('no rows')
}
return result_ok($rows->value[0])
}

export function insertOne($handle, $model, $row, $returning = false) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
if (!is_array($row) && !is_object($row)) {
return result_err('insert row must be non-empty array|object')
}
$cols = []
$values = []
$holders = []
$quoted = []
$idx = 1
foreach ($row as $col => $value) {
$cols[] = $col
$quoted[] = quote_ident($col)
$holders[] = '$' . $idx
$values[] = $value
$idx += 1
}
if (count($cols) === 0) {
return result_err('insert row must be non-empty array|object')
}
$sql = 'INSERT INTO ' . quote_ident($table) . ' (' . implode(', ', $quoted) . ') VALUES (' . implode(', ', $holders) . ')'
if ($returning) {
$sql = $sql . ' RETURNING *'
return db_rows(db_query($handle, $sql, $values))
}
return db_exec($handle, $sql, $values)
}

export function updateWhere($handle, $model, $patch, $where = null, $returning = false) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
if (!is_array($patch) && !is_object($patch)) {
return result_err('update patch must be non-empty array|object')
}
$params = []
$sets = []
foreach ($patch as $col => $value) {
$params[] = $value
$sets[] = quote_ident($col) . ' = $' . count($params)
}
if (count($sets) === 0) {
return result_err('update patch must be non-empty array|object')
}
$sql = 'UPDATE ' . quote_ident($table) . ' SET ' . implode(', ', $sets)
$where_sql = compile_predicate($where, $params)
if ($where_sql !== '') {
$sql = $sql . ' WHERE ' . $where_sql
}
if ($returning) {
$sql = $sql . ' RETURNING *'
return db_rows(db_query($handle, $sql, $params))
}
return db_exec($handle, $sql, $params)
}

export function deleteWhere($handle, $model, $where = null) {
$table = model_table($model)
if ($table === null) {
return result_err('unknown model')
}
$params = []
$sql = 'DELETE FROM ' . quote_ident($table)
$where_sql = compile_predicate($where, $params)
if ($where_sql !== '') {
$sql = $sql . ' WHERE ' . $where_sql
}
return db_exec($handle, $sql, $params)
}

function insert_values_builder($handle, $model, $row) {
return {
'exec': fn() => insertOne($handle, $model, $row),
'returning': fn() => insert_returning_builder($handle, $model, $row)
}
}

function insert_returning_many($handle, $model, $row) {
return insertOne($handle, $model, $row, true)
}

function insert_returning_one($handle, $model, $row) {
$rows = insertOne($handle, $model, $row, true)
if (!result_is_ok($rows)) {
return $rows
}
if (count($rows->value) === 0) {
return result_err('no rows')
}
return result_ok($rows->value[0])
}

function insert_returning_builder($handle, $model, $row) {
return {
'many': fn() => insert_returning_many($handle, $model, $row),
'one': fn() => insert_returning_one($handle, $model, $row)
}
}

export function insert($handle, $model) {
return {
'values': fn($row) => insert_values_builder($handle, $model, $row)
}
}

function select_builder($handle, $model, $where, $order, $take, $skip) {
return {
'where': fn($expr) => select_builder($handle, $model, $expr, $order, $take, $skip),
'orderBy': fn($expr) => select_builder($handle, $model, $where, $expr, $take, $skip),
'limit': fn($value) => select_builder($handle, $model, $where, $order, $value, $skip),
'offset': fn($value) => select_builder($handle, $model, $where, $order, $take, $value),
'many': fn() => selectMany($handle, $model, $where, $order, $take, $skip),
'one': fn() => selectOne($handle, $model, $where)
}
}

export function select($handle) {
return {
'from': fn($model) => select_builder($handle, $model, null, null, null, null)
}
}

function update_set_builder($handle, $model, $patch, $where, $returning) {
return {
'where': fn($expr) => update_set_builder($handle, $model, $patch, $expr, $returning),
'returning': fn() => update_set_builder($handle, $model, $patch, $where, true),
'exec': fn() => updateWhere($handle, $model, $patch, $where, false),
'many': fn() => updateWhere($handle, $model, $patch, $where, $returning),
'one': fn() => update_returning_one($handle, $model, $patch, $where)
}
}

function update_returning_one($handle, $model, $patch, $where) {
$rows = updateWhere($handle, $model, $patch, $where, true)
if (!result_is_ok($rows)) {
return $rows
}
if (count($rows->value) === 0) {
return result_err('no rows')
}
return result_ok($rows->value[0])
}

export function update($handle, $model) {
return {
'set': fn($patch) => update_set_builder($handle, $model, $patch, null, false)
}
}

function delete_builder($handle, $model, $where) {
return {
'where': fn($expr) => delete_builder($handle, $model, $expr),
'exec': fn() => deleteWhere($handle, $model, $where)
}
}

export function deleteQuery($handle, $model) {
return delete_builder($handle, $model, null)
}

function model_meta($meta, $model) {
if (!is_array($meta) || !array_key_exists('models', $meta)) {
return null
}
$name = model_name($model)
if ($name === null || !array_key_exists($name, $meta['models'])) {
return null
}
return $meta['models'][$name]
}

function relation_meta($meta, $model, $field) {
$m = model_meta($meta, $model)
if ($m === null || !is_array($m) || !array_key_exists('relations', $m) || !is_array($m['relations'])) {
return null
}
foreach ($m['relations'] as $rel) {
if (is_array($rel) && array_key_exists('field', $rel) && $rel['field'] === $field) {
return $rel
}
}
return null
}

export function loadRelation($handle, $meta, $model, $row, $field) {
if (!is_array($row)) {
return result_err('loadRelation expects row array')
}
$rel = relation_meta($meta, $model, $field)
if ($rel === null) {
return result_err('unknown relation')
}
if (!array_key_exists('kind', $rel) || !array_key_exists('model', $rel) || !array_key_exists('foreignKey', $rel)) {
return result_err('invalid relation metadata')
}
$kind = $rel['kind']
$target = $rel['model']
$fk = $rel['foreignKey']
if ($kind === 'hasMany') {
if (!array_key_exists('id', $row)) {
return result_err('source row missing id')
}
return selectMany($handle, $target, eq($fk, $row['id']))
}
if ($kind === 'belongsTo' || $kind === 'hasOne') {
if (!array_key_exists($fk, $row)) {
return result_err('source row missing foreign key')
}
return selectOne($handle, $target, eq('id', $row[$fk]))
}
return result_err('unsupported relation kind')
}

export function transaction($handle, $fn) {
$started = db_begin($handle)
if (!result_is_ok($started)) {
return $started
}
$result = $fn($handle)
if (is_object($result) && isset($result->ok) && !$result->ok) {
db_rollback($handle)
return $result
}
$committed = db_commit($handle)
if (!result_is_ok($committed)) {
db_rollback($handle)
return $committed
}
return result_ok($result)
}

export function createClient($meta, $handle = null) {
return {
meta: $meta,
handle: $handle,
models: {
        User: { name: 'User' },
        },
withHandle: fn($nextHandle) => createClient($meta, $nextHandle),
connect: connect,
close: close,
select: fn() => select($handle),
selectMany: selectMany,
selectOne: selectOne,
insert: fn($model) => insert($handle, $model),
insertOne: insertOne,
update: fn($model) => update($handle, $model),
updateWhere: updateWhere,
'delete': fn($model) => deleteQuery($handle, $model),
deleteWhere: deleteWhere,
loadRelation: fn($model, $row, $field) => loadRelation($handle, $meta, $model, $row, $field),
transaction: transaction,
eq: eq,
ilike: ilike,
isNull: isNull,
andWhere: andWhere,
orWhere: orWhere,
asc: asc,
desc: desc,
limit: limit,
offset: offset
}
}
