# PHP Wasm Extensions (WIT / Component Model Plan)

This document describes the WIT/component-model workflow for PHP/PHPX Wasm
extensions. A **v1 runtime** is available with a limited type set, and
`.d.phpx` stubs provide a typed DX in PHPX.

## Goals
- Keep the runtime ABI stable while we add typing.
- Let PHPX see rich types (records, enums, flags, options) from WIT.
- Map WIT records to PHPX `struct` or `Object<...>` (configurable).
- Keep `.php` and `.phpx` import ergonomics identical: `import ... as wasm`.

## File layout (planned)
```
php_modules/
  @user/
    hello/
      deka.json
      module.wasm
      module.wit
      module.d.phpx   # generated type stubs
```

### deka.json
```json
{
  "module": "module.wasm",
  "wit": "module.wit",
  "abi": "wit",
  "records": "struct",
  "stubs": "module.d.phpx",
  "world": "hello",
  "interfacePrefix": false,
  "crate": "rust",
  "crateName": "hello_wasm"
}
```

**Runtime fields:**
- `abi`: `wit` selects the component-model ABI (v1).
- `module`: wasm filename (default `module.wasm`).

**Tooling fields (used today):**
- `wit`: WIT file path (for stub generation).
- `records`: `struct` or `object`. Controls how WIT records map into PHPX types.
- `stubs`: optional path to the generated `.d.phpx` file (relative to the module root).
- `world`: optional; required if the package defines multiple worlds.
- `interfacePrefix`: when false, exported interface functions are flattened
  (e.g. `greet` instead of `api__greet`).
- `crate`: wasm guest crate directory (used by `deka wasm build`).
- `crateName`: wasm guest crate name (used by `deka wasm build`).

## Example WIT
```wit
package deka:hello@0.1.0;

interface api {
  record position {
    x: f64,
    y: f64,
  }

  record user {
    name: string,
    age: u32,
  }

  greet: func(name: string) -> string;
  get-position: func() -> position;
  make-user: func(name: string, age: u32) -> user;
}

world hello {
  export api;
}
```

## Rust (wit-bindgen) sketch
```rust
use wit_bindgen::generate;

wit_bindgen::generate!({
    path: "module.wit",
    world: "hello",
});

struct Hello;

impl Guest for Hello {
    fn greet(name: String) -> String {
        format!("Hello, {}!", name)
    }

    fn get_position() -> Position {
        Position { x: 1.0, y: 2.0 }
    }

    fn make_user(name: String, age: u32) -> User {
        User { name, age }
    }
}

export!(Hello);
```

## Generated PHPX stubs (example)
Run the stub generator:
```sh
cargo run -p wit-phpx -- php_modules/@user/hello/module.wit \
  --out php_modules/@user/hello/module.d.phpx \
  --records struct \
  --no-interface-prefix
```

By default, exported interfaces are prefixed (e.g. `api__greet`). Use
`--no-interface-prefix` for flatter names.
WIT kebab-case names (e.g. `get-position`) are converted to snake_case in stubs.

Generated `.d.phpx` (type-only):
```php
<?php
// Generated by wit-phpx. Do not edit by hand.
// This file is for PHPX tooling only (type stubs).
// World: hello
// Records: struct

struct Position {
    $x: float;
    $y: float;
}

struct User {
    $name: string;
    $age: int;
}

export function greet(string $name): string;
export function get_position(): Position;
export function make_user(string $name, int $age): User;
```

If you prefer structural objects, use `--records object` to emit:
```php
export type Position = Object<{ x: float, y: float }>;
export type User = Object<{ name: string, age: int }>;
```
`struct` maps to value semantics (COW) once structs land in PHPX.

## PHPX usage (runtime stays the same)
```php
import { greet, get_position } from '@user/hello' as wasm;

$pos = get_position();
echo $pos.x; // 0.0
```

The runtime still loads `module.wasm` and calls it via the host bridge; the
`.d.phpx` file is only for tooling and type-checking.

## Runtime support (v1)
Supported types:
- `bool`, integer scalars, `f32`, `f64`
- `string`
- `list<u8>` (byte arrays)
- `record` and `tuple` composed of supported types
- `option<T>` (nullable)
- `result<T, E>` (tagged object)
- `enum` (string case names)
- `flags` (array of flag names)

Not supported yet:
- `variant`, `resource`, `future`, `stream`

If a module uses unsupported types, the runtime will error during the wasm call.
The wasm module must export `memory` and `cabi_realloc` for canonical ABI calls.

### Option/result mapping (runtime)
- `option<T>` values: `null` means `none`, otherwise the payload is `some`.
- `result<T, E>` values: use a tagged object.
  - `{ ok: <value> }` for success
  - `{ err: <value> }` for error
  - PHPX `Result<T,E>` (`['ok' => true, 'value' => ...]` or `['ok' => false, 'error' => ...]`)
    is also accepted by the bridge.

### Enum/flags mapping (runtime)
- `enum` values are passed as case name strings. WIT case names are normalized
  to `snake_case` when returned to PHP.
- `flags` values are passed as arrays of case name strings (normalized to
  `snake_case`). The bridge also accepts integer bitmasks for flags.
- Flags are currently limited to 32 entries in v1.

## Helper script (recommended)
```sh
node scripts/gen-wit-stubs.js --root php_modules
```

Watch mode (example with `watchexec`):
```sh
watchexec -r -w php_modules -- node scripts/gen-wit-stubs.js --root php_modules
```

## CLI helpers (recommended)
```sh
deka wasm init @user/hello
deka wasm build @user/hello
deka wasm stubs @user/hello
```

## Developer workflow (today)
1) Scaffold a module:
```sh
deka wasm init @user/hello
```

2) Edit WIT + Rust guest code:
- `php_modules/@user/hello/module.wit`
- `php_modules/@user/hello/rust/src/lib.rs`

3) Build + copy wasm + regenerate stubs:
```sh
deka wasm build @user/hello
```

4) Import from PHPX:
```php
import { greet } from '@user/hello' as wasm;
echo greet("Sami");
```

Manual alternative (no CLI):
- `cargo build --release --target wasm32-unknown-unknown --manifest-path php_modules/@user/hello/rust/Cargo.toml`
- Copy the wasm from `rust/target/wasm32-unknown-unknown/release/<crate>.wasm` to `module.wasm`
- Run `node scripts/gen-wit-stubs.js --root php_modules/@user/hello`

## WIT -> PHPX type mapping
- `bool` -> `bool`
- `u8` -> `byte`
- `u16/u32/u64/s16/s32/s64` -> `int`
- `f32/f64` -> `float`
- `string/char` -> `string`
- `list<T>` -> `array<T>`
- `option<T>` -> `T|null`
- `result<T,E>` -> `Result<T, E>`
- `record { ... }` -> `struct` or `Object<{...}>`
- `enum` -> `string` (with enum cases in a comment)
- `variant` -> `mixed` (with cases in a comment)
- `flags` -> `array<string>` (with flag names in a comment)

## Notes
- The stub generator is **type-only**. It does not change runtime behavior.
- When component-model support lands, the same `.wit` file will drive both the
  runtime bindings and the PHPX stubs.
- The JSON ABI remains the current default until `abi: "wit"` is wired up.
- Example files live in `examples/wasm_hello_wit/`.
- PHPX typechecking will look for stubs on `import ... as wasm` and report an
  error if the stub file is missing.

## Remaining work
- Expand `abi: "wit"` coverage (variant/resources).
- WIT-driven marshaling refinements between wasm and PHP values.
- Typechecker ingestion of `.d.phpx` to type imported wasm exports (not just existence checks).
- Finalize interface-flattening defaults and collision handling at runtime.
- Wire stub generation into a build/CI step.
- Editor/tooling integration for `.d.phpx`.
