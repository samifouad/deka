// Generated by deka build. Do not edit manually.
// Target semantics: JavaScript runtime semantics.
export const phpxBuildMode = "subset-ast";
export const phpxTargetSemantics = "js";

if (!globalThis.panic) { globalThis.panic = (msg) => { throw new Error(String(msg)); }; }
if (!globalThis.function_exists) { globalThis.function_exists = (name) => typeof globalThis[name] === 'function'; }
if (!globalThis.class_exists) { globalThis.class_exists = (name) => typeof globalThis[name] === 'function' || typeof globalThis[name] === 'object'; }
if (!globalThis.class_alias) { globalThis.class_alias = () => false; }

if (!globalThis.defined) { globalThis.defined = (name) => Object.prototype.hasOwnProperty.call(globalThis, String(name)); }

if (!globalThis.__phpx_is_struct) { globalThis.__phpx_is_struct = (value, name) => Boolean(value && typeof value === 'object' && value.__struct === name); }

if (!globalThis.__phpx_func_num_args) { globalThis.__phpx_func_num_args = (args) => args.length; }
if (!globalThis.__phpx_func_get_args) { globalThis.__phpx_func_get_args = (args) => Array.prototype.slice.call(args); }
if (!globalThis.__phpx_func_get_arg) { globalThis.__phpx_func_get_arg = (args, idx) => (idx >= 0 && idx < args.length ? args[idx] : null); }

if (!globalThis.__deka_chr) { globalThis.__deka_chr = (code) => String.fromCharCode((Number(code) || 0) & 0xff); }
if (!globalThis.__deka_ord) { globalThis.__deka_ord = (value) => { const str = String(value ?? ''); return str.length ? str.charCodeAt(0) : 0; }; }
if (!globalThis.chr) { globalThis.chr = globalThis.__deka_chr; }
if (!globalThis.ord) { globalThis.ord = globalThis.__deka_ord; }
if (!globalThis.strlen) { globalThis.strlen = (value) => String(value ?? '').length; }
if (!globalThis.substr) { globalThis.substr = (value, start, length = null) => { const src = String(value ?? ''); let s = Number(start) || 0; if (s < 0) s = Math.max(src.length + s, 0); if (length === null || length === undefined) return src.slice(s); let l = Number(length) || 0; if (l < 0) return src.slice(s, Math.max(src.length + l, s)); return src.slice(s, s + l); }; }
if (!globalThis.ltrim) { globalThis.ltrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/^\s+/, ''); const set = new Set(String(chars)); let i = 0; while (i < src.length && set.has(src[i])) i += 1; return src.slice(i); }; }
if (!globalThis.rtrim) { globalThis.rtrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/\s+$/, ''); const set = new Set(String(chars)); let i = src.length - 1; while (i >= 0 && set.has(src[i])) i -= 1; return src.slice(0, i + 1); }; }
if (!globalThis.trim) { globalThis.trim = (value, chars = null) => globalThis.ltrim(globalThis.rtrim(value, chars), chars); }
if (!globalThis.strpos) { globalThis.strpos = (haystack, needle, offset = 0) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = h.indexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }
if (!globalThis.strrpos) { globalThis.strrpos = (haystack, needle, offset = null) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = offset === null || offset === undefined ? h.lastIndexOf(n) : h.lastIndexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }
if (!globalThis.str_starts_with) { globalThis.str_starts_with = (haystack, needle) => String(haystack ?? '').startsWith(String(needle ?? '')); }
if (!globalThis.str_ends_with) { globalThis.str_ends_with = (haystack, needle) => String(haystack ?? '').endsWith(String(needle ?? '')); }
if (!globalThis.str_contains) { globalThis.str_contains = (haystack, needle) => String(haystack ?? '').includes(String(needle ?? '')); }
if (!globalThis.strtolower) { globalThis.strtolower = (value) => String(value ?? '').toLowerCase(); }
if (!globalThis.strtoupper) { globalThis.strtoupper = (value) => String(value ?? '').toUpperCase(); }
if (!globalThis.array_key_exists) { globalThis.array_key_exists = (key, value) => { if (value === null || value === undefined) return false; if (Array.isArray(value)) { const idx = Number(key); return Number.isInteger(idx) && idx >= 0 && idx < value.length; } if (typeof value === 'object') return Object.prototype.hasOwnProperty.call(value, key); return false; }; }
if (!globalThis.in_array) { globalThis.in_array = (needle, haystack, strict = false) => { if (!Array.isArray(haystack)) return false; for (const item of haystack) { if (strict ? item === needle : item == needle) return true; } return false; }; }
if (!globalThis.explode) { globalThis.explode = (sep, value, limit = null) => { const s = String(value ?? ''); const parts = s.split(String(sep ?? '')); if (limit === null || limit === undefined || Number(limit) === 0) return parts; const n = Number(limit); if (!Number.isInteger(n)) return parts; if (n > 0) { if (parts.length <= n) return parts; const head = parts.slice(0, n - 1); head.push(parts.slice(n - 1).join(String(sep ?? ''))); return head; } return parts; }; }
if (!globalThis.implode) { globalThis.implode = (glue, pieces = null) => { if (pieces === null || pieces === undefined) { pieces = glue; glue = ''; } if (!Array.isArray(pieces)) return ''; return pieces.map((v) => String(v ?? '')).join(String(glue ?? '')); }; }
if (!globalThis.count) { globalThis.count = (value) => { if (Array.isArray(value) || typeof value === 'string') return value.length; if (value && typeof value === 'object') return Object.keys(value).length; return 0; }; }
if (!globalThis.time) { globalThis.time = () => Math.floor(Date.now() / 1000); }
if (!globalThis.getenv) { globalThis.getenv = (name) => { const key = String(name ?? ''); const env = globalThis.process && globalThis.process.env ? globalThis.process.env : null; if (!env || !Object.prototype.hasOwnProperty.call(env, key)) return false; const value = env[key]; return value === undefined || value === null ? false : String(value); }; }
if (!globalThis.is_promise) { globalThis.is_promise = (value) => Boolean(value && typeof value === 'object' && typeof value.then === 'function'); }
if (!globalThis.GLOBALS || typeof globalThis.GLOBALS !== 'object') { globalThis.GLOBALS = {}; }
if (typeof globalThis.JSON_ERROR_NONE !== 'number') { globalThis.JSON_ERROR_NONE = 0; }
if (typeof globalThis.JSON_ERROR_DEPTH !== 'number') { globalThis.JSON_ERROR_DEPTH = 1; }
if (typeof globalThis.JSON_ERROR_STATE_MISMATCH !== 'number') { globalThis.JSON_ERROR_STATE_MISMATCH = 2; }
if (typeof globalThis.JSON_ERROR_CTRL_CHAR !== 'number') { globalThis.JSON_ERROR_CTRL_CHAR = 3; }
if (typeof globalThis.JSON_ERROR_SYNTAX !== 'number') { globalThis.JSON_ERROR_SYNTAX = 4; }
if (typeof globalThis.JSON_ERROR_UTF8 !== 'number') { globalThis.JSON_ERROR_UTF8 = 5; }
if (typeof globalThis.JSON_ERROR_RECURSION !== 'number') { globalThis.JSON_ERROR_RECURSION = 6; }
if (typeof globalThis.JSON_ERROR_INF_OR_NAN !== 'number') { globalThis.JSON_ERROR_INF_OR_NAN = 7; }
if (typeof globalThis.JSON_ERROR_UNSUPPORTED_TYPE !== 'number') { globalThis.JSON_ERROR_UNSUPPORTED_TYPE = 8; }
if (typeof globalThis.JSON_ERROR_INVALID_PROPERTY_NAME !== 'number') { globalThis.JSON_ERROR_INVALID_PROPERTY_NAME = 9; }
if (typeof globalThis.JSON_ERROR_UTF16 !== 'number') { globalThis.JSON_ERROR_UTF16 = 10; }
if (!globalThis.__deka_object_set) { globalThis.__deka_object_set = (obj, key, value) => { if (obj && typeof obj === 'object') { obj[key] = value; } return obj; }; }
if (!globalThis.__phpx_base64_table) { globalThis.__phpx_base64_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; }
if (!globalThis.base64_encode) { globalThis.base64_encode = (input) => { const str = String(input ?? ''); const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < str.length; i += 3) { const b0 = str.charCodeAt(i) & 0xff; const b1 = i + 1 < str.length ? str.charCodeAt(i + 1) & 0xff : NaN; const b2 = i + 2 < str.length ? str.charCodeAt(i + 2) & 0xff : NaN; const n = (b0 << 16) | ((Number.isNaN(b1) ? 0 : b1) << 8) | (Number.isNaN(b2) ? 0 : b2); out += tbl[(n >> 18) & 63]; out += tbl[(n >> 12) & 63]; out += Number.isNaN(b1) ? '=' : tbl[(n >> 6) & 63]; out += Number.isNaN(b2) ? '=' : tbl[n & 63]; } return out; }; }
if (!globalThis.base64_decode) { globalThis.base64_decode = (input, strict = false) => { const src = String(input ?? '').replace(/\s+/g, ''); if (src.length % 4 !== 0) return strict ? false : ''; const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < src.length; i += 4) { const c0 = src[i], c1 = src[i + 1], c2 = src[i + 2], c3 = src[i + 3]; const n0 = tbl.indexOf(c0), n1 = tbl.indexOf(c1); const n2 = c2 === '=' ? -1 : tbl.indexOf(c2); const n3 = c3 === '=' ? -1 : tbl.indexOf(c3); if (n0 < 0 || n1 < 0 || n2 < -1 || n3 < -1) return strict ? false : ''; const n = (n0 << 18) | (n1 << 12) | ((n2 < 0 ? 0 : n2) << 6) | (n3 < 0 ? 0 : n3); out += String.fromCharCode((n >> 16) & 0xff); if (c2 !== '=') out += String.fromCharCode((n >> 8) & 0xff); if (c3 !== '=') out += String.fromCharCode(n & 0xff); } return out; }; }
if (!globalThis.__phpx_sha256_hex) { globalThis.__phpx_sha256_hex = (input) => { const K = [1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]; const bytes = []; const src = String(input ?? ''); for (let i = 0; i < src.length; i += 1) bytes.push(src.charCodeAt(i) & 0xff); const bitLen = bytes.length * 8; bytes.push(0x80); while ((bytes.length % 64) !== 56) bytes.push(0); for (let i = 7; i >= 0; i -= 1) bytes.push((bitLen >>> (i * 8)) & 0xff); let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a, h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19; const rotr = (x, n) => ((x >>> n) | (x << (32 - n))) >>> 0; for (let i = 0; i < bytes.length; i += 64) { const w = new Array(64); for (let j = 0; j < 16; j += 1) { const k = i + (j * 4); w[j] = (((bytes[k] << 24) | (bytes[k + 1] << 16) | (bytes[k + 2] << 8) | bytes[k + 3]) >>> 0); } for (let j = 16; j < 64; j += 1) { const s0 = (rotr(w[j - 15], 7) ^ rotr(w[j - 15], 18) ^ (w[j - 15] >>> 3)) >>> 0; const s1 = (rotr(w[j - 2], 17) ^ rotr(w[j - 2], 19) ^ (w[j - 2] >>> 10)) >>> 0; w[j] = (((w[j - 16] + s0) >>> 0) + ((w[j - 7] + s1) >>> 0)) >>> 0; } let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7; for (let j = 0; j < 64; j += 1) { const S1 = (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) >>> 0; const ch = ((e & f) ^ ((~e) & g)) >>> 0; const t1 = (((((h + S1) >>> 0) + ch) >>> 0) + ((K[j] + w[j]) >>> 0)) >>> 0; const S0 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) >>> 0; const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0; const t2 = (S0 + maj) >>> 0; h = g; g = f; f = e; e = (d + t1) >>> 0; d = c; c = b; b = a; a = (t1 + t2) >>> 0; } h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0; h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0; } const words = [h0, h1, h2, h3, h4, h5, h6, h7]; let out = ''; for (const w of words) { out += (w >>> 0).toString(16).padStart(8, '0'); } return out; }; }
if (!globalThis.__phpx_hex_to_binary) { globalThis.__phpx_hex_to_binary = (hex) => { const src = String(hex ?? ''); let out = ''; for (let i = 0; i < src.length; i += 2) out += String.fromCharCode(parseInt(src.slice(i, i + 2), 16) & 0xff); return out; }; }
if (!globalThis.__phpx_hmac_sha256_hex) { globalThis.__phpx_hmac_sha256_hex = (data, key) => { const toBytes = (s) => { const out = []; const src = String(s ?? ''); for (let i = 0; i < src.length; i += 1) out.push(src.charCodeAt(i) & 0xff); return out; }; const fromBytes = (arr) => arr.map((v) => String.fromCharCode(v & 0xff)).join(''); let k = toBytes(key); if (k.length > 64) { const kh = globalThis.__phpx_sha256_hex(fromBytes(k)); k = toBytes(globalThis.__phpx_hex_to_binary(kh)); } while (k.length < 64) k.push(0); const o = [], i = []; for (let n = 0; n < 64; n += 1) { o.push(k[n] ^ 0x5c); i.push(k[n] ^ 0x36); } const innerHex = globalThis.__phpx_sha256_hex(fromBytes(i) + String(data ?? '')); const outerHex = globalThis.__phpx_sha256_hex(fromBytes(o) + globalThis.__phpx_hex_to_binary(innerHex)); return outerHex; }; }
if (!globalThis.__phpx_node_crypto) { globalThis.__phpx_node_crypto = (() => { try { if (typeof require === 'function') { return require('node:crypto'); } } catch (_err) {} try { if (typeof require === 'function') { return require('crypto'); } } catch (_err) {} return null; })(); }
if (!globalThis.hash) { globalThis.hash = (algo, data, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_sha256_hex(String(data ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHash !== 'function') throw new Error('hash() requires crypto support'); const digest = mod.createHash(name).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }
if (!globalThis.hash_hmac) { globalThis.hash_hmac = (algo, data, key, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_hmac_sha256_hex(String(data ?? ''), String(key ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHmac !== 'function') throw new Error('hash_hmac() requires crypto support'); const digest = mod.createHmac(name, String(key ?? '')).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }
if (!globalThis.hash_equals) { globalThis.hash_equals = (a, b) => { const left = String(a ?? ''); const right = String(b ?? ''); if (left.length !== right.length) return false; let out = 0; for (let i = 0; i < left.length; i += 1) out |= left.charCodeAt(i) ^ right.charCodeAt(i); return out === 0; }; }
if (!globalThis.__phpx_symbol_table) { globalThis.__phpx_symbol_table = Object.create(null); }
if (!globalThis.__deka_symbol_set) { globalThis.__deka_symbol_set = (name, value) => { const key = String(name); globalThis.__phpx_symbol_table[key] = value; return true; }; }
if (!globalThis.__deka_symbol_get) { globalThis.__deka_symbol_get = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key) ? globalThis.__phpx_symbol_table[key] : null; }; }
if (!globalThis.__deka_symbol_exists) { globalThis.__deka_symbol_exists = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key); }; }
if (!globalThis.__phpx_array_cursor) { globalThis.__phpx_array_cursor = new WeakMap(); }
if (!globalThis.__deka_array_cursor) { globalThis.__deka_array_cursor = (arr, action) => { if (!arr || (typeof arr !== 'object' && !Array.isArray(arr))) return null; const map = globalThis.__phpx_array_cursor; let state = map.get(arr); if (!state) { state = { idx: 0 }; map.set(arr, state); } const keys = Object.keys(arr); if (keys.length === 0) return null; const clamp = () => { if (state.idx < 0) state.idx = 0; if (state.idx >= keys.length) state.idx = keys.length - 1; }; switch (String(action)) { case 'reset': state.idx = 0; break; case 'end': state.idx = keys.length - 1; break; case 'next': state.idx += 1; if (state.idx >= keys.length) return null; break; case 'prev': state.idx -= 1; if (state.idx < 0) return null; break; case 'pos': case 'current': break; case 'key': break; default: return null; } clamp(); const key = keys[state.idx]; if (String(action) === 'key') return key; return arr[key]; }; }

if (!globalThis.is_array || !globalThis.is_array.__deka_polyfill) { const __isArray = (value) => { if (Array.isArray(value)) return true; if (!(value !== null && typeof value === 'object' && Object.getPrototypeOf(value) === Object.prototype)) return false; if (Object.prototype.hasOwnProperty.call(value, '__struct')) return false; return true; }; __isArray.__deka_polyfill = true; globalThis.is_array = __isArray; }

import { result_ok, result_err } from 'core/result';
import { byte_is_digit, byte_is_hex, byte_is_whitespace } from 'core/byte';
import { num_parse_int, num_parse_float } from 'core/num';
import { bridge } from 'core/bridge';

if (!globalThis.__phpxStructMethods) { globalThis.__phpxStructMethods = Object.create(null); }
const __DEKA_JSON_ERROR_KEY = "__deka_json_last_error";
const __DEKA_JSON_ERROR_MSG_KEY = "__deka_json_last_error_msg";
function reader_new(input) {
return {"input": ("" + input), "pos": 0, "len": globalThis.strlen(("" + input))};
}

function reader_eof(reader) {
return (reader["pos"] >= reader["len"]);
}

function reader_peek_byte(reader) {
if (reader_eof(reader)) {
return null;
}
return globalThis.ord(reader["input"][reader["pos"]]);
}

function reader_next_byte(reader) {
let byte = reader_peek_byte(reader);
if ((byte !== null)) {
(reader["pos"] += 1);
}
return byte;
}

function reader_skip_ws(reader) {
while ((!reader_eof(reader))) {
let byte = reader_peek_byte(reader);
if (((byte === null) || (!byte_is_whitespace(byte)))) {
return;
}
(reader["pos"] += 1);
}
}

function __deka_json_to_assoc(value) {
let current = value;
for (let i = 0; (i < 16); (i += 1)) {
if (globalThis.is_object(current)) {
let arr = Array.isArray(current) ? current : (current && typeof current === 'object' ? Object.fromEntries(Object.entries(current)) : [current]);
if ((((globalThis.count(arr) === 1) && globalThis.array_key_exists(0, arr)) && (globalThis.is_object(arr[0]) || globalThis.is_array(arr[0])))) {
current = arr[0];
continue;
}
if ((((globalThis.count(arr) === 1) && globalThis.array_key_exists("0", arr)) && (globalThis.is_object(arr["0"]) || globalThis.is_array(arr["0"])))) {
current = arr["0"];
continue;
}
current = arr;
continue;
}
if (globalThis.is_array(current)) {
let out = [];
let is_entries = true;
for (const entry of (Array.isArray(current) ? current : Object.values((current ?? {})))) {
if ((((!globalThis.is_array(entry)) || (globalThis.count(entry) !== 2)) || (!globalThis.is_string(entry[0])))) {
is_entries = false;
break;
}
(out[entry[0]] = entry[1]);
}
if (is_entries) {
return out;
}
return current;
}
return null;
}
return null;
}

export function json_encode(value, flags, depth) {
if (flags === undefined) { flags = 0; }
if (depth === undefined) { depth = 512; }
__deka_json_reset_error();
let host = __deka_json_to_assoc(bridge("json", "encode", {"value": value, "flags": flags, "depth": depth}));
if ((globalThis.is_array(host) && globalThis.array_key_exists("ok", host))) {
if (((host["ok"] && globalThis.array_key_exists("json", host)) && globalThis.is_string(host["json"]))) {
return host["json"];
}
__deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
return false;
}
let out = __deka_json_encode_value(value, depth);
if (__deka_json_has_error()) {
return false;
}
return out;
}

export function json_decode(json, assoc, depth, flags) {
if (assoc === undefined) { assoc = false; }
if (depth === undefined) { depth = 512; }
if (flags === undefined) { flags = 0; }
__deka_json_reset_error();
let host = __deka_json_to_assoc(bridge("json", "decode", {"json": ("" + json), "assoc": assoc, "depth": depth, "flags": flags}));
if ((globalThis.is_array(host) && globalThis.array_key_exists("ok", host))) {
if (host["ok"]) {
if (globalThis.array_key_exists("value", host)) {
return host["value"];
}
return null;
}
__deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
return null;
}
json = ("" + json);
let reader = reader_new(json);
reader_skip_ws(reader);
let value = __deka_json_parse_value(reader, assoc, depth);
if (__deka_json_has_error()) {
return null;
}
reader_skip_ws(reader);
if ((!reader_eof(reader))) {
__deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
return null;
}
return value;
}

export function json_decode_result(json, assoc, depth, flags) {
if (assoc === undefined) { assoc = false; }
if (depth === undefined) { depth = 512; }
if (flags === undefined) { flags = 0; }
let value = json_decode(json, assoc, depth, flags);
let code = json_last_error();
if ((code === globalThis.JSON_ERROR_NONE)) {
return result_ok(value);
}
return result_err({"code": code, "message": json_last_error_msg()});
}

export function json_last_error() {
if (globalThis.array_key_exists(__DEKA_JSON_ERROR_KEY, globalThis.GLOBALS)) {
return globalThis.GLOBALS[__DEKA_JSON_ERROR_KEY];
}
return (globalThis.defined("JSON_ERROR_NONE") ? globalThis.JSON_ERROR_NONE : 0);
}

export function json_last_error_msg() {
if (globalThis.array_key_exists(__DEKA_JSON_ERROR_MSG_KEY, globalThis.GLOBALS)) {
return globalThis.GLOBALS[__DEKA_JSON_ERROR_MSG_KEY];
}
return __deka_json_error_message(json_last_error());
}

export function json_validate(json, depth, flags) {
if (depth === undefined) { depth = 512; }
if (flags === undefined) { flags = 0; }
__deka_json_reset_error();
let host = __deka_json_to_assoc(bridge("json", "validate", {"json": ("" + json), "depth": depth, "flags": flags}));
if (((globalThis.is_array(host) && globalThis.array_key_exists("ok", host)) && host["ok"])) {
if ((globalThis.array_key_exists("valid", host) && host["valid"])) {
return true;
}
__deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
return false;
}
json = ("" + json);
let reader = reader_new(json);
reader_skip_ws(reader);
let value = __deka_json_parse_value(reader, true, depth);
if (__deka_json_has_error()) {
return false;
}
reader_skip_ws(reader);
if ((!reader_eof(reader))) {
__deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
return false;
}
return ((value !== null) || (json_last_error() === globalThis.JSON_ERROR_NONE));
}

function __deka_json_has_error() {
return (json_last_error() !== (globalThis.defined("JSON_ERROR_NONE") ? globalThis.JSON_ERROR_NONE : 0));
}

function __deka_json_reset_error() {
(globalThis.GLOBALS[__DEKA_JSON_ERROR_KEY] = (globalThis.defined("JSON_ERROR_NONE") ? globalThis.JSON_ERROR_NONE : 0));
(globalThis.GLOBALS[__DEKA_JSON_ERROR_MSG_KEY] = __deka_json_error_message(globalThis.GLOBALS[__DEKA_JSON_ERROR_KEY]));
}

function __deka_json_set_error(code) {
(globalThis.GLOBALS[__DEKA_JSON_ERROR_KEY] = code);
(globalThis.GLOBALS[__DEKA_JSON_ERROR_MSG_KEY] = __deka_json_error_message(code));
}

function __deka_json_fail(code) {
__deka_json_set_error(code);
return null;
}

function __deka_json_error_message(code) {
switch (code) {
case globalThis.JSON_ERROR_NONE:
return "No error";
case globalThis.JSON_ERROR_DEPTH:
return "Maximum stack depth exceeded";
case globalThis.JSON_ERROR_STATE_MISMATCH:
return "State mismatch (invalid or malformed JSON)";
case globalThis.JSON_ERROR_CTRL_CHAR:
return "Control character error, possibly incorrectly encoded";
case globalThis.JSON_ERROR_SYNTAX:
return "Syntax error";
case globalThis.JSON_ERROR_UTF8:
return "Malformed UTF-8 characters, possibly incorrectly encoded";
case globalThis.JSON_ERROR_RECURSION:
return "Recursion detected";
case globalThis.JSON_ERROR_INF_OR_NAN:
return "Inf and NaN cannot be JSON encoded";
case globalThis.JSON_ERROR_UNSUPPORTED_TYPE:
return "Type is not supported";
case globalThis.JSON_ERROR_INVALID_PROPERTY_NAME:
return "The decoded property name is invalid";
case globalThis.JSON_ERROR_UTF16:
return "Single unpaired UTF-16 surrogate in unicode escape";
default:
return "Unknown error";
}
}

function __deka_json_parse_value(reader, assoc, depth) {
if ((depth <= 0)) {
return __deka_json_fail(globalThis.JSON_ERROR_DEPTH);
}
reader_skip_ws(reader);
let byte = reader_peek_byte(reader);
if ((byte === null)) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
if ((byte === 123)) {
return __deka_json_parse_object(reader, assoc, (depth - 1));
}
if ((byte === 91)) {
return __deka_json_parse_array(reader, assoc, (depth - 1));
}
if ((byte === 34)) {
return __deka_json_parse_string(reader);
}
if ((byte === 116)) {
return __deka_json_expect_literal(reader, "true", true);
}
if ((byte === 102)) {
return __deka_json_expect_literal(reader, "false", false);
}
if ((byte === 110)) {
return __deka_json_expect_literal(reader, "null", null);
}
if (((byte === 45) || byte_is_digit(byte))) {
return __deka_json_parse_number(reader);
}
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}

function __deka_json_expect_literal(reader, literal, value) {
let len = globalThis.strlen(literal);
for (let i = 0; (i < len); (i += 1)) {
let byte = reader_next_byte(reader);
if (((byte === null) || (globalThis.chr(byte) !== literal[i]))) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
}
return value;
}

function __deka_json_parse_array(reader, assoc, depth) {
reader_next_byte(reader);
let items = [];
reader_skip_ws(reader);
let byte = reader_peek_byte(reader);
if ((byte === 93)) {
reader_next_byte(reader);
return items;
}
while (true) {
let value = __deka_json_parse_value(reader, assoc, depth);
if (__deka_json_has_error()) {
return null;
}
(() => { const __arr = items; const __val = value; __arr.push(__val); return __val; })();
reader_skip_ws(reader);
byte = reader_peek_byte(reader);
if ((byte === 44)) {
reader_next_byte(reader);
reader_skip_ws(reader);
continue;
}
if ((byte === 93)) {
reader_next_byte(reader);
break;
}
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
return items;
}

function __deka_json_parse_object(reader, assoc, depth) {
reader_next_byte(reader);
let object = (assoc ? [] : {});
reader_skip_ws(reader);
let byte = reader_peek_byte(reader);
if ((byte === 125)) {
reader_next_byte(reader);
return object;
}
while (true) {
let key = __deka_json_parse_string(reader);
if (__deka_json_has_error()) {
return null;
}
reader_skip_ws(reader);
byte = reader_next_byte(reader);
if ((byte !== 58)) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
reader_skip_ws(reader);
let value = __deka_json_parse_value(reader, assoc, depth);
if (__deka_json_has_error()) {
return null;
}
if (assoc) {
(object[key] = value);
} else {
globalThis.__deka_object_set(object, key, value);
}
reader_skip_ws(reader);
byte = reader_peek_byte(reader);
if ((byte === 44)) {
reader_next_byte(reader);
reader_skip_ws(reader);
continue;
}
if ((byte === 125)) {
reader_next_byte(reader);
break;
}
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
return object;
}

function __deka_json_parse_string(reader) {
let byte = reader_next_byte(reader);
if ((byte !== 34)) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
let out = "";
while ((!reader_eof(reader))) {
byte = reader_next_byte(reader);
if ((byte === null)) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
if ((byte === 34)) {
return out;
}
if ((byte === 92)) {
let escape = reader_next_byte(reader);
if ((escape === null)) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
(out += __deka_json_escape_value(reader, escape));
if (__deka_json_has_error()) {
return null;
}
continue;
}
if ((byte < 32)) {
return __deka_json_fail(globalThis.JSON_ERROR_CTRL_CHAR);
}
(out += globalThis.chr(byte));
}
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}

function __deka_json_escape_value(reader, escape) {
switch (escape) {
case 34:
return "\"";
case 92:
return "\\";
case 47:
return "/";
case 98:
return "b";
case 102:
return "\f";
case 110:
return "\n";
case 114:
return "\r";
case 116:
return "\t";
case 117:
return __deka_json_parse_unicode_escape(reader);
default:
__deka_json_set_error(globalThis.JSON_ERROR_SYNTAX);
return "";
}
}

function __deka_json_parse_unicode_escape(reader) {
let hex = "";
for (let i = 0; (i < 4); (i += 1)) {
let byte = reader_next_byte(reader);
if (((byte === null) || (!byte_is_hex(byte)))) {
__deka_json_set_error(globalThis.JSON_ERROR_UTF8);
return "";
}
(hex += globalThis.chr(byte));
}
let code = globalThis.hexdec(hex);
if (((code >= 0xD800) && (code <= 0xDBFF))) {
let nextSlash = reader_next_byte(reader);
let nextU = reader_next_byte(reader);
if (((nextSlash !== 92) || (nextU !== 117))) {
__deka_json_set_error(globalThis.JSON_ERROR_UTF16);
return "";
}
let lowHex = "";
for (let i = 0; (i < 4); (i += 1)) {
let byte = reader_next_byte(reader);
if (((byte === null) || (!byte_is_hex(byte)))) {
__deka_json_set_error(globalThis.JSON_ERROR_UTF16);
return "";
}
(lowHex += globalThis.chr(byte));
}
let low = globalThis.hexdec(lowHex);
if (((low < 0xDC00) || (low > 0xDFFF))) {
__deka_json_set_error(globalThis.JSON_ERROR_UTF16);
return "";
}
code = ((0x10000 + ((code - 0xD800) << 10)) + (low - 0xDC00));
}
return __deka_json_codepoint_to_utf8(code);
}

function __deka_json_codepoint_to_utf8(code) {
if ((code <= 0x7F)) {
return globalThis.chr(code);
}
if ((code <= 0x7FF)) {
return (globalThis.chr((0xC0 | (code >> 6))) + globalThis.chr((0x80 | (code & 0x3F))));
}
if ((code <= 0xFFFF)) {
return ((globalThis.chr((0xE0 | (code >> 12))) + globalThis.chr((0x80 | ((code >> 6) & 0x3F)))) + globalThis.chr((0x80 | (code & 0x3F))));
}
if ((code <= 0x10FFFF)) {
return (((globalThis.chr((0xF0 | (code >> 18))) + globalThis.chr((0x80 | ((code >> 12) & 0x3F)))) + globalThis.chr((0x80 | ((code >> 6) & 0x3F)))) + globalThis.chr((0x80 | (code & 0x3F))));
}
__deka_json_set_error(globalThis.JSON_ERROR_UTF8);
return "";
}

function __deka_json_parse_number(reader) {
let num = "";
let byte = reader_peek_byte(reader);
if ((byte === 45)) {
(num += "-");
reader_next_byte(reader);
byte = reader_peek_byte(reader);
}
if ((byte === null)) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
if ((byte === 48)) {
(num += "0");
reader_next_byte(reader);
let next = reader_peek_byte(reader);
if (((next !== null) && byte_is_digit(next))) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
} else {
if ((!byte_is_digit(byte))) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
while (true) {
byte = reader_peek_byte(reader);
if (((byte === null) || (!byte_is_digit(byte)))) {
break;
}
(num += globalThis.chr(reader_next_byte(reader)));
}
}
byte = reader_peek_byte(reader);
if ((byte === 46)) {
(num += ".");
reader_next_byte(reader);
byte = reader_peek_byte(reader);
if (((byte === null) || (!byte_is_digit(byte)))) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
while (true) {
byte = reader_peek_byte(reader);
if (((byte === null) || (!byte_is_digit(byte)))) {
break;
}
(num += globalThis.chr(reader_next_byte(reader)));
}
}
byte = reader_peek_byte(reader);
if (((byte === 69) || (byte === 101))) {
(num += globalThis.chr(reader_next_byte(reader)));
byte = reader_peek_byte(reader);
if (((byte === 43) || (byte === 45))) {
(num += globalThis.chr(reader_next_byte(reader)));
}
byte = reader_peek_byte(reader);
if (((byte === null) || (!byte_is_digit(byte)))) {
return __deka_json_fail(globalThis.JSON_ERROR_SYNTAX);
}
while (true) {
byte = reader_peek_byte(reader);
if (((byte === null) || (!byte_is_digit(byte)))) {
break;
}
(num += globalThis.chr(reader_next_byte(reader)));
}
}
if (((globalThis.strpos(num, ".") !== false) || (globalThis.strpos(globalThis.strtolower(num), "e") !== false))) {
return num_parse_float(num);
}
return num_parse_int(num);
}

function __deka_json_encode_value(value, depth) {
if ((depth <= 0)) {
return __deka_json_fail(globalThis.JSON_ERROR_DEPTH);
}
if ((value === null)) {
return "null";
}
if (globalThis.is_bool(value)) {
return (value ? "true" : "false");
}
if (globalThis.is_int(value)) {
return ("" + value);
}
if (globalThis.is_float(value)) {
if ((globalThis.is_nan(value) || globalThis.is_infinite(value))) {
return __deka_json_fail(globalThis.JSON_ERROR_INF_OR_NAN);
}
return ("" + value);
}
if (globalThis.is_string(value)) {
return __deka_json_escape_string(value);
}
if (globalThis.is_array(value)) {
if (__deka_json_is_list_array(value)) {
let items = [];
for (const item of (Array.isArray(value) ? value : Object.values((value ?? {})))) {
let encoded = __deka_json_encode_value(item, (depth - 1));
if (__deka_json_has_error()) {
return null;
}
(() => { const __arr = items; const __val = encoded; __arr.push(__val); return __val; })();
}
return (("[" + globalThis.implode(",", items)) + "]");
}
let pairs = [];
for (const [key , item] of Object.entries(value)) {
let encodedValue = __deka_json_encode_value(item, (depth - 1));
if (__deka_json_has_error()) {
return null;
}
(() => { const __arr = pairs; const __val = ((__deka_json_escape_string(("" + key)) + ":") + encodedValue); __arr.push(__val); return __val; })();
}
return (("{" + globalThis.implode(",", pairs)) + "}");
}
if (globalThis.is_object(value)) {
let pairs = [];
for (const [key , item] of Object.entries(globalThis.get_object_vars(value))) {
let encodedValue = __deka_json_encode_value(item, (depth - 1));
if (__deka_json_has_error()) {
return null;
}
(() => { const __arr = pairs; const __val = ((__deka_json_escape_string(("" + key)) + ":") + encodedValue); __arr.push(__val); return __val; })();
}
return (("{" + globalThis.implode(",", pairs)) + "}");
}
return __deka_json_fail(globalThis.JSON_ERROR_UNSUPPORTED_TYPE);
}

function __deka_json_is_list_array(value) {
let expected = 0;
for (const [key , _] of Object.entries(value)) {
if ((key !== expected)) {
return false;
}
(expected += 1);
}
return true;
}

function __deka_json_escape_string(value) {
let out = "\"";
let len = globalThis.strlen(value);
for (let i = 0; (i < len); (i += 1)) {
let byte = globalThis.ord(value[i]);
switch (byte) {
case 34:
(out += "\\\"");
break;
case 92:
(out += "\\\\");
break;
case 8:
(out += "\\b");
break;
case 12:
(out += "\\f");
break;
case 10:
(out += "\\n");
break;
case 13:
(out += "\\r");
break;
case 9:
(out += "\\t");
break;
default:
if ((byte < 32)) {
(out += globalThis.sprintf("\\u%04x", byte));
} else {
(out += globalThis.chr(byte));
}
}
}
(out += "\"");
return out;
}

