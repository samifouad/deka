// Generated by deka build. Do not edit manually.
// Target semantics: JavaScript runtime semantics.
export const phpxBuildMode = "subset-ast";
export const phpxTargetSemantics = "js";

if (!globalThis.panic) { globalThis.panic = (msg) => { throw new Error(String(msg)); }; }
if (!globalThis.function_exists) { globalThis.function_exists = (name) => typeof globalThis[name] === 'function'; }
if (!globalThis.class_exists) { globalThis.class_exists = (name) => typeof globalThis[name] === 'function' || typeof globalThis[name] === 'object'; }
if (!globalThis.class_alias) { globalThis.class_alias = () => false; }

if (!globalThis.defined) { globalThis.defined = (name) => Object.prototype.hasOwnProperty.call(globalThis, String(name)); }

if (!globalThis.__phpx_is_struct) { globalThis.__phpx_is_struct = (value, name) => Boolean(value && typeof value === 'object' && value.__struct === name); }

if (!globalThis.__phpx_func_num_args) { globalThis.__phpx_func_num_args = (args) => args.length; }
if (!globalThis.__phpx_func_get_args) { globalThis.__phpx_func_get_args = (args) => Array.prototype.slice.call(args); }
if (!globalThis.__phpx_func_get_arg) { globalThis.__phpx_func_get_arg = (args, idx) => (idx >= 0 && idx < args.length ? args[idx] : null); }

if (!globalThis.__deka_chr) { globalThis.__deka_chr = (code) => String.fromCharCode((Number(code) || 0) & 0xff); }
if (!globalThis.__deka_ord) { globalThis.__deka_ord = (value) => { const str = String(value ?? ''); return str.length ? str.charCodeAt(0) : 0; }; }
if (!globalThis.chr) { globalThis.chr = globalThis.__deka_chr; }
if (!globalThis.ord) { globalThis.ord = globalThis.__deka_ord; }
if (!globalThis.strlen) { globalThis.strlen = (value) => String(value ?? '').length; }
if (!globalThis.substr) { globalThis.substr = (value, start, length = null) => { const src = String(value ?? ''); let s = Number(start) || 0; if (s < 0) s = Math.max(src.length + s, 0); if (length === null || length === undefined) return src.slice(s); let l = Number(length) || 0; if (l < 0) return src.slice(s, Math.max(src.length + l, s)); return src.slice(s, s + l); }; }
if (!globalThis.ltrim) { globalThis.ltrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/^\s+/, ''); const set = new Set(String(chars)); let i = 0; while (i < src.length && set.has(src[i])) i += 1; return src.slice(i); }; }
if (!globalThis.rtrim) { globalThis.rtrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/\s+$/, ''); const set = new Set(String(chars)); let i = src.length - 1; while (i >= 0 && set.has(src[i])) i -= 1; return src.slice(0, i + 1); }; }
if (!globalThis.trim) { globalThis.trim = (value, chars = null) => globalThis.ltrim(globalThis.rtrim(value, chars), chars); }
if (!globalThis.strpos) { globalThis.strpos = (haystack, needle, offset = 0) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = h.indexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }
if (!globalThis.strrpos) { globalThis.strrpos = (haystack, needle, offset = null) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = offset === null || offset === undefined ? h.lastIndexOf(n) : h.lastIndexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }
if (!globalThis.str_starts_with) { globalThis.str_starts_with = (haystack, needle) => String(haystack ?? '').startsWith(String(needle ?? '')); }
if (!globalThis.str_ends_with) { globalThis.str_ends_with = (haystack, needle) => String(haystack ?? '').endsWith(String(needle ?? '')); }
if (!globalThis.str_contains) { globalThis.str_contains = (haystack, needle) => String(haystack ?? '').includes(String(needle ?? '')); }
if (!globalThis.strtolower) { globalThis.strtolower = (value) => String(value ?? '').toLowerCase(); }
if (!globalThis.strtoupper) { globalThis.strtoupper = (value) => String(value ?? '').toUpperCase(); }
if (!globalThis.array_key_exists) { globalThis.array_key_exists = (key, value) => { if (value === null || value === undefined) return false; if (Array.isArray(value)) { const idx = Number(key); return Number.isInteger(idx) && idx >= 0 && idx < value.length; } if (typeof value === 'object') return Object.prototype.hasOwnProperty.call(value, key); return false; }; }
if (!globalThis.in_array) { globalThis.in_array = (needle, haystack, strict = false) => { if (!Array.isArray(haystack)) return false; for (const item of haystack) { if (strict ? item === needle : item == needle) return true; } return false; }; }
if (!globalThis.explode) { globalThis.explode = (sep, value, limit = null) => { const s = String(value ?? ''); const parts = s.split(String(sep ?? '')); if (limit === null || limit === undefined || Number(limit) === 0) return parts; const n = Number(limit); if (!Number.isInteger(n)) return parts; if (n > 0) { if (parts.length <= n) return parts; const head = parts.slice(0, n - 1); head.push(parts.slice(n - 1).join(String(sep ?? ''))); return head; } return parts; }; }
if (!globalThis.implode) { globalThis.implode = (glue, pieces = null) => { if (pieces === null || pieces === undefined) { pieces = glue; glue = ''; } if (!Array.isArray(pieces)) return ''; return pieces.map((v) => String(v ?? '')).join(String(glue ?? '')); }; }
if (!globalThis.count) { globalThis.count = (value) => { if (Array.isArray(value) || typeof value === 'string') return value.length; if (value && typeof value === 'object') return Object.keys(value).length; return 0; }; }
if (!globalThis.time) { globalThis.time = () => Math.floor(Date.now() / 1000); }
if (!globalThis.getenv) { globalThis.getenv = (name) => { const key = String(name ?? ''); const env = globalThis.process && globalThis.process.env ? globalThis.process.env : null; if (!env || !Object.prototype.hasOwnProperty.call(env, key)) return false; const value = env[key]; return value === undefined || value === null ? false : String(value); }; }
if (!globalThis.is_promise) { globalThis.is_promise = (value) => Boolean(value && typeof value === 'object' && typeof value.then === 'function'); }
if (!globalThis.GLOBALS || typeof globalThis.GLOBALS !== 'object') { globalThis.GLOBALS = {}; }
if (typeof globalThis.JSON_ERROR_NONE !== 'number') { globalThis.JSON_ERROR_NONE = 0; }
if (typeof globalThis.JSON_ERROR_DEPTH !== 'number') { globalThis.JSON_ERROR_DEPTH = 1; }
if (typeof globalThis.JSON_ERROR_STATE_MISMATCH !== 'number') { globalThis.JSON_ERROR_STATE_MISMATCH = 2; }
if (typeof globalThis.JSON_ERROR_CTRL_CHAR !== 'number') { globalThis.JSON_ERROR_CTRL_CHAR = 3; }
if (typeof globalThis.JSON_ERROR_SYNTAX !== 'number') { globalThis.JSON_ERROR_SYNTAX = 4; }
if (typeof globalThis.JSON_ERROR_UTF8 !== 'number') { globalThis.JSON_ERROR_UTF8 = 5; }
if (typeof globalThis.JSON_ERROR_RECURSION !== 'number') { globalThis.JSON_ERROR_RECURSION = 6; }
if (typeof globalThis.JSON_ERROR_INF_OR_NAN !== 'number') { globalThis.JSON_ERROR_INF_OR_NAN = 7; }
if (typeof globalThis.JSON_ERROR_UNSUPPORTED_TYPE !== 'number') { globalThis.JSON_ERROR_UNSUPPORTED_TYPE = 8; }
if (typeof globalThis.JSON_ERROR_INVALID_PROPERTY_NAME !== 'number') { globalThis.JSON_ERROR_INVALID_PROPERTY_NAME = 9; }
if (typeof globalThis.JSON_ERROR_UTF16 !== 'number') { globalThis.JSON_ERROR_UTF16 = 10; }
if (!globalThis.__deka_object_set) { globalThis.__deka_object_set = (obj, key, value) => { if (obj && typeof obj === 'object') { obj[key] = value; } return obj; }; }
if (!globalThis.__phpx_base64_table) { globalThis.__phpx_base64_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; }
if (!globalThis.base64_encode) { globalThis.base64_encode = (input) => { const str = String(input ?? ''); const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < str.length; i += 3) { const b0 = str.charCodeAt(i) & 0xff; const b1 = i + 1 < str.length ? str.charCodeAt(i + 1) & 0xff : NaN; const b2 = i + 2 < str.length ? str.charCodeAt(i + 2) & 0xff : NaN; const n = (b0 << 16) | ((Number.isNaN(b1) ? 0 : b1) << 8) | (Number.isNaN(b2) ? 0 : b2); out += tbl[(n >> 18) & 63]; out += tbl[(n >> 12) & 63]; out += Number.isNaN(b1) ? '=' : tbl[(n >> 6) & 63]; out += Number.isNaN(b2) ? '=' : tbl[n & 63]; } return out; }; }
if (!globalThis.base64_decode) { globalThis.base64_decode = (input, strict = false) => { const src = String(input ?? '').replace(/\s+/g, ''); if (src.length % 4 !== 0) return strict ? false : ''; const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < src.length; i += 4) { const c0 = src[i], c1 = src[i + 1], c2 = src[i + 2], c3 = src[i + 3]; const n0 = tbl.indexOf(c0), n1 = tbl.indexOf(c1); const n2 = c2 === '=' ? -1 : tbl.indexOf(c2); const n3 = c3 === '=' ? -1 : tbl.indexOf(c3); if (n0 < 0 || n1 < 0 || n2 < -1 || n3 < -1) return strict ? false : ''; const n = (n0 << 18) | (n1 << 12) | ((n2 < 0 ? 0 : n2) << 6) | (n3 < 0 ? 0 : n3); out += String.fromCharCode((n >> 16) & 0xff); if (c2 !== '=') out += String.fromCharCode((n >> 8) & 0xff); if (c3 !== '=') out += String.fromCharCode(n & 0xff); } return out; }; }
if (!globalThis.__phpx_sha256_hex) { globalThis.__phpx_sha256_hex = (input) => { const K = [1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]; const bytes = []; const src = String(input ?? ''); for (let i = 0; i < src.length; i += 1) bytes.push(src.charCodeAt(i) & 0xff); const bitLen = bytes.length * 8; bytes.push(0x80); while ((bytes.length % 64) !== 56) bytes.push(0); for (let i = 7; i >= 0; i -= 1) bytes.push((bitLen >>> (i * 8)) & 0xff); let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a, h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19; const rotr = (x, n) => ((x >>> n) | (x << (32 - n))) >>> 0; for (let i = 0; i < bytes.length; i += 64) { const w = new Array(64); for (let j = 0; j < 16; j += 1) { const k = i + (j * 4); w[j] = (((bytes[k] << 24) | (bytes[k + 1] << 16) | (bytes[k + 2] << 8) | bytes[k + 3]) >>> 0); } for (let j = 16; j < 64; j += 1) { const s0 = (rotr(w[j - 15], 7) ^ rotr(w[j - 15], 18) ^ (w[j - 15] >>> 3)) >>> 0; const s1 = (rotr(w[j - 2], 17) ^ rotr(w[j - 2], 19) ^ (w[j - 2] >>> 10)) >>> 0; w[j] = (((w[j - 16] + s0) >>> 0) + ((w[j - 7] + s1) >>> 0)) >>> 0; } let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7; for (let j = 0; j < 64; j += 1) { const S1 = (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) >>> 0; const ch = ((e & f) ^ ((~e) & g)) >>> 0; const t1 = (((((h + S1) >>> 0) + ch) >>> 0) + ((K[j] + w[j]) >>> 0)) >>> 0; const S0 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) >>> 0; const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0; const t2 = (S0 + maj) >>> 0; h = g; g = f; f = e; e = (d + t1) >>> 0; d = c; c = b; b = a; a = (t1 + t2) >>> 0; } h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0; h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0; } const words = [h0, h1, h2, h3, h4, h5, h6, h7]; let out = ''; for (const w of words) { out += (w >>> 0).toString(16).padStart(8, '0'); } return out; }; }
if (!globalThis.__phpx_hex_to_binary) { globalThis.__phpx_hex_to_binary = (hex) => { const src = String(hex ?? ''); let out = ''; for (let i = 0; i < src.length; i += 2) out += String.fromCharCode(parseInt(src.slice(i, i + 2), 16) & 0xff); return out; }; }
if (!globalThis.__phpx_hmac_sha256_hex) { globalThis.__phpx_hmac_sha256_hex = (data, key) => { const toBytes = (s) => { const out = []; const src = String(s ?? ''); for (let i = 0; i < src.length; i += 1) out.push(src.charCodeAt(i) & 0xff); return out; }; const fromBytes = (arr) => arr.map((v) => String.fromCharCode(v & 0xff)).join(''); let k = toBytes(key); if (k.length > 64) { const kh = globalThis.__phpx_sha256_hex(fromBytes(k)); k = toBytes(globalThis.__phpx_hex_to_binary(kh)); } while (k.length < 64) k.push(0); const o = [], i = []; for (let n = 0; n < 64; n += 1) { o.push(k[n] ^ 0x5c); i.push(k[n] ^ 0x36); } const innerHex = globalThis.__phpx_sha256_hex(fromBytes(i) + String(data ?? '')); const outerHex = globalThis.__phpx_sha256_hex(fromBytes(o) + globalThis.__phpx_hex_to_binary(innerHex)); return outerHex; }; }
if (!globalThis.__phpx_node_crypto) { globalThis.__phpx_node_crypto = (() => { try { if (typeof require === 'function') { return require('node:crypto'); } } catch (_err) {} try { if (typeof require === 'function') { return require('crypto'); } } catch (_err) {} return null; })(); }
if (!globalThis.hash) { globalThis.hash = (algo, data, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_sha256_hex(String(data ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHash !== 'function') throw new Error('hash() requires crypto support'); const digest = mod.createHash(name).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }
if (!globalThis.hash_hmac) { globalThis.hash_hmac = (algo, data, key, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_hmac_sha256_hex(String(data ?? ''), String(key ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHmac !== 'function') throw new Error('hash_hmac() requires crypto support'); const digest = mod.createHmac(name, String(key ?? '')).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }
if (!globalThis.hash_equals) { globalThis.hash_equals = (a, b) => { const left = String(a ?? ''); const right = String(b ?? ''); if (left.length !== right.length) return false; let out = 0; for (let i = 0; i < left.length; i += 1) out |= left.charCodeAt(i) ^ right.charCodeAt(i); return out === 0; }; }
if (!globalThis.__phpx_symbol_table) { globalThis.__phpx_symbol_table = Object.create(null); }
if (!globalThis.__deka_symbol_set) { globalThis.__deka_symbol_set = (name, value) => { const key = String(name); globalThis.__phpx_symbol_table[key] = value; return true; }; }
if (!globalThis.__deka_symbol_get) { globalThis.__deka_symbol_get = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key) ? globalThis.__phpx_symbol_table[key] : null; }; }
if (!globalThis.__deka_symbol_exists) { globalThis.__deka_symbol_exists = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key); }; }
if (!globalThis.__phpx_array_cursor) { globalThis.__phpx_array_cursor = new WeakMap(); }
if (!globalThis.__deka_array_cursor) { globalThis.__deka_array_cursor = (arr, action) => { if (!arr || (typeof arr !== 'object' && !Array.isArray(arr))) return null; const map = globalThis.__phpx_array_cursor; let state = map.get(arr); if (!state) { state = { idx: 0 }; map.set(arr, state); } const keys = Object.keys(arr); if (keys.length === 0) return null; const clamp = () => { if (state.idx < 0) state.idx = 0; if (state.idx >= keys.length) state.idx = keys.length - 1; }; switch (String(action)) { case 'reset': state.idx = 0; break; case 'end': state.idx = keys.length - 1; break; case 'next': state.idx += 1; if (state.idx >= keys.length) return null; break; case 'prev': state.idx -= 1; if (state.idx < 0) return null; break; case 'pos': case 'current': break; case 'key': break; default: return null; } clamp(); const key = keys[state.idx]; if (String(action) === 'key') return key; return arr[key]; }; }

if (!globalThis.is_array || !globalThis.is_array.__deka_polyfill) { const __isArray = (value) => { if (Array.isArray(value)) return true; if (!(value !== null && typeof value === 'object' && Object.getPrototypeOf(value) === Object.prototype)) return false; if (Object.prototype.hasOwnProperty.call(value, '__struct')) return false; return true; }; __isArray.__deka_polyfill = true; globalThis.is_array = __isArray; }

import { __deka_slice_bytes, __deka_strlen_bytes } from './bytes_utils.phpx';

if (!globalThis.__phpxStructMethods) { globalThis.__phpxStructMethods = Object.create(null); }
export function sscanf(string, format) {
if ((globalThis.__phpx_func_num_args(arguments) !== 2)) {
return null;
}
let input = ("" + string);
let fmt = ("" + format);
let inputLen = __deka_strlen_bytes(input);
let fmtLen = __deka_strlen_bytes(fmt);
let i = 0;
let f = 0;
let results = [];
while ((f < fmtLen)) {
let ch = fmt[f];
if (__deka_is_whitespace(ch)) {
while (((f < fmtLen) && __deka_is_whitespace(fmt[f]))) {
(f += 1);
}
if (((i >= inputLen) || (!__deka_is_whitespace(input[i])))) {
return null;
}
while (((i < inputLen) && __deka_is_whitespace(input[i]))) {
(i += 1);
}
continue;
}
if ((ch !== "%")) {
if (((i >= inputLen) || (input[i] !== ch))) {
return null;
}
(i += 1);
(f += 1);
continue;
}
(f += 1);
if ((f >= fmtLen)) {
return null;
}
if ((fmt[f] === "%")) {
if (((i >= inputLen) || (input[i] !== "%"))) {
return null;
}
(i += 1);
(f += 1);
continue;
}
let suppress = false;
if ((fmt[f] === "*")) {
suppress = true;
(f += 1);
if ((f >= fmtLen)) {
return null;
}
}
let widthStr = "";
while (((f < fmtLen) && __deka_is_digit(fmt[f]))) {
(widthStr += fmt[f]);
(f += 1);
}
let width = ((widthStr === "") ? null : Number.parseInt(widthStr, 10));
if ((f >= fmtLen)) {
return null;
}
let spec = fmt[f];
(f += 1);
let parsed = __deka_scan_spec(input, i, spec, width);
if ((parsed === null)) {
return null;
}
i = parsed["index"];
if ((!suppress)) {
(() => { const __arr = results; const __val = parsed["value"]; __arr.push(__val); return __val; })();
}
}
return results;
}

function __deka_scan_spec(input, idx, spec, width) {
switch (spec) {
case "d":
case "i":
return __deka_scan_int(input, idx, width);
case "u":
return __deka_scan_uint(input, idx, width);
case "x":
case "X":
return __deka_scan_hex(input, idx, width);
case "o":
return __deka_scan_oct(input, idx, width);
case "f":
case "e":
case "E":
case "g":
case "G":
return __deka_scan_float(input, idx);
case "s":
return __deka_scan_string(input, idx, width);
case "c":
return __deka_scan_char(input, idx, width);
default:
return null;
}
}

function __deka_scan_int(input, idx, width) {
let len = __deka_strlen_bytes(input);
let sign = 1;
if (((idx < len) && (input[idx] === "-"))) {
sign = (-1);
(idx += 1);
}
let digits = "";
let count = 0;
while ((((idx < len) && __deka_is_digit(input[idx])) && ((width === null) || (count < width)))) {
(digits += input[idx]);
(idx += 1);
(count += 1);
}
if ((count === 0)) {
return null;
}
let value = Number.parseInt(digits, 10);
if ((sign < 0)) {
value = (-value);
}
return {"value": value, "index": idx};
}

function __deka_scan_uint(input, idx, width) {
let len = __deka_strlen_bytes(input);
let digits = "";
let count = 0;
while ((((idx < len) && __deka_is_digit(input[idx])) && ((width === null) || (count < width)))) {
(digits += input[idx]);
(idx += 1);
(count += 1);
}
if ((count === 0)) {
return null;
}
return {"value": Number.parseInt(digits, 10), "index": idx};
}

function __deka_scan_hex(input, idx, width) {
let len = __deka_strlen_bytes(input);
if (((((idx + 1) < len) && (input[idx] === "0")) && ((input[(idx + 1)] === "x") || (input[(idx + 1)] === "X")))) {
(idx += 2);
}
let digits = "";
let count = 0;
while ((((idx < len) && __deka_is_hex_digit(input[idx])) && ((width === null) || (count < width)))) {
(digits += input[idx]);
(idx += 1);
(count += 1);
}
if ((count === 0)) {
return null;
}
return {"value": __deka_parse_base_digits(digits, 16), "index": idx};
}

function __deka_scan_oct(input, idx, width) {
let len = __deka_strlen_bytes(input);
let digits = "";
let count = 0;
while ((((idx < len) && __deka_is_oct_digit(input[idx])) && ((width === null) || (count < width)))) {
(digits += input[idx]);
(idx += 1);
(count += 1);
}
if ((count === 0)) {
return null;
}
return {"value": __deka_parse_base_digits(digits, 8), "index": idx};
}

function __deka_scan_float(input, idx) {
let len = __deka_strlen_bytes(input);
let start = idx;
if (((idx < len) && (input[idx] === "-"))) {
(idx += 1);
}
let before = 0;
while (((idx < len) && __deka_is_digit(input[idx]))) {
(idx += 1);
(before += 1);
}
let after = 0;
if (((idx < len) && (input[idx] === "."))) {
(idx += 1);
while (((idx < len) && __deka_is_digit(input[idx]))) {
(idx += 1);
(after += 1);
}
}
if (((before === 0) && (after === 0))) {
return null;
}
if (((idx < len) && ((input[idx] === "e") || (input[idx] === "E")))) {
let expStart = idx;
(idx += 1);
if (((idx < len) && ((input[idx] === "+") || (input[idx] === "-")))) {
(idx += 1);
}
let expDigits = 0;
while (((idx < len) && __deka_is_digit(input[idx]))) {
(idx += 1);
(expDigits += 1);
}
if ((expDigits === 0)) {
return null;
}
}
let token = __deka_slice_bytes(input, start, idx);
return {"value": Number(token), "index": idx};
}

function __deka_scan_string(input, idx, width) {
let len = __deka_strlen_bytes(input);
let start = idx;
let count = 0;
while ((((idx < len) && (!__deka_is_whitespace(input[idx]))) && ((width === null) || (count < width)))) {
(idx += 1);
(count += 1);
}
if ((count === 0)) {
return null;
}
return {"value": __deka_slice_bytes(input, start, (start + count)), "index": idx};
}

function __deka_scan_char(input, idx, width) {
let len = __deka_strlen_bytes(input);
let count = ((width === null) ? 1 : width);
if (((idx + count) > len)) {
return null;
}
let value = __deka_slice_bytes(input, idx, (idx + count));
return {"value": value, "index": (idx + count)};
}

function __deka_parse_base_digits(digits, base) {
let len = __deka_strlen_bytes(digits);
let value = 0;
for (let i = 0; (i < len); (i += 1)) {
let digit = __deka_digit_value(digits[i]);
if (((digit < 0) || (digit >= base))) {
return 0;
}
value = ((value * base) + digit);
}
return value;
}

function __deka_digit_value(ch) {
let code = globalThis.ord(ch);
if (((code >= 48) && (code <= 57))) {
return (code - 48);
}
if (((code >= 65) && (code <= 70))) {
return (code - 55);
}
if (((code >= 97) && (code <= 102))) {
return (code - 87);
}
return (-1);
}

function __deka_is_digit(ch) {
let code = globalThis.ord(ch);
return ((code >= 48) && (code <= 57));
}

function __deka_is_hex_digit(ch) {
let code = globalThis.ord(ch);
return ((((code >= 48) && (code <= 57)) || ((code >= 65) && (code <= 70))) || ((code >= 97) && (code <= 102)));
}

function __deka_is_oct_digit(ch) {
let code = globalThis.ord(ch);
return ((code >= 48) && (code <= 55));
}

function __deka_is_whitespace(ch) {
let code = globalThis.ord(ch);
return ((((((code === 32) || (code === 9)) || (code === 10)) || (code === 13)) || (code === 11)) || (code === 12));
}

