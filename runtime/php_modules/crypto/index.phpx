import { from_string as bytes_from_string, from_array as bytes_from_array, to_array as bytes_to_array } from 'bytes'
import { result_ok, result_err, result_is_ok } from 'core/result'
import { bridge } from 'core/bridge'

function to_assoc($value) {
  if (is_array($value)) {
    $out = []
    $is_entries = true
    foreach ($value as $entry) {
      if (!is_array($entry) || count($entry) !== 2 || !is_string($entry[0])) {
        $is_entries = false
        break
      }
      $out[$entry[0]] = $entry[1]
    }
    if ($is_entries) {
      return $out
    }
    return $value
  }
  return null
}

function to_string_value($value) {
  if (is_string($value)) {
    return $value
  }
  if (is_array($value)) {
    return json_encode($value)
  }
  if (is_object($value)) {
    return json_encode($value)
  }
  return '' . $value
}

function hex_from_bytes($bytes) {
  $arr = bytes_to_array($bytes)
  $hex = ''
  foreach ($arr as $v) {
    $part = dechex($v)
    if (strlen($part) < 2) {
      $part = '0' . $part
    }
    $hex = $hex . $part
  }
  return $hex
}

/// docid: phpx/crypto/random_bytes_result()
/// <Function name="random_bytes_result">
///   <Description>PHPX standard module function `random_bytes_result` from `crypto`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function random_bytes_result($len = 32) {
  $n = (int) $len
  if ($n <= 0) {
    return result_err('length must be > 0')
  }
  $raw = bridge('crypto', 'random_bytes', { length: $n })
  $assoc = to_assoc($raw)
  if (!is_array($assoc) || !array_key_exists('ok', $assoc) || !$assoc['ok']) {
    $msg = is_array($assoc) && array_key_exists('error', $assoc) ? $assoc['error'] : 'crypto random_bytes failed'
    return result_err($msg)
  }
  if (!array_key_exists('data', $assoc) || !is_array($assoc['data'])) {
    return result_err('crypto random_bytes returned invalid payload')
  }
  return result_ok(bytes_from_array($assoc['data']))
}

/// docid: phpx/crypto/random_hex()
/// <Function name="random_hex">
///   <Description>PHPX standard module function `random_hex` from `crypto`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function random_hex($len = 32) {
  $res = random_bytes_result($len)
  if (!result_is_ok($res)) {
    return $res
  }
  return result_ok(hex_from_bytes($res->value))
}

/// docid: phpx/crypto/sha256_hex()
/// <Function name="sha256_hex">
///   <Description>PHPX standard module function `sha256_hex` from `crypto`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function sha256_hex($value) {
  return hash('sha256', to_string_value($value))
}

/// docid: phpx/crypto/hmac_sha256_hex()
/// <Function name="hmac_sha256_hex">
///   <Description>PHPX standard module function `hmac_sha256_hex` from `crypto`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function hmac_sha256_hex($value, $key) {
  return hash_hmac('sha256', to_string_value($value), to_string_value($key))
}

/// docid: phpx/crypto/hmac_sha256_bytes()
/// <Function name="hmac_sha256_bytes">
///   <Description>PHPX standard module function `hmac_sha256_bytes` from `crypto`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function hmac_sha256_bytes($value, $key) {
  $raw = hash_hmac('sha256', to_string_value($value), to_string_value($key), true)
  return bytes_from_string($raw)
}

/// docid: phpx/crypto/secure_compare()
/// <Function name="secure_compare">
///   <Description>PHPX standard module function `secure_compare` from `crypto`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function secure_compare($a, $b) {
  return hash_equals(to_string_value($a), to_string_value($b))
}

/// docid: phpx/crypto/uuid_v4()
/// <Function name="uuid_v4">
///   <Description>PHPX standard module function `uuid_v4` from `crypto`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function uuid_v4() {
  $res = random_bytes_result(16)
  if (!result_is_ok($res)) {
    return $res
  }
  $arr = bytes_to_array($res->value)
  if (count($arr) !== 16) {
    return result_err('failed to generate uuid bytes')
  }
  $arr[6] = ($arr[6] & 0x0f) | 0x40
  $arr[8] = ($arr[8] & 0x3f) | 0x80
  $hex = ''
  foreach ($arr as $v) {
    $part = dechex($v)
    if (strlen($part) < 2) {
      $part = '0' . $part
    }
    $hex = $hex . $part
  }
  $uuid = substr($hex, 0, 8)
    . '-'
    . substr($hex, 8, 4)
    . '-'
    . substr($hex, 12, 4)
    . '-'
    . substr($hex, 16, 4)
    . '-'
    . substr($hex, 20, 12)
  return result_ok($uuid)
}
