import { result_ok, result_err, result_is_ok } from 'core/result'
import { hmac_sha256_bytes, secure_compare, base64_encode_string, base64_decode_string } from 'crypto'
import { to_string as bytes_to_string } from 'bytes'
import { json_encode, json_decode_result } from 'encoding/json'
import { rtrim } from 'string/rtrim'
import { str_replace } from 'string/str_replace'
import { strlen } from 'string/strlen'
import { str_repeat } from 'string/str_repeat'
import { strtoupper } from 'string/strtoupper'
import { explode } from 'string/explode'
import { now_ms } from 'time'

function to_assoc($value) {
  if (is_array($value)) {
    if (count($value) === 1 && array_key_exists(0, $value) && (is_object($value[0]) || is_array($value[0]))) {
      return is_object($value[0]) ? (array) $value[0] : $value[0]
    }
    if (count($value) === 1 && array_key_exists('0', $value) && (is_object($value['0']) || is_array($value['0']))) {
      return is_object($value['0']) ? (array) $value['0'] : $value['0']
    }
    return $value
  }
  if (is_object($value)) {
    $out = (array) $value
    if (count($out) === 1 && array_key_exists(0, $out) && (is_object($out[0]) || is_array($out[0]))) {
      return is_object($out[0]) ? (array) $out[0] : $out[0]
    }
    if (count($out) === 1 && array_key_exists('0', $out) && (is_object($out['0']) || is_array($out['0']))) {
      return is_object($out['0']) ? (array) $out['0'] : $out['0']
    }
    return $out
  }
  return []
}

function b64url_encode($raw) {
  return rtrim(str_replace(['+', '/'], ['-', '_'], base64_encode_string($raw)), '=')
}

function b64url_decode($value) {
  $padded = '' . $value
  $pad = strlen($padded) % 4
  if ($pad > 0) {
    $padded = $padded . str_repeat('=', 4 - $pad)
  }
  $decoded = base64_decode_string(str_replace(['-', '_'], ['+', '/'], $padded), true)
  if ($decoded === false) {
    return result_err('invalid base64url payload')
  }
  return result_ok($decoded)
}

function now_unix() {
  return (int) (now_ms() / 1000)
}

function normalize_claims($payload, $options = []) {
  $claims = to_assoc($payload)
  if (is_array($options) && array_key_exists('iss', $options)) {
    $claims['iss'] = $options['iss']
  }
  if (is_array($options) && array_key_exists('aud', $options)) {
    $claims['aud'] = $options['aud']
  }
  if (is_array($options) && array_key_exists('sub', $options)) {
    $claims['sub'] = $options['sub']
  }
  if (!array_key_exists('iat', $claims)) {
    $claims['iat'] = now_unix()
  }
  if (is_array($options) && array_key_exists('exp_in', $options)) {
    $claims['exp'] = now_unix() + (int) $options['exp_in']
  }
  if (is_array($options) && array_key_exists('exp', $options)) {
    $claims['exp'] = (int) $options['exp']
  }
  return $claims
}

/// docid: phpx/jwt/sign()
/// <Function name="sign">
///   <Description>PHPX standard module function `sign` from `jwt`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function sign($payload, $secret, $options = []) {
  $alg = is_array($options) && array_key_exists('alg', $options) ? strtoupper('' . $options['alg']) : 'HS256'
  if ($alg !== 'HS256') {
    return result_err('unsupported jwt alg: ' . $alg)
  }

  $header = [ 'alg' => 'HS256', 'typ' => 'JWT' ]
  $claims = normalize_claims($payload, $options)
  $header_json = json_encode($header)
  $claims_json = json_encode($claims)
  if (!is_string($header_json) || !is_string($claims_json)) {
    return result_err('failed to encode jwt parts')
  }
  $input = b64url_encode($header_json) . '.' . b64url_encode($claims_json)
  $sig = bytes_to_string(hmac_sha256_bytes($input, $secret))
  return result_ok($input . '.' . b64url_encode($sig))
}

function decode_parts($token) {
  $parts = explode('.', '' . $token)
  if (count($parts) !== 3) {
    return result_err('invalid jwt format')
  }
  $h = b64url_decode($parts[0])
  if (!result_is_ok($h)) {
    return $h
  }
  $p = b64url_decode($parts[1])
  if (!result_is_ok($p)) {
    return $p
  }
  $s = b64url_decode($parts[2])
  if (!result_is_ok($s)) {
    return $s
  }
  $header_json = $h->value
  $payload_json = $p->value
  $header_res = json_decode_result($header_json, true)
  if (!result_is_ok($header_res)) {
    return result_err('invalid jwt header json')
  }
  $payload_res = json_decode_result($payload_json, true)
  if (!result_is_ok($payload_res)) {
    return result_err('invalid jwt payload json')
  }
  return result_ok([
    'header' => $header_res->value,
    'payload' => $payload_res->value,
    'signature_raw' => $s->value,
    'signing_input' => $parts[0] . '.' . $parts[1],
  ])
}

function validate_claims($claims, $options = []) {
  $claims_assoc = to_assoc($claims)
  $now = now_unix()
  $leeway = is_array($options) && array_key_exists('leeway', $options) ? (int) $options['leeway'] : 0

  if (array_key_exists('iat', $claims_assoc) && (int) $claims_assoc['iat'] - $leeway > $now) {
    return result_err('jwt issued in future')
  }

  if (array_key_exists('exp', $claims_assoc) && (int) $claims_assoc['exp'] + $leeway < $now) {
    return result_err('jwt expired')
  }
  if (array_key_exists('nbf', $claims_assoc) && (int) $claims_assoc['nbf'] - $leeway > $now) {
    return result_err('jwt not active yet')
  }
  if (is_array($options) && array_key_exists('iss', $options)) {
    if (!array_key_exists('iss', $claims_assoc) || ('' . $claims_assoc['iss']) !== ('' . $options['iss'])) {
      return result_err('jwt issuer mismatch')
    }
  }
  if (is_array($options) && array_key_exists('aud', $options)) {
    if (!array_key_exists('aud', $claims_assoc) || ('' . $claims_assoc['aud']) !== ('' . $options['aud'])) {
      return result_err('jwt audience mismatch')
    }
  }
  return result_ok(true)
}

/// docid: phpx/jwt/verify()
/// <Function name="verify">
///   <Description>PHPX standard module function `verify` from `jwt`.</Description>
///   <ReturnType type="mixed" />
/// </Function>
export function verify($token, $secret, $options = []) {
  $parts_res = decode_parts($token)
  if (!result_is_ok($parts_res)) {
    return $parts_res
  }
  $parts = to_assoc($parts_res->value)
  $header = array_key_exists('header', $parts) ? to_assoc($parts['header']) : []
  $payload = array_key_exists('payload', $parts) ? to_assoc($parts['payload']) : []
  if (!array_key_exists('alg', $header) || strtoupper('' . $header['alg']) !== 'HS256') {
    return result_err('unsupported jwt alg')
  }
  $signing_input = array_key_exists('signing_input', $parts) ? $parts['signing_input'] : ''
  $signature_raw = array_key_exists('signature_raw', $parts) ? $parts['signature_raw'] : ''
  $expected_sig = bytes_to_string(hmac_sha256_bytes($signing_input, $secret))
  if (!secure_compare($expected_sig, $signature_raw)) {
    return result_err('invalid jwt signature')
  }
  $claims_check = validate_claims($payload, $options)
  if (!result_is_ok($claims_check)) {
    return $claims_check
  }
  return result_ok($payload)
}
