---
import { jsx, jsxs } from 'component/core'
import { renderPartialJson, isPartialRequest, Link, Hydration } from 'component/dom'
import { json_encode as encodeJson, json_decode_result } from 'encoding/json'
import { PreviewRouteSection, ForkResultSection } from '@/src/pages/repo_flows'
import { PackageStatPills, PackageVersionRows } from '@/src/pages/package_detail'
import { buildAdwaBaseUrl, buildAdwaPreviewUrl, buildAdwaPreviewUrlForRef, buildAdwaEditUrl } from '@/src/services/adwa'
import { gitApiDefaultBase, scopedReleaseDocsPath, scopedReleaseTreePath, scopedReleaseBlobPath, repoIssuesPath, repoIssueDetailPath, repoIssueCommentPath, repoPullsPath, repoPullDetailPath, repoPullCommentPath, repoResolvePath, repoForkPath } from '@/src/services/linkhash_git'
import { repoIssueCreateRoute, repoIssueCommentRoute, repoPullCreateRoute, repoPullCommentRoute, repoForkRoute, buildRepoActionRedirectPath } from '@/src/api/repo_actions'
import { meta } from '@/db/meta'
import { selectMany, selectOne, insertOne, updateWhere, deleteWhere, loadRelation, transaction, eq, ilike, isNull, andWhere, asc, desc, limit } from '@/db'
import { stats } from 'db'
import { connect as sqliteConnect, query as sqliteQuery, query_one as sqliteQueryOne, exec as sqliteExec, close as sqliteClose } from 'db/sqlite'
import { connect as mysqlConnect, query_one as mysqlQueryOne, exec as mysqlExec, close as mysqlClose } from 'db/mysql'
import { open as fsOpen, read as fsRead, close as fsClose } from 'fs'
import { len as bytesLen, to_string as bytesToString } from 'bytes'
import { get as cookieGet, set_header as cookieSetHeader, clear_header as cookieClearHeader } from 'cookies'
import { random_hex } from 'crypto'
import { connect as tcpConnect, tcp_write as tcpWrite, tcp_read as tcpRead, tcp_close as tcpClose } from 'tcp'
import { tls_upgrade, tls_write, tls_read, tls_close } from 'tls'
import { open_handle as dbOpenHandle, close as dbCloseRaw } from 'db'
import { result_is_ok, result_unwrap, result_ok, result_err } from 'core/result'
import { canonical_id as registryCanonicalId, artifact_key as registryArtifactKey } from 'registry/artifacts'

function envValue($name, $fallback = null) {
  $envBag = (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('_ENV', $GLOBALS) && is_array($GLOBALS['_ENV']))
    ? $GLOBALS['_ENV']
    : (is_array($_ENV) ? $_ENV : [])
  if (is_array($envBag) && array_key_exists($name, $envBag)) {
    $fromEnv = $envBag[$name]
    if ($fromEnv !== null && $fromEnv !== '') {
      return $fromEnv
    }
  }

  $val = getenv($name)
  if ($val !== false && $val !== null && $val !== '') {
    return $val
  }

  $serverBag = (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('_SERVER', $GLOBALS) && is_array($GLOBALS['_SERVER']))
    ? $GLOBALS['_SERVER']
    : (is_array($_SERVER) ? $_SERVER : [])
  if (is_array($serverBag) && array_key_exists($name, $serverBag)) {
    $fromServer = $serverBag[$name]
    if ($fromServer !== null && $fromServer !== '') {
      return $fromServer
    }
  }

  return $fallback
}

function parseDotEnvLine($line) {
  $raw = trim('' . $line)
  if ($raw === '' || strStartsWith($raw, '#')) {
    return null
  }
  $eq = strpos($raw, '=')
  if ($eq === false || $eq <= 0) {
    return null
  }
  $key = trim(substr($raw, 0, $eq))
  $value = trim(substr($raw, $eq + 1))
  if ($key === '') {
    return null
  }
  if ((strStartsWith($value, '"') && substr($value, -1) === '"') || (strStartsWith($value, "'") && substr($value, -1) === "'")) {
    $value = substr($value, 1, strlen($value) - 2)
  }
  return [ 'key' => $key, 'value' => $value ]
}

function loadDotEnv($path = '.env') {
  $full = '' . $path
  if (!is_file($full)) {
    return
  }
  $lines = @file($full)
  if (!is_array($lines)) {
    return
  }
  foreach ($lines as $line) {
    $pair = parseDotEnvLine($line)
    if (!is_array($pair)) {
      continue
    }
    $key = '' . $pair['key']
    $value = '' . $pair['value']
    if (!isset($GLOBALS) || !is_array($GLOBALS)) {
      continue
    }
    if (!array_key_exists('_ENV', $GLOBALS) || !is_array($GLOBALS['_ENV'])) {
      $GLOBALS['_ENV'] = []
    }
    $GLOBALS['_ENV'][$key] = $value
    if (!array_key_exists('_SERVER', $GLOBALS) || !is_array($GLOBALS['_SERVER'])) {
      $GLOBALS['_SERVER'] = []
    }
    $GLOBALS['_SERVER'][$key] = $value
  }
}

function getDbConfig() {
  return {
    host: envValue('DB_HOST', '127.0.0.1'),
    port: (int) envValue('DB_PORT', '55432'),
    database: envValue('DB_NAME', 'linkhash_registry'),
    user: envValue('DB_USER', 'postgres'),
    password: envValue('DB_PASSWORD', 'postgres')
  }
}

function getDbConfigCandidates(): array {
  $base = getDbConfig()
  $candidates = [$base]
  $hasExplicitPort = envValue('DB_PORT', '') !== ''
  if (!$hasExplicitPort) {
    $basePort = (int) rowValue($base, 'port', 55432)
    if ($basePort !== 5432) {
      $fallbackA = $base
      $fallbackA['port'] = 5432
      $candidates[] = $fallbackA
    }
    if ($basePort !== 55432) {
      $fallbackB = $base
      $fallbackB['port'] = 55432
      $candidates[] = $fallbackB
    }
  }
  return $candidates
}

function openDbHandle() {
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_db_pinned_handle', $GLOBALS)) {
    $pinned = (int) $GLOBALS['__lh_db_pinned_handle']
    if ($pinned > 0) {
      return result_ok($pinned)
    }
  }
  $errors = []
  foreach (getDbConfigCandidates() as $cfg) {
    $result = dbOpenHandle('postgres', $cfg)
    if (result_is_ok($result)) {
      if (isset($GLOBALS) && is_array($GLOBALS)) {
        $GLOBALS['__lh_db_pinned_handle'] = (int) $result->value
      }
      return $result
    }
    $errors[] = 'host=' . rowValue($cfg, 'host', '?')
      . ' port=' . ('' . rowValue($cfg, 'port', '?'))
      . ' db=' . rowValue($cfg, 'database', '?')
      . ' -> ' . ('' . $result->error)
  }
  return { ok: false, error: 'postgres connect failed across candidates: ' . implode(' | ', $errors) }
}

function dbClient($handle) {
  $m = meta()
  return { handle: (int) $handle, meta: $m, models: $m.models }
}

function clientSelectMany($client, $model, $where = null, $order = null, $limit = null, $offset = null, $includes = null) {
  return selectMany($client.handle, $client.meta, $model, $where, $order, $limit, $offset, $includes)
}

function clientSelectOne($client, $model, $where = null, $includes = null) {
  return selectOne($client.handle, $client.meta, $model, $where, $includes)
}

function clientInsertOne($client, $model, $row, $returning = false) {
  return insertOne($client.handle, $model, $row, $returning)
}

function clientUpdateWhere($client, $model, $where, $values, $returning = false) {
  return updateWhere($client.handle, $model, $where, $values, $returning)
}

function clientDeleteWhere($client, $model, $where, $returning = false) {
  return deleteWhere($client.handle, $model, $where, $returning)
}

function clientLoadRelation($client, $model, $row, $field) {
  return loadRelation($client.handle, $client.meta, $model, $row, $field)
}

function clientTransaction($client, $fn) {
  return transaction($client.handle, $fn)
}

function dbClose($handle) {
  $h = (int) $handle
  if ($h <= 0) {
    return result_ok(true)
  }
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_db_pinned_handle', $GLOBALS)) {
    $pinned = (int) $GLOBALS['__lh_db_pinned_handle']
    if ($pinned > 0 && $h === $pinned) {
      return result_ok(true)
    }
  }
  return dbCloseRaw($h)
}

function parseTimestamp($value) {
  if ($value === null) {
    return null
  }
  $str = trim('' . $value)
  if ($str === '') {
    return null
  }
  $parsed = strtotime($str)
  if ($parsed === false) {
    return null
  }
  return $parsed
}

function openCatalogFallbackSqlite() {
  return sqliteConnect({ path: 'db/linkhash.sqlite' })
}

function sqliteOrgHandle($orgId) {
  return 'org' . ('' . (int) $orgId)
}

function fetchFallbackVisiblePackageRows($limit = 25, $query = '') {
  $conn = openCatalogFallbackSqlite()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $db = $conn->value
  $max = max(1, (int) $limit)
  $term = trim('' . $query)
  if ($term === '') {
    $rowsRes = sqliteQuery(
      $db,
      "select id, org_id as orgId, name, description, latest_version as latestVersion, download_count as downloadCount, created_at as createdAt, updated_at as updatedAt
       from packages
       order by download_count desc, id desc
       limit ?",
      [$max]
    )
  } else {
    $like = '%' . strtolower($term) . '%'
    $rowsRes = sqliteQuery(
      $db,
      "select id, org_id as orgId, name, description, latest_version as latestVersion, download_count as downloadCount, created_at as createdAt, updated_at as updatedAt
       from packages
       where lower(name) like ? or lower(description) like ?
       order by download_count desc, id desc
       limit ?",
      [$like, $like, $max]
    )
  }
  sqliteClose($db)
  if (!result_is_ok($rowsRes)) {
    return { ok: false, error: $rowsRes->error }
  }
  $rows = rowsFromQueryResult($rowsRes)
  $normalized = []
  foreach ($rows as $row) {
    $row['orgHandle'] = sqliteOrgHandle(rowValue($row, 'orgId', rowValue($row, 'org_id', 0)))
    $row['visibility'] = 'public'
    $row['canonicalId'] = ''
    $normalized[] = $row
  }
  return { ok: true, rows: $normalized, source: 'sqlite' }
}

function fetchFallbackRegistryStatsResult() {
  $conn = openCatalogFallbackSqlite()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $db = $conn->value
  $row = sqliteQueryOne(
    $db,
    "select
      (select count(*) from packages) as packageCount,
      (select count(distinct org_id) from packages) as orgCount,
      0 as versionCount,
      (select coalesce(sum(download_count), 0) from packages) as totalDownloads",
    []
  )
  sqliteClose($db)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  return { ok: true, stats: [
    'packageCount' => (int) rowValue($row->value, 'packageCount', 0),
    'orgCount' => (int) rowValue($row->value, 'orgCount', 0),
    'versionCount' => (int) rowValue($row->value, 'versionCount', 0),
    'totalDownloads' => (int) rowValue($row->value, 'totalDownloads', 0)
  ], source: 'sqlite' }
}

function rowsFromQueryResult($result): array {
  if (!result_is_ok($result)) {
    return []
  }

  $value = $result->value
  if (is_array($value) && array_key_exists('rows', $value) && is_array($value['rows'])) {
    return $value['rows']
  }

  if (is_object($value) && isset($value->rows) && is_array($value->rows)) {
    return $value->rows
  }

  return []
}

function rowValue($row, $key, $fallback = null) {
  if (is_array($row) && array_key_exists($key, $row)) {
    return $row[$key]
  }
  if (is_object($row)) {
    $obj = get_object_vars($row)
    if (is_array($obj) && array_key_exists($key, $obj)) {
      return $obj[$key]
    }
  }

  $k = '' . $key
  $lower = strtolower($k)
  $snake = strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $k))
  if (is_array($row)) {
    if (array_key_exists($lower, $row)) {
      return $row[$lower]
    }
    if (array_key_exists($snake, $row)) {
      return $row[$snake]
    }
    $noscore = str_replace('_', '', $snake)
    if (array_key_exists($noscore, $row)) {
      return $row[$noscore]
    }
  }
  if (is_object($row)) {
    $obj = get_object_vars($row)
    if (is_array($obj) && array_key_exists($lower, $obj)) {
      return $obj[$lower]
    }
    if (is_array($obj) && array_key_exists($snake, $obj)) {
      return $obj[$snake]
    }
    $noscore = str_replace('_', '', $snake)
    if (is_array($obj) && array_key_exists($noscore, $obj)) {
      return $obj[$noscore]
    }
  }
  return $fallback
}

function resultObject($res) {
  if (result_is_ok($res)) {
    return { ok: true, value: $res->value }
  }
  return { ok: false, error: $res->error }
}

function sqlQuote($value) {
  $s = '' . $value
  return str_replace("'", "''", $s)
}

function probePostgres() {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $handle = $conn->value
  $client = dbClient($handle)
  $check = clientSelectMany($client, $client.models.RuntimeProbeLog, null, null, limit(1))
  dbClose($handle)
  if (!result_is_ok($check)) {
    return { ok: false, error: $check->error }
  }
  return { ok: true, row: { now: date('c') } }
}

function probeSqlite() {
  $conn = sqliteConnect({ path: 'db/linkhash.sqlite' })
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $handle = $conn->value
  $row = sqliteQueryOne($handle, 'select sqlite_version() as version', [])
  sqliteClose($handle)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  return { ok: true, row: $row->value }
}

function probeMySql() {
  $conn = mysqlConnect({
    host: envValue('MYSQL_HOST', '127.0.0.1'),
    port: (int) envValue('MYSQL_PORT', '3306'),
    database: envValue('MYSQL_DB', 'mysql'),
    user: envValue('MYSQL_USER', 'root'),
    password: envValue('MYSQL_PASSWORD', '')
  })
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $handle = $conn->value
  $row = mysqlQueryOne($handle, 'select 1 as ok', [])
  mysqlClose($handle)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  return { ok: true, row: $row->value }
}

function probeFsBytes() {
  $opened = fsOpen('db/linkhash.sqlite', 'r')
  if (!result_is_ok($opened)) {
    return { ok: false, error: $opened->error }
  }
  $handle = $opened->value
  $chunk = fsRead($handle, 16)
  fsClose($handle)
  if (!result_is_ok($chunk)) {
    return { ok: false, error: $chunk->error }
  }
  $bytes = $chunk->value
  return {
    ok: true,
    byte_len: bytesLen($bytes),
    preview: bytesToString($bytes)
  }
}

function collectRuntimeChecks() {
  return {
    postgres: probePostgres(),
    sqlite: probeSqlite(),
    mysql: probeMySql(),
    fs_bytes: probeFsBytes(),
    db_stats: resultObject(stats())
  }
}

function ensureProbeTable($target, $handle) {
  if ($target === 'postgres') {
    return result_ok(true)
  }
  if ($target === 'sqlite') {
    $sql = 'create table if not exists runtime_probe_log (driver text, note text, created_at text)'
    return sqliteExec($handle, $sql, [])
  }
  if ($target === 'mysql') {
    $sql = 'create table if not exists runtime_probe_log (driver text, note text, created_at text)'
    return mysqlExec($handle, $sql, [])
  }
  return { ok: false, error: 'unknown driver' }
}

function insertProbeRow($target, $handle, $note) {
  $now = date('c')
  if ($target === 'postgres') {
    $client = dbClient($handle)
    return clientInsertOne($client, $client.models.RuntimeProbeLog, {
      driver: '' . $target,
      note: '' . $note,
      created_at: '' . $now
    }, false)
  }
  if ($target === 'sqlite') {
    $sql = 'insert into runtime_probe_log (driver, note, created_at) values (?, ?, ?)'
    return sqliteExec($handle, $sql, [$target, $note, $now])
  }
  if ($target === 'mysql') {
    $sql = 'insert into runtime_probe_log (driver, note, created_at) values (?, ?, ?)'
    return mysqlExec($handle, $sql, [$target, $note, $now])
  }
  return { ok: false, error: 'unknown driver' }
}

function countProbeRows($target, $handle) {
  if ($target === 'postgres') {
    $client = dbClient($handle)
    $rows = clientSelectMany($client, $client.models.RuntimeProbeLog)
    if (!result_is_ok($rows)) {
      return $rows
    }
    return result_ok({ total: count($rows->value) })
  }
  if ($target === 'sqlite') {
    $sql = 'select count(*) as total from runtime_probe_log'
    return sqliteQueryOne($handle, $sql, [])
  }
  if ($target === 'mysql') {
    $sql = 'select count(*) as total from runtime_probe_log'
    return mysqlQueryOne($handle, $sql, [])
  }
  return { ok: false, error: 'unknown driver' }
}

function runtimeWriteProbe($target) {
  if (!is_string($target) || $target === '') {
    return { ok: false, error: 'target is required' }
  }

  if ($target === 'postgres') {
    $conn = openDbHandle()
    if (!result_is_ok($conn)) {
      return { ok: false, error: $conn->error }
    }
    $handle = $conn->value
    $mk = ensureProbeTable($target, $handle)
    if (!result_is_ok($mk)) {
      dbClose($handle)
      return { ok: false, error: $mk->error }
    }
    $ins = insertProbeRow($target, $handle, 'runtime write probe')
    if (!result_is_ok($ins)) {
      dbClose($handle)
      return { ok: false, error: $ins->error }
    }
    $row = countProbeRows($target, $handle)
    dbClose($handle)
    if (!result_is_ok($row)) {
      return { ok: false, error: $row->error }
    }
    return { ok: true, target: $target, count: rowValue($row->value, 'total', 0) }
  }

  if ($target === 'sqlite') {
    $conn = sqliteConnect({ path: 'db/linkhash.sqlite' })
    if (!result_is_ok($conn)) {
      return { ok: false, error: $conn->error }
    }
    $handle = $conn->value
    $mk = ensureProbeTable($target, $handle)
    if (!result_is_ok($mk)) {
      sqliteClose($handle)
      return { ok: false, error: $mk->error }
    }
    $ins = insertProbeRow($target, $handle, 'runtime write probe')
    if (!result_is_ok($ins)) {
      sqliteClose($handle)
      return { ok: false, error: $ins->error }
    }
    $row = countProbeRows($target, $handle)
    sqliteClose($handle)
    if (!result_is_ok($row)) {
      return { ok: false, error: $row->error }
    }
    return { ok: true, target: $target, count: rowValue($row->value, 'total', 0) }
  }

  if ($target === 'mysql') {
    $conn = mysqlConnect({
      host: envValue('MYSQL_HOST', '127.0.0.1'),
      port: (int) envValue('MYSQL_PORT', '3306'),
      database: envValue('MYSQL_DB', 'mysql'),
      user: envValue('MYSQL_USER', 'root'),
      password: envValue('MYSQL_PASSWORD', '')
    })
    if (!result_is_ok($conn)) {
      return { ok: false, error: $conn->error }
    }
    $handle = $conn->value
    $mk = ensureProbeTable($target, $handle)
    if (!result_is_ok($mk)) {
      mysqlClose($handle)
      return { ok: false, error: $mk->error }
    }
    $ins = insertProbeRow($target, $handle, 'runtime write probe')
    if (!result_is_ok($ins)) {
      mysqlClose($handle)
      return { ok: false, error: $ins->error }
    }
    $row = countProbeRows($target, $handle)
    mysqlClose($handle)
    if (!result_is_ok($row)) {
      return { ok: false, error: $row->error }
    }
    return { ok: true, target: $target, count: rowValue($row->value, 'total', 0) }
  }

  return { ok: false, error: 'unsupported target: ' . $target }
}

function Layout($props) {
  return <div class="min-h-screen bg-gray-50 text-gray-900">
    <nav class="bg-white shadow-sm border-b">
      <div class="mx-auto flex h-16 max-w-6xl items-center justify-between px-6">
        <div class="flex items-center gap-3">
          <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-blue-600 text-white font-semibold">L</div>
          <div>
            <div class="text-lg font-bold text-blue-600">linkha.sh</div>
            <div class="text-xs text-gray-500">PHPX package registry</div>
          </div>
        </div>
        <div class="flex items-center gap-4 text-sm">
          <Link to="/" layout="registry" class="text-blue-600 hover:text-blue-800">Home</Link>
          <Link to="/account" layout="registry" class="text-gray-600 hover:text-blue-600">Account</Link>
          <Link to="/playground" layout="registry" class="text-gray-600 hover:text-blue-600">Playground</Link>
          <Link to="/runtime" layout="registry" class="text-gray-600 hover:text-blue-600">Runtime Lab</Link>
          <Link to="/hmr-demo" layout="registry" class="text-gray-600 hover:text-blue-600">HMR Demo</Link>
          <a class="text-gray-600 hover:text-blue-600" href="#features">Features</a>
          <a class="text-gray-600 hover:text-blue-600" href="#quickstart">Quick Start</a>
        </div>
      </div>
    </nav>
    <main class="mx-auto max-w-6xl px-6 py-10">
      {$props.children}
    </main>
    <footer class="border-t border-gray-200 bg-white">
      <div class="mx-auto flex max-w-6xl items-center justify-between px-6 py-6 text-sm text-gray-500">
        <span>Built with PHPX</span>
        <span>Registry API v0.1</span>
      </div>
    </footer>
  </div>
}

function Hero() {
  return <section class="rounded-2xl bg-white p-10 shadow-sm">
    <div class="grid gap-10 md:grid-cols-[1.2fr_0.8fr]">
      <div>
        <h1 class="text-4xl font-bold text-gray-900">The PHPX Package Registry</h1>
        <p class="mt-4 text-lg text-gray-600">
          Discover, publish, and share PHPX packages. Built with PHPX, for PHPX.
        </p>
        <div class="mt-6 flex flex-wrap gap-3">
          <a href="/packages" class="rounded-lg bg-blue-600 px-5 py-2 text-sm font-semibold text-white hover:bg-blue-700">Browse packages</a>
          <a href="/publish" class="rounded-lg border border-gray-300 px-5 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50">Publish your first</a>
        </div>
      </div>
      <div class="rounded-xl bg-gray-900 p-6 text-sm text-gray-100">
        <div class="text-xs uppercase tracking-wide text-gray-400">install</div>
        <pre class="mt-3 whitespace-pre-wrap">deka install @linkhash/ui</pre>
        <div class="mt-6 text-xs uppercase tracking-wide text-gray-400">publish</div>
        <pre class="mt-3 whitespace-pre-wrap">deka publish</pre>
      </div>
    </div>
  </section>
}

function FeatureCard($props) {
  return <div class="rounded-xl border border-gray-200 bg-white p-6 shadow-sm hover:shadow-md transition-shadow">
    <div class="text-lg font-semibold text-gray-900">{$props.title}</div>
    <div class="mt-2 text-sm text-gray-600">{$props.copy}</div>
  </div>
}

function Features() {
  return <section id="features" class="mt-10">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Features</div>
    <h2 class="mt-2 text-2xl font-bold text-gray-900">Everything you need to ship PHPX</h2>
    <div class="mt-6 grid gap-6 md:grid-cols-3">
      <FeatureCard title="Discover" copy="Find PHPX packages with clear metadata and sharp docs." />
      <FeatureCard title="Publish" copy="Ship new releases in seconds with a frictionless flow." />
      <FeatureCard title="Playground" copy="Try packages in a browser-first PHPX sandbox." />
    </div>
  </section>
}

function QuickStart() {
  return <section id="quickstart" class="mt-12 rounded-2xl bg-white p-8 shadow-sm">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Quick Start</div>
    <h2 class="mt-2 text-2xl font-bold text-gray-900">Get going in minutes</h2>
    <div class="mt-6 grid gap-6 md:grid-cols-2">
      <div>
        <div class="text-sm font-semibold text-gray-800">Install a package</div>
        <div class="mt-2 rounded-lg bg-gray-900 px-4 py-3 font-mono text-sm text-gray-100">deka install @org/package</div>
      </div>
      <div>
        <div class="text-sm font-semibold text-gray-800">Publish your package</div>
        <div class="mt-2 rounded-lg bg-gray-900 px-4 py-3 font-mono text-sm text-gray-100">deka publish</div>
      </div>
    </div>
  </section>
}

function fetchTopPackages($limit = 6, $userId = 0): array {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return []
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  $rowsRes = fetchVisiblePackageRows($handle, $limit, '', $userId)
  dbClose($handle)
  if (!rowValue($rowsRes, 'ok', false)) {
    return []
  }
  $rows = rowValue($rowsRes, 'rows', [])
  return is_array($rows) ? $rows : []
}

function normalizePackage($pkg) {
  $orgHandle = '' . rowValue($pkg, 'orgHandle', rowValue($pkg, 'org_handle', ''))
  $name = '' . rowValue($pkg, 'name', '')
  $latestVersion = rowValue($pkg, 'latestVersion', rowValue($pkg, 'latest_version', 'n/a'))
  $canonicalId = '' . rowValue($pkg, 'canonicalId', rowValue($pkg, 'canonical_id', ''))
  return {
    id: rowValue($pkg, 'id', null),
    orgId: rowValue($pkg, 'orgId', rowValue($pkg, 'org_id', null)),
    orgHandle: $orgHandle,
    name: $name,
    description: rowValue($pkg, 'description', ''),
    latestVersion: $latestVersion,
    downloadCount: rowValue($pkg, 'downloadCount', rowValue($pkg, 'download_count', 0)),
    canonicalId: $canonicalId,
    packageCoord: ($orgHandle !== '' && $name !== '') ? ('@' . $orgHandle . '/' . $name) : null,
    packageVersionCoord: ($orgHandle !== '' && $name !== '' && ('' . $latestVersion) !== '') ? ('@' . $orgHandle . '/' . $name . '@' . $latestVersion) : null,
    visibility: rowValue($pkg, 'visibility', 'public'),
    createdAt: rowValue($pkg, 'createdAt', rowValue($pkg, 'created_at', null)),
    updatedAt: rowValue($pkg, 'updatedAt', rowValue($pkg, 'updated_at', null))
  }
}

function TopPackages($props) {
  if (!is_array($props->packages) || count($props->packages) === 0) {
    return <section class="mt-12 rounded-2xl border border-amber-200 bg-amber-50 p-8">
      <div class="text-sm font-semibold uppercase tracking-wide text-amber-700">Top Packages</div>
      <div class="mt-2 text-sm text-amber-800">No package data available yet.</div>
    </section>
  }

  $cards = []
  foreach ($props->packages as $pkg) {
    $name = rowValue($pkg, 'name', 'unknown')
    $description = rowValue($pkg, 'description', 'No description yet')
    $downloads = rowValue($pkg, 'downloadCount', 0)
    $latestVersion = rowValue($pkg, 'latestVersion', 'n/a')
    $orgHandle = '' . rowValue($pkg, 'orgHandle', rowValue($pkg, 'org_handle', ''))
    $packageHref = ($orgHandle !== '' && ('' . $name) !== '')
      ? ('/package/' . rawurlencode($orgHandle) . '/' . rawurlencode('' . $name))
      : ''

    $cards[] = <article class="rounded-xl border border-gray-200 p-4">
      <div class="flex items-start justify-between gap-4">
        <div>
          {$packageHref !== ''
            ? <a class="text-base font-semibold text-blue-700 hover:text-blue-900" href={$packageHref}>{$name}</a>
            : <div class="text-base font-semibold text-gray-900">{$name}</div>}
          <div class="mt-1 text-sm text-gray-600">{$description}</div>
        </div>
        <div class="rounded-md bg-blue-50 px-3 py-1 text-xs font-semibold text-blue-700">{(string) $downloads . ' downloads'}</div>
      </div>
      <div class="mt-3 text-xs text-gray-500">{'Latest version: ' . $latestVersion}</div>
    </article>
  }

  return <section class="mt-12 rounded-2xl bg-white p-8 shadow-sm">
    <div class="flex items-center justify-between">
      <div>
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Top Packages</div>
        <h2 class="mt-2 text-2xl font-bold text-gray-900">Live data from Postgres</h2>
      </div>
      <a href="/api/packages" class="text-sm font-semibold text-blue-600 hover:text-blue-800">JSON API</a>
    </div>
    <div class="mt-6 grid gap-4">
      {$cards}
    </div>
  </section>
}

function FeaturedPackages($props) {
  $packages = is_array($props->packages) ? $props->packages : []
  if (count($packages) === 0) {
    return <section class="mt-10 rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Featured</div>
      <h2 class="mt-2 text-2xl font-bold text-gray-900">Featured packages coming soon</h2>
    </section>
  }
  $cards = []
  $limit = min(3, count($packages))
  for ($i = 0; $i < $limit; $i = $i + 1) {
    $pkg = $packages[$i]
    $name = rowValue($pkg, 'name', '')
    $desc = rowValue($pkg, 'description', '')
    $orgHandle = '' . rowValue($pkg, 'orgHandle', rowValue($pkg, 'org_handle', ''))
    $packageHref = ($orgHandle !== '' && ('' . $name) !== '')
      ? ('/package/' . rawurlencode($orgHandle) . '/' . rawurlencode('' . $name))
      : ''
    $cards[] = <article class="rounded-xl border border-blue-100 bg-blue-50 p-4">
      <div class="text-sm font-semibold text-blue-700">{'Featured #' . ($i + 1)}</div>
      {$packageHref !== ''
        ? <a class="mt-1 block text-lg font-bold text-blue-800 hover:text-blue-900" href={$packageHref}>{$name}</a>
        : <div class="mt-1 text-lg font-bold text-gray-900">{$name}</div>}
      <p class="mt-2 text-sm text-gray-700">{$desc}</p>
    </article>
  }
  return <section class="mt-10 rounded-2xl bg-white p-8 shadow-sm">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Featured</div>
    <h2 class="mt-2 text-2xl font-bold text-gray-900">Popular packages this week</h2>
    <div class="mt-6 grid gap-4 md:grid-cols-3">
      {$cards}
    </div>
  </section>
}

function RuntimeStats($props) {
  if (!is_array($props->stats)) {
    return <section class="mt-8 rounded-2xl border border-gray-200 bg-white p-6 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Runtime Stats</div>
      <div class="mt-2 text-sm text-gray-600">Stats unavailable.</div>
    </section>
  }

  $active = array_key_exists('active_handles', $props->stats) ? $props->stats['active_handles'] : 0
  $byDriver = array_key_exists('handles_by_driver', $props->stats) ? $props->stats['handles_by_driver'] : []
  $metrics = array_key_exists('metrics', $props->stats) ? $props->stats['metrics'] : []
  $queryPostgres = is_array($metrics) && array_key_exists('query:postgres', $metrics) ? $metrics['query:postgres'] : []
  $queryCalls = is_array($queryPostgres) && array_key_exists('calls', $queryPostgres) ? $queryPostgres['calls'] : 0
  $queryAvgMs = is_array($queryPostgres) && array_key_exists('avg_ms', $queryPostgres) ? $queryPostgres['avg_ms'] : 0

  return <section class="mt-8 rounded-2xl border border-blue-100 bg-blue-50 p-6">
    <div class="flex items-center justify-between gap-4">
      <div>
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-700">Runtime Stats</div>
        <div class="mt-1 text-sm text-blue-900">Live host bridge metrics from `db.stats()`.</div>
      </div>
      <a href="/api/db-stats" class="text-sm font-semibold text-blue-700 hover:text-blue-900">JSON</a>
    </div>
    <div class="mt-4 grid gap-3 md:grid-cols-3">
      <div class="rounded-lg bg-white p-3">
        <div class="text-xs text-gray-500">Active Handles</div>
        <div class="mt-1 text-xl font-bold text-gray-900">{(string) $active}</div>
      </div>
      <div class="rounded-lg bg-white p-3">
        <div class="text-xs text-gray-500">Postgres Query Calls</div>
        <div class="mt-1 text-xl font-bold text-gray-900">{(string) $queryCalls}</div>
      </div>
      <div class="rounded-lg bg-white p-3">
        <div class="text-xs text-gray-500">Postgres Query Avg (ms)</div>
        <div class="mt-1 text-xl font-bold text-gray-900">{(string) $queryAvgMs}</div>
      </div>
    </div>
    <div class="mt-3 text-xs text-gray-500">{'handles_by_driver: ' . encodeJson($byDriver)}</div>
  </section>
}

function fetchRegistryStatsResult() {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $db = $conn->value
  $client = dbClient($db)
  $packagesRes = clientSelectMany($client, $client.models.Package)
  $orgsRes = clientSelectMany($client, $client.models.LhOrg)
  $versionsRes = clientSelectMany($client, $client.models.PackageVersion)
  dbClose($db)
  if (!result_is_ok($packagesRes)) {
    return { ok: false, error: $packagesRes->error }
  }
  if (!result_is_ok($orgsRes)) {
    return { ok: false, error: $orgsRes->error }
  }
  if (!result_is_ok($versionsRes)) {
    return { ok: false, error: $versionsRes->error }
  }
  $downloadRows = $packagesRes->value
  $totalDownloads = 0
  foreach ($downloadRows as $drow) {
    $totalDownloads += (int) rowValue($drow, 'downloadCount', rowValue($drow, 'download_count', 0))
  }
  return { ok: true, stats: [
    'packageCount' => count($packagesRes->value),
    'orgCount' => count($orgsRes->value),
    'versionCount' => count($versionsRes->value),
    'totalDownloads' => (int) $totalDownloads
  ], source: 'postgres', degraded: false, warning: null }
}

function fetchRegistryStats() {
  $res = fetchRegistryStatsResult()
  if (!rowValue($res, 'ok', false)) {
    return []
  }
  return rowValue($res, 'stats', [])
}

function RegistryStatsPanel($props) {
  $stats = is_array($props->stats) ? $props->stats : []
  $packageCount = array_key_exists('packageCount', $stats) ? $stats['packageCount'] : 0
  $orgCount = array_key_exists('orgCount', $stats) ? $stats['orgCount'] : 0
  $versionCount = array_key_exists('versionCount', $stats) ? $stats['versionCount'] : 0
  $totalDownloads = array_key_exists('totalDownloads', $stats) ? $stats['totalDownloads'] : 0
  return <section class="mt-8 rounded-2xl bg-white p-8 shadow-sm">
    <div class="flex items-center justify-between gap-4">
      <div>
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Registry Stats</div>
        <h2 class="mt-2 text-2xl font-bold text-gray-900">Current package ecosystem snapshot</h2>
      </div>
      <a href="/api/stats/packages" class="text-sm font-semibold text-blue-600 hover:text-blue-800">JSON</a>
    </div>
    <div class="mt-6 grid gap-4 md:grid-cols-4">
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Packages</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $packageCount}</div></div>
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Organizations</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $orgCount}</div></div>
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Versions</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $versionCount}</div></div>
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Downloads</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $totalDownloads}</div></div>
    </div>
  </section>
}

function Home($props) {
  return <Layout>
    <Hero />
    <Features />
    <QuickStart />
    <RegistryStatsPanel stats={$props->registryStats} />
    <FeaturedPackages packages={$props->packages} />
    <TopPackages packages={$props->packages} />
    <RuntimeStats stats={$props->stats} />
  </Layout>
}

function RuntimeLab($props) {
  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="flex items-center justify-between gap-4">
        <div>
          <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Runtime Lab</div>
          <h2 class="mt-2 text-2xl font-bold text-gray-900">Live feature checks</h2>
          <p class="mt-2 text-sm text-gray-600">Exercises component hydration, bridge-backed db modules, and fs/bytes.</p>
        </div>
        <a href="/api/runtime-checks" class="rounded-lg border border-gray-300 px-4 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50">JSON checks</a>
      </div>
      <div class="mt-6 rounded-xl bg-gray-900 p-4 text-xs text-gray-100 whitespace-pre-wrap">{encodeJson($props->checks)}</div>
    </section>
    <section class="mt-8 rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Write Path Probes</div>
      <h3 class="mt-2 text-xl font-bold text-gray-900">Run insert/count probes per driver</h3>
      <p class="mt-2 text-sm text-gray-600">Each action creates `runtime_probe_log` if needed, inserts one row, then returns total count.</p>
      <div class="mt-5 flex flex-wrap gap-3">
        <a class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" href="/api/runtime-action?target=postgres&op=write_probe">Postgres write probe</a>
        <a class="rounded-lg bg-emerald-600 px-4 py-2 text-sm font-semibold text-white hover:bg-emerald-700" href="/api/runtime-action?target=mysql&op=write_probe">MySQL write probe</a>
        <a class="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white hover:bg-indigo-700" href="/api/runtime-action?target=sqlite&op=write_probe">SQLite write probe</a>
      </div>
    </section>
  </Layout>
}

const HMR_DEMO_MESSAGE = 'Hot component message: v8'

function HmrInputCard() {
  return <section class="rounded-2xl border border-emerald-200 bg-emerald-50 p-6" dataDekaId="hmr-input-card">
    <div class="text-sm font-semibold uppercase tracking-wide text-emerald-700">State Check</div>
    <h3 class="mt-2 text-xl font-bold text-gray-900">Type in this input, then edit component code</h3>
    <p class="mt-2 text-sm text-gray-700">If HMR patching is granular, your typed value and cursor selection remain after save.</p>
    <input id="hmr-name" name="hmr-name" class="mt-4 w-full rounded-lg border border-gray-300 px-3 py-2 text-sm" placeholder="Type here, then save code changes" dataDekaId="hmr-input" />
  </section>
}

function HmrHotCard() {
  return <section class="rounded-2xl border border-blue-200 bg-blue-50 p-6" dataDekaId="hmr-hot-card">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-700">Hot Component</div>
    <h3 class="mt-2 text-xl font-bold text-gray-900">This section should patch on save</h3>
    <p id="hmr-hot-message" class="mt-2 text-sm text-blue-900" dataDekaId="hmr-hot-message">{HMR_DEMO_MESSAGE}</p>
    <p class="mt-2 text-xs text-blue-700">Edit `HMR_DEMO_MESSAGE` in `main.phpx` and save.</p>
  </section>
}

function HmrDemo() {
  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">HMR Demo</div>
      <h2 class="mt-2 text-2xl font-bold text-gray-900">Component patch + input state preservation</h2>
      <ol class="mt-3 list-decimal pl-5 text-sm text-gray-700 space-y-1">
        <li>Type text into the input below</li>
        <li>Change `HMR_DEMO_MESSAGE` in `main.phpx` from `v1` to `v2`</li>
        <li>Save and watch only the hot component content update</li>
      </ol>
      <div class="mt-6 grid gap-6">
        <HmrInputCard />
        <HmrHotCard />
      </div>
    </section>
  </Layout>
}

function apiPackages() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $me = authCurrentUser()
  $userId = $me['ok'] ? (int) rowValue($me['user'], 'id', 0) : 0
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    $data = {
      packages: [],
      total: 0,
      registry: 'linkha.sh',
      version: '0.1.0',
      ok: false,
      error: $conn->error
    }
    echo jsonReply($data)
    return
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  $rowsRes = fetchVisiblePackageRows($handle, 25, '', $userId)
  dbClose($handle)
  if (!rowValue($rowsRes, 'ok', false)) {
    echo jsonReply({
      packages: [],
      total: 0,
      registry: 'linkha.sh',
      version: '0.1.0',
      ok: false,
      error: rowValue($rowsRes, 'error', 'query failed')
    })
    return
  }
  $rows = rowValue($rowsRes, 'rows', [])
  $packages = []
  foreach ($rows as $row) {
    $packages[] = normalizePackage($row)
  }

  $data = {
    packages: $packages,
    total: count($packages),
    registry: 'linkha.sh',
    version: '0.1.0',
    ok: true
  }
  echo jsonReply($data)
}

function apiSearch() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $query = isset($_GET['q']) ? $_GET['q'] : ''
  $me = authCurrentUser()
  $userId = $me['ok'] ? (int) rowValue($me['user'], 'id', 0) : 0
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    $data = {
      query: $query,
      results: [],
      ok: false,
      error: $conn->error
    }
    echo jsonReply($data)
    return
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  $rowsRes = fetchVisiblePackageRows($handle, 50, $query, $userId)
  dbClose($handle)
  if (!rowValue($rowsRes, 'ok', false)) {
    echo jsonReply({
      query: $query,
      results: [],
      total: 0,
      ok: false,
      error: rowValue($rowsRes, 'error', 'query failed')
    })
    return
  }
  $rows = rowValue($rowsRes, 'rows', [])
  $results = []
  foreach ($rows as $row) {
    $results[] = normalizePackage($row)
  }

  $data = {
    query: $query,
    results: $results,
    total: count($results),
    ok: true
  }
  echo jsonReply($data)
}

function apiDbStats() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $res = stats()
  if (!result_is_ok($res)) {
    echo jsonReply({
      ok: false,
      error: $res->error
    })
    return
  }
  echo jsonReply({
    ok: true,
    stats: $res->value
  })
}

function apiPackageStats() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $statsRes = fetchRegistryStatsResult()
  if (!rowValue($statsRes, 'ok', false)) {
    echo jsonReply({ ok: false, error: rowValue($statsRes, 'error', 'stats unavailable') })
    return
  }
  echo jsonReply({
    ok: true,
    stats: rowValue($statsRes, 'stats', []),
    source: rowValue($statsRes, 'source', 'postgres'),
    degraded: rowValue($statsRes, 'degraded', false),
    warning: rowValue($statsRes, 'warning', null)
  })
}

function apiRuntimeChecks() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  echo jsonReply({
    ok: true,
    checks: collectRuntimeChecks()
  })
}

function apiRuntimeAction() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply({ ok: false, error: $auth['error'] })
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply({ ok: false, error: $csrf['error'] })
    return
  }
  $target = queryValue('target', '')
  $op = queryValue('op', '')
  if ($op !== 'write_probe') {
    echo jsonReply({ ok: false, error: 'unsupported op', op: $op })
    return
  }
  $result = runtimeWriteProbe($target)
  echo jsonReply($result)
}

function apiRegistryIdentity() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')

  $handle = '' . queryValue('handle', 'samifou.ad')
  $name = '' . queryValue('name', 'demo-package')
  $version = '' . queryValue('version', '0.1.0')
  $lockHash = '' . queryValue('lock', 'dev')

  echo jsonReply({
    ok: true,
    handle: $handle,
    name: $name,
    version: $version,
    lock_hash: $lockHash,
    canonical_id: registryCanonicalId($handle, $name, $version, $lockHash),
    artifact_key: registryArtifactKey($handle, $name, $version, $lockHash)
  })
}

function requestData() {
  if (is_array($_POST) && count($_POST) > 0) {
    return $_POST
  }
  if (is_array($_GET) && count($_GET) > 0) {
    return $_GET
  }
  return []
}

function queryValue($key, $fallback = null) {
  if (is_array($_GET) && array_key_exists($key, $_GET)) {
    return $_GET[$key]
  }
  if (is_array($_SERVER) && array_key_exists('REQUEST_URI', $_SERVER)) {
    $rawUri = '' . $_SERVER['REQUEST_URI']
    $pos = strpos($rawUri, '?')
    if ($pos !== false) {
      $qs = substr($rawUri, $pos + 1)
      if ($qs !== '') {
        $pairs = explode('&', $qs)
        foreach ($pairs as $pair) {
          if ($pair === '') {
            continue
          }
          $eqPos = strpos($pair, '=')
          $kRaw = $eqPos === false ? $pair : substr($pair, 0, $eqPos)
          $vRaw = $eqPos === false ? '' : substr($pair, $eqPos + 1)
          $k = urldecode('' . $kRaw)
          if ($k !== '' . $key) {
            continue
          }
          $v = urldecode('' . $vRaw)
          return $v
        }
      }
    }
  }
  return $fallback
}

function strStartsWith($value, $prefix) {
  $value = '' . $value
  $prefix = '' . $prefix
  if (strlen($prefix) > strlen($value)) {
    return false
  }
  return substr($value, 0, strlen($prefix)) === $prefix
}

function oauthB64Url($raw) {
  $b64 = base64_encode($raw)
  $out = str_replace('+', '-', $b64)
  $out = str_replace('/', '_', $out)
  return rtrim($out, '=')
}

function stableDigestHex($value, $targetLen = 64) {
  $s = '' . $value
  $h1 = 5381
  $h2 = 52711
  $n = strlen($s)
  for ($i = 0; $i < $n; $i = $i + 1) {
    $c = ord(substr($s, $i, 1))
    $h1 = (($h1 * 33) + $c) % 2147483647
    $h2 = (($h2 * 131) + $c + $i) % 2147483629
  }
  $hex = strtolower(dechex($h1) . dechex($h2) . dechex($n))
  while (strlen($hex) < (int) $targetLen) {
    $h1 = (($h1 * 33) + $h2 + $n) % 2147483647
    $h2 = (($h2 * 131) + $h1 + $n) % 2147483629
    $hex = $hex . strtolower(dechex($h1) . dechex($h2))
  }
  return substr($hex, 0, (int) $targetLen)
}

function sha256Raw($value) {
  if (function_exists('hash')) {
    return hash('sha256', '' . $value, true)
  }
  $hex = stableDigestHex($value, 64)
  if (function_exists('hex2bin')) {
    $raw = hex2bin($hex)
    if ($raw !== false) {
      return $raw
    }
  }
  if (function_exists('pack')) {
    return pack('H*', $hex)
  }
  return $hex
}

function oauthPkceChallenge($verifier) {
  $rawHash = sha256Raw($verifier)
  return oauthB64Url($rawHash)
}

function parseUrlParts($url) {
  $raw = '' . $url
  if ($raw === '') {
    return null
  }
  $parts = parse_url($raw)
  if (!is_array($parts)) {
    return null
  }
  if (!array_key_exists('scheme', $parts) || !array_key_exists('host', $parts)) {
    return null
  }
  $scheme = strtolower('' . $parts['scheme'])
  $host = '' . $parts['host']
  $port = array_key_exists('port', $parts) ? (int) $parts['port'] : ($scheme === 'https' ? 443 : 80)
  $path = array_key_exists('path', $parts) ? ('' . $parts['path']) : '/'
  if ($path === '') {
    $path = '/'
  }
  if (array_key_exists('query', $parts) && ('' . $parts['query']) !== '') {
    $path = $path . '?' . $parts['query']
  }
  return {
    scheme: $scheme,
    host: $host,
    port: $port,
    path: $path
  }
}

function parseHttpHeaders($rawHeaders) {
  $normalized = str_replace("\r\n", "\n", '' . $rawHeaders)
  $lines = explode("\n", $normalized)
  $statusLine = count($lines) > 0 ? ('' . $lines[0]) : ''
  $status = 0
  if (preg_match('/^HTTP\/[0-9.]+\s+([0-9]{3})/i', $statusLine, $m)) {
    $status = (int) $m[1]
  }
  $headers = []
  for ($i = 1; $i < count($lines); $i = $i + 1) {
    $line = '' . $lines[$i]
    if ($line === '') {
      continue
    }
    $pos = strpos($line, ':')
    if ($pos === false) {
      continue
    }
    $name = strtolower(trim(substr($line, 0, $pos)))
    $value = trim(substr($line, $pos + 1))
    $headers[$name] = $value
  }
  return { status: $status, headers: $headers }
}

function decodeChunkedBody($chunked) {
  $data = '' . $chunked
  $out = ''
  while (true) {
    $linePos = strpos($data, "\r\n")
    if ($linePos === false) {
      break
    }
    $lenLine = trim(substr($data, 0, $linePos))
    $data = substr($data, $linePos + 2)
    if ($lenLine === '') {
      continue
    }
    $semi = strpos($lenLine, ';')
    if ($semi !== false) {
      $lenLine = substr($lenLine, 0, $semi)
    }
    $len = hexdec($lenLine)
    if (!is_int($len) && !is_float($len)) {
      break
    }
    $len = (int) $len
    if ($len <= 0) {
      break
    }
    if (strlen($data) < $len) {
      break
    }
    $out = $out . substr($data, 0, $len)
    $data = substr($data, $len)
    if (strStartsWith($data, "\r\n")) {
      $data = substr($data, 2)
    }
  }
  return $out
}

function httpRequestRaw($method, $url, $headers = [], $body = '') {
  $parts = parseUrlParts($url)
  if ($parts === null) {
    return { ok: false, error: 'invalid url' }
  }
  $scheme = '' . $parts->scheme
  $host = '' . $parts->host
  $port = (int) $parts->port
  $path = '' . $parts->path

  $conn = tcpConnect($host, $port, { timeout_ms: 15000 })
  if (!result_is_ok($conn)) {
    return { ok: false, error: 'tcp connect failed: ' . $conn->error }
  }
  $handle = $conn->value
  $active = $handle
  if ($scheme === 'https') {
    $up = tls_upgrade($handle, $host)
    if (!result_is_ok($up)) {
      tcpClose($handle)
      return { ok: false, error: 'tls upgrade failed: ' . $up->error }
    }
    $active = $up->value
  }

  $reqHeaders = [
    'Host' => $host,
    'Connection' => 'close',
    'Accept' => 'application/json, text/plain;q=0.9, */*;q=0.8'
  ]
  foreach ($headers as $k => $v) {
    $reqHeaders['' . $k] = '' . $v
  }
  $payload = '' . $body
  if ($payload !== '') {
    $reqHeaders['Content-Length'] = '' . strlen($payload)
  }
  $head = strtoupper('' . $method) . ' ' . $path . " HTTP/1.1\r\n"
  foreach ($reqHeaders as $k => $v) {
    $head = $head . $k . ': ' . $v . "\r\n"
  }
  $request = $head . "\r\n" . $payload

  $wr = $scheme === 'https' ? tls_write($active, $request) : tcpWrite($active, $request)
  if (!result_is_ok($wr)) {
    if ($scheme === 'https') {
      tls_close($active)
      tcpClose($handle)
    } else {
      tcpClose($handle)
    }
    return { ok: false, error: 'write failed: ' . $wr->error }
  }

  $raw = ''
  while (true) {
    $chunk = $scheme === 'https' ? tls_read($active, 4096) : tcpRead($active, 4096)
    if (!result_is_ok($chunk)) {
      break
    }
    $piece = '' . $chunk->value
    if ($piece === '') {
      break
    }
    $raw = $raw . $piece
  }

  if ($scheme === 'https') {
    tls_close($active)
    tcpClose($handle)
  } else {
    tcpClose($handle)
  }

  $sepPos = strpos($raw, "\r\n\r\n")
  $sepLen = 4
  if ($sepPos === false) {
    $sepPos = strpos($raw, "\n\n")
    $sepLen = 2
  }
  if ($sepPos === false) {
    return { ok: false, error: 'invalid http response', raw: $raw }
  }
  $rawHeaders = substr($raw, 0, $sepPos)
  $rawBody = substr($raw, $sepPos + $sepLen)
  $parsed = parseHttpHeaders($rawHeaders)
  $status = (int) $parsed->status
  $outHeaders = $parsed->headers
  if (is_array($outHeaders) && array_key_exists('transfer-encoding', $outHeaders)) {
    $te = strtolower('' . $outHeaders['transfer-encoding'])
    if (strpos($te, 'chunked') !== false) {
      $rawBody = decodeChunkedBody($rawBody)
    }
  }

  return {
    ok: true,
    status: $status,
    headers: $outHeaders,
    body: $rawBody
  }
}

function formUrlEncode($pairs) {
  $parts = []
  foreach ($pairs as $k => $v) {
    $parts[] = urlencode('' . $k) . '=' . urlencode('' . $v)
  }
  return implode('&', $parts)
}

function linkhashGitApiBase() {
  $override = trim('' . envValue('LINKHASH_GIT_API_URL', ''))
  if ($override !== '') {
    return rtrim($override, '/')
  }
  $candidates = [gitApiDefaultBase(), 'http://127.0.0.1:8608']
  foreach ($candidates as $candidate) {
    $base = rtrim(trim('' . $candidate), '/')
    if ($base === '') {
      continue
    }
    $probe = httpRequestRaw('GET', $base . '/health', [ 'Accept' => 'application/json' ], '')
    if (is_array($probe) && rowValue($probe, 'ok', false)) {
      $status = (int) rowValue($probe, 'status', 0)
      if ($status >= 200 && $status < 500) {
        return $base
      }
    }
  }
  return rtrim(gitApiDefaultBase(), '/')
}

function fetchRemoteReleaseDocs($org, $name, $version) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $ver = trim('' . $version)
  if ($scope === '' || $pkg === '' || $ver === '') {
    return [ 'ok' => false, 'error' => 'invalid docs target' ]
  }
  $url = linkhashGitApiBase() . scopedReleaseDocsPath($scope, $pkg, $ver)
  $res = httpRequestRaw('GET', $url, [ 'Accept' => 'application/json' ], '')
  if (!rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'docs request failed (' . rowValue($res, 'error', 'request failed') . ')' ]
  }
  $status = (int) rowValue($res, 'status', 0)
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'docs not available', 'status' => $status ]
  }
  $decoded = decodeJsonLike(rowValue($res, 'body', '{}'), null)
  if (!is_array($decoded)) {
    return [ 'ok' => false, 'error' => 'invalid docs payload' ]
  }
  return [ 'ok' => true, 'value' => $decoded ]
}

function fetchRemoteReleaseTree($org, $name, $version) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $ver = trim('' . $version)
  if ($scope === '' || $pkg === '' || $ver === '') {
    return [ 'ok' => false, 'error' => 'invalid tree target' ]
  }
  $url = linkhashGitApiBase() . scopedReleaseTreePath($scope, $pkg, $ver)
  $res = httpRequestRaw('GET', $url, [ 'Accept' => 'application/json' ], '')
  if (!rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'tree request failed (' . rowValue($res, 'error', 'request failed') . ')' ]
  }
  $status = (int) rowValue($res, 'status', 0)
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'tree not available', 'status' => $status ]
  }
  $decoded = decodeJsonLike(rowValue($res, 'body', '{}'), null)
  if (!is_array($decoded)) {
    return [ 'ok' => false, 'error' => 'invalid tree payload' ]
  }
  return [ 'ok' => true, 'value' => $decoded ]
}

function fetchRemoteReleaseBlob($org, $name, $version, $path) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $ver = trim('' . $version)
  $file = ltrim(trim('' . $path), '/')
  if ($scope === '' || $pkg === '' || $ver === '' || $file === '') {
    return [ 'ok' => false, 'error' => 'invalid blob target' ]
  }
  $url = linkhashGitApiBase() . scopedReleaseBlobPath($scope, $pkg, $ver, $file)
  $res = httpRequestRaw('GET', $url, [ 'Accept' => 'application/json' ], '')
  if (!rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'blob request failed (' . rowValue($res, 'error', 'request failed') . ')' ]
  }
  $status = (int) rowValue($res, 'status', 0)
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'blob not available', 'status' => $status ]
  }
  $decoded = decodeJsonLike(rowValue($res, 'body', '{}'), null)
  if (!is_array($decoded)) {
    return [ 'ok' => false, 'error' => 'invalid blob payload' ]
  }
  return [ 'ok' => true, 'value' => $decoded ]
}

function linkhashGitAuthToken() {
  $token = trim('' . envValue('LINKHASH_GIT_TOKEN', ''))
  if ($token !== '') {
    return $token
  }
  return trim('' . envValue('LINKHASH_GIT_API_TOKEN', ''))
}

function linkhashGitAuthHeaders($extra = []) {
  $headers = is_array($extra) ? $extra : []
  $headers['Accept'] = 'application/json'
  $token = linkhashGitAuthToken()
  if ($token !== '') {
    $headers['Authorization'] = 'Bearer ' . $token
  }
  return $headers
}

function fetchRemoteGitJson($method, $path, $payload = null) {
  $url = linkhashGitApiBase() . $path
  $body = ''
  $headers = linkhashGitAuthHeaders([])
  if ($payload !== null) {
    $encoded = encodeJson(normalizeJsonValue($payload))
    if (!is_string($encoded)) {
      return [ 'ok' => false, 'error' => 'json encode failed' ]
    }
    $body = $encoded
    $headers['Content-Type'] = 'application/json'
  }
  $res = httpRequestRaw($method, $url, $headers, $body)
  if (!rowValue($res, 'ok', false)) {
    $rawErr = '' . rowValue($res, 'error', 'request failed')
    return [ 'ok' => false, 'error' => 'request failed (' . $rawErr . ')', 'url' => $url ]
  }
  $status = (int) rowValue($res, 'status', 0)
  $decoded = decodeJsonLike(rowValue($res, 'body', '{}'), null)
  if (!is_array($decoded)) {
    return [ 'ok' => false, 'error' => 'invalid response payload', 'status' => $status ]
  }
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => '' . rowValue($decoded, 'error', 'request rejected'), 'status' => $status, 'payload' => $decoded ]
  }
  return [ 'ok' => true, 'value' => $decoded, 'status' => $status ]
}

function fetchRemoteRepoIssues($org, $name, $state = 'open') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  if ($scope === '' || $pkg === '') {
    return [ 'ok' => false, 'error' => 'invalid issues target' ]
  }
  return fetchRemoteGitJson('GET', repoIssuesPath($scope, $pkg, $state))
}

function fetchRemoteRepoIssueDetail($org, $name, $number) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  if ($scope === '' || $pkg === '' || $n <= 0) {
    return [ 'ok' => false, 'error' => 'invalid issue target' ]
  }
  return fetchRemoteGitJson('GET', repoIssueDetailPath($scope, $pkg, $n))
}

function createRemoteRepoIssue($org, $name, $title, $body = '') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $t = trim('' . $title)
  if ($scope === '' || $pkg === '' || $t === '') {
    return [ 'ok' => false, 'error' => 'org, package, and title are required' ]
  }
  return fetchRemoteGitJson('POST', '/api/repos/' . rawurlencode($scope) . '/' . rawurlencode($pkg) . '/issues', [
    'title' => $t,
    'body' => trim('' . $body)
  ])
}

function createRemoteRepoIssueComment($org, $name, $number, $body) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  $text = trim('' . $body)
  if ($scope === '' || $pkg === '' || $n <= 0 || $text === '') {
    return [ 'ok' => false, 'error' => 'org, package, issue, and comment body are required' ]
  }
  return fetchRemoteGitJson('POST', repoIssueCommentPath($scope, $pkg, $n), [
    'body' => $text
  ])
}

function fetchRemoteRepoPulls($org, $name, $state = 'open') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  if ($scope === '' || $pkg === '') {
    return [ 'ok' => false, 'error' => 'invalid pull target' ]
  }
  return fetchRemoteGitJson('GET', repoPullsPath($scope, $pkg, $state))
}

function fetchRemoteRepoPullDetail($org, $name, $number) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  if ($scope === '' || $pkg === '' || $n <= 0) {
    return [ 'ok' => false, 'error' => 'invalid pull target' ]
  }
  return fetchRemoteGitJson('GET', repoPullDetailPath($scope, $pkg, $n))
}

function createRemoteRepoPull($org, $name, $title, $sourceRef, $targetRef, $body = '') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $t = trim('' . $title)
  $src = trim('' . $sourceRef)
  $dst = trim('' . $targetRef)
  if ($scope === '' || $pkg === '' || $t === '' || $src === '' || $dst === '') {
    return [ 'ok' => false, 'error' => 'org, package, title, source_ref, and target_ref are required' ]
  }
  return fetchRemoteGitJson('POST', '/api/repos/' . rawurlencode($scope) . '/' . rawurlencode($pkg) . '/pulls', [
    'title' => $t,
    'body' => trim('' . $body),
    'source_ref' => $src,
    'target_ref' => $dst
  ])
}

function createRemoteRepoPullComment($org, $name, $number, $body) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  $text = trim('' . $body)
  if ($scope === '' || $pkg === '' || $n <= 0 || $text === '') {
    return [ 'ok' => false, 'error' => 'org, package, pull, and comment body are required' ]
  }
  return fetchRemoteGitJson('POST', repoPullCommentPath($scope, $pkg, $n), [
    'body' => $text
  ])
}

function fetchRepoRefResolution($owner, $repo, $ref = 'HEAD') {
  $org = normalizeHandleName($owner)
  $name = normalizePackageName($repo)
  $targetRef = trim('' . $ref)
  if ($targetRef === '') {
    $targetRef = 'HEAD'
  }
  if ($org === '' || $name === '') {
    return [ 'ok' => false, 'error' => 'invalid preview target' ]
  }
  $path = repoResolvePath($org, $name, $targetRef)
  $url = linkhashGitApiBase() . $path
  $res = httpRequestRaw('GET', $url, [ 'Accept' => 'application/json' ], '')
  if (!rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'request failed (' . rowValue($res, 'error', 'request failed') . ')', 'url' => $url ]
  }
  $status = (int) rowValue($res, 'status', 0)
  $payload = decodeJsonLike(rowValue($res, 'body', '{}'), [])
  if ($status === 0 && is_array($payload) && rowValue($payload, 'ok', false) && ('' . rowValue($payload, 'commit', '')) !== '') {
    return [ 'ok' => true, 'value' => $payload, 'status' => 200, 'url' => $url ]
  }
  if ($status < 200 || $status >= 300) {
    $err = '' . rowValue($payload, 'error', 'request rejected') . ' (status ' . (string) $status . ')'
    return [ 'ok' => false, 'error' => $err, 'status' => $status, 'url' => $url ]
  }
  return [ 'ok' => true, 'value' => is_array($payload) ? $payload : [], 'status' => $status, 'url' => $url ]
}

function createRemoteRepoFork($sourceOwner, $sourceRepo, $targetRepo) {
  $owner = normalizeHandleName($sourceOwner)
  $repo = normalizePackageName($sourceRepo)
  $target = normalizePackageName($targetRepo)
  if ($owner === '' || $repo === '' || $target === '') {
    return [ 'ok' => false, 'error' => 'invalid fork target' ]
  }
  return fetchRemoteGitJson('POST', repoForkPath($owner, $repo), [
    'target_repo' => $target
  ])
}

function adwaBaseUrl() {
  return buildAdwaBaseUrl(envValue('LINKHASH_ADWA_BASE_URL', 'http://localhost:8600'))
}

function adwaPreviewUrl($owner, $repo, $commit) {
  return buildAdwaPreviewUrl(adwaBaseUrl(), normalizeHandleName($owner), normalizePackageName($repo), $commit)
}

function adwaPreviewUrlForRef($owner, $repo, $ref = 'HEAD') {
  return buildAdwaPreviewUrlForRef(adwaBaseUrl(), normalizeHandleName($owner), normalizePackageName($repo), trim('' . $ref))
}

function adwaEditUrl($owner, $repo, $commit = '') {
  return buildAdwaEditUrl(adwaBaseUrl(), normalizeHandleName($owner), normalizePackageName($repo), $commit)
}

function oauthConfig() {
  $clientId = '' . envValue('LINKHASH_OAUTH_CLIENT_ID', 'linkhash-dev')
  $clientSecret = '' . envValue('LINKHASH_OAUTH_CLIENT_SECRET', '')
  $callback = '' . envValue('LINKHASH_OAUTH_CALLBACK', 'http://localhost:8530/api/auth/callback')
  $authUrl = '' . envValue('LINKHASH_OAUTH_AUTH_URL', 'https://bsky.social/oauth/authorize')
  $tokenUrl = '' . envValue('LINKHASH_OAUTH_TOKEN_URL', 'https://bsky.social/oauth/token')
  $profileUrl = '' . envValue('LINKHASH_OAUTH_PROFILE_URL', 'https://bsky.social/xrpc/com.atproto.server.getSession')
  $scope = '' . envValue('LINKHASH_OAUTH_SCOPE', 'atproto transition:generic')
  return {
    clientId: $clientId,
    clientSecret: $clientSecret,
    callback: $callback,
    authUrl: $authUrl,
    tokenUrl: $tokenUrl,
    profileUrl: $profileUrl,
    scope: $scope
  }
}

function oauthCallbackAllowed($callback) {
  $allowlistRaw = '' . envValue('LINKHASH_OAUTH_CALLBACK_ALLOWLIST', '')
  if ($allowlistRaw === '') {
    return true
  }
  $target = '' . $callback
  $parts = explode(',', $allowlistRaw)
  foreach ($parts as $item) {
    $candidate = trim('' . $item)
    if ($candidate === '') {
      continue
    }
    if ($candidate === $target) {
      return true
    }
  }
  return false
}

function oauthFetchProfile($accessToken, $cfg) {
  $res = httpRequestRaw('GET', '' . $cfg->profileUrl, [
    'Authorization' => 'Bearer ' . $accessToken,
    'Accept' => 'application/json'
  ])
  if (!is_array($res) || !$res['ok']) {
    return [ 'ok' => false, 'error' => 'profile request failed' ]
  }
  if ((int) $res['status'] < 200 || (int) $res['status'] >= 300) {
    return [ 'ok' => false, 'error' => 'profile request rejected', 'status' => $res['status'], 'body' => $res['body'] ]
  }
  $decoded = decodeJsonLike($res['body'], null)
  if (!is_array($decoded)) {
    return [ 'ok' => false, 'error' => 'invalid profile json' ]
  }
  $profile = $decoded
  if (!is_array($profile)) {
    return [ 'ok' => false, 'error' => 'invalid profile payload' ]
  }
  $did = array_key_exists('did', $profile) ? ('' . $profile['did']) : ''
  $handle = array_key_exists('handle', $profile) ? ('' . $profile['handle']) : ''
  if ($did === '' && array_key_exists('sub', $profile)) {
    $did = '' . $profile['sub']
  }
  if ($handle === '' && array_key_exists('preferred_username', $profile)) {
    $handle = '' . $profile['preferred_username']
  }
  if ($did === '' || $handle === '') {
    return [ 'ok' => false, 'error' => 'profile missing did/handle', 'profile' => $profile ]
  }
  $display = array_key_exists('displayName', $profile) ? ('' . $profile['displayName']) : $handle
  return [ 'ok' => true, 'did' => $did, 'handle' => $handle, 'displayName' => $display, 'profile' => $profile ]
}

function oauthPackContext($state, $pkceVerifier) {
  return ('' . $state) . '.' . ('' . $pkceVerifier)
}

function oauthUnpackContext($packed) {
  $raw = '' . $packed
  $pos = strpos($raw, '.')
  if ($pos === false) {
    return null
  }
  $state = substr($raw, 0, $pos)
  $pkce = substr($raw, $pos + 1)
  if ($state === '' || $pkce === '') {
    return null
  }
  return { state: '' . $state, pkce: '' . $pkce }
}

function requestCookie($name, $fallback = null) {
  $value = cookieGet($name, null)
  if ($value !== null && $value !== '') {
    return urldecode('' . $value)
  }
  if (!is_array($_SERVER) || !array_key_exists('HTTP_COOKIE', $_SERVER)) {
    return $fallback
  }
  $header = '' . $_SERVER['HTTP_COOKIE']
  if ($header === '') {
    return $fallback
  }
  $parts = explode(';', $header)
  $target = '' . $name
  foreach ($parts as $part) {
    $piece = trim($part)
    $eqPos = strpos($piece, '=')
    if ($eqPos === false) {
      continue
    }
    $k = trim(substr($piece, 0, $eqPos))
    $v = trim(substr($piece, $eqPos + 1))
    if ($k === $target) {
      return urldecode($v)
    }
  }
  return $fallback
}

function authRequestToken() {
  $token = requestCookie('lh_session', null)
  if ($token !== null && $token !== '') {
    return $token
  }
  $allowQuery = strtolower('' . envValue('LINKHASH_ALLOW_QUERY_SESSION', '0'))
  if ($allowQuery === '1' || $allowQuery === 'true' || $allowQuery === 'yes' || $allowQuery === 'on') {
    $q = queryValue('session', null)
    if ($q !== null && $q !== '') {
      return '' . $q
    }
  }
  if (is_array($_SERVER) && array_key_exists('HTTP_AUTHORIZATION', $_SERVER)) {
    $raw = '' . $_SERVER['HTTP_AUTHORIZATION']
    if (strlen($raw) >= 7 && strtolower(substr($raw, 0, 7)) === 'bearer ') {
      $bearer = trim(substr($raw, 7))
      if ($bearer !== '') {
        return $bearer
      }
    }
  }
  return null
}

function requestMethod() {
  if (is_array($_SERVER) && array_key_exists('REQUEST_METHOD', $_SERVER)) {
    return strtoupper('' . $_SERVER['REQUEST_METHOD'])
  }
  return 'GET'
}

function requireMethod($expected) {
  $actual = requestMethod()
  $want = strtoupper('' . $expected)
  if ($actual !== $want) {
    return [ 'ok' => false, 'error' => 'method not allowed', 'expected' => $want, 'actual' => $actual ]
  }
  return [ 'ok' => true ]
}

function normalizeJsonValue($value, $depth = 0) {
  if ($depth > 32) {
    return null
  }
  $t = gettype($value)
  if ($t === 'NULL' || $t === 'boolean' || $t === 'integer' || $t === 'double' || $t === 'string') {
    return $value
  }
  if (is_array($value)) {
    $out = []
    foreach ($value as $k => $v) {
      $out[$k] = normalizeJsonValue($v, $depth + 1)
    }
    return $out
  }
  if (is_object($value)) {
    $out = []
    foreach ($value as $k => $v) {
      $out['' . $k] = normalizeJsonValue($v, $depth + 1)
    }
    if (count($out) > 0) {
      return $out
    }

    $arr = (array) $value
    if (count($arr) === 1 && array_key_exists(0, $arr) && (is_object($arr[0]) || is_array($arr[0]))) {
      return normalizeJsonValue($arr[0], $depth + 1)
    }
    if (count($arr) === 1 && array_key_exists('0', $arr) && (is_object($arr['0']) || is_array($arr['0']))) {
      return normalizeJsonValue($arr['0'], $depth + 1)
    }
    foreach ($arr as $k => $v) {
      $out['' . $k] = normalizeJsonValue($v, $depth + 1)
    }
    return $out
  }
  if ($t === 'resource') {
    return null
  }
  return '' . $value
}

function jsonReply($value) {
  $encoded = encodeJson(normalizeJsonValue($value))
  if (!is_string($encoded)) {
    return '{"ok":false,"error":"encode failed"}'
  }
  return $encoded
}

function wantsHtmlResponse() {
  if (!is_array($_SERVER) || !array_key_exists('HTTP_ACCEPT', $_SERVER)) {
    return false
  }
  $accept = strtolower('' . $_SERVER['HTTP_ACCEPT'])
  return strpos($accept, 'text/html') !== false
}

function redirectTo($url, $status = '302 Found') {
  header('HTTP/1.1 ' . $status)
  header('Location: ' . $url)
}

function cookieSecureFlag() {
  $raw = strtolower(trim('' . envValue('LINKHASH_SECURE_COOKIES', 'false')))
  return $raw === '1' || $raw === 'true' || $raw === 'yes'
}

function requestMethod() {
  if (is_array($_SERVER) && array_key_exists('REQUEST_METHOD', $_SERVER)) {
    return strtoupper('' . $_SERVER['REQUEST_METHOD'])
  }
  return 'GET'
}

function requestPath() {
  if (is_array($_SERVER) && array_key_exists('REQUEST_URI', $_SERVER)) {
    $uri = '' . $_SERVER['REQUEST_URI']
    $parts = explode('?', $uri)
    return count($parts) > 0 ? ('' . $parts[0]) : $uri
  }
  return '/'
}

function requestId() {
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_request_id', $GLOBALS) && ('' . $GLOBALS['__lh_request_id']) !== '') {
    return '' . $GLOBALS['__lh_request_id']
  }
  $incoming = is_array($_SERVER) && array_key_exists('HTTP_X_REQUEST_ID', $_SERVER) ? ('' . $_SERVER['HTTP_X_REQUEST_ID']) : ''
  $rid = $incoming !== '' ? $incoming : ('req_' . devRandomHex(24))
  if (isset($GLOBALS) && is_array($GLOBALS)) {
    $GLOBALS['__lh_request_id'] = $rid
  }
  return $rid
}

function logDirPath() {
  return '' . envValue('LINKHASH_LOG_DIR', 'storage/logs')
}

function ensureLogDir() {
  $dir = trim(logDirPath())
  if ($dir === '') {
    return false
  }
  if (is_dir($dir)) {
    return true
  }
  $parts = explode('/', $dir)
  $current = ''
  foreach ($parts as $part) {
    $seg = trim('' . $part)
    if ($seg === '') {
      continue
    }
    $current = $current === '' ? $seg : ($current . '/' . $seg)
    if (!is_dir($current)) {
      @mkdir($current)
    }
  }
  return is_dir($dir)
}

function appendLogLine($line) {
  $clean = trim('' . $line)
  $logFile = '' . envValue('LINKHASH_LOG_FILE', '')
  if (function_exists('error_log')) {
    if ($logFile !== '') {
      @error_log($clean . "\n", 3, $logFile)
    }
    @error_log('[linkhash] ' . $clean)
    return true
  }
  return false
}

function ensureEventLogSchema($db) {
  return
}

function logEventDb($payload) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $metaJson = encodeJson(normalizeJsonValue(rowValue($payload, 'meta', {})))
  if (!is_string($metaJson)) {
    $metaJson = '{}'
  }
  clientInsertOne($client, $client.models.LhEventLog, {
    level: '' . rowValue($payload, 'level', 'info'),
    event: '' . rowValue($payload, 'event', 'unknown'),
    request_id: '' . rowValue($payload, 'requestId', ''),
    method: '' . rowValue($payload, 'method', ''),
    path: '' . rowValue($payload, 'path', ''),
    meta_json: $metaJson
  }, false)
  dbClose($db)
}

function logEvent($level, $event, $meta = []) {
  $payload = {
    ts: gmdate('c'),
    level: '' . $level,
    event: '' . $event,
    requestId: requestId(),
    method: requestMethod(),
    path: requestPath(),
    meta: normalizeJsonValue($meta)
  }
  $line = jsonReply($payload)
  appendLogLine($line . "\n")
  $backend = strtolower('' . envValue('LINKHASH_LOG_BACKEND', 'db'))
  if ($backend === 'db') {
    logEventDb($payload)
  }
}

function ensureAuditSchema($db) {
  return
}

function auditEvent($action, $auth, $result = 'ok', $subjectKind = '', $subjectRef = '', $details = []) {
  $authKind = 'anonymous'
  $scopeMask = 0
  $actorUserId = null
  $actorHandle = ''
  if (is_array($auth) && rowValue($auth, 'ok', false)) {
    $authKind = '' . rowValue($auth, 'kind', 'session')
    $scopeMask = (int) rowValue($auth, 'scopeMask', 0)
    $user = rowValue($auth, 'user', null)
    if ($user !== null) {
      $uid = (int) rowValue($user, 'id', 0)
      if ($uid > 0) {
        $actorUserId = $uid
      }
      $actorHandle = '' . rowValue($user, 'handle', '')
    }
  }
  $detailJson = encodeJson(normalizeJsonValue($details))
  if (!is_string($detailJson)) {
    $detailJson = '{}'
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  clientInsertOne($client, $client.models.LhAuditLog, {
    action: '' . $action,
    result: '' . $result,
    actor_user_id: $actorUserId === null ? null : (int) $actorUserId,
    actor_handle: $actorHandle,
    auth_kind: $authKind,
    scope_mask: (int) $scopeMask,
    subject_kind: '' . $subjectKind,
    subject_ref: '' . $subjectRef,
    request_id: requestId(),
    method: requestMethod(),
    path: requestPath(),
    ip_address: '' . clientIp(),
    detail_json: $detailJson
  }, false)
  dbClose($db)
}

function linkhashErrorHandler($errno, $errstr, $errfile, $errline) {
  logEvent('error', 'php.warning', {
    errno: (int) $errno,
    message: '' . $errstr,
    file: '' . $errfile,
    line: (int) $errline
  })
  return false
}

function linkhashShutdownHandler() {
  if (!function_exists('error_get_last')) {
    return
  }
  $last = error_get_last()
  if (!is_array($last) || count($last) === 0) {
    return
  }
  logEvent('error', 'php.shutdown', {
    type: rowValue($last, 'type', null),
    message: rowValue($last, 'message', ''),
    file: rowValue($last, 'file', ''),
    line: rowValue($last, 'line', 0)
  })
}

function installRuntimeHandlers() {
  if (function_exists('set_error_handler')) {
    set_error_handler('linkhashErrorHandler')
  }
  if (function_exists('register_shutdown_function')) {
    register_shutdown_function('linkhashShutdownHandler')
  }
}

function authScopeMask($scopeText) {
  $mask = 0
  $parts = explode(',', strtolower('' . $scopeText))
  foreach ($parts as $part) {
    $item = trim($part)
    if ($item === 'read') {
      $mask = $mask | 1
    } else if ($item === 'read:write') {
      $mask = $mask | 3
    } else if ($item === 'read:write:delete') {
      $mask = $mask | 7
    }
  }
  if ($mask === 0) {
    $mask = 1
  }
  return $mask
}

function authScopeText($mask) {
  $out = []
  $m = (int) $mask
  if (($m & 1) !== 0) {
    $out[] = 'read'
  }
  if (($m & 2) !== 0) {
    $out[] = 'read:write'
  }
  if (($m & 4) !== 0) {
    $out[] = 'read:write:delete'
  }
  return implode(',', $out)
}

function authTokenHash($token) {
  return sha256Hex('' . $token)
}

function secureStringEquals($a, $b): bool {
  $left = '' . $a
  $right = '' . $b
  if (function_exists('hash_equals')) {
    return hash_equals($left, $right)
  }
  $leftLen = strlen($left)
  $rightLen = strlen($right)
  $len = max($leftLen, $rightLen)
  $diff = $leftLen ^ $rightLen
  for ($i = 0; $i < $len; $i = $i + 1) {
    $lc = $i < $leftLen ? ord(substr($left, $i, 1)) : 0
    $rc = $i < $rightLen ? ord(substr($right, $i, 1)) : 0
    $diff = $diff | ($lc ^ $rc)
  }
  return $diff === 0
}

function authSessionExpiresAt($seconds = 604800) {
  return gmdate('Y-m-d H:i:s', time() + (int) $seconds)
}

function authIdleTimeoutSeconds() {
  return max(300, (int) envValue('LINKHASH_SESSION_IDLE_SECONDS', '86400'))
}

function authMaxTimeoutSeconds() {
  return max(300, (int) envValue('LINKHASH_SESSION_MAX_SECONDS', '604800'))
}

function isNoRowsError($error): bool {
  $msg = strtolower('' . $error)
  return strpos($msg, 'no rows') !== false || strpos($msg, 'not found') !== false
}

function authSelectUserByDid($db, $did) {
  $client = dbClient($db)
  return clientSelectOne($client, 
    $client.models.LhUser,
    eq('did', '' . $did)
  )
}

function authUpsertUserByDid($db, $did, $handle, $displayName) {
  $existing = authSelectUserByDid($db, $did)
  if (result_is_ok($existing)) {
    $client = dbClient($db)
    $up = clientUpdateWhere($client, 
      $client.models.LhUser,
      eq('did', '' . $did),
      {
        handle: '' . $handle,
        display_name: '' . $displayName,
        updated_at: gmdate('c')
      },
      false
    )
    if (!result_is_ok($up)) {
      return $up
    }
    return authSelectUserByDid($db, $did)
  }
  if (!isNoRowsError($existing->error)) {
    return $existing
  }

  $client = dbClient($db)
  $ins = clientInsertOne($client, 
    $client.models.LhUser,
    {
      did: '' . $did,
      handle: '' . $handle,
      display_name: '' . $displayName
    },
    false
  )
  if (!result_is_ok($ins)) {
    return $ins
  }
  return authSelectUserByDid($db, $did)
}

function clientIp() {
  if (is_array($_SERVER) && array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) {
    $raw = '' . $_SERVER['HTTP_X_FORWARDED_FOR']
    $parts = explode(',', $raw)
    if (count($parts) > 0) {
      $first = trim('' . $parts[0])
      if ($first !== '') {
        return $first
      }
    }
  }
  if (is_array($_SERVER) && array_key_exists('REMOTE_ADDR', $_SERVER)) {
    $ip = trim('' . $_SERVER['REMOTE_ADDR'])
    if ($ip !== '') {
      return $ip
    }
  }
  return 'unknown'
}

function reservedHandles() {
  return [
    'deka', 'linkhash', 'admin', 'support', 'system', 'root', 'security',
    'api', 'auth', 'www', 'assets', 'cdn', 'status', 'ops', 'infra',
    'help', 'docs', 'mail', 'postmaster', 'abuse', 'owner', 'owners',
    'maintainer', 'maintainers', 'publisher', 'publishers', 'billing',
    'payments', 'legal', 'privacy', 'terms', 'contact', 'team', 'teams',
    'about', 'blog', 'news', 'download', 'downloads', 'search', 'new',
    'create', 'dashboard', 'settings', 'login', 'logout', 'signin',
    'signup', 'register', 'account', 'accounts', 'user', 'users'
  ]
}

function reservedPackageNames() {
  return [
    'core', 'runtime', 'php', 'phpx', 'stdlib', 'modules', 'internal',
    'deka', 'linkhash', 'api', 'auth', 'system', 'root', 'admin',
    'support', 'security', 'test', 'tests', 'example', 'examples'
  ]
}

function normalizeHandleName($handle) {
  $h = strtolower(trim('' . $handle))
  if (strStartsWith($h, '@')) {
    $h = substr($h, 1)
  }
  return $h
}

function normalizePackageName($name) {
  return strtolower(trim('' . $name))
}

function isReservedHandle($handle) {
  $h = normalizeHandleName($handle)
  if ($h === '') {
    return true
  }
  foreach (reservedHandles() as $reserved) {
    if ($h === $reserved) {
      return true
    }
  }
  return false
}

function isValidHandleName($handle) {
  $h = normalizeHandleName($handle)
  if ($h === '') {
    return false
  }
  return preg_match('/^[a-z0-9](?:[a-z0-9.-]{0,62}[a-z0-9])?$/', $h) === 1
}

function isReservedPackageName($name) {
  $n = normalizePackageName($name)
  if ($n === '') {
    return true
  }
  foreach (reservedPackageNames() as $reserved) {
    if ($n === $reserved) {
      return true
    }
  }
  return false
}

function isValidPackageName($name) {
  $n = normalizePackageName($name)
  if ($n === '') {
    return false
  }
  return preg_match('/^[a-z0-9](?:[a-z0-9._-]{0,126}[a-z0-9])?$/', $n) === 1
}

function ensureAuthSchema($db) {
  return
}

function bootstrapSchema() {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    logEvent('error', 'schema.bootstrap_failed', { error: $conn->error })
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  dbClose($db)
}

function ensureUserOrgMembership($db, $user) {
  $userId = '' . rowValue($user, 'id', '0')
  $handle = '' . rowValue($user, 'handle', '')
  $normalized = normalizeHandleName($handle)
  if ($normalized === '' || isReservedHandle($normalized)) {
    return [ 'ok' => false, 'error' => 'reserved or invalid org handle' ]
  }

  $client = dbClient($db)
  $orgRes = clientSelectOne($client, $client.models.LhOrg, eq('handle', $normalized))
  if (!result_is_ok($orgRes)) {
    if (!isNoRowsError($orgRes->error)) {
      return [ 'ok' => false, 'error' => $orgRes->error ]
    }
    $created = clientInsertOne($client, $client.models.LhOrg, {
      handle: $normalized,
      visibility: 'public'
    }, false)
    if (!result_is_ok($created)) {
      return [ 'ok' => false, 'error' => $created->error ]
    }
    $orgRes = clientSelectOne($client, $client.models.LhOrg, eq('handle', $normalized))
    if (!result_is_ok($orgRes)) {
      return [ 'ok' => false, 'error' => $orgRes->error ]
    }
  } else {
    clientUpdateWhere($client, 
      $client.models.LhOrg,
      eq('id', (int) rowValue($orgRes->value, 'id', 0)),
      { updated_at: gmdate('c') },
      false
    )
  }

  $orgId = (int) rowValue($orgRes->value, 'id', 0)
  $memberRes = clientSelectOne($client, 
    $client.models.LhOrgMember,
    andWhere(eq('org_id', $orgId), eq('user_id', (int) $userId))
  )
  if (result_is_ok($memberRes)) {
    $membership = clientUpdateWhere($client, 
      $client.models.LhOrgMember,
      eq('id', (int) rowValue($memberRes->value, 'id', 0)),
      { role: 'publisher', revoked_at: null },
      false
    )
    if (!result_is_ok($membership)) {
      return [ 'ok' => false, 'error' => $membership->error ]
    }
  } else if (isNoRowsError($memberRes->error)) {
    $membership = clientInsertOne($client, 
      $client.models.LhOrgMember,
      {
        org_id: $orgId,
        user_id: (int) $userId,
        role: 'publisher'
      },
      false
    )
    if (!result_is_ok($membership)) {
      return [ 'ok' => false, 'error' => $membership->error ]
    }
  } else {
    return [ 'ok' => false, 'error' => $memberRes->error ]
  }

  return [ 'ok' => true, 'org' => $orgRes->value ]
}

function canonicalOrgRole($role) {
  $r = strtolower(trim('' . $role))
  if ($r === 'owner') {
    return 'publisher'
  }
  return $r
}

function orgMemberRole($db, $orgId, $userId) {
  $client = dbClient($db)
  $row = clientSelectOne($client, 
    $client.models.LhOrgMember,
    andWhere(
      eq('org_id', (int) $orgId),
      eq('user_id', (int) $userId),
      isNull('revoked_at')
    )
  )
  if (!result_is_ok($row)) {
    return null
  }
  return canonicalOrgRole(rowValue($row->value, 'role', ''))
}

function canEditOrg($db, $orgId, $userId) {
  $role = orgMemberRole($db, $orgId, $userId)
  return $role === 'publisher' || $role === 'maintainer'
}

function canManageOrg($db, $orgId, $userId) {
  $role = orgMemberRole($db, $orgId, $userId)
  return $role === 'publisher'
}

function allowedMemberRole($role) {
  $r = strtolower(trim('' . $role))
  return $r === 'publisher' || $r === 'maintainer' || $r === 'public'
}

function rateLimitCheck($db, $bucket, $subjectKey, $limit, $windowSeconds) {
  $bucketName = '' . $bucket
  $subject = '' . $subjectKey
  $maxCount = max(1, (int) $limit)
  $window = max(1, (int) $windowSeconds)
  $client = dbClient($db)
  $hits = clientSelectMany($client, 
    $client.models.LhRateLimitHit,
    andWhere(
      eq('bucket', $bucketName),
      eq('subject_key', $subject)
    )
  )
  if (!result_is_ok($hits)) {
    return [ 'ok' => false, 'error' => $hits->error ]
  }
  $now = time()
  $windowStart = $now - $window
  $seen = 0
  foreach ($hits->value as $hit) {
    $ts = parseTimestamp(rowValue($hit, 'createdAt', rowValue($hit, 'created_at', '')))
    if ($ts === null) {
      continue
    }
    if ($ts < $windowStart) {
      clientDeleteWhere($client, 
        $client.models.LhRateLimitHit,
        eq('id', (int) rowValue($hit, 'id', 0)),
        false
      )
      continue
    }
    $seen += 1
  }
  $ins = clientInsertOne($client, 
    $client.models.LhRateLimitHit,
    {
      bucket: $bucketName,
      subject_key: $subject,
      created_at: gmdate('c')
    },
    false
  )
  if (!result_is_ok($ins)) {
    return [ 'ok' => false, 'error' => $ins->error ]
  }
  $seen += 1
  if ($seen > $maxCount) {
    return [ 'ok' => false, 'error' => 'rate limit exceeded', 'bucket' => $bucketName, 'limit' => $maxCount, 'window' => $window ]
  }
  return [ 'ok' => true, 'count' => $seen ]
}

function enforceRateLimit($bucket, $subjectKey, $limit, $windowSeconds) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => 'authIssueSession.open: ' . $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $res = rateLimitCheck($db, $bucket, $subjectKey, $limit, $windowSeconds)
  dbClose($db)
  return $res
}

function enforceIpRateLimit($bucket, $limit, $windowSeconds) {
  return enforceRateLimit($bucket, 'ip:' . clientIp(), $limit, $windowSeconds)
}

function enforceUserRateLimit($bucket, $userId, $limit, $windowSeconds) {
  return enforceRateLimit($bucket, 'user:' . ('' . $userId), $limit, $windowSeconds)
}

function parseVisibility($raw, $fallback = 'public') {
  $value = strtolower(trim('' . $raw))
  if ($value === '') {
    return $fallback
  }
  if ($value === 'public' || $value === 'private') {
    return $value
  }
  return null
}

function authUserId($auth) {
  if (!rowValue($auth, 'ok', false)) {
    return 0
  }
  $user = rowValue($auth, 'user', null)
  if ($user === null) {
    return 0
  }
  return (int) rowValue($user, 'id', 0)
}

function fetchVisiblePackageRows($db, $limit = 25, $query = '', $userId = 0) {
  $max = max(1, (int) $limit)
  $q = strtolower(trim('' . $query))
  $uid = (int) $userId
  $client = dbClient($db)

  $packages = []
  if ($uid > 0) {
    $members = clientSelectMany($client, 
      $client.models.LhOrgMember,
      andWhere(
        eq('user_id', $uid),
        isNull('revoked_at')
      )
    )
    if (!result_is_ok($members)) {
      return { ok: false, error: $members->error }
    }
    $allowed = []
    foreach ($members->value as $member) {
      $role = canonicalOrgRole(rowValue($member, 'role', ''))
      if ($role === 'publisher' || $role === 'maintainer') {
        $allowed[(int) rowValue($member, 'org_id', 0)] = true
      }
    }

    $publicRes = clientSelectMany($client, $client.models.Package, eq('visibility', 'public'))
    if (!result_is_ok($publicRes)) {
      return { ok: false, error: $publicRes->error }
    }
    $privateRes = clientSelectMany($client, $client.models.Package, eq('visibility', 'private'))
    if (!result_is_ok($privateRes)) {
      return { ok: false, error: $privateRes->error }
    }
    foreach ($publicRes->value as $row) {
      $packages[] = $row
    }
    foreach ($privateRes->value as $row) {
      $orgId = (int) rowValue($row, 'org_id', rowValue($row, 'orgId', 0))
      if (array_key_exists($orgId, $allowed)) {
        $packages[] = $row
      }
    }
  } else {
    $publicRes = clientSelectMany($client, $client.models.Package, eq('visibility', 'public'))
    if (!result_is_ok($publicRes)) {
      return { ok: false, error: $publicRes->error }
    }
    $packages = $publicRes->value
  }

  if ($q !== '') {
    $filtered = []
    foreach ($packages as $row) {
      $name = strtolower('' . rowValue($row, 'name', ''))
      $desc = strtolower('' . rowValue($row, 'description', ''))
      if (strpos($name, $q) !== false || strpos($desc, $q) !== false) {
        $filtered[] = $row
      }
    }
    $packages = $filtered
  }

  usort($packages, function ($a, $b) {
    $ad = (int) rowValue($a, 'download_count', rowValue($a, 'downloadCount', 0))
    $bd = (int) rowValue($b, 'download_count', rowValue($b, 'downloadCount', 0))
    if ($ad === $bd) {
      $aid = (int) rowValue($a, 'id', 0)
      $bid = (int) rowValue($b, 'id', 0)
      if ($aid === $bid) {
        return 0
      }
      return $bid > $aid ? 1 : -1
    }
    return $bd > $ad ? 1 : -1
  })

  if (count($packages) > $max) {
    $packages = array_slice($packages, 0, $max)
  }

  $orgsRes = clientSelectMany($client, $client.models.LhOrg)
  if (!result_is_ok($orgsRes)) {
    return { ok: false, error: $orgsRes->error }
  }
  $orgMap = []
  foreach ($orgsRes->value as $org) {
    $orgMap[(int) rowValue($org, 'id', 0)] = '' . rowValue($org, 'handle', '')
  }

  $versionsRes = clientSelectMany($client, $client.models.PackageVersion)
  if (!result_is_ok($versionsRes)) {
    return { ok: false, error: $versionsRes->error }
  }
  $latestByPackage = []
  foreach ($packages as $row) {
    $latestByPackage[(int) rowValue($row, 'id', 0)] = '' . rowValue($row, 'latest_version', rowValue($row, 'latestVersion', ''))
  }
  $canonicalByPackage = []
  foreach ($versionsRes->value as $ver) {
    $pid = (int) rowValue($ver, 'package_id', rowValue($ver, 'packageId', 0))
    $latest = array_key_exists($pid, $latestByPackage) ? $latestByPackage[$pid] : ''
    if ($latest === '') {
      continue
    }
    $verName = '' . rowValue($ver, 'version', '')
    if ($verName === $latest) {
      $canonicalByPackage[$pid] = '' . rowValue($ver, 'canonical_id', rowValue($ver, 'canonicalId', ''))
    }
  }

  $out = []
  foreach ($packages as $row) {
    $orgId = (int) rowValue($row, 'org_id', rowValue($row, 'orgId', 0))
    $pid = (int) rowValue($row, 'id', 0)
    $row['orgHandle'] = array_key_exists($orgId, $orgMap) ? $orgMap[$orgId] : ''
    $row['canonicalId'] = array_key_exists($pid, $canonicalByPackage) ? $canonicalByPackage[$pid] : ''
    $out[] = $row
  }

  return { ok: true, rows: $out }
}

function devRandomHex($len = 32) {
  $need = max(2, (int) $len)
  $rand = random_hex($need)
  if (result_is_ok($rand)) {
    $value = result_unwrap($rand)
    if (is_string($value) && strlen($value) >= $need) {
      return substr($value, 0, $need)
    }
  }
  $buf = ''
  while (strlen($buf) < $need) {
    $micros = (int) (microtime(true) * 1000000)
    $salt = mt_rand(0, 0x7fffffff)
    $buf = $buf . dechex($micros) . dechex($salt)
  }
  return substr($buf, 0, $need)
}

function authIssueSession($handle, $userId) {
  $token = 'lhs_' . devRandomHex(32)
  $csrf = 'lhcsrf_' . devRandomHex(32)
  $tokenHash = authTokenHash($token)
  $csrfHash = authTokenHash($csrf)
  $maxSecs = (int) authMaxTimeoutSeconds()
  $ipAddress = isset($_SERVER['REMOTE_ADDR']) ? ('' . $_SERVER['REMOTE_ADDR']) : ''
  $userAgent = isset($_SERVER['HTTP_USER_AGENT']) ? ('' . $_SERVER['HTTP_USER_AGENT']) : ''

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  clientUpdateWhere($client, 
    $client.models.LhSession,
    andWhere(
      eq('user_id', (int) $userId),
      isNull('revoked_at')
    ),
    { revoked_at: gmdate('c') },
    false
  )
  $insExec = clientInsertOne($client, 
    $client.models.LhSession,
    {
      user_id: (int) $userId,
      session_token_hash: $tokenHash,
      csrf_token_hash: $csrfHash,
      last_seen_at: gmdate('c'),
      expires_at: authSessionExpiresAt(),
      created_at: gmdate('c'),
      ip_address: $ipAddress,
      user_agent: $userAgent
    },
    false
  )
  if (!result_is_ok($insExec)) {
    $diag = [
      'userIdType' => gettype($userId),
      'tokenHashType' => gettype($tokenHash),
      'tokenHashLen' => strlen('' . $tokenHash),
      'csrfHashType' => gettype($csrfHash),
      'csrfHashLen' => strlen('' . $csrfHash),
      'ipType' => gettype($ipAddress),
      'uaType' => gettype($userAgent),
      'ttl' => '7 days'
    ]
    return [ 'ok' => false, 'error' => 'authIssueSession.insert: ' . $insExec->error, 'diag' => $diag ]
  }
  $lookup = clientSelectOne($client, $client.models.LhSession, eq('session_token_hash', $tokenHash))
  dbClose($db)
  if (!result_is_ok($lookup)) {
    return [ 'ok' => false, 'error' => 'authIssueSession.lookup: ' . $lookup->error ]
  }

  cookieSetHeader('lh_session', $token, [
    'path' => '/',
    'max_age' => (int) $maxSecs,
    'same_site' => 'Lax',
    'http_only' => true,
    'secure' => cookieSecureFlag()
  ])

  return [ 'ok' => true, 'token' => $token, 'csrf' => $csrf, 'session' => $lookup->value ]
}

function authCurrentUser() {
  $sessionToken = authRequestToken()
  if ($sessionToken === null || $sessionToken === '') {
    return [ 'ok' => false, 'error' => 'not authenticated' ]
  }
  if (strStartsWith($sessionToken, 'lhs_dev:')) {
    $parts = explode(':', $sessionToken)
    if (count($parts) >= 4) {
      $devUid = (int) $parts[1]
      $devCsrf = '' . $parts[2]
      if ($devUid > 0) {
      $conn = openDbHandle()
      if (!result_is_ok($conn)) {
        return [ 'ok' => false, 'error' => $conn->error ]
      }
      $db = $conn->value
      $client = dbClient($db)
      $user = clientSelectOne($client, $client.models.LhUser, eq('id', $devUid))
      dbClose($db)
      if (result_is_ok($user)) {
        $u = $user->value
        if (is_array($u)) {
          $u['csrfHash'] = authTokenHash($devCsrf)
        } else {
          $u->csrfHash = authTokenHash($devCsrf)
        }
        return [ 'ok' => true, 'user' => $u ]
      }
      return [ 'ok' => false, 'error' => 'dev session user lookup failed: ' . $user->error ]
    }
    }
  }
  $tokenHash = authTokenHash($sessionToken)
  $idleSecs = '' . authIdleTimeoutSeconds()
  $maxSecs = '' . authMaxTimeoutSeconds()
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $session = clientSelectOne($client, $client.models.LhSession, eq('session_token_hash', $tokenHash))
  if (result_is_ok($session)) {
    $s = $session->value
    $revokedAt = rowValue($s, 'revoked_at', rowValue($s, 'revokedAt', null))
    $expiresAt = parseTimestamp(rowValue($s, 'expires_at', rowValue($s, 'expiresAt', null)))
    $lastSeenAt = parseTimestamp(rowValue($s, 'last_seen_at', rowValue($s, 'lastSeenAt', null)))
    $createdAt = parseTimestamp(rowValue($s, 'created_at', rowValue($s, 'createdAt', null)))
    $now = time()
    $idleLimit = $now - (int) $idleSecs
    $maxLimit = $now - (int) $maxSecs
    if ($revokedAt !== null) {
      $session = result_err('revoked')
    } else if ($expiresAt !== null && $expiresAt <= $now) {
      $session = result_err('expired')
    } else if ($lastSeenAt !== null && $lastSeenAt <= $idleLimit) {
      $session = result_err('idle timeout')
    } else if ($createdAt !== null && $createdAt <= $maxLimit) {
      $session = result_err('max timeout')
    }
  }
  if (result_is_ok($session)) {
    clientUpdateWhere($client, 
      $client.models.LhSession,
      eq('id', (int) rowValue($session->value, 'id', 0)),
      { last_seen_at: gmdate('c') },
      false
    )
    $user = clientSelectOne($client, 
      $client.models.LhUser,
      eq('id', (int) rowValue($session->value, 'user_id', rowValue($session->value, 'userId', 0)))
    )
    if (result_is_ok($user)) {
      $u = $user->value
      if (is_array($u)) {
        $u['csrfHash'] = rowValue($session->value, 'csrf_token_hash', rowValue($session->value, 'csrfTokenHash', ''))
      } else {
        $u->csrfHash = rowValue($session->value, 'csrf_token_hash', rowValue($session->value, 'csrfTokenHash', ''))
      }
      $session = result_ok($u)
    } else {
      $session = result_err($user->error)
    }
  }
  dbClose($db)
  if (!result_is_ok($session)) {
    return [ 'ok' => false, 'error' => 'not authenticated' ]
  }
  return [ 'ok' => true, 'user' => $session->value ]
}

function authValidateCsrfForSessionUser($user) {
  $expectedHash = '' . rowValue($user, 'csrfHash', rowValue($user, 'csrfhash', ''))
  if ($expectedHash === '') {
    return [ 'ok' => false, 'error' => 'missing csrf token for session' ]
  }
  $presented = is_array($_SERVER) && array_key_exists('HTTP_X_CSRF_TOKEN', $_SERVER)
    ? trim('' . $_SERVER['HTTP_X_CSRF_TOKEN'])
    : ''
  if ($presented === '') {
    $body = requestData()
    if (is_array($body) && array_key_exists('csrf', $body)) {
      $presented = trim('' . $body['csrf'])
    }
  }
  if ($presented === '') {
    $presented = trim('' . queryValue('csrf', ''))
  }
  if ($presented === '') {
    return [ 'ok' => false, 'error' => 'missing csrf token' ]
  }
  $presentedHash = authTokenHash($presented)
  if (!secureStringEquals($expectedHash, $presentedHash)) {
    return [ 'ok' => false, 'error' => 'invalid csrf token' ]
  }
  return [ 'ok' => true ]
}

function authValidateCsrfForAuth($auth) {
  if (!is_array($auth) || !array_key_exists('ok', $auth) || !$auth['ok']) {
    return [ 'ok' => false, 'error' => 'not authenticated' ]
  }
  if (!array_key_exists('kind', $auth) || $auth['kind'] !== 'session') {
    return [ 'ok' => true ]
  }
  return authValidateCsrfForSessionUser($auth['user'])
}

function authHasScopeMask($actualMask, $requiredMask) {
  $actual = (int) $actualMask
  $required = (int) $requiredMask
  return ($actual & $required) === $required
}

function authPatFromBearer($requiredMask = 1) {
  if (!is_array($_SERVER) || !array_key_exists('HTTP_AUTHORIZATION', $_SERVER)) {
    return [ 'ok' => false, 'error' => 'missing authorization header' ]
  }
  $raw = '' . $_SERVER['HTTP_AUTHORIZATION']
  if (!(strlen($raw) >= 7 && strtolower(substr($raw, 0, 7)) === 'bearer ')) {
    return [ 'ok' => false, 'error' => 'invalid authorization scheme' ]
  }
  $token = trim(substr($raw, 7))
  if ($token === '' || strpos($token, 'lh_pat_') !== 0) {
    return [ 'ok' => false, 'error' => 'invalid PAT token' ]
  }
  $tokenHash = authTokenHash($token)
  $required = '' . (int) $requiredMask

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $tokenRow = clientSelectOne($client, $client.models.LhApiToken, eq('token_hash', $tokenHash))
  if (result_is_ok($tokenRow)) {
    $tokenValue = $tokenRow->value
    $revokedAt = rowValue($tokenValue, 'revoked_at', rowValue($tokenValue, 'revokedAt', null))
    $expiresAt = parseTimestamp(rowValue($tokenValue, 'expires_at', rowValue($tokenValue, 'expiresAt', null)))
    $scopeMask = (int) rowValue($tokenValue, 'scope_mask', rowValue($tokenValue, 'scopeMask', 0))
    $now = time()
    if ($revokedAt !== null) {
      $tokenRow = result_err('revoked')
    } else if ($expiresAt !== null && $expiresAt <= $now) {
      $tokenRow = result_err('expired')
    } else if (!authHasScopeMask($scopeMask, (int) $requiredMask)) {
      $tokenRow = result_err('scope')
    } else {
      clientUpdateWhere($client, 
        $client.models.LhApiToken,
        eq('id', (int) rowValue($tokenValue, 'id', 0)),
        { last_used_at: gmdate('c') },
        false
      )
      $user = clientSelectOne($client, 
        $client.models.LhUser,
        eq('id', (int) rowValue($tokenValue, 'user_id', rowValue($tokenValue, 'userId', 0)))
      )
      if (result_is_ok($user)) {
        $userValue = $user->value
        if (is_array($userValue)) {
          $userValue['tokenId'] = rowValue($tokenValue, 'id', 0)
          $userValue['scopeMask'] = $scopeMask
        } else {
          $userValue->tokenId = rowValue($tokenValue, 'id', 0)
          $userValue->scopeMask = $scopeMask
        }
        $tokenRow = result_ok($userValue)
      } else {
        $tokenRow = result_err($user->error)
      }
    }
  }
  dbClose($db)
  if (!result_is_ok($tokenRow)) {
    return [ 'ok' => false, 'error' => 'invalid or insufficient PAT scope' ]
  }
  return [
    'ok' => true,
    'kind' => 'pat',
    'scopeMask' => (int) rowValue($tokenRow->value, 'scopeMask', rowValue($tokenRow->value, 'scope_mask', 0)),
    'user' => $tokenRow->value
  ]
}

function authWithScope($requiredMask = 1) {
  $required = (int) $requiredMask
  $session = authCurrentUser()
  if ($session['ok']) {
    return [
      'ok' => true,
      'kind' => 'session',
      'scopeMask' => 7,
      'user' => $session['user']
    ]
  }
  $pat = authPatFromBearer($required)
  if ($pat['ok']) {
    return $pat
  }
  return [ 'ok' => false, 'error' => 'not authenticated or insufficient scope' ]
}

function oauthBeginFlow() {
  $rateIp = enforceIpRateLimit('auth.login.ip', 30, 60)
  if (!$rateIp['ok']) {
    return [ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.login.ip' ]
  }
  $cfg = oauthConfig()
  if ($cfg->clientId === '') {
    return [ 'ok' => false, 'error' => 'oauth client id is not configured (LINKHASH_OAUTH_CLIENT_ID)' ]
  }
  if (!oauthCallbackAllowed($cfg->callback)) {
    return [ 'ok' => false, 'error' => 'oauth callback is not allowlisted', 'callback' => $cfg->callback ]
  }
  $state = devRandomHex(16)
  $verifier = devRandomHex(64)
  $challenge = oauthPkceChallenge($verifier)
  cookieSetHeader('lh_oauth_ctx', oauthPackContext($state, $verifier), [
    'path' => '/',
    'max_age' => 600,
    'same_site' => 'Lax',
    'http_only' => true,
    'secure' => cookieSecureFlag()
  ])
  $authUrl = $cfg->authUrl . '?' . formUrlEncode([
    'client_id' => $cfg->clientId,
    'redirect_uri' => $cfg->callback,
    'response_type' => 'code',
    'state' => $state,
    'scope' => $cfg->scope,
    'code_challenge' => $challenge,
    'code_challenge_method' => 'S256'
  ])
  return [
    'ok' => true,
    'auth_url' => $authUrl,
    'provider' => 'bluesky',
    'pkce' => 'S256'
  ]
}

function apiAuthLogin() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $start = oauthBeginFlow()
  if (!$start['ok']) {
    auditEvent('auth.login', [ 'ok' => false ], 'error', 'oauth', 'start', [ 'error' => $start['error'] ])
    echo jsonReply($start)
    return
  }
  auditEvent('auth.login', [ 'ok' => false ], 'ok', 'oauth', 'start', [])
  if (wantsHtmlResponse()) {
    redirectTo($start['auth_url'])
    return
  }
  echo jsonReply($start)
}

function apiAuthCallback() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $rateIp = enforceIpRateLimit('auth.callback.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.callback.ip' ])
    return
  }
  $cfg = oauthConfig()
  if ($cfg->clientId === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'oauth client id is not configured (LINKHASH_OAUTH_CLIENT_ID)' ])
    return
  }
  if (!oauthCallbackAllowed($cfg->callback)) {
    echo jsonReply([ 'ok' => false, 'error' => 'oauth callback is not allowlisted', 'callback' => $cfg->callback ])
    return
  }

  $state = '' . queryValue('state', '')
  $code = '' . queryValue('code', '')
  $ctx = oauthUnpackContext(requestCookie('lh_oauth_ctx', ''))
  $expectedState = $ctx === null ? ('' . requestCookie('lh_oauth_state', '')) : ('' . $ctx->state)
  $pkce = $ctx === null ? ('' . requestCookie('lh_oauth_pkce', '')) : ('' . $ctx->pkce)
  if ($state === '' || $state !== $expectedState) {
    echo jsonReply([ 'ok' => false, 'error' => 'invalid oauth state' ])
    return
  }
  if ($code === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'missing oauth code' ])
    return
  }
  if ($pkce === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'missing pkce verifier cookie' ])
    return
  }

  $tokenBody = [
    'grant_type' => 'authorization_code',
    'client_id' => $cfg->clientId,
    'code' => $code,
    'redirect_uri' => $cfg->callback,
    'code_verifier' => $pkce
  ]
  if ($cfg->clientSecret !== '') {
    $tokenBody['client_secret'] = $cfg->clientSecret
  }
  $tokenRes = httpRequestRaw('POST', $cfg->tokenUrl, [
    'Content-Type' => 'application/x-www-form-urlencoded',
    'Accept' => 'application/json'
  ], formUrlEncode($tokenBody))
  if (!is_array($tokenRes) || !$tokenRes['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => 'token exchange request failed', 'details' => $tokenRes ])
    return
  }
  if ((int) $tokenRes['status'] < 200 || (int) $tokenRes['status'] >= 300) {
    echo jsonReply([ 'ok' => false, 'error' => 'token exchange rejected', 'status' => $tokenRes['status'], 'body' => $tokenRes['body'] ])
    return
  }
  $tokenDecoded = decodeJsonLike($tokenRes['body'], null)
  if (!is_array($tokenDecoded)) {
    echo jsonReply([ 'ok' => false, 'error' => 'invalid token response json' ])
    return
  }
  $tokens = $tokenDecoded
  if (!array_key_exists('access_token', $tokens) || ('' . $tokens['access_token']) === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'token response missing access_token', 'response' => $tokens ])
    return
  }
  $accessToken = '' . $tokens['access_token']
  $profileRes = oauthFetchProfile($accessToken, $cfg)
  if (!$profileRes['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => 'failed to fetch oauth profile', 'details' => $profileRes ])
    return
  }

  $did = '' . $profileRes['did']
  $handle = '' . $profileRes['handle']
  $displayName = '' . $profileRes['displayName']
  if (!isValidHandleName($handle) || isReservedHandle($handle)) {
    echo jsonReply([ 'ok' => false, 'error' => 'reserved or invalid handle' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $user = authUpsertUserByDid($db, $did, $handle, $displayName)
  if (result_is_ok($user)) {
    ensureUserOrgMembership($db, $user->value)
  }
  dbClose($db)
  if (!result_is_ok($user)) {
    auditEvent('auth.callback', [ 'ok' => false ], 'error', 'user', $handle, [ 'error' => $user->error ])
    echo jsonReply([ 'ok' => false, 'error' => $user->error ])
    return
  }
  $issue = authIssueSession($handle, '' . rowValue($user->value, 'id', '0'))
  if (!$issue['ok']) {
    auditEvent('auth.callback', [ 'ok' => false ], 'error', 'user', $handle, [ 'error' => $issue['error'] ])
    echo jsonReply([ 'ok' => false, 'error' => $issue['error'] ])
    return
  }
  auditEvent('auth.callback', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $user->value ], 'ok', 'user', '' . rowValue($user->value, 'id', '0'), [ 'handle' => $handle ])
  cookieClearHeader('lh_oauth_ctx', ['path' => '/'])
  cookieClearHeader('lh_oauth_state', ['path' => '/'])
  cookieClearHeader('lh_oauth_pkce', ['path' => '/'])
  if (wantsHtmlResponse()) {
    redirectTo('/account')
    return
  }
  echo jsonReply([
    'ok' => true,
    'user' => $user->value,
    'provider' => 'bluesky',
    'session' => $issue['token'],
    'csrf' => $issue['csrf']
  ])
}

function apiAuthDevLogin() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $rateIp = enforceIpRateLimit('auth.dev_login.ip', 30, 60)
  if (!$rateIp['ok']) {
    logEvent('warn', 'auth.dev_login.rate_limit_unavailable', { error: $rateIp['error'] })
  }
  $handle = '' . queryValue('handle', 'samifou.ad')
  if (!isValidHandleName($handle) || isReservedHandle($handle)) {
    echo jsonReply([ 'ok' => false, 'error' => 'reserved or invalid handle' ])
    return
  }
  $did = '' . queryValue('did', ('did:plc:' . str_replace('.', '', $handle)))
  $displayName = '' . queryValue('display_name', $handle)
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $user = authUpsertUserByDid($db, $did, $handle, $displayName)
  if (result_is_ok($user)) {
    ensureUserOrgMembership($db, $user->value)
  }
  dbClose($db)
  if (!result_is_ok($user)) {
    auditEvent('auth.dev_login', [ 'ok' => false ], 'error', 'user', $handle, [ 'error' => $user->error ])
    echo jsonReply([ 'ok' => false, 'error' => $user->error ])
    return
  }
  $issue = authIssueSession($handle, '' . rowValue($user->value, 'id', '0'))
  if ($issue['ok']) {
    auditEvent('auth.dev_login', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $user->value ], 'ok', 'user', '' . rowValue($user->value, 'id', '0'), [ 'handle' => $handle, 'mode' => 'db-session' ])
    if (wantsHtmlResponse()) {
      redirectTo('/account')
      return
    }
    echo jsonReply([ 'ok' => true, 'user' => $user->value, 'session' => $issue['token'], 'csrf' => $issue['csrf'], 'mode' => 'db-session' ])
    return
  }

  $csrf = 'lhcsrf_' . devRandomHex(32)
  $devSession = 'lhs_dev:' . rowValue($user->value, 'id', '0') . ':' . $csrf . ':' . devRandomHex(12)
  $maxSecs = (int) authMaxTimeoutSeconds()
  cookieSetHeader('lh_session', $devSession, [
    'path' => '/',
    'max_age' => $maxSecs,
    'same_site' => 'Lax',
    'http_only' => true,
    'secure' => cookieSecureFlag()
  ])
  auditEvent('auth.dev_login', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $user->value ], 'warn', 'user', '' . rowValue($user->value, 'id', '0'), [ 'handle' => $handle, 'mode' => 'dev-cookie-fallback', 'issueError' => $issue['error'] ])
  if (wantsHtmlResponse()) {
    redirectTo('/account')
    return
  }
  echo jsonReply([ 'ok' => true, 'user' => $user->value, 'session' => $devSession, 'csrf' => $csrf, 'mode' => 'dev-cookie', 'warning' => $issue['error'] ])
}

function apiAuthLogout() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $sessionToken = authRequestToken()
  if ($sessionToken === null || $sessionToken === '') {
    cookieClearHeader('lh_session', ['path' => '/'])
    auditEvent('auth.logout', [ 'ok' => false ], 'ok', 'session', 'none', [])
    echo jsonReply([ 'ok' => true ])
    return
  }
  $me = authCurrentUser()
  if ($me['ok']) {
    $csrf = authValidateCsrfForSessionUser($me['user'])
    if (!$csrf['ok']) {
      echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
      return
    }
  }
  if ($sessionToken !== null && $sessionToken !== '') {
    $tokenHash = authTokenHash($sessionToken)
    $conn = openDbHandle()
    if (result_is_ok($conn)) {
      $db = $conn->value
      $client = dbClient($db)
      clientUpdateWhere($client, 
        $client.models.LhSession,
        eq('session_token_hash', $tokenHash),
        { revoked_at: gmdate('c') },
        false
      )
      dbClose($db)
    }
  }
  cookieClearHeader('lh_session', ['path' => '/'])
  auditEvent('auth.logout', $me['ok'] ? [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ] : [ 'ok' => false ], 'ok', 'session', 'active', [])
  if (wantsHtmlResponse()) {
    redirectTo('/')
    return
  }
  echo jsonReply([ 'ok' => true ])
}

function apiAuthMe() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $u = $me['user']
  echo jsonReply([
    'ok' => true,
    'user' => [
      'id' => rowValue($u, 'id', null),
      'did' => rowValue($u, 'did', null),
      'handle' => rowValue($u, 'handle', null),
      'displayName' => rowValue($u, 'displayName', rowValue($u, 'displayname', null)),
      'avatarUrl' => rowValue($u, 'avatarUrl', rowValue($u, 'avatarurl', null))
    ]
  ])
}

function apiAuthPatCreate() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $userId = (int) rowValue($me['user'], 'id', 0)
  $rateUser = enforceUserRateLimit('auth.pat_mutate.user', $userId, 10, 60)
  if (!$rateUser['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateUser['error'], 'bucket' => 'auth.pat_mutate.user' ])
    return
  }
  $rateIp = enforceIpRateLimit('auth.pat_mutate.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.pat_mutate.ip' ])
    return
  }
  $csrf = authValidateCsrfForSessionUser($me['user'])
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $body = requestData()
  $label = array_key_exists('label', $body) ? ('' . $body['label']) : ('' . queryValue('label', 'default'))
  $scopeText = array_key_exists('scope', $body) ? ('' . $body['scope']) : ('' . queryValue('scope', 'read:write'))
  $expiresDays = (int) (array_key_exists('expires_days', $body) ? $body['expires_days'] : queryValue('expires_days', 30))

  $prefix = devRandomHex(8)
  $rawToken = 'lh_pat_' . $prefix . '_' . devRandomHex(24)
  $tokenHash = authTokenHash($rawToken)
  $scopeMask = authScopeMask($scopeText)
  $expiresDaysClamped = '' . max(1, $expiresDays)

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $expiresAt = gmdate('c', time() + ((int) $expiresDaysClamped * 86400))
  $ins = clientInsertOne($client, 
    $client.models.LhApiToken,
    {
      user_id: (int) rowValue($me['user'], 'id', 0),
      token_prefix: $prefix,
      token_hash: $tokenHash,
      scope_mask: (int) $scopeMask,
      label: $label,
      expires_at: $expiresAt,
      created_at: gmdate('c')
    },
    false
  )
  dbClose($db)
  if (!result_is_ok($ins)) {
    auditEvent('pat.create', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'error', 'pat', 'create', [ 'error' => $ins->error ])
    echo jsonReply([ 'ok' => false, 'error' => $ins->error ])
    return
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $meta = clientSelectOne($client, $client.models.LhApiToken, eq('token_hash', $tokenHash))
  dbClose($db)
  if (!result_is_ok($meta)) {
    echo jsonReply([ 'ok' => false, 'error' => $meta->error ])
    return
  }
  auditEvent('pat.create', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'ok', 'pat', '' . rowValue($meta->value, 'id', '0'), [ 'label' => $label, 'scopeMask' => $scopeMask, 'expiresDays' => $expiresDaysClamped ])

  echo jsonReply([
    'ok' => true,
    'token' => $rawToken,
    'token_hint' => $prefix,
    'meta' => $meta->value
  ])
}

function apiAuthPatList() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $rows = clientSelectMany($client, 
    $client.models.LhApiToken,
    eq('user_id', (int) rowValue($me['user'], 'id', 0)),
    desc('created_at')
  )
  dbClose($db)
  if (!result_is_ok($rows)) {
    echo jsonReply([ 'ok' => false, 'error' => $rows->error ])
    return
  }
  $out = []
  foreach ($rows->value as $row) {
    if (rowValue($row, 'revokedat', rowValue($row, 'revoked_at', null)) !== null) {
      continue
    }
    $scopeMask = (int) rowValue($row, 'scopemask', rowValue($row, 'scope_mask', 0))
    $lastUsedAt = rowValue($row, 'last_used_at', rowValue($row, 'lastusedat', null))
    $out[] = [
      'id' => rowValue($row, 'id', 0),
      'tokenPrefix' => rowValue($row, 'tokenprefix', rowValue($row, 'token_prefix', '')),
      'label' => rowValue($row, 'label', ''),
      'scopeMask' => $scopeMask,
      'scope' => authScopeText($scopeMask),
      'used' => $lastUsedAt !== null && ('' . $lastUsedAt) !== '',
      'lastUsedAt' => $lastUsedAt,
      'expiresAt' => rowValue($row, 'expiresat', rowValue($row, 'expires_at', null)),
      'createdAt' => rowValue($row, 'createdat', rowValue($row, 'created_at', null))
    ]
  }
  echo jsonReply([ 'ok' => true, 'tokens' => $out ])
}

function apiAuthPatRevoke() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $userId = (int) rowValue($me['user'], 'id', 0)
  $rateUser = enforceUserRateLimit('auth.pat_mutate.user', $userId, 10, 60)
  if (!$rateUser['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateUser['error'], 'bucket' => 'auth.pat_mutate.user' ])
    return
  }
  $rateIp = enforceIpRateLimit('auth.pat_mutate.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.pat_mutate.ip' ])
    return
  }
  $csrf = authValidateCsrfForSessionUser($me['user'])
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $body = requestData()
  $id = (int) (array_key_exists('id', $body) ? $body['id'] : queryValue('id', 0))
  if ($id <= 0) {
    echo jsonReply([ 'ok' => false, 'error' => 'id is required' ])
    return
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $res = clientUpdateWhere($client, 
    $client.models.LhApiToken,
    andWhere(
      eq('id', (int) $id),
      eq('user_id', (int) rowValue($me['user'], 'id', 0))
    ),
    { revoked_at: gmdate('c') },
    false
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    auditEvent('pat.revoke', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'error', 'pat', '' . $id, [ 'error' => $res->error ])
    echo jsonReply([ 'ok' => false, 'error' => $res->error ])
    return
  }
  auditEvent('pat.revoke', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'ok', 'pat', '' . $id, [])
  echo jsonReply([ 'ok' => true, 'id' => $id ])
}

function apiAuthPatRevokeAll() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $userId = (int) rowValue($me['user'], 'id', 0)
  $rateUser = enforceUserRateLimit('auth.pat_mutate.user', $userId, 10, 60)
  if (!$rateUser['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateUser['error'], 'bucket' => 'auth.pat_mutate.user' ])
    return
  }
  $rateIp = enforceIpRateLimit('auth.pat_mutate.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.pat_mutate.ip' ])
    return
  }
  $csrf = authValidateCsrfForSessionUser($me['user'])
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $res = clientUpdateWhere($client, 
    $client.models.LhApiToken,
    andWhere(
      eq('user_id', (int) rowValue($me['user'], 'id', 0)),
      isNull('revoked_at')
    ),
    { revoked_at: gmdate('c') },
    false
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    auditEvent('pat.revoke_all', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'error', 'pat', 'all', [ 'error' => $res->error ])
    echo jsonReply([ 'ok' => false, 'error' => $res->error ])
    return
  }
  auditEvent('pat.revoke_all', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'ok', 'pat', 'all', [])
  echo jsonReply([ 'ok' => true ])
}

function fetchPatListForUserId($userId) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error, 'tokens' => [] ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $rows = clientSelectMany($client, 
    $client.models.LhApiToken,
    andWhere(
      eq('user_id', (int) $userId),
      isNull('revoked_at')
    ),
    desc('created_at')
  )
  dbClose($db)
  if (!result_is_ok($rows)) {
    return [ 'ok' => false, 'error' => $rows->error, 'tokens' => [] ]
  }
  $out = []
  foreach ($rows->value as $row) {
    $scopeMask = (int) rowValue($row, 'scopemask', rowValue($row, 'scope_mask', 0))
    $out[] = [
      'id' => (int) rowValue($row, 'id', 0),
      'tokenPrefix' => rowValue($row, 'tokenprefix', rowValue($row, 'token_prefix', '')),
      'label' => rowValue($row, 'label', ''),
      'scopeMask' => $scopeMask,
      'scope' => authScopeText($scopeMask),
      'lastUsedAt' => rowValue($row, 'lastusedat', rowValue($row, 'last_used_at', null)),
      'expiresAt' => rowValue($row, 'expiresat', rowValue($row, 'expires_at', null)),
      'createdAt' => rowValue($row, 'createdat', rowValue($row, 'created_at', null))
    ]
  }
  return [ 'ok' => true, 'tokens' => $out ]
}

function fetchOrgsForUserId($userId) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error, 'orgs' => [] ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $members = clientSelectMany($client, 
    $client.models.LhOrgMember,
    andWhere(
      eq('user_id', (int) $userId),
      isNull('revoked_at')
    )
  )
  $orgsRes = clientSelectMany($client, $client.models.LhOrg, null, asc('handle'))
  dbClose($db)
  if (!result_is_ok($members)) {
    return [ 'ok' => false, 'error' => $members->error, 'orgs' => [] ]
  }
  if (!result_is_ok($orgsRes)) {
    return [ 'ok' => false, 'error' => $orgsRes->error, 'orgs' => [] ]
  }
  $orgMap = []
  foreach ($orgsRes->value as $org) {
    $orgMap[(int) rowValue($org, 'id', 0)] = $org
  }
  $out = []
  foreach ($members->value as $row) {
    $orgId = (int) rowValue($row, 'org_id', rowValue($row, 'orgId', 0))
    if (!array_key_exists($orgId, $orgMap)) {
      continue
    }
    $org = $orgMap[$orgId]
    $out[] = [
      'id' => (int) rowValue($org, 'id', 0),
      'handle' => rowValue($org, 'handle', ''),
      'visibility' => rowValue($org, 'visibility', 'public'),
      'role' => rowValue($row, 'role', 'maintainer')
    ]
  }
  return [ 'ok' => true, 'orgs' => $out ]
}

function accountCreatePat($user, $label, $scope, $days) {
  $userId = (int) rowValue($user, 'id', 0)
  if ($userId <= 0) {
    return [ 'ok' => false, 'error' => 'invalid user' ]
  }
  $prefix = devRandomHex(8)
  $rawToken = 'lh_pat_' . $prefix . '_' . devRandomHex(24)
  $tokenHash = authTokenHash($rawToken)
  $scopeMask = authScopeMask($scope)
  $expiresDays = max(1, (int) $days)

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $expiresAt = gmdate('c', time() + ($expiresDays * 86400))
  $ins = clientInsertOne($client, 
    $client.models.LhApiToken,
    {
      user_id: $userId,
      token_prefix: $prefix,
      token_hash: $tokenHash,
      scope_mask: (int) $scopeMask,
      label: '' . $label,
      expires_at: $expiresAt,
      created_at: gmdate('c')
    },
    false
  )
  dbClose($db)
  if (!result_is_ok($ins)) {
    return [ 'ok' => false, 'error' => $ins->error ]
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $meta = clientSelectOne($client, $client.models.LhApiToken, eq('token_hash', $tokenHash))
  dbClose($db)
  if (!result_is_ok($meta)) {
    return [ 'ok' => false, 'error' => $meta->error ]
  }
  return [ 'ok' => true, 'token' => $rawToken, 'id' => rowValue($meta->value, 'id', 0) ]
}

function accountRevokePat($user, $id) {
  $userId = (int) rowValue($user, 'id', 0)
  $tokenId = (int) $id
  if ($userId <= 0 || $tokenId <= 0) {
    return [ 'ok' => false, 'error' => 'invalid revoke request' ]
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $res = clientUpdateWhere($client, 
    $client.models.LhApiToken,
    andWhere(
      eq('id', $tokenId),
      eq('user_id', $userId)
    ),
    { revoked_at: gmdate('c') },
    false
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    return [ 'ok' => false, 'error' => $res->error ]
  }
  return [ 'ok' => true ]
}

function accountRevokeAllPat($user) {
  $userId = (int) rowValue($user, 'id', 0)
  if ($userId <= 0) {
    return [ 'ok' => false, 'error' => 'invalid user' ]
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $res = clientUpdateWhere($client, 
    $client.models.LhApiToken,
    andWhere(
      eq('user_id', $userId),
      isNull('revoked_at')
    ),
    { revoked_at: gmdate('c') },
    false
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    return [ 'ok' => false, 'error' => $res->error ]
  }
  return [ 'ok' => true ]
}

function apiOrgsMine() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $userId = authUserId($auth)
  $res = fetchOrgsForUserId($userId)
  if (!$res['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $res['error'] ])
    return
  }
  $orgs = rowValue($res, 'orgs', [])
  echo jsonReply([ 'ok' => true, 'orgs' => $orgs, 'total' => count($orgs) ])
}

function apiOrgsCreate() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(4)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $handle = normalizeHandleName(queryValue('handle', array_key_exists('handle', $body) ? $body['handle'] : ''))
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : 'public'), 'public')
  if (!isValidHandleName($handle) || isReservedHandle($handle)) {
    echo jsonReply([ 'ok' => false, 'error' => 'reserved or invalid org handle' ])
    return
  }
  if ($visibility === null) {
    echo jsonReply({ ok: false, error: 'visibility must be public or private' })
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $org = clientSelectOne($client, $client.models.LhOrg, eq('handle', $handle))
  if (!result_is_ok($org)) {
    if (!isNoRowsError($org->error)) {
      dbClose($db)
      echo jsonReply([ 'ok' => false, 'error' => $org->error ])
      return
    }
    $created = clientInsertOne($client, 
      $client.models.LhOrg,
      { handle: $handle, visibility: $visibility },
      false
    )
    if (!result_is_ok($created)) {
      dbClose($db)
      echo jsonReply([ 'ok' => false, 'error' => $created->error ])
      return
    }
    $org = clientSelectOne($client, $client.models.LhOrg, eq('handle', $handle))
    if (!result_is_ok($org)) {
      dbClose($db)
      echo jsonReply([ 'ok' => false, 'error' => $org->error ])
      return
    }
  } else {
    clientUpdateWhere($client, 
      $client.models.LhOrg,
      eq('id', (int) rowValue($org->value, 'id', 0)),
      { updated_at: gmdate('c') },
      false
    )
  }

  $orgId = (int) rowValue($org->value, 'id', 0)
  $member = clientSelectOne($client, 
    $client.models.LhOrgMember,
    andWhere(
      eq('org_id', $orgId),
      eq('user_id', (int) $userId)
    )
  )
  if (result_is_ok($member)) {
    $memberUpdate = clientUpdateWhere($client, 
      $client.models.LhOrgMember,
      eq('id', (int) rowValue($member->value, 'id', 0)),
      { role: 'publisher', revoked_at: null },
      false
    )
    if (!result_is_ok($memberUpdate)) {
      dbClose($db)
      auditEvent('org.create', $auth, 'error', 'org', $handle, [ 'error' => $memberUpdate->error ])
      echo jsonReply([ 'ok' => false, 'error' => $memberUpdate->error ])
      return
    }
  } else if (isNoRowsError($member->error)) {
    $memberInsert = clientInsertOne($client, 
      $client.models.LhOrgMember,
      { org_id: $orgId, user_id: (int) $userId, role: 'publisher' },
      false
    )
    if (!result_is_ok($memberInsert)) {
      dbClose($db)
      auditEvent('org.create', $auth, 'error', 'org', $handle, [ 'error' => $memberInsert->error ])
      echo jsonReply([ 'ok' => false, 'error' => $memberInsert->error ])
      return
    }
  } else {
    dbClose($db)
    auditEvent('org.create', $auth, 'error', 'org', $handle, [ 'error' => $member->error ])
    echo jsonReply([ 'ok' => false, 'error' => $member->error ])
    return
  }
  dbClose($db)
  auditEvent('org.create', $auth, 'ok', 'org', $handle, [ 'orgId' => $orgId, 'visibility' => $visibility ])
  echo jsonReply([ 'ok' => true, 'org' => $org->value ])
}

function apiOrgMembersList() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $userId = authUserId($auth)
  $orgId = (int) queryValue('orgId', 0)
  if ($orgId <= 0) {
    echo jsonReply([ 'ok' => false, 'error' => 'orgId is required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  if (!canEditOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org access' ])
    return
  }
  $client = dbClient($db)
  $members = clientSelectMany($client, 
    $client.models.LhOrgMember,
    andWhere(
      eq('org_id', $orgId),
      isNull('revoked_at')
    ),
    asc('created_at')
  )
  $users = clientSelectMany($client, $client.models.LhUser)
  dbClose($db)
  if (!result_is_ok($members)) {
    echo jsonReply([ 'ok' => false, 'error' => $members->error ])
    return
  }
  if (!result_is_ok($users)) {
    echo jsonReply([ 'ok' => false, 'error' => $users->error ])
    return
  }
  $out = []
  $userMap = []
  foreach ($users->value as $user) {
    $userMap[(int) rowValue($user, 'id', 0)] = $user
  }
  foreach ($members->value as $row) {
    $uid = (int) rowValue($row, 'user_id', rowValue($row, 'userId', 0))
    if (!array_key_exists($uid, $userMap)) {
      continue
    }
    $user = $userMap[$uid]
    $out[] = [
      'userId' => $uid,
      'handle' => rowValue($user, 'handle', ''),
      'displayName' => rowValue($user, 'display_name', rowValue($user, 'displayName', null)),
      'role' => rowValue($row, 'role', '')
    ]
  }
  echo jsonReply([ 'ok' => true, 'members' => $out, 'total' => count($out) ])
}

function apiOrgMembersUpsert() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(4)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $targetHandle = normalizeHandleName(queryValue('handle', array_key_exists('handle', $body) ? $body['handle'] : ''))
  $role = strtolower(trim('' . queryValue('role', array_key_exists('role', $body) ? $body['role'] : 'maintainer')))
  if ($orgId <= 0 || $targetHandle === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'orgId and handle are required' ])
    return
  }
  if (!allowedMemberRole($role)) {
    echo jsonReply([ 'ok' => false, 'error' => 'role must be publisher, maintainer, or public' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  if (!canManageOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org manage access' ])
    return
  }
  $client = dbClient($db)
  $target = clientSelectOne($client, $client.models.LhUser, ilike('handle', $targetHandle))
  if (!result_is_ok($target)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $targetId = '' . rowValue($target->value, 'id', '0')
  if ($targetId === '0') {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $existing = clientSelectOne($client, 
    $client.models.LhOrgMember,
    andWhere(
      eq('org_id', (int) $orgId),
      eq('user_id', (int) $targetId)
    )
  )
  if (result_is_ok($existing)) {
    $up = clientUpdateWhere($client, 
      $client.models.LhOrgMember,
      eq('id', (int) rowValue($existing->value, 'id', 0)),
      { role: $role, revoked_at: null },
      false
    )
  } else if (isNoRowsError($existing->error)) {
    $up = clientInsertOne($client, 
      $client.models.LhOrgMember,
      { org_id: (int) $orgId, user_id: (int) $targetId, role: $role },
      false
    )
  } else {
    $up = $existing
  }
  dbClose($db)
  if (!result_is_ok($up)) {
    auditEvent('org.member.upsert', $auth, 'error', 'org', '' . $orgId, [ 'handle' => $targetHandle, 'role' => $role, 'error' => $up->error ])
    echo jsonReply([ 'ok' => false, 'error' => $up->error ])
    return
  }
  auditEvent('org.member.upsert', $auth, 'ok', 'org', '' . $orgId, [ 'handle' => $targetHandle, 'role' => $role ])
  echo jsonReply([ 'ok' => true, 'orgId' => $orgId, 'handle' => $targetHandle, 'role' => $role ])
}

function apiOrgMembersRemove() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(4)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $targetHandle = normalizeHandleName(queryValue('handle', array_key_exists('handle', $body) ? $body['handle'] : ''))
  if ($orgId <= 0 || $targetHandle === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'orgId and handle are required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  if (!canManageOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org manage access' ])
    return
  }
  $client = dbClient($db)
  $target = clientSelectOne($client, $client.models.LhUser, ilike('handle', $targetHandle))
  if (!result_is_ok($target)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $targetId = '' . rowValue($target->value, 'id', '0')
  if ($targetId === '0') {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $selfId = '' . $userId
  if ($targetId === $selfId) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'cannot remove your own membership' ])
    return
  }
  $up = clientUpdateWhere($client, 
    $client.models.LhOrgMember,
    andWhere(
      eq('org_id', (int) $orgId),
      eq('user_id', (int) $targetId),
      isNull('revoked_at')
    ),
    { revoked_at: gmdate('c') },
    false
  )
  dbClose($db)
  if (!result_is_ok($up)) {
    auditEvent('org.member.remove', $auth, 'error', 'org', '' . $orgId, [ 'handle' => $targetHandle, 'error' => $up->error ])
    echo jsonReply([ 'ok' => false, 'error' => $up->error ])
    return
  }
  auditEvent('org.member.remove', $auth, 'ok', 'org', '' . $orgId, [ 'handle' => $targetHandle ])
  echo jsonReply([ 'ok' => true, 'orgId' => $orgId, 'handle' => $targetHandle ])
}

function apiPackageSetVisibility() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $name = normalizePackageName(queryValue('name', array_key_exists('name', $body) ? $body['name'] : ''))
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : ''), null)
  if ($name === '' || $visibility === null) {
    echo jsonReply([ 'ok' => false, 'error' => 'name and valid visibility are required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $pkg = clientSelectOne($client, $client.models.Package, ilike('name', $name))
  if (!result_is_ok($pkg)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'package not found' ])
    return
  }
  $orgId = (int) rowValue($pkg->value, 'orgId', rowValue($pkg->value, 'org_id', 0))
  if ($orgId <= 0 || !canEditOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org edit access' ])
    return
  }
  $up = clientUpdateWhere($client, 
    $client.models.Package,
    eq('id', (int) rowValue($pkg->value, 'id', 0)),
    { visibility: $visibility },
    false
  )
  dbClose($db)
  if (!result_is_ok($up)) {
    echo jsonReply([ 'ok' => false, 'error' => $up->error ])
    return
  }
  echo jsonReply([ 'ok' => true, 'name' => $name, 'visibility' => $visibility ])
}

function sha256Hex($value) {
  if (function_exists('hash')) {
    return strtolower(hash('sha256', '' . $value))
  }
  return stableDigestHex($value, 64)
}

function hmacSha256Hex($key, $data) {
  if (function_exists('hash_hmac')) {
    return strtolower(hash_hmac('sha256', '' . $data, '' . $key))
  }
  return stableDigestHex(('' . $key) . ':' . ('' . $data), 64)
}

function hmacSha256Raw($key, $data) {
  if (function_exists('hash_hmac')) {
    return hash_hmac('sha256', '' . $data, '' . $key, true)
  }
  return sha256Raw(('' . $key) . ':' . ('' . $data))
}

function r2BackendMode() {
  return strtolower(trim('' . envValue('LINKHASH_ARTIFACT_BACKEND', 'local')))
}

function r2Enabled() {
  $mode = r2BackendMode()
  return $mode === 'r2' || $mode === 'auto'
}

function r2Bucket() {
  return trim('' . envValue('LINKHASH_R2_BUCKET', ''))
}

function r2AccountId() {
  return trim('' . envValue('LINKHASH_R2_ACCOUNT_ID', ''))
}

function r2AccessKeyId() {
  return trim('' . envValue('LINKHASH_R2_ACCESS_KEY_ID', ''))
}

function r2SecretAccessKey() {
  return trim('' . envValue('LINKHASH_R2_SECRET_ACCESS_KEY', ''))
}

function r2Region() {
  $v = trim('' . envValue('LINKHASH_R2_REGION', 'auto'))
  return $v === '' ? 'auto' : $v
}

function r2EndpointHost() {
  $explicit = trim('' . envValue('LINKHASH_R2_ENDPOINT', ''))
  if ($explicit !== '') {
    if (strpos($explicit, 'http://') === 0) {
      return substr($explicit, strlen('http://'))
    }
    if (strpos($explicit, 'https://') === 0) {
      return substr($explicit, strlen('https://'))
    }
    return $explicit
  }
  $acct = r2AccountId()
  if ($acct === '') {
    return ''
  }
  return $acct . '.r2.cloudflarestorage.com'
}

function r2ConfigValid() {
  return r2Bucket() !== '' && r2EndpointHost() !== '' && r2AccessKeyId() !== '' && r2SecretAccessKey() !== ''
}

function r2EncodePath($bucket, $key) {
  $parts = explode('/', '' . $key)
  $encoded = []
  foreach ($parts as $part) {
    $encoded[] = rawurlencode($part)
  }
  return '/' . rawurlencode('' . $bucket) . '/' . implode('/', $encoded)
}

function r2SignV4($method, $canonicalPath, $payload, $host) {
  $accessKey = r2AccessKeyId()
  $secret = r2SecretAccessKey()
  $region = r2Region()
  $amzDate = gmdate('Ymd\THis\Z')
  $dateStamp = gmdate('Ymd')
  $payloadHash = sha256Hex($payload)

  $canonicalHeaders =
    'host:' . strtolower('' . $host) . "\n" .
    'x-amz-content-sha256:' . $payloadHash . "\n" .
    'x-amz-date:' . $amzDate . "\n"
  $signedHeaders = 'host;x-amz-content-sha256;x-amz-date'
  $canonicalRequest =
    strtoupper('' . $method) . "\n" .
    $canonicalPath . "\n" .
    "\n" .
    $canonicalHeaders . "\n" .
    $signedHeaders . "\n" .
    $payloadHash

  $scope = $dateStamp . '/' . $region . '/s3/aws4_request'
  $stringToSign =
    'AWS4-HMAC-SHA256' . "\n" .
    $amzDate . "\n" .
    $scope . "\n" .
    sha256Hex($canonicalRequest)

  $kDate = hmacSha256Raw('AWS4' . $secret, $dateStamp)
  $kRegion = hmacSha256Raw($kDate, $region)
  $kService = hmacSha256Raw($kRegion, 's3')
  $kSigning = hmacSha256Raw($kService, 'aws4_request')
  $signature = strtolower(bin2hex(hmacSha256Raw($kSigning, $stringToSign)))

  $authHeader = 'AWS4-HMAC-SHA256 Credential=' . $accessKey . '/' . $scope . ', SignedHeaders=' . $signedHeaders . ', Signature=' . $signature

  return [
    'Authorization' => $authHeader,
    'x-amz-content-sha256' => $payloadHash,
    'x-amz-date' => $amzDate
  ]
}

function r2PutObject($key, $bytes, $mime = 'application/octet-stream') {
  if (!r2ConfigValid()) {
    return [ 'ok' => false, 'error' => 'r2 config incomplete' ]
  }
  $host = r2EndpointHost()
  $path = r2EncodePath(r2Bucket(), $key)
  $url = 'https://' . $host . $path
  $sigHeaders = r2SignV4('PUT', $path, $bytes, $host)
  $headers = [
    'Host' => $host,
    'Content-Type' => $mime,
    'x-amz-content-sha256' => $sigHeaders['x-amz-content-sha256'],
    'x-amz-date' => $sigHeaders['x-amz-date'],
    'Authorization' => $sigHeaders['Authorization']
  ]
  $res = httpRequestRaw('PUT', $url, $headers, $bytes)
  if (!is_array($res) || !$res['ok']) {
    return [ 'ok' => false, 'error' => 'r2 request failed', 'details' => $res ]
  }
  $status = (int) $res['status']
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'r2 put rejected', 'status' => $status, 'body' => $res['body'] ]
  }
  return [ 'ok' => true ]
}

function r2GetObject($key) {
  if (!r2ConfigValid()) {
    return [ 'ok' => false, 'error' => 'r2 config incomplete' ]
  }
  $host = r2EndpointHost()
  $path = r2EncodePath(r2Bucket(), $key)
  $url = 'https://' . $host . $path
  $sigHeaders = r2SignV4('GET', $path, '', $host)
  $headers = [
    'Host' => $host,
    'x-amz-content-sha256' => $sigHeaders['x-amz-content-sha256'],
    'x-amz-date' => $sigHeaders['x-amz-date'],
    'Authorization' => $sigHeaders['Authorization']
  ]
  $res = httpRequestRaw('GET', $url, $headers, '')
  if (!is_array($res) || !$res['ok']) {
    return [ 'ok' => false, 'error' => 'r2 request failed', 'details' => $res ]
  }
  $status = (int) $res['status']
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'r2 get rejected', 'status' => $status, 'body' => $res['body'] ]
  }
  $headersOut = is_array($res['headers']) ? $res['headers'] : []
  $mime = array_key_exists('content-type', $headersOut) ? ('' . $headersOut['content-type']) : 'application/octet-stream'
  return [ 'ok' => true, 'body' => '' . $res['body'], 'mime' => $mime ]
}

function packageIsVisibleTo($db, $pkgRow, $auth) {
  $visibility = '' . rowValue($pkgRow, 'visibility', 'public')
  if ($visibility === 'public') {
    return true
  }
  if (!rowValue($auth, 'ok', false)) {
    return false
  }
  $userId = authUserId($auth)
  $orgId = (int) rowValue($pkgRow, 'orgId', rowValue($pkgRow, 'org_id', 0))
  if ($userId <= 0 || $orgId <= 0) {
    return false
  }
  return canEditOrg($db, $orgId, $userId)
}

function apiPublishPackage() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $name = normalizePackageName(queryValue('name', array_key_exists('name', $body) ? $body['name'] : ''))
  $version = trim('' . queryValue('version', array_key_exists('version', $body) ? $body['version'] : ''))
  $lockHash = trim('' . queryValue('lockHash', array_key_exists('lockHash', $body) ? $body['lockHash'] : 'dev'))
  $sha256 = trim('' . queryValue('sha256', array_key_exists('sha256', $body) ? $body['sha256'] : ''))
  $integrityAlgo = trim('' . queryValue('integrityAlgo', array_key_exists('integrityAlgo', $body) ? $body['integrityAlgo'] : ''))
  $moduleGraphHash = trim('' . queryValue('moduleGraphHash', array_key_exists('moduleGraphHash', $body) ? $body['moduleGraphHash'] : ''))
  $fsGraphHash = trim('' . queryValue('fsGraphHash', array_key_exists('fsGraphHash', $body) ? $body['fsGraphHash'] : ''))
  $mime = trim('' . queryValue('mime', array_key_exists('mime', $body) ? $body['mime'] : 'application/octet-stream'))
  $mainFile = trim('' . queryValue('mainFile', array_key_exists('mainFile', $body) ? $body['mainFile'] : 'index.phpx'))
  $artifactB64 = '' . queryValue('artifactBase64', array_key_exists('artifactBase64', $body) ? $body['artifactBase64'] : '')
  $description = '' . queryValue('description', array_key_exists('description', $body) ? $body['description'] : 'Published package')
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : 'public'), 'public')
  $filesInput = array_key_exists('files', $body) ? $body['files'] : []
  $depsInput = array_key_exists('dependencies', $body) ? $body['dependencies'] : []
  $readme = '' . queryValue('readme', array_key_exists('readme', $body) ? $body['readme'] : '')
  $capabilityInput = array_key_exists('capabilityMetadata', $body) ? $body['capabilityMetadata'] : (array_key_exists('capabilities', $body) ? [ 'declared' => $body['capabilities'] ] : null)

  if (array_key_exists('integrity', $body) && (is_array($body['integrity']) || is_object($body['integrity']))) {
    $integrity = is_array($body['integrity']) ? $body['integrity'] : (array) $body['integrity']
    if ($integrityAlgo === '' && array_key_exists('algo', $integrity)) {
      $integrityAlgo = trim('' . $integrity['algo'])
    }
    if ($moduleGraphHash === '' && array_key_exists('moduleGraphHash', $integrity)) {
      $moduleGraphHash = trim('' . $integrity['moduleGraphHash'])
    }
    if ($fsGraphHash === '' && array_key_exists('fsGraphHash', $integrity)) {
      $fsGraphHash = trim('' . $integrity['fsGraphHash'])
    }
    if (($moduleGraphHash === '' || $fsGraphHash === '') && array_key_exists('moduleGraph', $integrity)) {
      $moduleGraph = is_array($integrity['moduleGraph']) ? $integrity['moduleGraph'] : (array) $integrity['moduleGraph']
      if ($moduleGraphHash === '' && array_key_exists('hash', $moduleGraph)) {
        $moduleGraphHash = trim('' . $moduleGraph['hash'])
      }
      if ($integrityAlgo === '' && array_key_exists('algo', $moduleGraph)) {
        $integrityAlgo = trim('' . $moduleGraph['algo'])
      }
    }
    if (($moduleGraphHash === '' || $fsGraphHash === '') && array_key_exists('fsGraph', $integrity)) {
      $fsGraph = is_array($integrity['fsGraph']) ? $integrity['fsGraph'] : (array) $integrity['fsGraph']
      if ($fsGraphHash === '' && array_key_exists('hash', $fsGraph)) {
        $fsGraphHash = trim('' . $fsGraph['hash'])
      }
      if ($integrityAlgo === '' && array_key_exists('algo', $fsGraph)) {
        $integrityAlgo = trim('' . $fsGraph['algo'])
      }
    }
  }

  if ($integrityAlgo === '' && ($moduleGraphHash !== '' || $fsGraphHash !== '')) {
    $integrityAlgo = 'sha256'
  }

  $filesDecoded = decodeJsonLike($filesInput, [])
  $depsDecoded = decodeJsonLike($depsInput, [])
  $capabilityDecoded = decodeJsonLike($capabilityInput, null)
  $filesPayload = is_array($filesDecoded) ? $filesDecoded : []
  $depsPayload = is_array($depsDecoded) ? $depsDecoded : []
  $capabilityPayload = $capabilityDecoded === null ? null : $capabilityDecoded

  if ($orgId <= 0 || !isValidPackageName($name) || isReservedPackageName($name) || $version === '' || $visibility === null) {
    auditEvent('package.publish', $auth, 'error', 'package', '@' . $orgId . '/' . $name . '@' . $version, [ 'error' => 'invalid publish parameters' ])
    echo jsonReply([ 'ok' => false, 'error' => 'orgId, valid name, version, and visibility are required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  if (!canEditOrg($db, $orgId, $userId)) {
    auditEvent('package.publish', $auth, 'forbidden', 'org', '' . $orgId, [ 'name' => $name, 'version' => $version ])
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org edit access' ])
    return
  }

  $pkg = clientSelectOne($client, 
    $client.models.Package,
    andWhere(
      eq('org_id', $orgId),
      ilike('name', $name)
    )
  )
  $packageId = 0
  if (result_is_ok($pkg)) {
    $packageId = (int) rowValue($pkg->value, 'id', 0)
  } else if (isNoRowsError($pkg->error)) {
    $created = clientInsertOne($client, 
      $client.models.Package,
      {
        org_id: $orgId,
        name: $name,
        description: $description,
        latest_version: $version,
        download_count: 0,
        visibility: $visibility,
        private_read_mask: 0,
        created_at: gmdate('c'),
        updated_at: gmdate('c')
      },
      false
    )
    if (!result_is_ok($created)) {
      dbClose($db)
      echo jsonReply([ 'ok' => false, 'error' => $created->error ])
      return
    }
    $pkg = clientSelectOne($client, 
      $client.models.Package,
      andWhere(
        eq('org_id', $orgId),
        ilike('name', $name)
      )
    )
    if (!result_is_ok($pkg)) {
      dbClose($db)
      echo jsonReply([ 'ok' => false, 'error' => $pkg->error ])
      return
    }
    $packageId = (int) rowValue($pkg->value, 'id', 0)
  } else {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => $pkg->error ])
    return
  }
  if ($packageId <= 0) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'failed to resolve package id' ])
    return
  }

  $owner = clientSelectOne($client, $client.models.LhOrg, eq('id', $orgId))
  $ownerHandle = result_is_ok($owner) ? ('' . rowValue($owner->value, 'handle', 'org')) : 'org'
  $canonicalId = registryCanonicalId($ownerHandle, $name, $version, $lockHash)
  $artifactKey = registryArtifactKey($ownerHandle, $name, $version, $lockHash)

  $artifactBytes = $artifactB64 !== '' ? base64_decode($artifactB64) : ''
  if ($artifactBytes === false) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'artifactBase64 is invalid' ])
    return
  }
  $artifactSize = (int) strlen($artifactBytes)
  $artifactBackend = 'local'
  $artifactNotice = null
  if (r2Enabled()) {
    $put = r2PutObject($artifactKey, $artifactBytes, $mime)
    if ($put['ok']) {
      $artifactBackend = 'r2'
    } else {
      $artifactNotice = 'r2 upload failed; using inline postgres fallback'
    }
  }

  $verRow = clientSelectOne($client, 
    $client.models.PackageVersion,
    andWhere(
      eq('package_id', $packageId),
      eq('version', $version)
    )
  )
  if (result_is_ok($verRow)) {
    $upVer = clientUpdateWhere($client, 
      $client.models.PackageVersion,
      eq('id', (int) rowValue($verRow->value, 'id', 0)),
      {
        main_file: $mainFile,
        files: $filesPayload,
        dependencies: $depsPayload,
        readme: $readme,
        published_at: gmdate('c'),
        r2_key: null,
        sha256: $sha256,
        canonical_id: $canonicalId,
        lock_hash: $lockHash,
        integrity_algo: $integrityAlgo,
        module_graph_hash: $moduleGraphHash,
        fs_graph_hash: $fsGraphHash,
        artifact_backend: $artifactBackend,
        artifact_key: $artifactKey,
        artifact_mime: $mime,
        artifact_size_bytes: $artifactSize,
        artifact_inline_b64: $artifactB64,
        capability_metadata: $capabilityPayload
      },
      false
    )
  } else if (isNoRowsError($verRow->error)) {
    $upVer = clientInsertOne($client, 
      $client.models.PackageVersion,
      {
        package_id: $packageId,
        version: $version,
        main_file: $mainFile,
        files: $filesPayload,
        dependencies: $depsPayload,
        readme: $readme,
        published_at: gmdate('c'),
        r2_key: null,
        sha256: $sha256,
        canonical_id: $canonicalId,
        lock_hash: $lockHash,
        integrity_algo: $integrityAlgo,
        module_graph_hash: $moduleGraphHash,
        fs_graph_hash: $fsGraphHash,
        artifact_backend: $artifactBackend,
        artifact_key: $artifactKey,
        artifact_mime: $mime,
        artifact_size_bytes: $artifactSize,
        artifact_inline_b64: $artifactB64,
        capability_metadata: $capabilityPayload
      },
      false
    )
  } else {
    $upVer = $verRow
  }
  if (!result_is_ok($upVer)) {
    auditEvent('package.publish', $auth, 'error', 'package', '@' . $ownerHandle . '/' . $name . '@' . $version, [ 'error' => $upVer->error ])
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => $upVer->error ])
    return
  }

  clientUpdateWhere($client, 
    $client.models.Package,
    eq('id', $packageId),
    { latest_version: $version, visibility: $visibility, updated_at: gmdate('c') },
    false
  )
  dbClose($db)

  echo jsonReply([
    'ok' => true,
    'package' => [ 'orgId' => $orgId, 'name' => $name, 'version' => $version, 'visibility' => $visibility ],
    'artifact' => [ 'backend' => $artifactBackend, 'key' => $artifactKey, 'sizeBytes' => $artifactSize ],
    'notice' => $artifactNotice,
    'canonicalId' => $canonicalId,
    'downloadUrl' => '/api/artifacts/' . $canonicalId
  ])
  auditEvent('package.publish', $auth, 'ok', 'package', '@' . $ownerHandle . '/' . $name . '@' . $version, [ 'canonicalId' => $canonicalId, 'visibility' => $visibility, 'artifactBackend' => $artifactBackend ])
}

function apiInstallPackage() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $orgHandle = normalizeHandleName(queryValue('org', ''))
  $name = normalizePackageName(queryValue('name', ''))
  $version = trim('' . queryValue('version', 'latest'))
  if ($orgHandle === '' || $name === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'org and name are required' ])
    return
  }
  $auth = authWithScope(1)

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $org = clientSelectOne($client, $client.models.LhOrg, ilike('handle', $orgHandle))
  if (!result_is_ok($org)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'org not found' ])
    return
  }
  $orgId = (int) rowValue($org->value, 'id', 0)
  $pkg = clientSelectOne($client, 
    $client.models.Package,
    andWhere(
      eq('org_id', $orgId),
      ilike('name', $name)
    )
  )
  if (!result_is_ok($pkg)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'package not found' ])
    return
  }
  if (!packageIsVisibleTo($db, $pkg->value, $auth)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: package is private' ])
    return
  }
  $packageId = (int) rowValue($pkg->value, 'id', 0)
  $resolvedVersion = $version === 'latest' ? ('' . rowValue($pkg->value, 'latestVersion', rowValue($pkg->value, 'latest_version', ''))) : $version
  $ver = clientSelectOne($client, 
    $client.models.PackageVersion,
    andWhere(
      eq('package_id', $packageId),
      eq('version', $resolvedVersion)
    )
  )
  if (!result_is_ok($ver)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'version not found' ])
    return
  }
  $versionId = (int) rowValue($ver->value, 'id', 0)
  $canonicalId = '' . rowValue($ver->value, 'canonicalId', rowValue($ver->value, 'canonical_id', ''))
  if ($canonicalId === '') {
    $lockHash = '' . rowValue($ver->value, 'lockHash', rowValue($ver->value, 'lock_hash', 'dev'))
    $canonicalId = registryCanonicalId($orgHandle, $name, $resolvedVersion, $lockHash === '' ? 'dev' : $lockHash)
  }
  clientInsertOne($client, 
    $client.models.Download,
    {
      package_id: $packageId,
      version_id: $versionId,
      downloaded_at: gmdate('c'),
      ip_address: clientIp(),
      user_agent: (is_array($_SERVER) && array_key_exists('HTTP_USER_AGENT', $_SERVER)) ? $_SERVER['HTTP_USER_AGENT'] : ''
    },
    false
  )
  $currentDownloads = (int) rowValue($pkg->value, 'download_count', rowValue($pkg->value, 'downloadCount', 0))
  clientUpdateWhere($client, 
    $client.models.Package,
    eq('id', $packageId),
    { download_count: $currentDownloads + 1 },
    false
  )
  dbClose($db)

  echo jsonReply([
    'ok' => true,
    'org' => $orgHandle,
    'name' => $name,
    'version' => $resolvedVersion,
    'canonicalId' => $canonicalId,
    'artifact' => [
      'backend' => rowValue($ver->value, 'artifactBackend', rowValue($ver->value, 'artifact_backend', 'local')),
      'key' => rowValue($ver->value, 'artifactKey', rowValue($ver->value, 'artifact_key', null)),
      'mime' => rowValue($ver->value, 'artifactMime', rowValue($ver->value, 'artifact_mime', 'application/octet-stream')),
      'sizeBytes' => (int) rowValue($ver->value, 'artifactSizeBytes', rowValue($ver->value, 'artifact_size_bytes', 0))
    ],
    'integrity' => [
      'algo' => rowValue($ver->value, 'integrityAlgo', rowValue($ver->value, 'integrity_algo', '')),
      'moduleGraphHash' => rowValue($ver->value, 'moduleGraphHash', rowValue($ver->value, 'module_graph_hash', '')),
      'fsGraphHash' => rowValue($ver->value, 'fsGraphHash', rowValue($ver->value, 'fs_graph_hash', ''))
    ],
    'downloadUrl' => '/api/artifacts/' . $canonicalId
  ])
}

function fetchPackageDetail($orgHandle, $name, $auth) {
  $org = normalizeHandleName($orgHandle)
  $pkgName = normalizePackageName($name)
  if ($org === '' || $pkgName === '') {
    return [ 'ok' => false, 'error' => 'org and name are required' ]
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $orgRow = clientSelectOne($client, $client.models.LhOrg, ilike('handle', $org))
  if (!result_is_ok($orgRow)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'org lookup failed', 'detail' => $orgRow->error ]
  }
  $orgId = (int) rowValue($orgRow->value, 'id', 0)
  $pkgRow = clientSelectOne($client, 
    $client.models.Package,
    andWhere(
      eq('org_id', $orgId),
      ilike('name', $pkgName)
    )
  )
  if (!result_is_ok($pkgRow)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'package not found' ]
  }
  if (!packageIsVisibleTo($db, $pkgRow->value, $auth)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'forbidden: package is private' ]
  }

  $versions = clientSelectMany($client, 
    $client.models.PackageVersion,
    eq('package_id', (int) rowValue($pkgRow->value, 'id', 0)),
    desc('published_at')
  )
  $versionRows = result_is_ok($versions) ? $versions->value : []
  $activeVersion = count($versionRows) > 0 ? ('' . rowValue($versionRows[0], 'version', '')) : ''
  $docsSymbols = []
  $docsError = ''
  $treeEntries = []
  $treeError = ''
  $selectedFile = trim('' . queryValue('file', ''))
  $selectedFileContent = ''
  $selectedFileError = ''
  $issues = []
  $issuesError = ''
  $activeIssueNumber = (int) queryValue('issue', 0)
  $activeIssue = null
  $activeIssueComments = []
  $activeIssueError = ''
  $pulls = []
  $pullsError = ''
  $activePullNumber = (int) queryValue('pull', 0)
  $activePull = null
  $activePullComments = []
  $activePullError = ''
  if ($activeVersion !== '') {
    $docs = fetchRemoteReleaseDocs($org, $pkgName, $activeVersion)
    if (rowValue($docs, 'ok', false)) {
      $docsSymbols = rowValue(rowValue($docs, 'value', []), 'symbols', [])
    } else {
      $docsError = '' . rowValue($docs, 'error', '')
    }

    $tree = fetchRemoteReleaseTree($org, $pkgName, $activeVersion)
    if (rowValue($tree, 'ok', false)) {
      $treeEntries = rowValue(rowValue($tree, 'value', []), 'entries', [])
      if ($selectedFile === '' && is_array($treeEntries) && count($treeEntries) > 0) {
        $selectedFile = '' . rowValue($treeEntries[0], 'path', '')
      }
      if ($selectedFile !== '') {
        $blob = fetchRemoteReleaseBlob($org, $pkgName, $activeVersion, $selectedFile)
        if (rowValue($blob, 'ok', false)) {
          $selectedFileContent = '' . rowValue(rowValue($blob, 'value', []), 'content', '')
        } else {
          $selectedFileError = '' . rowValue($blob, 'error', '')
        }
      }
    } else {
      $treeError = '' . rowValue($tree, 'error', '')
    }
  }

  $issueList = fetchRemoteRepoIssues($org, $pkgName, 'open')
  if (rowValue($issueList, 'ok', false)) {
    $issues = rowValue(rowValue($issueList, 'value', []), 'issues', [])
  } else {
    $issuesError = '' . rowValue($issueList, 'error', '')
  }
  if ($activeIssueNumber > 0) {
    $issueDetail = fetchRemoteRepoIssueDetail($org, $pkgName, $activeIssueNumber)
    if (rowValue($issueDetail, 'ok', false)) {
      $activeIssue = rowValue(rowValue($issueDetail, 'value', []), 'issue', null)
      $activeIssueComments = rowValue(rowValue($issueDetail, 'value', []), 'comments', [])
    } else {
      $activeIssueError = '' . rowValue($issueDetail, 'error', '')
    }
  }

  $pullList = fetchRemoteRepoPulls($org, $pkgName, 'open')
  if (rowValue($pullList, 'ok', false)) {
    $pulls = rowValue(rowValue($pullList, 'value', []), 'pulls', [])
  } else {
    $pullsError = '' . rowValue($pullList, 'error', '')
  }
  if ($activePullNumber > 0) {
    $pullDetail = fetchRemoteRepoPullDetail($org, $pkgName, $activePullNumber)
    if (rowValue($pullDetail, 'ok', false)) {
      $activePull = rowValue(rowValue($pullDetail, 'value', []), 'pull', null)
      $activePullComments = rowValue(rowValue($pullDetail, 'value', []), 'comments', [])
    } else {
      $activePullError = '' . rowValue($pullDetail, 'error', '')
    }
  }
  dbClose($db)

  return [
    'ok' => true,
    'org' => rowValue($orgRow->value, 'handle', $org),
    'package' => [
      'id' => rowValue($pkgRow->value, 'id', null),
      'name' => rowValue($pkgRow->value, 'name', $pkgName),
      'description' => rowValue($pkgRow->value, 'description', ''),
      'latestVersion' => rowValue($pkgRow->value, 'latestVersion', rowValue($pkgRow->value, 'latest_version', null)),
      'downloadCount' => (int) rowValue($pkgRow->value, 'downloadCount', rowValue($pkgRow->value, 'download_count', 0)),
      'visibility' => rowValue($pkgRow->value, 'visibility', 'public')
    ],
    'versions' => $versionRows,
    'docsSymbols' => $docsSymbols,
    'docsError' => $docsError,
    'treeEntries' => $treeEntries,
    'treeError' => $treeError,
    'selectedFile' => $selectedFile,
    'selectedFileContent' => $selectedFileContent,
    'selectedFileError' => $selectedFileError,
    'issues' => $issues,
    'issuesError' => $issuesError,
    'activeIssue' => $activeIssue,
    'activeIssueComments' => $activeIssueComments,
    'activeIssueError' => $activeIssueError,
    'pulls' => $pulls,
    'pullsError' => $pullsError,
    'activePull' => $activePull,
    'activePullComments' => $activePullComments,
    'activePullError' => $activePullError,
    'repoAction' => '' . queryValue('repo_action', ''),
    'repoMessage' => '' . queryValue('repo_message', '')
  ]
}

function decodeJsonLike($value, $fallback = null) {
  if (is_array($value)) {
    return $value
  }
  if (is_object($value)) {
    return (array) $value
  }
  $raw = trim('' . $value)
  if ($raw === '') {
    return $fallback
  }
  $parsed = json_decode_result($raw, true)
  if (result_is_ok($parsed) && is_array($parsed->value)) {
    return $parsed->value
  }
  return $fallback
}

function normalizeCapabilityToken($value) {
  $cap = strtolower(trim('' . $value))
  if ($cap === '') {
    return ''
  }
  if (preg_match('/^[a-z][a-z0-9._-]{0,63}$/', $cap) !== 1) {
    return ''
  }
  return $cap
}

function normalizeCapabilityList($raw): array {
  $items = []
  if (is_array($raw)) {
    foreach ($raw as $entry) {
      $cap = normalizeCapabilityToken($entry)
      if ($cap !== '') {
        $items[] = $cap
      }
    }
  } else {
    $text = trim('' . $raw)
    if ($text !== '') {
      $parts = explode(',', $text)
      foreach ($parts as $entry) {
        $cap = normalizeCapabilityToken($entry)
        if ($cap !== '') {
          $items[] = $cap
        }
      }
    }
  }
  $seen = []
  $out = []
  foreach ($items as $cap) {
    if (!array_key_exists($cap, $seen)) {
      $seen[$cap] = true
      $out[] = $cap
    }
  }
  return $out
}

function extractVersionCapabilities($versionRow): array {
  $meta = rowValue($versionRow, 'capabilityMetadata', rowValue($versionRow, 'capability_metadata', null))
  $metaObj = decodeJsonLike($meta, [])
  $declared = normalizeCapabilityList(rowValue($metaObj, 'declared', []))
  $detected = normalizeCapabilityList(rowValue($metaObj, 'detected', []))
  $flat = normalizeCapabilityList(rowValue($metaObj, 'capabilities', []))

  if (count($declared) > 0) {
    return $declared
  }
  if (count($detected) > 0) {
    return $detected
  }
  if (count($flat) > 0) {
    return $flat
  }
  return []
}

function normalizeVersionFiles($rawFiles, $mainFile = 'index.phpx'): array {
  $files = decodeJsonLike($rawFiles, [])
  $out = []
  if (!is_array($files)) {
    $files = []
  }

  $isList = true
  foreach ($files as $k => $_v) {
    if (!(is_int($k) || preg_match('/^\d+$/', '' . $k) === 1)) {
      $isList = false
      break
    }
  }
  if ($isList) {
    foreach ($files as $entry) {
      if (is_string($entry)) {
        $path = trim($entry)
        if ($path !== '') {
          $out[] = [ 'path' => $path, 'sizeBytes' => null ]
        }
        continue
      }
      if (is_array($entry) || is_object($entry)) {
        $row = is_array($entry) ? $entry : (array) $entry
        $path = trim('' . rowValue($row, 'path', rowValue($row, 'name', rowValue($row, 'file', ''))))
        if ($path === '') {
          continue
        }
        $size = rowValue($row, 'sizeBytes', rowValue($row, 'size', null))
        $out[] = [ 'path' => $path, 'sizeBytes' => is_numeric($size) ? (int) $size : null ]
      }
    }
  } else {
    foreach ($files as $path => $value) {
      $p = trim('' . $path)
      if ($p === '') {
        continue
      }
      $size = null
      if (is_string($value)) {
        $size = strlen($value)
      } else if (is_array($value) || is_object($value)) {
        $row = is_array($value) ? $value : (array) $value
        $sizeRaw = rowValue($row, 'sizeBytes', rowValue($row, 'size', null))
        if (is_numeric($sizeRaw)) {
          $size = (int) $sizeRaw
        }
      }
      $out[] = [ 'path' => $p, 'sizeBytes' => $size ]
    }
  }

  if (count($out) === 0) {
    $fallbackMain = trim('' . $mainFile)
    if ($fallbackMain !== '') {
      $out[] = [ 'path' => $fallbackMain, 'sizeBytes' => null ]
    }
  }
  return $out
}

function versionReadmeText($versionRow, $packageCoord, $versionTag) {
  $readme = trim('' . rowValue($versionRow, 'readme', ''))
  if ($readme !== '') {
    return $readme
  }
  return '# ' . $packageCoord . "\n\n" .
    'No README published for `' . $versionTag . '` yet.' . "\n\n" .
    'Publish with `readme` metadata to show installation and usage docs here.'
}

function parseAliasPackagePath($path) {
  $raw = '' . $path
  if (!strStartsWith($raw, '/@')) {
    return null
  }
  $trimmed = trim($raw, '/')
  if (!strStartsWith($trimmed, '@')) {
    return null
  }
  $parts = explode('/', $trimmed)
  if (count($parts) < 2) {
    return null
  }
  $org = normalizeHandleName(substr($parts[0], 1))
  $pkgVersion = '' . $parts[1]
  $atPos = strrpos($pkgVersion, '@')
  $pkg = $atPos === false ? $pkgVersion : substr($pkgVersion, 0, $atPos)
  $ver = $atPos === false ? '' : substr($pkgVersion, $atPos + 1)
  $pkg = normalizePackageName($pkg)
  if (!isValidHandleName($org) || isReservedHandle($org) || !isValidPackageName($pkg) || isReservedPackageName($pkg)) {
    return null
  }
  return [
    'org' => $org,
    'name' => $pkg,
    'version' => trim('' . $ver)
  ]
}

function parsePreviewRepoPath($path) {
  $raw = '' . $path
  if (!strStartsWith($raw, '/@')) {
    return null
  }
  $trimmed = trim($raw, '/')
  $parts = explode('/', $trimmed)
  if (count($parts) < 3) {
    return null
  }
  $owner = normalizeHandleName(substr($parts[0], 1))
  $repo = normalizePackageName($parts[1])
  $ref = trim('' . $parts[2])
  if ($owner === '' || $repo === '' || $ref === '') {
    return null
  }
  return [ 'owner' => $owner, 'repo' => $repo, 'ref' => $ref ]
}

function findVersionInRows($versions, $targetVersion) {
  if (!is_array($versions)) {
    return null
  }
  $wanted = trim('' . $targetVersion)
  if ($wanted === '') {
    return null
  }
  foreach ($versions as $v) {
    if (('' . rowValue($v, 'version', '')) === $wanted) {
      return $v
    }
  }
  return null
}

function fetchCanonicalTarget($canonicalId, $auth) {
  $id = trim('' . $canonicalId)
  if ($id === '' || !strStartsWith($id, 'lh_')) {
    return [ 'ok' => false, 'error' => 'invalid canonical id' ]
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $ver = clientSelectOne($client, $client.models.PackageVersion, eq('canonical_id', $id))
  if (!result_is_ok($ver)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'canonical package not found' ]
  }
  $pkg = clientSelectOne($client, $client.models.Package, eq('id', (int) rowValue($ver->value, 'package_id', 0)))
  if (!result_is_ok($pkg)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'package not found' ]
  }
  $org = clientSelectOne($client, $client.models.LhOrg, eq('id', (int) rowValue($pkg->value, 'org_id', 0)))
  if (!result_is_ok($org)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'org not found' ]
  }
  if (!packageIsVisibleTo($db, $pkg->value, $auth)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'forbidden: package is private' ]
  }
  $target = [
    'org' => '' . rowValue($org->value, 'handle', ''),
    'name' => '' . rowValue($pkg->value, 'name', ''),
    'version' => '' . rowValue($ver->value, 'version', ''),
    'canonicalId' => '' . rowValue($ver->value, 'canonical_id', rowValue($ver->value, 'canonicalId', ''))
  ]
  dbClose($db)
  return [ 'ok' => true, 'target' => $target ]
}

function packageRoutePath($org, $name) {
  return '/package/' . rawurlencode(normalizeHandleName($org)) . '/' . rawurlencode(normalizePackageName($name))
}

function repoActionRedirect($org, $name, $action, $message = '', $numberKey = '', $number = 0) {
  redirectTo(buildRepoActionRedirectPath(packageRoutePath($org, $name), $action, $message, $numberKey, $number))
}

function apiRepoIssueCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $title = '' . rowValue($data, 'title', '')
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoIssue($org, $name, $title, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      $issue = rowValue(rowValue($res, 'value', []), 'issue', [])
      repoActionRedirect($org, $name, 'issue_created', 'Issue created.', 'issue', (int) rowValue($issue, 'number', 0))
    } else {
      repoActionRedirect($org, $name, 'issue_failed', '' . rowValue($res, 'error', 'Issue create failed'))
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoIssueCommentCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $number = (int) rowValue($data, 'number', 0)
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoIssueComment($org, $name, $number, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      repoActionRedirect($org, $name, 'issue_comment_created', 'Issue comment created.', 'issue', $number)
    } else {
      repoActionRedirect($org, $name, 'issue_comment_failed', '' . rowValue($res, 'error', 'Issue comment failed'), 'issue', $number)
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoPullCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $title = '' . rowValue($data, 'title', '')
  $sourceRef = '' . rowValue($data, 'source_ref', '')
  $targetRef = '' . rowValue($data, 'target_ref', '')
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoPull($org, $name, $title, $sourceRef, $targetRef, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      $pull = rowValue(rowValue($res, 'value', []), 'pull', [])
      repoActionRedirect($org, $name, 'pull_created', 'Pull request created.', 'pull', (int) rowValue($pull, 'number', 0))
    } else {
      repoActionRedirect($org, $name, 'pull_failed', '' . rowValue($res, 'error', 'Pull create failed'))
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoPullCommentCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $number = (int) rowValue($data, 'number', 0)
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoPullComment($org, $name, $number, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      repoActionRedirect($org, $name, 'pull_comment_created', 'Pull request comment created.', 'pull', $number)
    } else {
      repoActionRedirect($org, $name, 'pull_comment_failed', '' . rowValue($res, 'error', 'Pull request comment failed'), 'pull', $number)
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoFork() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $sourceOwner = '' . rowValue($data, 'source_owner', rowValue($data, 'org', ''))
  $sourceRepo = '' . rowValue($data, 'source_repo', rowValue($data, 'name', ''))
  $targetRepo = '' . rowValue($data, 'target_repo', ($sourceRepo === '' ? '' : ($sourceRepo . '-fork')))
  $res = createRemoteRepoFork($sourceOwner, $sourceRepo, $targetRepo)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      $payload = rowValue($res, 'value', [])
      $targetOwner = '' . rowValue($payload, 'targetOwner', $sourceOwner)
      $targetName = '' . rowValue($payload, 'targetRepo', $targetRepo)
      $commit = '' . rowValue($payload, 'commit', '')
      auditEvent(
        'repo.fork',
        [ 'ok' => true, 'kind' => 'service-token' ],
        'ok',
        'repo',
        '@' . $targetOwner . '/' . $targetName,
        [ 'sourceOwner' => $sourceOwner, 'sourceRepo' => $sourceRepo, 'targetRepo' => $targetName, 'commit' => $commit ]
      )
      $url = '/fork/result?source_owner=' . rawurlencode($sourceOwner)
        . '&source_repo=' . rawurlencode($sourceRepo)
        . '&target_owner=' . rawurlencode($targetOwner)
        . '&target_repo=' . rawurlencode($targetName)
        . '&commit=' . rawurlencode($commit)
      redirectTo($url)
    } else {
      auditEvent(
        'repo.fork',
        [ 'ok' => false, 'kind' => 'service-token' ],
        'error',
        'repo',
        '@' . $sourceOwner . '/' . $sourceRepo,
        [ 'targetRepo' => $targetRepo, 'error' => rowValue($res, 'error', 'fork failed') ]
      )
      repoActionRedirect($sourceOwner, $sourceRepo, 'fork_failed', '' . rowValue($res, 'error', 'fork failed'))
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiPackageDetail() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  $org = queryValue('org', '')
  $name = queryValue('name', '')
  $detail = fetchPackageDetail($org, $name, $auth)
  echo jsonReply($detail)
}

function fetchOrgProfile($handle, $auth) {
  $orgHandle = normalizeHandleName($handle)
  if ($orgHandle === '') {
    return [ 'ok' => false, 'error' => 'org handle is required' ]
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  $client = dbClient($db)
  $org = clientSelectOne($client, $client.models.LhOrg, ilike('handle', $orgHandle))
  if (!result_is_ok($org)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'org lookup failed', 'detail' => $org->error ]
  }
  $orgRow = $org->value
  $orgId = (int) rowValue($orgRow, 'id', 0)
  $orgVisibility = '' . rowValue($orgRow, 'visibility', 'public')
  $viewerId = authUserId($auth)
  $memberAccess = $viewerId > 0 && canEditOrg($db, $orgId, $viewerId)
  if ($orgVisibility === 'private' && !$memberAccess) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'forbidden: org is private' ]
  }
  $where = eq('org_id', $orgId)
  if (!$memberAccess) {
    $where = andWhere($where, eq('visibility', 'public'))
  }
  $pkgRes = clientSelectMany($client, $client.models.Package, $where, desc('download_count'))
  dbClose($db)

  $packages = []
  $pkgRows = result_is_ok($pkgRes) ? $pkgRes->value : []
  usort($pkgRows, function ($a, $b) {
    $ad = (int) rowValue($a, 'download_count', rowValue($a, 'downloadCount', 0))
    $bd = (int) rowValue($b, 'download_count', rowValue($b, 'downloadCount', 0))
    if ($ad === $bd) {
      $aid = (int) rowValue($a, 'id', 0)
      $bid = (int) rowValue($b, 'id', 0)
      if ($aid === $bid) {
        return 0
      }
      return $bid > $aid ? 1 : -1
    }
    return $bd > $ad ? 1 : -1
  })
  if (count($pkgRows) > 100) {
    $pkgRows = array_slice($pkgRows, 0, 100)
  }
  foreach ($pkgRows as $row) {
    $packages[] = normalizePackage($row)
  }
  return [
    'ok' => true,
    'org' => [ 'id' => $orgId, 'handle' => rowValue($orgRow, 'handle', $orgHandle), 'visibility' => $orgVisibility ],
    'packages' => $packages
  ]
}

function apiOrgDetail() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  $detail = fetchOrgProfile(queryValue('handle', ''), $auth)
  echo jsonReply($detail)
}

function apiArtifactDownload($canonicalId) {
  $id = trim('' . $canonicalId)
  if ($id === '') {
    header('HTTP/1.1 400 Bad Request')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => 'canonical id is required' ])
    return
  }
  $auth = authWithScope(1)
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    header('HTTP/1.1 500 Internal Server Error')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $client = dbClient($db)
  $ver = clientSelectOne($client, $client.models.PackageVersion, eq('canonical_id', $id))
  if (!result_is_ok($ver)) {
    dbClose($db)
    header('HTTP/1.1 404 Not Found')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => 'artifact not found' ])
    return
  }
  $pkg = clientSelectOne($client, $client.models.Package, eq('id', (int) rowValue($ver->value, 'package_id', 0)))
  if (!result_is_ok($pkg)) {
    dbClose($db)
    header('HTTP/1.1 404 Not Found')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => 'artifact not found' ])
    return
  }

  if (!packageIsVisibleTo($db, $pkg->value, $auth)) {
    dbClose($db)
    header('HTTP/1.1 403 Forbidden')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: package is private' ])
    return
  }
  $backend = '' . rowValue($ver->value, 'artifactBackend', rowValue($ver->value, 'artifact_backend', 'local'))
  $mime = '' . rowValue($ver->value, 'artifactMime', rowValue($ver->value, 'artifact_mime', 'application/octet-stream'))
  $artifactKey = '' . rowValue($ver->value, 'artifactKey', rowValue($ver->value, 'artifact_key', ''))
  $bytes = null
  if ($backend === 'r2' && $artifactKey !== '') {
    $fromR2 = r2GetObject($artifactKey)
    if ($fromR2['ok']) {
      $bytes = '' . $fromR2['body']
      $mime = '' . $fromR2['mime']
    }
  }
  if ($bytes === null) {
    $b64 = '' . rowValue($ver->value, 'artifactInlineB64', rowValue($ver->value, 'artifact_inline_b64', ''))
    if ($b64 === '') {
      dbClose($db)
      header('HTTP/1.1 404 Not Found')
      header('Content-Type: application/json')
      echo jsonReply([ 'ok' => false, 'error' => 'artifact bytes missing' ])
      return
    }
    $decoded = base64_decode($b64)
    if ($decoded === false) {
      dbClose($db)
      header('HTTP/1.1 500 Internal Server Error')
      header('Content-Type: application/json')
      echo jsonReply([ 'ok' => false, 'error' => 'artifact decode failed' ])
      return
    }
    $bytes = $decoded
  }
  dbClose($db)
  header('Content-Type: ' . ($mime === '' ? 'application/octet-stream' : $mime))
  header('Content-Length: ' . strlen($bytes))
  header('Content-Disposition: attachment; filename="' . $id . '.bin"')
  echo $bytes
}

function PackageDetailPage($props) {
  if (!$props->ok) {
    return <Layout>
      <section class="rounded-2xl bg-white p-8 shadow-sm">
        <h2 class="text-2xl font-bold text-gray-900">Package Not Available</h2>
        <p class="mt-3 text-sm text-gray-600">{'' . rowValue($props, 'error', 'not found')}</p>
      </section>
    </Layout>
  }

  $pkg = rowValue($props, 'package', [])
  $versions = rowValue($props, 'versions', [])
  $activeVersion = count($versions) > 0 ? $versions[0] : []
  $activeVersionName = '' . rowValue($activeVersion, 'version', rowValue($pkg, 'latestVersion', ''))
  $mainFile = '' . rowValue($activeVersion, 'mainFile', rowValue($activeVersion, 'main_file', 'index.phpx'))
  $fileRows = normalizeVersionFiles(rowValue($activeVersion, 'files', []), $mainFile)
  $treeEntries = rowValue($props, 'treeEntries', [])
  $treeError = '' . rowValue($props, 'treeError', '')
  $selectedFile = '' . rowValue($props, 'selectedFile', '')
  $selectedFileContent = '' . rowValue($props, 'selectedFileContent', '')
  $selectedFileError = '' . rowValue($props, 'selectedFileError', '')
  $capabilities = extractVersionCapabilities($activeVersion)
  $docsSymbols = rowValue($props, 'docsSymbols', [])
  $docsError = '' . rowValue($props, 'docsError', '')
  $issues = rowValue($props, 'issues', [])
  $issuesError = '' . rowValue($props, 'issuesError', '')
  $activeIssue = rowValue($props, 'activeIssue', null)
  $activeIssueComments = rowValue($props, 'activeIssueComments', [])
  $activeIssueError = '' . rowValue($props, 'activeIssueError', '')
  $pulls = rowValue($props, 'pulls', [])
  $pullsError = '' . rowValue($props, 'pullsError', '')
  $activePull = rowValue($props, 'activePull', null)
  $activePullComments = rowValue($props, 'activePullComments', [])
  $activePullError = '' . rowValue($props, 'activePullError', '')
  $repoAction = '' . rowValue($props, 'repoAction', '')
  $repoMessage = '' . rowValue($props, 'repoMessage', '')
  $packageCoord = '@' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '')
  $previewRoute = '/@' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '') . '/HEAD'
  $forkDefaultRepo = '' . rowValue($pkg, 'name', '') . '-fork'
  $readmeText = versionReadmeText($activeVersion, $packageCoord, $activeVersionName)
  $items = []
  foreach ($versions as $v) {
    $ver = rowValue($v, 'version', '')
    $cid = '' . rowValue($v, 'canonicalId', rowValue($v, 'canonical_id', ''))
    $size = (int) rowValue($v, 'artifactSizeBytes', rowValue($v, 'artifact_size_bytes', 0))
    $items[] = <li class="rounded-lg border border-gray-200 p-3">
      <div class="flex items-center justify-between gap-3">
        <div class="text-sm font-semibold text-gray-900">{'v' . $ver}</div>
        <a class="text-xs text-blue-600 hover:text-blue-800" href={'/api/artifacts/' . $cid}>download</a>
      </div>
      <div class="mt-1 text-xs text-gray-500">{'size: ' . $size . ' bytes'}</div>
    </li>
  }

  $knownCapabilities = ['read', 'write', 'net', 'env', 'db', 'run', 'dynamic', 'wasm']
  $capabilityLookup = []
  foreach ($capabilities as $cap) {
    $capabilityLookup['' . $cap] = true
  }
  $capabilityRows = []
  foreach ($knownCapabilities as $cap) {
    $enabled = array_key_exists($cap, $capabilityLookup)
    $capabilityRows[] = <div class="flex items-center justify-between rounded border border-gray-200 bg-gray-50 px-3 py-2">
      <span class="font-mono text-xs text-gray-700">{$cap}</span>
      <span class={'rounded px-2 py-0.5 text-[11px] font-semibold ' . ($enabled ? 'bg-emerald-100 text-emerald-700' : 'bg-gray-200 text-gray-500')}>
        {$enabled ? 'required' : 'none'}
      </span>
    </div>
  }

  $capabilityPills = []
  foreach ($capabilities as $cap) {
    $capabilityPills[] = <span class="rounded-full bg-blue-100 px-2 py-1 text-[11px] font-semibold text-blue-700">{$cap}</span>
  }

  $integrityAlgo = '' . rowValue($activeVersion, 'integrityAlgo', rowValue($activeVersion, 'integrity_algo', ''))
  $moduleGraphHash = '' . rowValue($activeVersion, 'moduleGraphHash', rowValue($activeVersion, 'module_graph_hash', ''))
  $fsGraphHash = '' . rowValue($activeVersion, 'fsGraphHash', rowValue($activeVersion, 'fs_graph_hash', ''))
  if ($integrityAlgo !== '' || $moduleGraphHash !== '' || $fsGraphHash !== '') {
    $capabilityRows[] = <div class="rounded border border-gray-200 bg-gray-50 px-3 py-2 text-xs text-gray-700">
      <div class="flex items-center justify-between">
        <span class="font-mono text-[11px] text-gray-500">integrity</span>
        <span class="rounded bg-slate-200 px-2 py-0.5 text-[11px] text-slate-700">{$integrityAlgo === '' ? 'unknown' : $integrityAlgo}</span>
      </div>
      <div class="mt-2 grid gap-1">
        <div><span class="text-gray-500">module graph</span> {' ' . ($moduleGraphHash === '' ? '-' : substr($moduleGraphHash, 0, 12) . '')}</div>
        <div><span class="text-gray-500">fs graph</span> {' ' . ($fsGraphHash === '' ? '-' : substr($fsGraphHash, 0, 12) . '')}</div>
      </div>
    </div>
  }

  $fileSource = (is_array($treeEntries) && count($treeEntries) > 0) ? $treeEntries : $fileRows
  $fileItems = []
  $fileLimit = min(120, count($fileSource))
  $packagePath = '/package/' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '')
  for ($i = 0; $i < $fileLimit; $i = $i + 1) {
    $f = $fileSource[$i]
    $path = '' . rowValue($f, 'path', '')
    $sizeRaw = rowValue($f, 'sizeBytes', rowValue($f, 'size', null))
    $sizeText = is_numeric($sizeRaw) ? ((string) ((int) $sizeRaw) . ' B') : ''
    $isSelected = $selectedFile !== '' && $selectedFile === $path
    $fileItems[] = <li class="flex items-center justify-between gap-2 rounded border border-gray-200 bg-gray-50 px-3 py-1.5">
      <a class={'truncate font-mono text-xs ' . ($isSelected ? 'text-blue-700 font-semibold' : 'text-gray-700 hover:text-blue-700')} href={$packagePath . '?file=' . rawurlencode($path)}>{$path}</a>
      {$sizeText !== '' ? <span class="text-[11px] text-gray-500">{$sizeText}</span> : <span class="text-[11px] text-gray-400">-</span>}
    </li>
  }
  $hasMoreFiles = count($fileSource) > $fileLimit
  $docRows = []
  $docLimit = min(12, is_array($docsSymbols) ? count($docsSymbols) : 0)
  for ($i = 0; $i < $docLimit; $i = $i + 1) {
    $d = $docsSymbols[$i]
    $docRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2">
      <div class="flex items-center justify-between gap-2">
        <span class="font-mono text-xs text-gray-700">{'' . rowValue($d, 'symbol', '')}</span>
        <span class="rounded bg-gray-200 px-2 py-0.5 text-[11px] text-gray-600">{'' . rowValue($d, 'kind', '')}</span>
      </div>
      <div class="mt-1 text-xs text-gray-600">{'' . rowValue($d, 'summary', '')}</div>
    </li>
  }
  $hasMoreDocs = is_array($docsSymbols) && count($docsSymbols) > $docLimit
  $issueRows = []
  if (is_array($issues)) {
    foreach ($issues as $item) {
      $number = (int) rowValue($item, 'number', 0)
      $href = $packagePath . '?issue=' . (string) $number
      $issueRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2">
        <a class="text-sm font-semibold text-blue-700 hover:text-blue-900" href={$href}>{'#' . (string) $number . ' ' . rowValue($item, 'title', '')}</a>
        <div class="mt-1 text-xs text-gray-500">{'by ' . rowValue($item, 'author', '') . '  ' . rowValue($item, 'state', 'open')}</div>
      </li>
    }
  }
  $pullRows = []
  if (is_array($pulls)) {
    foreach ($pulls as $item) {
      $number = (int) rowValue($item, 'number', 0)
      $href = $packagePath . '?pull=' . (string) $number
      $pullRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2">
        <a class="text-sm font-semibold text-blue-700 hover:text-blue-900" href={$href}>{'#' . (string) $number . ' ' . rowValue($item, 'title', '')}</a>
        <div class="mt-1 text-xs text-gray-500">{'by ' . rowValue($item, 'author', '') . '  ' . rowValue($item, 'state', 'open') . '  ' . rowValue($item, 'source_ref', rowValue($item, 'sourceRef', '?')) . ' -> ' . rowValue($item, 'target_ref', rowValue($item, 'targetRef', '?'))}</div>
      </li>
    }
  }
  $issueCommentRows = []
  if (is_array($activeIssueComments)) {
    foreach ($activeIssueComments as $comment) {
      $issueCommentRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2 text-xs text-gray-700">
        <div class="font-semibold text-gray-800">{rowValue($comment, 'author', '')}</div>
        <div class="mt-1 whitespace-pre-wrap">{rowValue($comment, 'body', '')}</div>
      </li>
    }
  }
  $pullCommentRows = []
  if (is_array($activePullComments)) {
    foreach ($activePullComments as $comment) {
      $pullCommentRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2 text-xs text-gray-700">
        <div class="font-semibold text-gray-800">{rowValue($comment, 'author', '')}</div>
        <div class="mt-1 whitespace-pre-wrap">{rowValue($comment, 'body', '')}</div>
      </li>
    }
  }

  return <Layout>
    <section class="rounded-xl border border-gray-200 bg-white shadow-sm">
      <div class="border-b border-gray-200 px-6 py-4">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <div>
            <div class="text-sm text-gray-500">{rowValue($props, 'org', '')}</div>
            <h1 class="text-2xl font-semibold text-blue-700">{rowValue($pkg, 'name', '')}</h1>
            <p class="mt-1 text-sm text-gray-600">{rowValue($pkg, 'description', '')}</p>
          </div>
          <div class="flex flex-wrap gap-2">
            <a class="rounded border border-gray-300 px-3 py-1.5 text-sm font-semibold text-gray-700 hover:bg-gray-50" href={$previewRoute}>Preview</a>
            <form method="POST" action={repoForkRoute()} class="flex items-center gap-2">
              <input type="hidden" name="source_owner" value={rowValue($props, 'org', '')} />
              <input type="hidden" name="source_repo" value={rowValue($pkg, 'name', '')} />
              <input class="w-40 rounded border border-gray-300 px-2 py-1.5 text-sm" type="text" name="target_repo" value={$forkDefaultRepo} />
              <button class="rounded bg-indigo-600 px-3 py-1.5 text-sm font-semibold text-white hover:bg-indigo-700" type="submit">Fork</button>
            </form>
          </div>
        </div>
        <PackageStatPills latestVersion={rowValue($pkg, 'latestVersion', 'n/a')} downloadCount={rowValue($pkg, 'downloadCount', 0)} visibility={rowValue($pkg, 'visibility', 'public')} />
      </div>

      <div class="border-b border-gray-200 px-6">
        <div class="flex flex-wrap gap-5 text-sm">
          <span class="border-b-2 border-blue-600 py-3 font-semibold text-gray-900">Code</span>
          <span class="py-3 text-gray-600">Issues ({is_array($issues) ? (string) count($issues) : '0'})</span>
          <span class="py-3 text-gray-600">Pull requests ({is_array($pulls) ? (string) count($pulls) : '0'})</span>
          <span class="py-3 text-gray-600">Security</span>
          <span class="py-3 text-gray-600">Releases ({(string) count($items)})</span>
        </div>
      </div>

      {$repoAction !== '' ? <div class={'mx-6 mt-4 rounded border px-3 py-2 text-xs ' . ((strpos($repoAction, 'failed') !== false) ? 'border-rose-200 bg-rose-50 text-rose-700' : 'border-emerald-200 bg-emerald-50 text-emerald-700')}>
        {$repoMessage === '' ? $repoAction : $repoMessage}
      </div> : null}

      <div class="p-6" style="display:flex;gap:24px;align-items:flex-start;">
        <main class="space-y-4" style="flex:1 1 auto;min-width:0;">
          <section class="rounded-lg border border-gray-200">
            <div class="flex items-center justify-between border-b border-gray-200 bg-gray-50 px-4 py-2 text-xs text-gray-600">
              <span>{'Files (' . (string) count($fileSource) . ')'}</span>
              <span>{'entrypoint: ' . ($mainFile === '' ? 'index.phpx' : $mainFile)}</span>
            </div>
            {$treeError !== '' ? <div class="border-b border-amber-200 bg-amber-50 px-4 py-2 text-xs text-amber-800">{'Tree source: ' . $treeError}</div> : null}
            <div style="display:grid;grid-template-columns:minmax(240px,34%) minmax(0,1fr);">
              <div class="max-h-[420px] overflow-auto border-r border-gray-200">
                <ul class="grid gap-1 p-2">
                  {$fileItems}
                </ul>
                {$hasMoreFiles ? <div class="px-3 pb-2 text-xs text-gray-500">{'showing first ' . (string) $fileLimit . ' files'}</div> : null}
              </div>
              <div>
                <div class="border-b border-gray-200 px-4 py-2 text-xs text-gray-600">
                  {$selectedFile !== '' ? $selectedFile : 'Select a file'}
                </div>
                {$selectedFileError !== '' ? <div class="px-4 py-2 text-xs text-amber-800">{'Blob source: ' . $selectedFileError}</div> : null}
                {$selectedFileContent !== '' ? <pre class="max-h-[380px] overflow-auto bg-gray-900 p-4 text-[12px] leading-5 text-gray-100 whitespace-pre-wrap">{$selectedFileContent}</pre> : <div class="p-4 text-sm text-gray-500">Select a file from the list.</div>}
              </div>
            </div>
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <div class="flex items-center justify-between gap-3">
              <h3 class="text-sm font-semibold text-gray-900">README</h3>
              <span class="text-xs text-gray-500">{'@' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '')}</span>
            </div>
            <pre class="mt-3 max-h-[520px] overflow-auto rounded bg-gray-50 p-4 text-xs leading-6 text-gray-700 whitespace-pre-wrap">{'' . $readmeText}</pre>
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <div class="flex items-center justify-between gap-3">
              <h3 class="text-sm font-semibold text-gray-900">API Docs</h3>
              <span class="text-xs text-gray-500">{is_array($docsSymbols) ? ((string) count($docsSymbols) . ' symbols') : '0 symbols'}</span>
            </div>
            {$docsError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Docs source: ' . $docsError}</div> : null}
            <ul class="mt-3 grid gap-2">
              {$docRows}
            </ul>
            {$hasMoreDocs ? <div class="mt-2 text-xs text-gray-500">{'showing first ' . (string) $docLimit . ' docs entries'}</div> : null}
          </section>
        </main>

        <aside class="space-y-4" style="flex:0 0 320px;width:320px;">
          <section class="rounded-lg border border-gray-200 p-4">
            <h3 class="text-sm font-semibold text-gray-900">About</h3>
            <p class="mt-2 text-sm text-gray-600">{rowValue($pkg, 'description', 'No description provided.')}</p>
            <div class="mt-3 grid gap-2 text-xs text-gray-600">
              <div>{'Package: @' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '')}</div>
              <div>{'Latest: ' . rowValue($pkg, 'latestVersion', 'n/a')}</div>
              <div>{'Visibility: ' . rowValue($pkg, 'visibility', 'public')}</div>
              <div>{'Downloads: ' . (string) rowValue($pkg, 'downloadCount', 0)}</div>
            </div>
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <h3 class="text-sm font-semibold text-gray-900">Tags</h3>
            <div class="mt-2 flex flex-wrap gap-2">
              {count($capabilityPills) > 0 ? $capabilityPills : <span class="text-xs text-gray-500">No tags yet</span>}
            </div>
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <h3 class="text-sm font-semibold text-gray-900">Releases</h3>
            <div class="mt-3">
              <PackageVersionRows items={$items} />
            </div>
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <h3 class="text-sm font-semibold text-gray-900">Security</h3>
            <div class="mt-3 grid gap-2">
              {$capabilityRows}
            </div>
          </section>
        </aside>
      </div>

      <div class="grid gap-6 border-t border-gray-200 p-6" style="grid-template-columns:minmax(0,1fr) minmax(0,1fr);">
        <section class="rounded-lg border border-gray-200 p-4">
          <div class="flex items-center justify-between gap-3">
            <h3 class="text-sm font-semibold text-gray-900">Issues</h3>
            <span class="text-xs text-gray-500">{is_array($issues) ? ((string) count($issues) . ' open') : '0 open'}</span>
          </div>
          {$issuesError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Issues source: ' . $issuesError . '. Set LINKHASH_GIT_TOKEN to enable issue APIs.'}</div> : null}
          <ul class="mt-3 grid gap-2">{$issueRows}</ul>
          <form class="mt-4 grid gap-2" method="POST" action={repoIssueCreateRoute()}>
            <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
            <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="title" placeholder="Issue title" />
            <textarea class="min-h-[90px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Describe the issue"></textarea>
            <button class="rounded bg-blue-600 px-3 py-2 text-sm font-semibold text-white hover:bg-blue-700" type="submit">Create issue</button>
          </form>
          {$activeIssueError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Issue detail: ' . $activeIssueError}</div> : null}
          {$activeIssue !== null ? <div class="mt-4 rounded border border-gray-200 bg-gray-50 p-3">
            <div class="text-sm font-semibold text-gray-900">{'#' . rowValue($activeIssue, 'number', 0) . ' ' . rowValue($activeIssue, 'title', '')}</div>
            <div class="mt-1 text-xs text-gray-600 whitespace-pre-wrap">{rowValue($activeIssue, 'body', '')}</div>
            <div class="mt-3 text-xs font-semibold text-gray-700">Comments</div>
            <ul class="mt-2 grid gap-2">{$issueCommentRows}</ul>
            <form class="mt-3 grid gap-2" method="POST" action={repoIssueCommentRoute()}>
              <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
              <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
              <input type="hidden" name="number" value={rowValue($activeIssue, 'number', 0)} />
              <textarea class="min-h-[80px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Add comment"></textarea>
              <button class="rounded border border-gray-300 px-3 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-100" type="submit">Comment on issue</button>
            </form>
          </div> : null}
        </section>

        <section class="rounded-lg border border-gray-200 p-4">
          <div class="flex items-center justify-between gap-3">
            <h3 class="text-sm font-semibold text-gray-900">Pull Requests</h3>
            <span class="text-xs text-gray-500">{is_array($pulls) ? ((string) count($pulls) . ' open') : '0 open'}</span>
          </div>
          {$pullsError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Pulls source: ' . $pullsError . '. Set LINKHASH_GIT_TOKEN to enable pull APIs.'}</div> : null}
          <ul class="mt-3 grid gap-2">{$pullRows}</ul>
          <form class="mt-4 grid gap-2" method="POST" action={repoPullCreateRoute()}>
            <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
            <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="title" placeholder="Pull request title" />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="source_ref" placeholder="source ref (feature/my-change)" />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="target_ref" value="main" />
            <textarea class="min-h-[90px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Describe the change"></textarea>
            <button class="rounded bg-indigo-600 px-3 py-2 text-sm font-semibold text-white hover:bg-indigo-700" type="submit">Create pull request</button>
          </form>
          {$activePullError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Pull detail: ' . $activePullError}</div> : null}
          {$activePull !== null ? <div class="mt-4 rounded border border-gray-200 bg-gray-50 p-3">
            <div class="text-sm font-semibold text-gray-900">{'#' . rowValue($activePull, 'number', 0) . ' ' . rowValue($activePull, 'title', '')}</div>
            <div class="mt-1 text-xs text-gray-600">{rowValue($activePull, 'source_ref', rowValue($activePull, 'sourceRef', '?')) . ' -> ' . rowValue($activePull, 'target_ref', rowValue($activePull, 'targetRef', '?'))}</div>
            <div class="mt-1 text-xs text-gray-600 whitespace-pre-wrap">{rowValue($activePull, 'body', '')}</div>
            <div class="mt-3 text-xs font-semibold text-gray-700">Comments</div>
            <ul class="mt-2 grid gap-2">{$pullCommentRows}</ul>
            <form class="mt-3 grid gap-2" method="POST" action={repoPullCommentRoute()}>
              <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
              <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
              <input type="hidden" name="number" value={rowValue($activePull, 'number', 0)} />
              <textarea class="min-h-[80px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Add comment"></textarea>
              <button class="rounded border border-gray-300 px-3 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-100" type="submit">Comment on pull request</button>
            </form>
          </div> : null}
        </section>
      </div>
    </section>
  </Layout>
}

function OrgProfilePage($props) {
  if (!$props->ok) {
    return <Layout>
      <section class="rounded-2xl bg-white p-8 shadow-sm">
        <h2 class="text-2xl font-bold text-gray-900">Organization Not Available</h2>
        <p class="mt-3 text-sm text-gray-600">{'' . rowValue($props, 'error', 'not found')}</p>
      </section>
    </Layout>
  }

  $org = rowValue($props, 'org', [])
  $packages = rowValue($props, 'packages', [])
  $cards = []
  foreach ($packages as $pkg) {
    $cards[] = <article class="rounded-xl border border-gray-200 p-4">
      <div class="flex items-center justify-between gap-3">
        <a class="text-base font-semibold text-blue-700 hover:text-blue-900" href={'/package/' . rowValue($org, 'handle', '') . '/' . rowValue($pkg, 'name', '')}>
          {rowValue($pkg, 'name', '')}
        </a>
        <span class="text-xs rounded bg-gray-100 px-2 py-1">{rowValue($pkg, 'visibility', 'public')}</span>
      </div>
      <p class="mt-2 text-sm text-gray-600">{rowValue($pkg, 'description', '')}</p>
    </article>
  }

  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Organization</div>
      <h1 class="mt-2 text-3xl font-bold text-gray-900">{'@' . rowValue($org, 'handle', '')}</h1>
      <div class="mt-3 text-xs rounded bg-gray-100 inline-flex px-2 py-1">{'visibility: ' . rowValue($org, 'visibility', 'public')}</div>
      <h3 class="mt-6 text-lg font-semibold text-gray-900">Packages</h3>
      <div class="mt-3 grid gap-3">
        {$cards}
      </div>
    </section>
  </Layout>
}

function AccountPage($props) {
  if (!$props->ok) {
    return <Layout>
      <section class="rounded-2xl bg-white p-8 shadow-sm">
        <h2 class="text-2xl font-bold text-gray-900">Sign in required</h2>
        <p class="mt-3 text-sm text-gray-600">Use Bluesky OAuth or local dev login to access account settings.</p>
        <div class="mt-6 flex gap-3">
          <a class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" href="/auth/start">Sign in with Bluesky</a>
          <a class="rounded-lg border border-gray-300 px-4 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50" href="/api/auth/dev-login?handle=samifou.ad">Dev Login</a>
        </div>
      </section>
    </Layout>
  }

  $user = isset($props->user) ? $props->user : []
  $notice = isset($props->notice) ? ('' . $props->notice) : ''
  $newToken = isset($props->newToken) ? ('' . $props->newToken) : ''

  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Account</div>
      <h1 class="mt-2 text-3xl font-bold text-gray-900">{'@' . rowValue($user, 'handle', 'user')}</h1>
      <p class="mt-2 text-sm text-gray-600">{rowValue($user, 'did', '')}</p>
      {$notice !== '' ? <div class="mt-4 rounded-lg border border-blue-200 bg-blue-50 px-4 py-3 text-sm text-blue-700">{$notice}</div> : null}
      {$newToken !== '' ? <div class="mt-4 rounded-lg border border-emerald-200 bg-emerald-50 px-4 py-3 text-sm text-emerald-700">{'New token: ' . $newToken}</div> : null}
    </section>

    <section class="mt-6 grid gap-6 md:grid-cols-2">
      <div class="rounded-2xl bg-white p-6 shadow-sm">
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Personal Access Tokens</div>
        <p class="mt-2 text-sm text-gray-600">Create a token for CLI publish/install flows. Use API list/revoke endpoints below for full management.</p>
        <form class="mt-4 grid gap-3" method="GET" action="/account">
          <input type="hidden" name="action" value="create_pat" />
          <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" type="text" name="label" placeholder="token label" />
          <select class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="scope">
            <option value="read">read</option>
            <option value="read:write" selected>read:write</option>
            <option value="read:write:delete">read:write:delete</option>
          </select>
          <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" type="number" min="1" max="3650" name="expires_days" value="30" />
          <button class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" type="submit">Create token</button>
        </form>
        <form class="mt-3" method="GET" action="/account">
          <input type="hidden" name="action" value="revoke_all_pat" />
          <button class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" type="submit">Revoke all</button>
        </form>
        <div class="mt-4 text-xs text-gray-500">
          <div><a class="text-blue-600 hover:text-blue-800" href="/api/auth/token/list">GET /api/auth/token/list</a></div>
          <div class="mt-1"><a class="text-blue-600 hover:text-blue-800" href="/api/auth/me">GET /api/auth/me</a></div>
        </div>
      </div>

      <div class="rounded-2xl bg-white p-6 shadow-sm">
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Organization Access</div>
        <p class="mt-2 text-sm text-gray-600">View and manage org permissions through API routes while the full UI is being finished.</p>
        <div class="mt-4 text-xs text-gray-500">
          <div><a class="text-blue-600 hover:text-blue-800" href="/api/orgs/mine">GET /api/orgs/mine</a></div>
          <div class="mt-1"><a class="text-blue-600 hover:text-blue-800" href="/api/orgs/members?orgId=1">GET /api/orgs/members</a></div>
        </div>
      </div>
    </section>
  </Layout>
}

function PlaygroundPage($props) {
  $org = '' . rowValue($props, 'org', '')
  $name = '' . rowValue($props, 'name', '')
  $version = '' . rowValue($props, 'version', 'latest')
  $resolved = rowValue($props, 'resolved', null)
  $error = '' . rowValue($props, 'error', '')
  $install = rowValue($props, 'install', null)
  $artifactUrl = '' . rowValue($props, 'artifactUrl', '')
  $versions = rowValue($props, 'versions', [])

  $versionItems = []
  if (is_array($versions)) {
    foreach ($versions as $v) {
      $ver = '' . rowValue($v, 'version', '')
      if ($ver === '') {
        continue
      }
      $href = '/playground?org=' . rawurlencode($org) . '&name=' . rawurlencode($name) . '&version=' . rawurlencode($ver)
      $versionItems[] = <a class="inline-flex rounded bg-gray-100 px-2 py-1 text-xs text-gray-700 hover:bg-gray-200" href={$href}>{$ver}</a>
    }
  }

  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Playground</div>
      <h1 class="mt-2 text-3xl font-bold text-gray-900">Package Inspector</h1>
      <p class="mt-2 text-sm text-gray-600">Resolve a package/version, inspect metadata, and fetch install/artifact endpoints.</p>
      <form class="mt-6 grid gap-4 md:grid-cols-4" method="GET" action="/playground">
        <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="org" placeholder="org handle" value={$org} />
        <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="name" placeholder="package name" value={$name} />
        <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="version" placeholder="latest" value={$version} />
        <button class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" type="submit">Resolve</button>
      </form>
      {$error !== '' ? <div class="mt-4 rounded-lg border border-rose-200 bg-rose-50 px-4 py-3 text-sm text-rose-700">{$error}</div> : null}
      {$resolved !== null ? <div class="mt-6 rounded-xl border border-gray-200 p-5">
        <div class="text-sm font-semibold text-gray-900">{'@' . $org . '/' . $name . ' @ ' . ('' . rowValue($resolved, 'version', $version))}</div>
        <div class="mt-2 text-sm text-gray-600">{'' . rowValue($resolved, 'description', '')}</div>
        <div class="mt-3 grid gap-2 text-xs text-gray-700 md:grid-cols-2">
          <div>{'canonicalId: ' . ('' . rowValue($resolved, 'canonicalId', ''))}</div>
          <div>{'artifact backend: ' . ('' . rowValue($resolved, 'artifactBackend', 'local'))}</div>
          <div>{'artifact size: ' . (string) rowValue($resolved, 'artifactSizeBytes', 0) . ' bytes'}</div>
          <div>{'visibility: ' . ('' . rowValue($resolved, 'visibility', 'public'))}</div>
        </div>
        {$install !== null ? <div class="mt-4 rounded-lg bg-gray-900 p-3 text-xs text-gray-100 whitespace-pre-wrap">{jsonReply($install)}</div> : null}
        <div class="mt-4 flex flex-wrap gap-2">
          {$artifactUrl !== '' ? <a class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" href={$artifactUrl}>Download artifact</a> : null}
          <a class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" href={'/api/package?org=' . rawurlencode($org) . '&name=' . rawurlencode($name)}>Package API</a>
          <a class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" href={'/api/install?org=' . rawurlencode($org) . '&name=' . rawurlencode($name) . '&version=' . rawurlencode($version === '' ? 'latest' : $version)}>Install API</a>
        </div>
        <div class="mt-4 flex flex-wrap gap-2">{$versionItems}</div>
      </div> : null}
    </section>
  </Layout>
}

function apiCreateDemoPackage() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply({ ok: false, error: $auth['error'] })
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply({ ok: false, error: $csrf['error'] })
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply({ ok: false, error: $conn->error })
    return
  }

  $body = requestData()
  $seed = (int) (microtime(true) * 1000)
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $pkgName = normalizePackageName('' . queryValue('name', array_key_exists('name', $body) ? $body['name'] : ('demo_pkg_' . (string) ($seed % 100000))))
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : 'public'), 'public')

  if ($orgId <= 0) {
    dbClose($conn->value)
    echo jsonReply({ ok: false, error: 'orgId is required' })
    return
  }
  if (!isValidPackageName($pkgName) || isReservedPackageName($pkgName)) {
    dbClose($conn->value)
    echo jsonReply({ ok: false, error: 'invalid or reserved package name' })
    return
  }
  if ($visibility === null) {
    dbClose($conn->value)
    echo jsonReply({ ok: false, error: 'visibility must be public or private' })
    return
  }

  $handle = $conn->value
  $client = dbClient($handle)
  if (!canEditOrg($handle, $orgId, $userId)) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'forbidden: missing org edit access' })
    return
  }
  $insert = clientInsertOne($client, 
    $client.models.Package,
    {
      org_id: $orgId,
      name: $pkgName,
      description: 'Demo package created from API',
      latest_version: '0.1.0',
      download_count: 0,
      visibility: $visibility,
      private_read_mask: 0,
      created_at: gmdate('c'),
      updated_at: gmdate('c')
    },
    false
  )
  $pkgInsert = $insert
  if (result_is_ok($insert)) {
    $pkgInsert = clientSelectOne($client, 
      $client.models.Package,
      andWhere(
        eq('org_id', $orgId),
        ilike('name', $pkgName)
      )
    )
  }
  dbClose($handle)

  echo jsonReply({
    ok: result_is_ok($pkgInsert),
    package: result_is_ok($pkgInsert) ? $pkgInsert->value : $pkgInsert->error,
    data: {
      orgId: $orgId,
      packageName: $pkgName,
      visibility: $visibility
    }
  })
}

function apiBumpPackageDownloads() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply({ ok: false, error: $auth['error'] })
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply({ ok: false, error: $csrf['error'] })
    return
  }

  $body = requestData()
  $name = '' . queryValue('name', array_key_exists('name', $body) ? $body['name'] : '')
  $by = (int) queryValue('by', array_key_exists('by', $body) ? $body['by'] : 1)
  if ($name === '') {
    echo jsonReply({ ok: false, error: 'name is required' })
    return
  }
  if ($by < 1) {
    $by = 1
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply({ ok: false, error: $conn->error })
    return
  }

  $handle = $conn->value
  $client = dbClient($handle)
  $row = clientSelectOne($client, $client.models.Package, ilike('name', $name))
  if (!result_is_ok($row)) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'package not found' })
    return
  }

  $pkg = $row->value
  $id = (int) rowValue($pkg, 'id', 0)
  $orgId = (int) rowValue($pkg, 'orgId', rowValue($pkg, 'org_id', 0))
  if ($id <= 0) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'package not found' })
    return
  }
  if ($orgId <= 0 || !canEditOrg($handle, $orgId, $userId)) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'forbidden: missing org edit access' })
    return
  }
  $current = (int) rowValue($pkg, 'downloadCount', rowValue($pkg, 'download_count', 0))
  $next = $current + $by
  $updated = clientUpdateWhere($client, 
    $client.models.Package,
    eq('id', $id),
    { download_count: $next },
    false
  )
  dbClose($handle)

  if (!result_is_ok($updated)) {
    echo jsonReply({ ok: false, error: $updated->error })
    return
  }

  echo jsonReply({
    ok: true,
    package: $name,
    before: $current,
    after: $next
  })
}

loadDotEnv('.env')
installRuntimeHandlers()
bootstrapSchema()

$uri = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : '/'
$parts = explode('?', $uri)
$path = $parts[0]
if (strpos($path, '/api/') === 0) {
  header('X-Request-Id: ' . requestId())
  logEvent('info', 'api.request', { route: '' . $path })
}

if ($path === '/api/packages') {
  apiPackages()
  return
}

if ($path === '/api/search') {
  apiSearch()
  return
}

if ($path === '/api/db-stats') {
  apiDbStats()
  return
}

if ($path === '/api/stats/packages') {
  apiPackageStats()
  return
}

if ($path === '/api/runtime-checks') {
  apiRuntimeChecks()
  return
}

if ($path === '/api/runtime-action') {
  apiRuntimeAction()
  return
}

if ($path === '/api/registry/identity') {
  apiRegistryIdentity()
  return
}

if ($path === '/api/auth/login') {
  apiAuthLogin()
  return
}

if ($path === '/api/auth/callback') {
  apiAuthCallback()
  return
}

if ($path === '/api/auth/dev-login') {
  apiAuthDevLogin()
  return
}

if ($path === '/api/auth/logout') {
  apiAuthLogout()
  return
}

if ($path === '/api/auth/me') {
  apiAuthMe()
  return
}

if ($path === '/api/auth/token/create') {
  apiAuthPatCreate()
  return
}

if ($path === '/api/auth/token/list') {
  apiAuthPatList()
  return
}

if ($path === '/api/auth/token/revoke') {
  apiAuthPatRevoke()
  return
}

if ($path === '/api/auth/token/revoke-all') {
  apiAuthPatRevokeAll()
  return
}

if ($path === '/api/orgs/mine') {
  apiOrgsMine()
  return
}

if ($path === '/api/orgs/create') {
  apiOrgsCreate()
  return
}

if ($path === '/api/orgs/members') {
  apiOrgMembersList()
  return
}

if ($path === '/api/orgs/members/upsert') {
  apiOrgMembersUpsert()
  return
}

if ($path === '/api/orgs/members/remove') {
  apiOrgMembersRemove()
  return
}

if ($path === '/api/packages/visibility') {
  apiPackageSetVisibility()
  return
}

if ($path === '/api/package') {
  apiPackageDetail()
  return
}

if ($path === '/api/org') {
  apiOrgDetail()
  return
}

if ($path === '/api/publish') {
  apiPublishPackage()
  return
}

if ($path === '/api/install') {
  apiInstallPackage()
  return
}

if ($path === repoIssueCreateRoute()) {
  apiRepoIssueCreate()
  return
}

if ($path === repoIssueCommentRoute()) {
  apiRepoIssueCommentCreate()
  return
}

if ($path === repoPullCreateRoute()) {
  apiRepoPullCreate()
  return
}

if ($path === repoPullCommentRoute()) {
  apiRepoPullCommentCreate()
  return
}

if ($path === repoForkRoute()) {
  apiRepoFork()
  return
}

if (strpos($path, '/api/artifacts/') === 0) {
  $canonical = substr($path, strlen('/api/artifacts/'))
  apiArtifactDownload($canonical)
  return
}

if ($path === '/api/dev/create-package') {
  apiCreateDemoPackage()
  return
}

if ($path === '/api/dev/bump-downloads') {
  apiBumpPackageDownloads()
  return
}


if ($path === '/auth/start') {
  $start = oauthBeginFlow()
  if (!$start['ok']) {
    header('Content-Type: application/json')
    header('X-Powered-By: linkha.sh')
    echo jsonReply($start)
    return
  }
  redirectTo($start['auth_url'])
  return
}

if (strpos($path, '/api/') === 0) {
  header('HTTP/1.1 404 Not Found')
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  header('X-Request-Id: ' . requestId())
  logEvent('warn', 'api.not_found', { route: '' . $path })
  echo jsonReply({
    ok: false,
    error: 'not found'
  })
  return
}

$title = 'linkha.sh - PHPX registry'
$viewer = authCurrentUser()
$viewerId = $viewer['ok'] ? (int) rowValue($viewer['user'], 'id', 0) : 0
$topPackages = []
$registryStats = []
$runtimeStats = []
$checks = []
$node = null
if (strpos($path, '/package/') === 0) {
  $parts = explode('/', trim($path, '/'))
  $org = count($parts) >= 2 ? $parts[1] : ''
  $pkg = count($parts) >= 3 ? $parts[2] : ''
  $auth = authWithScope(1)
  $detail = fetchPackageDetail($org, $pkg, $auth)
  $node = <PackageDetailPage ok={$detail['ok']} org={rowValue($detail, 'org', '')} package={rowValue($detail, 'package', [])} versions={rowValue($detail, 'versions', [])} docsSymbols={rowValue($detail, 'docsSymbols', [])} docsError={rowValue($detail, 'docsError', '')} treeEntries={rowValue($detail, 'treeEntries', [])} treeError={rowValue($detail, 'treeError', '')} selectedFile={rowValue($detail, 'selectedFile', '')} selectedFileContent={rowValue($detail, 'selectedFileContent', '')} selectedFileError={rowValue($detail, 'selectedFileError', '')} error={rowValue($detail, 'error', '')} />
} else if (strStartsWith($path, '/@')) {
  $preview = parsePreviewRepoPath($path)
  if ($preview !== null) {
    $resolved = fetchRepoRefResolution(rowValue($preview, 'owner', ''), rowValue($preview, 'repo', ''), rowValue($preview, 'ref', 'HEAD'))
    if (rowValue($resolved, 'ok', false)) {
      $value = rowValue($resolved, 'value', [])
      $owner = rowValue($preview, 'owner', '')
      $repo = rowValue($preview, 'repo', '')
      $ref = rowValue($preview, 'ref', '')
      $commit = '' . rowValue($value, 'commit', '')
      $shortCommit = '' . rowValue($value, 'shortCommit', (strlen($commit) > 12 ? substr($commit, 0, 12) : $commit))
      auditEvent(
        'repo.preview.resolve',
        [ 'ok' => true, 'kind' => 'anonymous' ],
        'ok',
        'repo',
        '@' . $owner . '/' . $repo,
        [ 'requestedRef' => $ref, 'commit' => $commit ]
      )
      $node = <Layout>
        <PreviewRouteSection ok={true} owner={$owner} repo={$repo} ref={$ref} shortCommit={$shortCommit} previewPath={$path} previewUrl={adwaPreviewUrl($owner, $repo, $commit)} editUrl={adwaEditUrl($owner, $repo, $commit)} />
      </Layout>
    } else {
      $owner = rowValue($preview, 'owner', '')
      $repo = rowValue($preview, 'repo', '')
      $ref = rowValue($preview, 'ref', '')
      auditEvent(
        'repo.preview.resolve',
        [ 'ok' => false, 'kind' => 'anonymous' ],
        'error',
        'repo',
        '@' . $owner . '/' . $repo,
        [ 'requestedRef' => $ref, 'error' => rowValue($resolved, 'error', 'resolve failed') ]
      )
      $err = '' . rowValue($resolved, 'error', 'resolve failed')
      $resolvedUrl = '' . rowValue($resolved, 'url', '')
      $remedy = ' Ensure linkhash-git is running and LINKHASH_GIT_API_URL points to it (e.g. http://127.0.0.1:8508).'
      if ($resolvedUrl !== '') {
        $err = $err . ' [resolver=' . $resolvedUrl . ']'
      }
      $node = <Layout>
        <PreviewRouteSection ok={false} owner={$owner} repo={$repo} ref={$ref} previewPath={$path} error={$err . $remedy} previewUrl={adwaPreviewUrlForRef($owner, $repo, $ref)} editUrl={adwaEditUrl($owner, $repo)} />
      </Layout>
    }
  } else {
    $alias = parseAliasPackagePath($path)
    if ($alias === null) {
      $node = <PackageDetailPage ok={false} org={''} package={[]} versions={[]} docsSymbols={[]} docsError={''} treeEntries={[]} treeError={''} selectedFile={''} selectedFileContent={''} selectedFileError={''} error={'invalid package route'} />
    } else {
      $auth = authWithScope(1)
      $detail = fetchPackageDetail($alias['org'], $alias['name'], $auth)
      if ($detail['ok'] && ('' . $alias['version']) !== '') {
        $picked = findVersionInRows(rowValue($detail, 'versions', []), $alias['version'])
        if ($picked === null) {
          $detail = [ 'ok' => false, 'error' => 'version not found' ]
        } else {
          $pkgDetail = rowValue($detail, 'package', [])
          $pkgDetail['latestVersion'] = '' . $alias['version']
          $detail['package'] = $pkgDetail
          $detail['versions'] = [$picked]
        }
      }
      $node = <PackageDetailPage ok={rowValue($detail, 'ok', false)} org={rowValue($detail, 'org', '')} package={rowValue($detail, 'package', [])} versions={rowValue($detail, 'versions', [])} docsSymbols={rowValue($detail, 'docsSymbols', [])} docsError={rowValue($detail, 'docsError', '')} treeEntries={rowValue($detail, 'treeEntries', [])} treeError={rowValue($detail, 'treeError', '')} selectedFile={rowValue($detail, 'selectedFile', '')} selectedFileContent={rowValue($detail, 'selectedFileContent', '')} selectedFileError={rowValue($detail, 'selectedFileError', '')} error={rowValue($detail, 'error', '')} />
    }
  }
} else if (strStartsWith($path, '/lh_')) {
  $cid = substr($path, 1)
  $auth = authWithScope(1)
  $resolved = fetchCanonicalTarget($cid, $auth)
  if (!rowValue($resolved, 'ok', false)) {
    $node = <PackageDetailPage ok={false} org={''} package={[]} versions={[]} docsSymbols={[]} docsError={''} treeEntries={[]} treeError={''} selectedFile={''} selectedFileContent={''} selectedFileError={''} error={rowValue($resolved, 'error', 'not found')} />
  } else {
    $target = rowValue($resolved, 'target', [])
    $detail = fetchPackageDetail(rowValue($target, 'org', ''), rowValue($target, 'name', ''), $auth)
    if ($detail['ok']) {
      $picked = findVersionInRows(rowValue($detail, 'versions', []), rowValue($target, 'version', ''))
      if ($picked !== null) {
        $pkgDetail = rowValue($detail, 'package', [])
        $pkgDetail['latestVersion'] = '' . rowValue($target, 'version', '')
        $detail['package'] = $pkgDetail
        $detail['versions'] = [$picked]
      }
    }
    $node = <PackageDetailPage ok={rowValue($detail, 'ok', false)} org={rowValue($detail, 'org', '')} package={rowValue($detail, 'package', [])} versions={rowValue($detail, 'versions', [])} docsSymbols={rowValue($detail, 'docsSymbols', [])} docsError={rowValue($detail, 'docsError', '')} treeEntries={rowValue($detail, 'treeEntries', [])} treeError={rowValue($detail, 'treeError', '')} selectedFile={rowValue($detail, 'selectedFile', '')} selectedFileContent={rowValue($detail, 'selectedFileContent', '')} selectedFileError={rowValue($detail, 'selectedFileError', '')} error={rowValue($detail, 'error', '')} />
  }
} else if (strpos($path, '/org/') === 0) {
  $parts = explode('/', trim($path, '/'))
  $org = count($parts) >= 2 ? $parts[1] : ''
  $auth = authWithScope(1)
  $detail = fetchOrgProfile($org, $auth)
  $node = <OrgProfilePage ok={$detail['ok']} org={rowValue($detail, 'org', [])} packages={rowValue($detail, 'packages', [])} error={rowValue($detail, 'error', '')} />
} else if ($path === '/playground') {
  $auth = authWithScope(1)
  $org = '' . queryValue('org', '')
  $pkg = '' . queryValue('name', '')
  $requestedVersion = '' . queryValue('version', 'latest')
  $error = ''
  $resolved = null
  $install = null
  $artifactUrl = ''
  $versions = []
  if ($org !== '' && $pkg !== '') {
    $detail = fetchPackageDetail($org, $pkg, $auth)
    if (!rowValue($detail, 'ok', false)) {
      $error = '' . rowValue($detail, 'error', 'resolve failed')
    } else {
      $versions = rowValue($detail, 'versions', [])
      $package = rowValue($detail, 'package', [])
      $effectiveVersion = ($requestedVersion === '' || $requestedVersion === 'latest')
        ? ('' . rowValue($package, 'latestVersion', ''))
        : $requestedVersion
      $picked = null
      foreach ($versions as $v) {
        if ('' . rowValue($v, 'version', '') === $effectiveVersion) {
          $picked = $v
          break
        }
      }
      if ($picked === null && is_array($versions) && count($versions) > 0) {
        $picked = $versions[0]
        $effectiveVersion = '' . rowValue($picked, 'version', $effectiveVersion)
      }
      if ($picked === null) {
        $error = 'no published versions found'
      } else {
        $cid = '' . rowValue($picked, 'canonicalId', rowValue($picked, 'canonical_id', ''))
        $artifactUrl = $cid === '' ? '' : ('/api/artifacts/' . $cid)
        $resolved = [
          'version' => $effectiveVersion,
          'description' => rowValue($package, 'description', ''),
          'visibility' => rowValue($package, 'visibility', 'public'),
          'canonicalId' => $cid,
          'artifactBackend' => rowValue($picked, 'artifactBackend', rowValue($picked, 'artifact_backend', 'local')),
          'artifactSizeBytes' => rowValue($picked, 'artifactSizeBytes', rowValue($picked, 'artifact_size_bytes', 0))
        ]
        $install = [
          'ok' => true,
          'org' => normalizeHandleName($org),
          'name' => normalizePackageName($pkg),
          'version' => $effectiveVersion,
          'canonicalId' => $cid,
          'downloadUrl' => $artifactUrl
        ]
        $requestedVersion = $effectiveVersion
      }
    }
  }
  $node = <PlaygroundPage org={$org} name={$pkg} version={$requestedVersion} error={$error} resolved={$resolved} install={$install} artifactUrl={$artifactUrl} versions={$versions} />
} else if ($path === '/fork/result') {
  $sourceOwner = '' . queryValue('source_owner', '')
  $sourceRepo = '' . queryValue('source_repo', '')
  $targetOwner = '' . queryValue('target_owner', '')
  $targetRepo = '' . queryValue('target_repo', '')
  $commit = '' . queryValue('commit', '')
  $short = strlen($commit) > 12 ? substr($commit, 0, 12) : $commit
  $cloneUrl = 'http://localhost:8508/' . $targetOwner . '/' . $targetRepo . '.git'
  $node = <Layout>
    <ForkResultSection
      sourceOwner={$sourceOwner}
      sourceRepo={$sourceRepo}
      targetOwner={$targetOwner}
      targetRepo={$targetRepo}
      shortCommit={$short}
      cloneCommand={'git clone ' . $cloneUrl}
      upstreamCommand={'cd ' . $targetRepo . ' && git remote add upstream http://localhost:8508/' . $sourceOwner . '/' . $sourceRepo . '.git'}
      previewUrl={'/@' . $targetOwner . '/' . $targetRepo . '/HEAD'}
      editUrl={adwaEditUrl($targetOwner, $targetRepo, $commit)}
      packageUrl={'/package/' . $targetOwner . '/' . $targetRepo}
    />
  </Layout>
} else if ($path === '/account') {
  $auth = authWithScope(1)
  if (!$auth['ok']) {
    $node = <AccountPage ok={false} />
  } else {
    $user = rowValue($auth, 'user', [])
    $notice = ''
    $newToken = ''
    $action = '' . queryValue('action', '')
    if ($action === 'create_pat') {
      $label = '' . queryValue('label', 'default')
      $scope = '' . queryValue('scope', 'read:write')
      $expires = (int) queryValue('expires_days', 30)
      $created = accountCreatePat($user, $label, $scope, $expires)
      if ($created['ok']) {
        $notice = 'token created'
        $newToken = '' . rowValue($created, 'token', '')
      } else {
        $notice = '' . rowValue($created, 'error', 'token create failed')
      }
    } else if ($action === 'revoke_pat') {
      $id = (int) queryValue('id', 0)
      $revoked = accountRevokePat($user, $id)
      $notice = $revoked['ok'] ? 'token revoked' : ('' . rowValue($revoked, 'error', 'token revoke failed'))
    } else if ($action === 'revoke_all_pat') {
      $all = accountRevokeAllPat($user)
      $notice = $all['ok'] ? 'all tokens revoked' : ('' . rowValue($all, 'error', 'token revoke failed'))
    }
    $node = <AccountPage
      ok={true}
      user={$user}
      notice={$notice}
      newToken={$newToken}
    />
  }
} else if ($path === '/runtime') {
  $checks = collectRuntimeChecks()
  $node = <RuntimeLab checks={$checks} />
} else if ($path === '/hmr-demo') {
  $node = <HmrDemo />
} else {
  $topPackages = fetchTopPackages(6, $viewerId)
  $registryStats = fetchRegistryStats()
  $statsResult = stats()
  $runtimeStats = result_is_ok($statsResult) ? $statsResult->value : []
  $node = <Home packages={$topPackages} stats={$runtimeStats} registryStats={$registryStats} />
}

if (isPartialRequest()) {
  echo renderPartialJson($node, $title)
  return
}
---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{$title}</title>
  </head>
  <body>
    <div id="app" dataLayout="registry">{$node}</div>
    <Hydration container="#app" layout="registry" />
  </body>
</html>
