---
import { jsx, jsxs } from 'component/core'
import { renderPartialJson, isPartialRequest, Link, Hydration } from 'component/dom'
import { json_encode as encodeJson } from 'encoding/json'
import { PreviewRouteSection, ForkResultSection } from '@/src/pages/repo_flows'
import { PackageStatPills, PackageVersionRows } from '@/src/pages/package_detail'
import { buildAdwaBaseUrl, buildAdwaPreviewUrl, buildAdwaEditUrl } from '@/src/services/adwa'
import { gitApiDefaultBase, scopedReleaseDocsPath, scopedReleaseTreePath, scopedReleaseBlobPath, repoIssuesPath, repoIssueDetailPath, repoIssueCommentPath, repoPullsPath, repoPullDetailPath, repoPullCommentPath, repoResolvePath, repoForkPath } from '@/src/services/linkhash_git'
import { repoIssueCreateRoute, repoIssueCommentRoute, repoPullCreateRoute, repoPullCommentRoute, repoForkRoute, buildRepoActionRedirectPath } from '@/src/api/repo_actions'
import { stats } from 'db'
import { query as pgQuery, exec as pgExec } from 'db/postgres'
import { connect as sqliteConnect, query as sqliteQuery, query_one as sqliteQueryOne, exec as sqliteExec, close as sqliteClose } from 'db/sqlite'
import { connect as mysqlConnect, query_one as mysqlQueryOne, exec as mysqlExec, close as mysqlClose } from 'db/mysql'
import { open as fsOpen, read as fsRead, close as fsClose } from 'fs'
import { len as bytesLen, to_string as bytesToString } from 'bytes'
import { get as cookieGet, set_header as cookieSetHeader, clear_header as cookieClearHeader } from 'cookies'
import { random_hex } from 'crypto'
import { connect as tcpConnect, tcp_write as tcpWrite, tcp_read as tcpRead, tcp_close as tcpClose } from 'tcp'
import { tls_upgrade, tls_write, tls_read, tls_close } from 'tls'
import { open_handle as dbOpenHandle, close as dbCloseRaw } from 'db'
import { result_is_ok, result_unwrap, result_ok, result_err } from 'core/result'
import { canonical_id as registryCanonicalId, artifact_key as registryArtifactKey } from 'registry/artifacts'

function envValue($name, $fallback = null) {
  $envBag = (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('_ENV', $GLOBALS) && is_array($GLOBALS['_ENV']))
    ? $GLOBALS['_ENV']
    : (is_array($_ENV) ? $_ENV : [])
  if (is_array($envBag) && array_key_exists($name, $envBag)) {
    $fromEnv = $envBag[$name]
    if ($fromEnv !== null && $fromEnv !== '') {
      return $fromEnv
    }
  }

  $val = getenv($name)
  if ($val !== false && $val !== null && $val !== '') {
    return $val
  }

  $serverBag = (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('_SERVER', $GLOBALS) && is_array($GLOBALS['_SERVER']))
    ? $GLOBALS['_SERVER']
    : (is_array($_SERVER) ? $_SERVER : [])
  if (is_array($serverBag) && array_key_exists($name, $serverBag)) {
    $fromServer = $serverBag[$name]
    if ($fromServer !== null && $fromServer !== '') {
      return $fromServer
    }
  }

  return $fallback
}

function parseDotEnvLine($line) {
  $raw = trim('' . $line)
  if ($raw === '' || strStartsWith($raw, '#')) {
    return null
  }
  $eq = strpos($raw, '=')
  if ($eq === false || $eq <= 0) {
    return null
  }
  $key = trim(substr($raw, 0, $eq))
  $value = trim(substr($raw, $eq + 1))
  if ($key === '') {
    return null
  }
  if ((strStartsWith($value, '"') && substr($value, -1) === '"') || (strStartsWith($value, "'") && substr($value, -1) === "'")) {
    $value = substr($value, 1, strlen($value) - 2)
  }
  return [ 'key' => $key, 'value' => $value ]
}

function loadDotEnv($path = '.env') {
  $full = '' . $path
  if (!is_file($full)) {
    return
  }
  $lines = @file($full)
  if (!is_array($lines)) {
    return
  }
  foreach ($lines as $line) {
    $pair = parseDotEnvLine($line)
    if (!is_array($pair)) {
      continue
    }
    $key = '' . $pair['key']
    $value = '' . $pair['value']
    if (!isset($GLOBALS) || !is_array($GLOBALS)) {
      continue
    }
    if (!array_key_exists('_ENV', $GLOBALS) || !is_array($GLOBALS['_ENV'])) {
      $GLOBALS['_ENV'] = []
    }
    $GLOBALS['_ENV'][$key] = $value
    if (!array_key_exists('_SERVER', $GLOBALS) || !is_array($GLOBALS['_SERVER'])) {
      $GLOBALS['_SERVER'] = []
    }
    $GLOBALS['_SERVER'][$key] = $value
  }
}

function getDbConfig() {
  return {
    host: envValue('DB_HOST', '127.0.0.1'),
    port: (int) envValue('DB_PORT', '55432'),
    database: envValue('DB_NAME', 'linkhash_registry'),
    user: envValue('DB_USER', 'postgres'),
    password: envValue('DB_PASSWORD', 'postgres')
  }
}

function getDbConfigCandidates(): array {
  $base = getDbConfig()
  $candidates = [$base]
  $hasExplicitPort = envValue('DB_PORT', '') !== ''
  if (!$hasExplicitPort) {
    $basePort = (int) rowValue($base, 'port', 55432)
    if ($basePort !== 5432) {
      $fallbackA = $base
      $fallbackA['port'] = 5432
      $candidates[] = $fallbackA
    }
    if ($basePort !== 55432) {
      $fallbackB = $base
      $fallbackB['port'] = 55432
      $candidates[] = $fallbackB
    }
  }
  return $candidates
}

function openDbHandle() {
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_db_pinned_handle', $GLOBALS)) {
    $pinned = (int) $GLOBALS['__lh_db_pinned_handle']
    if ($pinned > 0) {
      return result_ok($pinned)
    }
  }
  $errors = []
  foreach (getDbConfigCandidates() as $cfg) {
    $result = dbOpenHandle('postgres', $cfg)
    if (result_is_ok($result)) {
      if (isset($GLOBALS) && is_array($GLOBALS)) {
        $GLOBALS['__lh_db_pinned_handle'] = (int) $result->value
      }
      return $result
    }
    $errors[] = 'host=' . rowValue($cfg, 'host', '?')
      . ' port=' . ('' . rowValue($cfg, 'port', '?'))
      . ' db=' . rowValue($cfg, 'database', '?')
      . ' -> ' . ('' . $result->error)
  }
  return { ok: false, error: 'postgres connect failed across candidates: ' . implode(' | ', $errors) }
}

function dbClose($handle) {
  $h = (int) $handle
  if ($h <= 0) {
    return result_ok(true)
  }
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_db_pinned_handle', $GLOBALS)) {
    $pinned = (int) $GLOBALS['__lh_db_pinned_handle']
    if ($pinned > 0 && $h === $pinned) {
      return result_ok(true)
    }
  }
  return dbCloseRaw($h)
}

function isUnknownHandleError($error): bool {
  $msg = strtolower('' . $error)
  return strpos($msg, 'unknown handle') !== false
}

function dbExec($handle, $sql, $params = []) {
  $res = pgExec($handle, $sql, $params)
  if (result_is_ok($res) || !isUnknownHandleError($res->error)) {
    return $res
  }
  $reopen = openDbHandle()
  if (!result_is_ok($reopen)) {
    return $res
  }
  $fresh = $reopen->value
  return pgExec($fresh, $sql, $params)
}

function dbQuery($handle, $sql, $params = []) {
  $res = pgQuery($handle, $sql, $params)
  if (result_is_ok($res) || !isUnknownHandleError($res->error)) {
    return $res
  }
  $reopen = openDbHandle()
  if (!result_is_ok($reopen)) {
    return $res
  }
  $fresh = $reopen->value
  return pgQuery($fresh, $sql, $params)
}

function dbQueryOne($handle, $sql, $params = []) {
  $res = dbQuery($handle, $sql, $params)
  if (!result_is_ok($res)) {
    return $res
  }
  $rows = rowsFromQueryResult($res)
  if (!is_array($rows) || count($rows) === 0) {
    return result_err('no rows')
  }
  return result_ok($rows[0])
}

function openCatalogFallbackSqlite() {
  return sqliteConnect({ path: 'db/linkhash.sqlite' })
}

function sqliteOrgHandle($orgId) {
  return 'org' . ('' . (int) $orgId)
}

function fetchFallbackVisiblePackageRows($limit = 25, $query = '') {
  $conn = openCatalogFallbackSqlite()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $db = $conn->value
  $max = max(1, (int) $limit)
  $term = trim('' . $query)
  if ($term === '') {
    $rowsRes = sqliteQuery(
      $db,
      "select id, org_id as orgId, name, description, latest_version as latestVersion, download_count as downloadCount, created_at as createdAt, updated_at as updatedAt
       from packages
       order by download_count desc, id desc
       limit ?",
      [$max]
    )
  } else {
    $like = '%' . strtolower($term) . '%'
    $rowsRes = sqliteQuery(
      $db,
      "select id, org_id as orgId, name, description, latest_version as latestVersion, download_count as downloadCount, created_at as createdAt, updated_at as updatedAt
       from packages
       where lower(name) like ? or lower(description) like ?
       order by download_count desc, id desc
       limit ?",
      [$like, $like, $max]
    )
  }
  sqliteClose($db)
  if (!result_is_ok($rowsRes)) {
    return { ok: false, error: $rowsRes->error }
  }
  $rows = rowsFromQueryResult($rowsRes)
  $normalized = []
  foreach ($rows as $row) {
    $row['orgHandle'] = sqliteOrgHandle(rowValue($row, 'orgId', rowValue($row, 'org_id', 0)))
    $row['visibility'] = 'public'
    $row['canonicalId'] = ''
    $normalized[] = $row
  }
  return { ok: true, rows: $normalized, source: 'sqlite' }
}

function fetchFallbackRegistryStatsResult() {
  $conn = openCatalogFallbackSqlite()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $db = $conn->value
  $row = sqliteQueryOne(
    $db,
    "select
      (select count(*) from packages) as packageCount,
      (select count(distinct org_id) from packages) as orgCount,
      0 as versionCount,
      (select coalesce(sum(download_count), 0) from packages) as totalDownloads",
    []
  )
  sqliteClose($db)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  return { ok: true, stats: [
    'packageCount' => (int) rowValue($row->value, 'packageCount', 0),
    'orgCount' => (int) rowValue($row->value, 'orgCount', 0),
    'versionCount' => (int) rowValue($row->value, 'versionCount', 0),
    'totalDownloads' => (int) rowValue($row->value, 'totalDownloads', 0)
  ], source: 'sqlite' }
}

function rowsFromQueryResult($result): array {
  if (!result_is_ok($result)) {
    return []
  }

  $value = $result->value
  if (is_array($value) && array_key_exists('rows', $value) && is_array($value['rows'])) {
    return $value['rows']
  }

  if (is_object($value) && isset($value->rows) && is_array($value->rows)) {
    return $value->rows
  }

  return []
}

function rowValue($row, $key, $fallback = null) {
  if (is_array($row) && array_key_exists($key, $row)) {
    return $row[$key]
  }
  if (is_object($row)) {
    $obj = get_object_vars($row)
    if (is_array($obj) && array_key_exists($key, $obj)) {
      return $obj[$key]
    }
  }

  $k = '' . $key
  $lower = strtolower($k)
  $snake = strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $k))
  if (is_array($row)) {
    if (array_key_exists($lower, $row)) {
      return $row[$lower]
    }
    if (array_key_exists($snake, $row)) {
      return $row[$snake]
    }
    $noscore = str_replace('_', '', $snake)
    if (array_key_exists($noscore, $row)) {
      return $row[$noscore]
    }
  }
  if (is_object($row)) {
    $obj = get_object_vars($row)
    if (is_array($obj) && array_key_exists($lower, $obj)) {
      return $obj[$lower]
    }
    if (is_array($obj) && array_key_exists($snake, $obj)) {
      return $obj[$snake]
    }
    $noscore = str_replace('_', '', $snake)
    if (is_array($obj) && array_key_exists($noscore, $obj)) {
      return $obj[$noscore]
    }
  }
  return $fallback
}

function resultObject($res) {
  if (result_is_ok($res)) {
    return { ok: true, value: $res->value }
  }
  return { ok: false, error: $res->error }
}

function sqlQuote($value) {
  $s = '' . $value
  return str_replace("'", "''", $s)
}

function probePostgres() {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $handle = $conn->value
  $row = dbQueryOne($handle, 'select now() as now', [])
  dbClose($handle)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  return { ok: true, row: $row->value }
}

function probeSqlite() {
  $conn = sqliteConnect({ path: 'db/linkhash.sqlite' })
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $handle = $conn->value
  $row = sqliteQueryOne($handle, 'select sqlite_version() as version', [])
  sqliteClose($handle)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  return { ok: true, row: $row->value }
}

function probeMySql() {
  $conn = mysqlConnect({
    host: envValue('MYSQL_HOST', '127.0.0.1'),
    port: (int) envValue('MYSQL_PORT', '3306'),
    database: envValue('MYSQL_DB', 'mysql'),
    user: envValue('MYSQL_USER', 'root'),
    password: envValue('MYSQL_PASSWORD', '')
  })
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $handle = $conn->value
  $row = mysqlQueryOne($handle, 'select 1 as ok', [])
  mysqlClose($handle)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  return { ok: true, row: $row->value }
}

function probeFsBytes() {
  $opened = fsOpen('db/linkhash.sqlite', 'r')
  if (!result_is_ok($opened)) {
    return { ok: false, error: $opened->error }
  }
  $handle = $opened->value
  $chunk = fsRead($handle, 16)
  fsClose($handle)
  if (!result_is_ok($chunk)) {
    return { ok: false, error: $chunk->error }
  }
  $bytes = $chunk->value
  return {
    ok: true,
    byte_len: bytesLen($bytes),
    preview: bytesToString($bytes)
  }
}

function collectRuntimeChecks() {
  return {
    postgres: probePostgres(),
    sqlite: probeSqlite(),
    mysql: probeMySql(),
    fs_bytes: probeFsBytes(),
    db_stats: resultObject(stats())
  }
}

function ensureProbeTable($target, $handle) {
  $sql = 'create table if not exists runtime_probe_log (driver text, note text, created_at text)'
  if ($target === 'postgres') {
    return dbExec($handle, $sql, [])
  }
  if ($target === 'sqlite') {
    return sqliteExec($handle, $sql, [])
  }
  if ($target === 'mysql') {
    return mysqlExec($handle, $sql, [])
  }
  return { ok: false, error: 'unknown driver' }
}

function insertProbeRow($target, $handle, $note) {
  $now = date('c')
  $sql = 'insert into runtime_probe_log (driver, note, created_at) values (?, ?, ?)'
  if ($target === 'postgres') {
    $sql = 'insert into runtime_probe_log (driver, note, created_at) values ($1, $2, $3)'
    return dbExec($handle, $sql, [$target, $note, $now])
  }
  if ($target === 'sqlite') {
    return sqliteExec($handle, $sql, [$target, $note, $now])
  }
  if ($target === 'mysql') {
    return mysqlExec($handle, $sql, [$target, $note, $now])
  }
  return { ok: false, error: 'unknown driver' }
}

function countProbeRows($target, $handle) {
  $sql = 'select count(*) as total from runtime_probe_log'
  if ($target === 'postgres') {
    return dbQueryOne($handle, $sql, [])
  }
  if ($target === 'sqlite') {
    return sqliteQueryOne($handle, $sql, [])
  }
  if ($target === 'mysql') {
    return mysqlQueryOne($handle, $sql, [])
  }
  return { ok: false, error: 'unknown driver' }
}

function runtimeWriteProbe($target) {
  if (!is_string($target) || $target === '') {
    return { ok: false, error: 'target is required' }
  }

  if ($target === 'postgres') {
    $conn = openDbHandle()
    if (!result_is_ok($conn)) {
      return { ok: false, error: $conn->error }
    }
    $handle = $conn->value
    $mk = ensureProbeTable($target, $handle)
    if (!result_is_ok($mk)) {
      dbClose($handle)
      return { ok: false, error: $mk->error }
    }
    $ins = insertProbeRow($target, $handle, 'runtime write probe')
    if (!result_is_ok($ins)) {
      dbClose($handle)
      return { ok: false, error: $ins->error }
    }
    $row = countProbeRows($target, $handle)
    dbClose($handle)
    if (!result_is_ok($row)) {
      return { ok: false, error: $row->error }
    }
    return { ok: true, target: $target, count: rowValue($row->value, 'total', 0) }
  }

  if ($target === 'sqlite') {
    $conn = sqliteConnect({ path: 'db/linkhash.sqlite' })
    if (!result_is_ok($conn)) {
      return { ok: false, error: $conn->error }
    }
    $handle = $conn->value
    $mk = ensureProbeTable($target, $handle)
    if (!result_is_ok($mk)) {
      sqliteClose($handle)
      return { ok: false, error: $mk->error }
    }
    $ins = insertProbeRow($target, $handle, 'runtime write probe')
    if (!result_is_ok($ins)) {
      sqliteClose($handle)
      return { ok: false, error: $ins->error }
    }
    $row = countProbeRows($target, $handle)
    sqliteClose($handle)
    if (!result_is_ok($row)) {
      return { ok: false, error: $row->error }
    }
    return { ok: true, target: $target, count: rowValue($row->value, 'total', 0) }
  }

  if ($target === 'mysql') {
    $conn = mysqlConnect({
      host: envValue('MYSQL_HOST', '127.0.0.1'),
      port: (int) envValue('MYSQL_PORT', '3306'),
      database: envValue('MYSQL_DB', 'mysql'),
      user: envValue('MYSQL_USER', 'root'),
      password: envValue('MYSQL_PASSWORD', '')
    })
    if (!result_is_ok($conn)) {
      return { ok: false, error: $conn->error }
    }
    $handle = $conn->value
    $mk = ensureProbeTable($target, $handle)
    if (!result_is_ok($mk)) {
      mysqlClose($handle)
      return { ok: false, error: $mk->error }
    }
    $ins = insertProbeRow($target, $handle, 'runtime write probe')
    if (!result_is_ok($ins)) {
      mysqlClose($handle)
      return { ok: false, error: $ins->error }
    }
    $row = countProbeRows($target, $handle)
    mysqlClose($handle)
    if (!result_is_ok($row)) {
      return { ok: false, error: $row->error }
    }
    return { ok: true, target: $target, count: rowValue($row->value, 'total', 0) }
  }

  return { ok: false, error: 'unsupported target: ' . $target }
}

function Layout($props) {
  return <div class="min-h-screen bg-gray-50 text-gray-900">
    <nav class="bg-white shadow-sm border-b">
      <div class="mx-auto flex h-16 max-w-6xl items-center justify-between px-6">
        <div class="flex items-center gap-3">
          <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-blue-600 text-white font-semibold">L</div>
          <div>
            <div class="text-lg font-bold text-blue-600">linkha.sh</div>
            <div class="text-xs text-gray-500">PHPX package registry</div>
          </div>
        </div>
        <div class="flex items-center gap-4 text-sm">
          <Link to="/" layout="registry" class="text-blue-600 hover:text-blue-800">Home</Link>
          <Link to="/account" layout="registry" class="text-gray-600 hover:text-blue-600">Account</Link>
          <Link to="/playground" layout="registry" class="text-gray-600 hover:text-blue-600">Playground</Link>
          <Link to="/runtime" layout="registry" class="text-gray-600 hover:text-blue-600">Runtime Lab</Link>
          <Link to="/hmr-demo" layout="registry" class="text-gray-600 hover:text-blue-600">HMR Demo</Link>
          <a class="text-gray-600 hover:text-blue-600" href="#features">Features</a>
          <a class="text-gray-600 hover:text-blue-600" href="#quickstart">Quick Start</a>
        </div>
      </div>
    </nav>
    <main class="mx-auto max-w-6xl px-6 py-10">
      {$props.children}
    </main>
    <footer class="border-t border-gray-200 bg-white">
      <div class="mx-auto flex max-w-6xl items-center justify-between px-6 py-6 text-sm text-gray-500">
        <span>Built with PHPX</span>
        <span>Registry API v0.1</span>
      </div>
    </footer>
  </div>
}

function Hero() {
  return <section class="rounded-2xl bg-white p-10 shadow-sm">
    <div class="grid gap-10 md:grid-cols-[1.2fr_0.8fr]">
      <div>
        <h1 class="text-4xl font-bold text-gray-900">The PHPX Package Registry</h1>
        <p class="mt-4 text-lg text-gray-600">
          Discover, publish, and share PHPX packages. Built with PHPX, for PHPX.
        </p>
        <div class="mt-6 flex flex-wrap gap-3">
          <a href="/packages" class="rounded-lg bg-blue-600 px-5 py-2 text-sm font-semibold text-white hover:bg-blue-700">Browse packages</a>
          <a href="/publish" class="rounded-lg border border-gray-300 px-5 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50">Publish your first</a>
        </div>
      </div>
      <div class="rounded-xl bg-gray-900 p-6 text-sm text-gray-100">
        <div class="text-xs uppercase tracking-wide text-gray-400">install</div>
        <pre class="mt-3 whitespace-pre-wrap">deka install @linkhash/ui</pre>
        <div class="mt-6 text-xs uppercase tracking-wide text-gray-400">publish</div>
        <pre class="mt-3 whitespace-pre-wrap">deka publish</pre>
      </div>
    </div>
  </section>
}

function FeatureCard($props) {
  return <div class="rounded-xl border border-gray-200 bg-white p-6 shadow-sm hover:shadow-md transition-shadow">
    <div class="text-lg font-semibold text-gray-900">{$props.title}</div>
    <div class="mt-2 text-sm text-gray-600">{$props.copy}</div>
  </div>
}

function Features() {
  return <section id="features" class="mt-10">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Features</div>
    <h2 class="mt-2 text-2xl font-bold text-gray-900">Everything you need to ship PHPX</h2>
    <div class="mt-6 grid gap-6 md:grid-cols-3">
      <FeatureCard title="Discover" copy="Find PHPX packages with clear metadata and sharp docs." />
      <FeatureCard title="Publish" copy="Ship new releases in seconds with a frictionless flow." />
      <FeatureCard title="Playground" copy="Try packages in a browser-first PHPX sandbox." />
    </div>
  </section>
}

function QuickStart() {
  return <section id="quickstart" class="mt-12 rounded-2xl bg-white p-8 shadow-sm">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Quick Start</div>
    <h2 class="mt-2 text-2xl font-bold text-gray-900">Get going in minutes</h2>
    <div class="mt-6 grid gap-6 md:grid-cols-2">
      <div>
        <div class="text-sm font-semibold text-gray-800">Install a package</div>
        <div class="mt-2 rounded-lg bg-gray-900 px-4 py-3 font-mono text-sm text-gray-100">deka install @org/package</div>
      </div>
      <div>
        <div class="text-sm font-semibold text-gray-800">Publish your package</div>
        <div class="mt-2 rounded-lg bg-gray-900 px-4 py-3 font-mono text-sm text-gray-100">deka publish</div>
      </div>
    </div>
  </section>
}

function fetchTopPackages($limit = 6, $userId = 0): array {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return []
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  $rowsRes = fetchVisiblePackageRows($handle, $limit, '', $userId)
  dbClose($handle)
  if (!rowValue($rowsRes, 'ok', false)) {
    return []
  }
  $rows = rowValue($rowsRes, 'rows', [])
  return is_array($rows) ? $rows : []
}

function normalizePackage($pkg) {
  $orgHandle = '' . rowValue($pkg, 'orgHandle', rowValue($pkg, 'org_handle', ''))
  $name = '' . rowValue($pkg, 'name', '')
  $latestVersion = rowValue($pkg, 'latestVersion', rowValue($pkg, 'latest_version', 'n/a'))
  $canonicalId = '' . rowValue($pkg, 'canonicalId', rowValue($pkg, 'canonical_id', ''))
  return {
    id: rowValue($pkg, 'id', null),
    orgId: rowValue($pkg, 'orgId', rowValue($pkg, 'org_id', null)),
    orgHandle: $orgHandle,
    name: $name,
    description: rowValue($pkg, 'description', ''),
    latestVersion: $latestVersion,
    downloadCount: rowValue($pkg, 'downloadCount', rowValue($pkg, 'download_count', 0)),
    canonicalId: $canonicalId,
    packageCoord: ($orgHandle !== '' && $name !== '') ? ('@' . $orgHandle . '/' . $name) : null,
    packageVersionCoord: ($orgHandle !== '' && $name !== '' && ('' . $latestVersion) !== '') ? ('@' . $orgHandle . '/' . $name . '@' . $latestVersion) : null,
    visibility: rowValue($pkg, 'visibility', 'public'),
    createdAt: rowValue($pkg, 'createdAt', rowValue($pkg, 'created_at', null)),
    updatedAt: rowValue($pkg, 'updatedAt', rowValue($pkg, 'updated_at', null))
  }
}

function TopPackages($props) {
  if (!is_array($props->packages) || count($props->packages) === 0) {
    return <section class="mt-12 rounded-2xl border border-amber-200 bg-amber-50 p-8">
      <div class="text-sm font-semibold uppercase tracking-wide text-amber-700">Top Packages</div>
      <div class="mt-2 text-sm text-amber-800">No package data available yet.</div>
    </section>
  }

  $cards = []
  foreach ($props->packages as $pkg) {
    $name = rowValue($pkg, 'name', 'unknown')
    $description = rowValue($pkg, 'description', 'No description yet')
    $downloads = rowValue($pkg, 'downloadCount', 0)
    $latestVersion = rowValue($pkg, 'latestVersion', 'n/a')
    $orgHandle = '' . rowValue($pkg, 'orgHandle', rowValue($pkg, 'org_handle', ''))
    $packageHref = ($orgHandle !== '' && ('' . $name) !== '')
      ? ('/package/' . rawurlencode($orgHandle) . '/' . rawurlencode('' . $name))
      : ''

    $cards[] = <article class="rounded-xl border border-gray-200 p-4">
      <div class="flex items-start justify-between gap-4">
        <div>
          {$packageHref !== ''
            ? <a class="text-base font-semibold text-blue-700 hover:text-blue-900" href={$packageHref}>{$name}</a>
            : <div class="text-base font-semibold text-gray-900">{$name}</div>}
          <div class="mt-1 text-sm text-gray-600">{$description}</div>
        </div>
        <div class="rounded-md bg-blue-50 px-3 py-1 text-xs font-semibold text-blue-700">{(string) $downloads . ' downloads'}</div>
      </div>
      <div class="mt-3 text-xs text-gray-500">{'Latest version: ' . $latestVersion}</div>
    </article>
  }

  return <section class="mt-12 rounded-2xl bg-white p-8 shadow-sm">
    <div class="flex items-center justify-between">
      <div>
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Top Packages</div>
        <h2 class="mt-2 text-2xl font-bold text-gray-900">Live data from Postgres</h2>
      </div>
      <a href="/api/packages" class="text-sm font-semibold text-blue-600 hover:text-blue-800">JSON API</a>
    </div>
    <div class="mt-6 grid gap-4">
      {$cards}
    </div>
  </section>
}

function FeaturedPackages($props) {
  $packages = is_array($props->packages) ? $props->packages : []
  if (count($packages) === 0) {
    return <section class="mt-10 rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Featured</div>
      <h2 class="mt-2 text-2xl font-bold text-gray-900">Featured packages coming soon</h2>
    </section>
  }
  $cards = []
  $limit = min(3, count($packages))
  for ($i = 0; $i < $limit; $i = $i + 1) {
    $pkg = $packages[$i]
    $name = rowValue($pkg, 'name', '')
    $desc = rowValue($pkg, 'description', '')
    $orgHandle = '' . rowValue($pkg, 'orgHandle', rowValue($pkg, 'org_handle', ''))
    $packageHref = ($orgHandle !== '' && ('' . $name) !== '')
      ? ('/package/' . rawurlencode($orgHandle) . '/' . rawurlencode('' . $name))
      : ''
    $cards[] = <article class="rounded-xl border border-blue-100 bg-blue-50 p-4">
      <div class="text-sm font-semibold text-blue-700">{'Featured #' . ($i + 1)}</div>
      {$packageHref !== ''
        ? <a class="mt-1 block text-lg font-bold text-blue-800 hover:text-blue-900" href={$packageHref}>{$name}</a>
        : <div class="mt-1 text-lg font-bold text-gray-900">{$name}</div>}
      <p class="mt-2 text-sm text-gray-700">{$desc}</p>
    </article>
  }
  return <section class="mt-10 rounded-2xl bg-white p-8 shadow-sm">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Featured</div>
    <h2 class="mt-2 text-2xl font-bold text-gray-900">Popular packages this week</h2>
    <div class="mt-6 grid gap-4 md:grid-cols-3">
      {$cards}
    </div>
  </section>
}

function RuntimeStats($props) {
  if (!is_array($props->stats)) {
    return <section class="mt-8 rounded-2xl border border-gray-200 bg-white p-6 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Runtime Stats</div>
      <div class="mt-2 text-sm text-gray-600">Stats unavailable.</div>
    </section>
  }

  $active = array_key_exists('active_handles', $props->stats) ? $props->stats['active_handles'] : 0
  $byDriver = array_key_exists('handles_by_driver', $props->stats) ? $props->stats['handles_by_driver'] : []
  $metrics = array_key_exists('metrics', $props->stats) ? $props->stats['metrics'] : []
  $queryPostgres = is_array($metrics) && array_key_exists('query:postgres', $metrics) ? $metrics['query:postgres'] : []
  $queryCalls = is_array($queryPostgres) && array_key_exists('calls', $queryPostgres) ? $queryPostgres['calls'] : 0
  $queryAvgMs = is_array($queryPostgres) && array_key_exists('avg_ms', $queryPostgres) ? $queryPostgres['avg_ms'] : 0

  return <section class="mt-8 rounded-2xl border border-blue-100 bg-blue-50 p-6">
    <div class="flex items-center justify-between gap-4">
      <div>
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-700">Runtime Stats</div>
        <div class="mt-1 text-sm text-blue-900">Live host bridge metrics from `db.stats()`.</div>
      </div>
      <a href="/api/db-stats" class="text-sm font-semibold text-blue-700 hover:text-blue-900">JSON</a>
    </div>
    <div class="mt-4 grid gap-3 md:grid-cols-3">
      <div class="rounded-lg bg-white p-3">
        <div class="text-xs text-gray-500">Active Handles</div>
        <div class="mt-1 text-xl font-bold text-gray-900">{(string) $active}</div>
      </div>
      <div class="rounded-lg bg-white p-3">
        <div class="text-xs text-gray-500">Postgres Query Calls</div>
        <div class="mt-1 text-xl font-bold text-gray-900">{(string) $queryCalls}</div>
      </div>
      <div class="rounded-lg bg-white p-3">
        <div class="text-xs text-gray-500">Postgres Query Avg (ms)</div>
        <div class="mt-1 text-xl font-bold text-gray-900">{(string) $queryAvgMs}</div>
      </div>
    </div>
    <div class="mt-3 text-xs text-gray-500">{'handles_by_driver: ' . encodeJson($byDriver)}</div>
  </section>
}

function fetchRegistryStatsResult() {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return { ok: false, error: $conn->error }
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $row = dbQueryOne(
    $db,
    "select
      (select count(*) from packages) as packageCount,
      (select count(*) from lh_orgs) as orgCount,
      (select count(*) from package_versions) as versionCount",
    []
  )
  $downloadRowsRes = dbQuery(
    $db,
    "select download_count as downloadCount from packages",
    []
  )
  dbClose($db)
  if (!result_is_ok($row)) {
    return { ok: false, error: $row->error }
  }
  if (!result_is_ok($downloadRowsRes)) {
    return { ok: false, error: $downloadRowsRes->error }
  }
  $downloadRows = rowsFromQueryResult($downloadRowsRes)
  $totalDownloads = 0
  foreach ($downloadRows as $drow) {
    $totalDownloads += (int) rowValue($drow, 'downloadCount', rowValue($drow, 'download_count', 0))
  }
  return { ok: true, stats: [
    'packageCount' => (int) rowValue($row->value, 'packageCount', rowValue($row->value, 'packagecount', 0)),
    'orgCount' => (int) rowValue($row->value, 'orgCount', rowValue($row->value, 'orgcount', 0)),
    'versionCount' => (int) rowValue($row->value, 'versionCount', rowValue($row->value, 'versioncount', 0)),
    'totalDownloads' => (int) $totalDownloads
  ], source: 'postgres', degraded: false, warning: null }
}

function fetchRegistryStats() {
  $res = fetchRegistryStatsResult()
  if (!rowValue($res, 'ok', false)) {
    return []
  }
  return rowValue($res, 'stats', [])
}

function RegistryStatsPanel($props) {
  $stats = is_array($props->stats) ? $props->stats : []
  $packageCount = array_key_exists('packageCount', $stats) ? $stats['packageCount'] : 0
  $orgCount = array_key_exists('orgCount', $stats) ? $stats['orgCount'] : 0
  $versionCount = array_key_exists('versionCount', $stats) ? $stats['versionCount'] : 0
  $totalDownloads = array_key_exists('totalDownloads', $stats) ? $stats['totalDownloads'] : 0
  return <section class="mt-8 rounded-2xl bg-white p-8 shadow-sm">
    <div class="flex items-center justify-between gap-4">
      <div>
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Registry Stats</div>
        <h2 class="mt-2 text-2xl font-bold text-gray-900">Current package ecosystem snapshot</h2>
      </div>
      <a href="/api/stats/packages" class="text-sm font-semibold text-blue-600 hover:text-blue-800">JSON</a>
    </div>
    <div class="mt-6 grid gap-4 md:grid-cols-4">
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Packages</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $packageCount}</div></div>
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Organizations</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $orgCount}</div></div>
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Versions</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $versionCount}</div></div>
      <div class="rounded-lg border border-gray-200 p-4"><div class="text-xs text-gray-500">Downloads</div><div class="mt-1 text-xl font-bold text-gray-900">{(string) $totalDownloads}</div></div>
    </div>
  </section>
}

function Home($props) {
  return <Layout>
    <Hero />
    <Features />
    <QuickStart />
    <RegistryStatsPanel stats={$props->registryStats} />
    <FeaturedPackages packages={$props->packages} />
    <TopPackages packages={$props->packages} />
    <RuntimeStats stats={$props->stats} />
  </Layout>
}

function RuntimeLab($props) {
  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="flex items-center justify-between gap-4">
        <div>
          <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Runtime Lab</div>
          <h2 class="mt-2 text-2xl font-bold text-gray-900">Live feature checks</h2>
          <p class="mt-2 text-sm text-gray-600">Exercises component hydration, bridge-backed db modules, and fs/bytes.</p>
        </div>
        <a href="/api/runtime-checks" class="rounded-lg border border-gray-300 px-4 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50">JSON checks</a>
      </div>
      <div class="mt-6 rounded-xl bg-gray-900 p-4 text-xs text-gray-100 whitespace-pre-wrap">{encodeJson($props->checks)}</div>
    </section>
    <section class="mt-8 rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Write Path Probes</div>
      <h3 class="mt-2 text-xl font-bold text-gray-900">Run insert/count probes per driver</h3>
      <p class="mt-2 text-sm text-gray-600">Each action creates `runtime_probe_log` if needed, inserts one row, then returns total count.</p>
      <div class="mt-5 flex flex-wrap gap-3">
        <a class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" href="/api/runtime-action?target=postgres&op=write_probe">Postgres write probe</a>
        <a class="rounded-lg bg-emerald-600 px-4 py-2 text-sm font-semibold text-white hover:bg-emerald-700" href="/api/runtime-action?target=mysql&op=write_probe">MySQL write probe</a>
        <a class="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-semibold text-white hover:bg-indigo-700" href="/api/runtime-action?target=sqlite&op=write_probe">SQLite write probe</a>
      </div>
    </section>
  </Layout>
}

const HMR_DEMO_MESSAGE = 'Hot component message: v8'

function HmrInputCard() {
  return <section class="rounded-2xl border border-emerald-200 bg-emerald-50 p-6" dataDekaId="hmr-input-card">
    <div class="text-sm font-semibold uppercase tracking-wide text-emerald-700">State Check</div>
    <h3 class="mt-2 text-xl font-bold text-gray-900">Type in this input, then edit component code</h3>
    <p class="mt-2 text-sm text-gray-700">If HMR patching is granular, your typed value and cursor selection remain after save.</p>
    <input id="hmr-name" name="hmr-name" class="mt-4 w-full rounded-lg border border-gray-300 px-3 py-2 text-sm" placeholder="Type here, then save code changes" dataDekaId="hmr-input" />
  </section>
}

function HmrHotCard() {
  return <section class="rounded-2xl border border-blue-200 bg-blue-50 p-6" dataDekaId="hmr-hot-card">
    <div class="text-sm font-semibold uppercase tracking-wide text-blue-700">Hot Component</div>
    <h3 class="mt-2 text-xl font-bold text-gray-900">This section should patch on save</h3>
    <p id="hmr-hot-message" class="mt-2 text-sm text-blue-900" dataDekaId="hmr-hot-message">{HMR_DEMO_MESSAGE}</p>
    <p class="mt-2 text-xs text-blue-700">Edit `HMR_DEMO_MESSAGE` in `main.phpx` and save.</p>
  </section>
}

function HmrDemo() {
  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">HMR Demo</div>
      <h2 class="mt-2 text-2xl font-bold text-gray-900">Component patch + input state preservation</h2>
      <ol class="mt-3 list-decimal pl-5 text-sm text-gray-700 space-y-1">
        <li>Type text into the input below</li>
        <li>Change `HMR_DEMO_MESSAGE` in `main.phpx` from `v1` to `v2`</li>
        <li>Save and watch only the hot component content update</li>
      </ol>
      <div class="mt-6 grid gap-6">
        <HmrInputCard />
        <HmrHotCard />
      </div>
    </section>
  </Layout>
}

function apiPackages() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $me = authCurrentUser()
  $userId = $me['ok'] ? (int) rowValue($me['user'], 'id', 0) : 0
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    $data = {
      packages: [],
      total: 0,
      registry: 'linkha.sh',
      version: '0.1.0',
      ok: false,
      error: $conn->error
    }
    echo jsonReply($data)
    return
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  $rowsRes = fetchVisiblePackageRows($handle, 25, '', $userId)
  dbClose($handle)
  if (!rowValue($rowsRes, 'ok', false)) {
    echo jsonReply({
      packages: [],
      total: 0,
      registry: 'linkha.sh',
      version: '0.1.0',
      ok: false,
      error: rowValue($rowsRes, 'error', 'query failed')
    })
    return
  }
  $rows = rowValue($rowsRes, 'rows', [])
  $packages = []
  foreach ($rows as $row) {
    $packages[] = normalizePackage($row)
  }

  $data = {
    packages: $packages,
    total: count($packages),
    registry: 'linkha.sh',
    version: '0.1.0',
    ok: true
  }
  echo jsonReply($data)
}

function apiSearch() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $query = isset($_GET['q']) ? $_GET['q'] : ''
  $me = authCurrentUser()
  $userId = $me['ok'] ? (int) rowValue($me['user'], 'id', 0) : 0
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    $data = {
      query: $query,
      results: [],
      ok: false,
      error: $conn->error
    }
    echo jsonReply($data)
    return
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  $rowsRes = fetchVisiblePackageRows($handle, 50, $query, $userId)
  dbClose($handle)
  if (!rowValue($rowsRes, 'ok', false)) {
    echo jsonReply({
      query: $query,
      results: [],
      total: 0,
      ok: false,
      error: rowValue($rowsRes, 'error', 'query failed')
    })
    return
  }
  $rows = rowValue($rowsRes, 'rows', [])
  $results = []
  foreach ($rows as $row) {
    $results[] = normalizePackage($row)
  }

  $data = {
    query: $query,
    results: $results,
    total: count($results),
    ok: true
  }
  echo jsonReply($data)
}

function apiDbStats() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $res = stats()
  if (!result_is_ok($res)) {
    echo jsonReply({
      ok: false,
      error: $res->error
    })
    return
  }
  echo jsonReply({
    ok: true,
    stats: $res->value
  })
}

function apiPackageStats() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $statsRes = fetchRegistryStatsResult()
  if (!rowValue($statsRes, 'ok', false)) {
    echo jsonReply({ ok: false, error: rowValue($statsRes, 'error', 'stats unavailable') })
    return
  }
  echo jsonReply({
    ok: true,
    stats: rowValue($statsRes, 'stats', []),
    source: rowValue($statsRes, 'source', 'postgres'),
    degraded: rowValue($statsRes, 'degraded', false),
    warning: rowValue($statsRes, 'warning', null)
  })
}

function apiRuntimeChecks() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  echo jsonReply({
    ok: true,
    checks: collectRuntimeChecks()
  })
}

function apiRuntimeAction() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply({ ok: false, error: $auth['error'] })
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply({ ok: false, error: $csrf['error'] })
    return
  }
  $target = queryValue('target', '')
  $op = queryValue('op', '')
  if ($op !== 'write_probe') {
    echo jsonReply({ ok: false, error: 'unsupported op', op: $op })
    return
  }
  $result = runtimeWriteProbe($target)
  echo jsonReply($result)
}

function apiRegistryIdentity() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')

  $handle = '' . queryValue('handle', 'samifou.ad')
  $name = '' . queryValue('name', 'demo-package')
  $version = '' . queryValue('version', '0.1.0')
  $lockHash = '' . queryValue('lock', 'dev')

  echo jsonReply({
    ok: true,
    handle: $handle,
    name: $name,
    version: $version,
    lock_hash: $lockHash,
    canonical_id: registryCanonicalId($handle, $name, $version, $lockHash),
    artifact_key: registryArtifactKey($handle, $name, $version, $lockHash)
  })
}

function requestData() {
  if (is_array($_POST) && count($_POST) > 0) {
    return $_POST
  }
  if (is_array($_GET) && count($_GET) > 0) {
    return $_GET
  }
  return []
}

function queryValue($key, $fallback = null) {
  if (is_array($_GET) && array_key_exists($key, $_GET)) {
    return $_GET[$key]
  }
  if (is_array($_SERVER) && array_key_exists('REQUEST_URI', $_SERVER)) {
    $rawUri = '' . $_SERVER['REQUEST_URI']
    $pos = strpos($rawUri, '?')
    if ($pos !== false) {
      $qs = substr($rawUri, $pos + 1)
      if ($qs !== '') {
        $pairs = explode('&', $qs)
        foreach ($pairs as $pair) {
          if ($pair === '') {
            continue
          }
          $eqPos = strpos($pair, '=')
          $kRaw = $eqPos === false ? $pair : substr($pair, 0, $eqPos)
          $vRaw = $eqPos === false ? '' : substr($pair, $eqPos + 1)
          $k = urldecode('' . $kRaw)
          if ($k !== '' . $key) {
            continue
          }
          $v = urldecode('' . $vRaw)
          return $v
        }
      }
    }
  }
  return $fallback
}

function strStartsWith($value, $prefix) {
  $value = '' . $value
  $prefix = '' . $prefix
  if (strlen($prefix) > strlen($value)) {
    return false
  }
  return substr($value, 0, strlen($prefix)) === $prefix
}

function oauthB64Url($raw) {
  $b64 = base64_encode($raw)
  $out = str_replace('+', '-', $b64)
  $out = str_replace('/', '_', $out)
  return rtrim($out, '=')
}

function stableDigestHex($value, $targetLen = 64) {
  $s = '' . $value
  $h1 = 5381
  $h2 = 52711
  $n = strlen($s)
  for ($i = 0; $i < $n; $i = $i + 1) {
    $c = ord(substr($s, $i, 1))
    $h1 = (($h1 * 33) + $c) % 2147483647
    $h2 = (($h2 * 131) + $c + $i) % 2147483629
  }
  $hex = strtolower(dechex($h1) . dechex($h2) . dechex($n))
  while (strlen($hex) < (int) $targetLen) {
    $h1 = (($h1 * 33) + $h2 + $n) % 2147483647
    $h2 = (($h2 * 131) + $h1 + $n) % 2147483629
    $hex = $hex . strtolower(dechex($h1) . dechex($h2))
  }
  return substr($hex, 0, (int) $targetLen)
}

function sha256Raw($value) {
  if (function_exists('hash')) {
    return hash('sha256', '' . $value, true)
  }
  $hex = stableDigestHex($value, 64)
  if (function_exists('hex2bin')) {
    $raw = hex2bin($hex)
    if ($raw !== false) {
      return $raw
    }
  }
  if (function_exists('pack')) {
    return pack('H*', $hex)
  }
  return $hex
}

function oauthPkceChallenge($verifier) {
  $rawHash = sha256Raw($verifier)
  return oauthB64Url($rawHash)
}

function parseUrlParts($url) {
  $raw = '' . $url
  if ($raw === '') {
    return null
  }
  $parts = parse_url($raw)
  if (!is_array($parts)) {
    return null
  }
  if (!array_key_exists('scheme', $parts) || !array_key_exists('host', $parts)) {
    return null
  }
  $scheme = strtolower('' . $parts['scheme'])
  $host = '' . $parts['host']
  $port = array_key_exists('port', $parts) ? (int) $parts['port'] : ($scheme === 'https' ? 443 : 80)
  $path = array_key_exists('path', $parts) ? ('' . $parts['path']) : '/'
  if ($path === '') {
    $path = '/'
  }
  if (array_key_exists('query', $parts) && ('' . $parts['query']) !== '') {
    $path = $path . '?' . $parts['query']
  }
  return {
    scheme: $scheme,
    host: $host,
    port: $port,
    path: $path
  }
}

function parseHttpHeaders($rawHeaders) {
  $lines = explode("\r\n", '' . $rawHeaders)
  $statusLine = count($lines) > 0 ? ('' . $lines[0]) : ''
  $status = 0
  if (preg_match('/^HTTP\/[0-9.]+\s+([0-9]{3})/', $statusLine, $m)) {
    $status = (int) $m[1]
  }
  $headers = []
  for ($i = 1; $i < count($lines); $i = $i + 1) {
    $line = '' . $lines[$i]
    if ($line === '') {
      continue
    }
    $pos = strpos($line, ':')
    if ($pos === false) {
      continue
    }
    $name = strtolower(trim(substr($line, 0, $pos)))
    $value = trim(substr($line, $pos + 1))
    $headers[$name] = $value
  }
  return { status: $status, headers: $headers }
}

function decodeChunkedBody($chunked) {
  $data = '' . $chunked
  $out = ''
  while (true) {
    $linePos = strpos($data, "\r\n")
    if ($linePos === false) {
      break
    }
    $lenLine = trim(substr($data, 0, $linePos))
    $data = substr($data, $linePos + 2)
    if ($lenLine === '') {
      continue
    }
    $semi = strpos($lenLine, ';')
    if ($semi !== false) {
      $lenLine = substr($lenLine, 0, $semi)
    }
    $len = hexdec($lenLine)
    if (!is_int($len) && !is_float($len)) {
      break
    }
    $len = (int) $len
    if ($len <= 0) {
      break
    }
    if (strlen($data) < $len) {
      break
    }
    $out = $out . substr($data, 0, $len)
    $data = substr($data, $len)
    if (strStartsWith($data, "\r\n")) {
      $data = substr($data, 2)
    }
  }
  return $out
}

function httpRequestRaw($method, $url, $headers = [], $body = '') {
  $parts = parseUrlParts($url)
  if ($parts === null) {
    return { ok: false, error: 'invalid url' }
  }
  $scheme = '' . $parts->scheme
  $host = '' . $parts->host
  $port = (int) $parts->port
  $path = '' . $parts->path

  $conn = tcpConnect($host, $port, { timeout_ms: 15000 })
  if (!result_is_ok($conn)) {
    return { ok: false, error: 'tcp connect failed: ' . $conn->error }
  }
  $handle = $conn->value
  $active = $handle
  if ($scheme === 'https') {
    $up = tls_upgrade($handle, $host)
    if (!result_is_ok($up)) {
      tcpClose($handle)
      return { ok: false, error: 'tls upgrade failed: ' . $up->error }
    }
    $active = $up->value
  }

  $reqHeaders = [
    'Host' => $host,
    'Connection' => 'close',
    'Accept' => 'application/json, text/plain;q=0.9, */*;q=0.8'
  ]
  foreach ($headers as $k => $v) {
    $reqHeaders['' . $k] = '' . $v
  }
  $payload = '' . $body
  if ($payload !== '') {
    $reqHeaders['Content-Length'] = '' . strlen($payload)
  }
  $head = strtoupper('' . $method) . ' ' . $path . " HTTP/1.1\r\n"
  foreach ($reqHeaders as $k => $v) {
    $head = $head . $k . ': ' . $v . "\r\n"
  }
  $request = $head . "\r\n" . $payload

  $wr = $scheme === 'https' ? tls_write($active, $request) : tcpWrite($active, $request)
  if (!result_is_ok($wr)) {
    if ($scheme === 'https') {
      tls_close($active)
      tcpClose($handle)
    } else {
      tcpClose($handle)
    }
    return { ok: false, error: 'write failed: ' . $wr->error }
  }

  $raw = ''
  while (true) {
    $chunk = $scheme === 'https' ? tls_read($active, 4096) : tcpRead($active, 4096)
    if (!result_is_ok($chunk)) {
      break
    }
    $piece = '' . $chunk->value
    if ($piece === '') {
      break
    }
    $raw = $raw . $piece
  }

  if ($scheme === 'https') {
    tls_close($active)
    tcpClose($handle)
  } else {
    tcpClose($handle)
  }

  $sepPos = strpos($raw, "\r\n\r\n")
  if ($sepPos === false) {
    return { ok: false, error: 'invalid http response', raw: $raw }
  }
  $rawHeaders = substr($raw, 0, $sepPos)
  $rawBody = substr($raw, $sepPos + 4)
  $parsed = parseHttpHeaders($rawHeaders)
  $status = (int) $parsed->status
  $outHeaders = $parsed->headers
  if (is_array($outHeaders) && array_key_exists('transfer-encoding', $outHeaders)) {
    $te = strtolower('' . $outHeaders['transfer-encoding'])
    if (strpos($te, 'chunked') !== false) {
      $rawBody = decodeChunkedBody($rawBody)
    }
  }

  return {
    ok: true,
    status: $status,
    headers: $outHeaders,
    body: $rawBody
  }
}

function formUrlEncode($pairs) {
  $parts = []
  foreach ($pairs as $k => $v) {
    $parts[] = urlencode('' . $k) . '=' . urlencode('' . $v)
  }
  return implode('&', $parts)
}

function linkhashGitApiBase() {
  $base = trim('' . envValue('LINKHASH_GIT_API_URL', gitApiDefaultBase()))
  if ($base === '') {
    return 'http://localhost:8508'
  }
  return rtrim($base, '/')
}

function fetchRemoteReleaseDocs($org, $name, $version) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $ver = trim('' . $version)
  if ($scope === '' || $pkg === '' || $ver === '') {
    return [ 'ok' => false, 'error' => 'invalid docs target' ]
  }
  $url = linkhashGitApiBase() . scopedReleaseDocsPath($scope, $pkg, $ver)
  $res = httpRequestRaw('GET', $url, [ 'Accept' => 'application/json' ], '')
  if (!is_array($res) || !rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'docs request failed' ]
  }
  $status = (int) rowValue($res, 'status', 0)
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'docs not available', 'status' => $status ]
  }
  $decoded = json_decode_result(rowValue($res, 'body', '{}'), true)
  if (!result_is_ok($decoded) || !is_array($decoded->value)) {
    return [ 'ok' => false, 'error' => 'invalid docs payload' ]
  }
  return [ 'ok' => true, 'value' => $decoded->value ]
}

function fetchRemoteReleaseTree($org, $name, $version) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $ver = trim('' . $version)
  if ($scope === '' || $pkg === '' || $ver === '') {
    return [ 'ok' => false, 'error' => 'invalid tree target' ]
  }
  $url = linkhashGitApiBase() . scopedReleaseTreePath($scope, $pkg, $ver)
  $res = httpRequestRaw('GET', $url, [ 'Accept' => 'application/json' ], '')
  if (!is_array($res) || !rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'tree request failed' ]
  }
  $status = (int) rowValue($res, 'status', 0)
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'tree not available', 'status' => $status ]
  }
  $decoded = json_decode_result(rowValue($res, 'body', '{}'), true)
  if (!result_is_ok($decoded) || !is_array($decoded->value)) {
    return [ 'ok' => false, 'error' => 'invalid tree payload' ]
  }
  return [ 'ok' => true, 'value' => $decoded->value ]
}

function fetchRemoteReleaseBlob($org, $name, $version, $path) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $ver = trim('' . $version)
  $file = ltrim(trim('' . $path), '/')
  if ($scope === '' || $pkg === '' || $ver === '' || $file === '') {
    return [ 'ok' => false, 'error' => 'invalid blob target' ]
  }
  $url = linkhashGitApiBase() . scopedReleaseBlobPath($scope, $pkg, $ver, $file)
  $res = httpRequestRaw('GET', $url, [ 'Accept' => 'application/json' ], '')
  if (!is_array($res) || !rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'blob request failed' ]
  }
  $status = (int) rowValue($res, 'status', 0)
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'blob not available', 'status' => $status ]
  }
  $decoded = json_decode_result(rowValue($res, 'body', '{}'), true)
  if (!result_is_ok($decoded) || !is_array($decoded->value)) {
    return [ 'ok' => false, 'error' => 'invalid blob payload' ]
  }
  return [ 'ok' => true, 'value' => $decoded->value ]
}

function linkhashGitAuthToken() {
  $token = trim('' . envValue('LINKHASH_GIT_TOKEN', ''))
  if ($token !== '') {
    return $token
  }
  return trim('' . envValue('LINKHASH_GIT_API_TOKEN', ''))
}

function linkhashGitAuthHeaders($extra = []) {
  $headers = is_array($extra) ? $extra : []
  $headers['Accept'] = 'application/json'
  $token = linkhashGitAuthToken()
  if ($token !== '') {
    $headers['Authorization'] = 'Bearer ' . $token
  }
  return $headers
}

function fetchRemoteGitJson($method, $path, $payload = null) {
  $url = linkhashGitApiBase() . $path
  $body = ''
  $headers = linkhashGitAuthHeaders([])
  if ($payload !== null) {
    $encoded = encodeJson(normalizeJsonValue($payload))
    if (!is_string($encoded)) {
      return [ 'ok' => false, 'error' => 'json encode failed' ]
    }
    $body = $encoded
    $headers['Content-Type'] = 'application/json'
  }
  $res = httpRequestRaw($method, $url, $headers, $body)
  if (!is_array($res) || !rowValue($res, 'ok', false)) {
    return [ 'ok' => false, 'error' => 'request failed' ]
  }
  $status = (int) rowValue($res, 'status', 0)
  $decoded = json_decode_result(rowValue($res, 'body', '{}'), true)
  if (!result_is_ok($decoded) || !is_array($decoded->value)) {
    return [ 'ok' => false, 'error' => 'invalid response payload', 'status' => $status ]
  }
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => '' . rowValue($decoded->value, 'error', 'request rejected'), 'status' => $status, 'payload' => $decoded->value ]
  }
  return [ 'ok' => true, 'value' => $decoded->value, 'status' => $status ]
}

function fetchRemoteRepoIssues($org, $name, $state = 'open') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  if ($scope === '' || $pkg === '') {
    return [ 'ok' => false, 'error' => 'invalid issues target' ]
  }
  return fetchRemoteGitJson('GET', repoIssuesPath($scope, $pkg, $state))
}

function fetchRemoteRepoIssueDetail($org, $name, $number) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  if ($scope === '' || $pkg === '' || $n <= 0) {
    return [ 'ok' => false, 'error' => 'invalid issue target' ]
  }
  return fetchRemoteGitJson('GET', repoIssueDetailPath($scope, $pkg, $n))
}

function createRemoteRepoIssue($org, $name, $title, $body = '') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $t = trim('' . $title)
  if ($scope === '' || $pkg === '' || $t === '') {
    return [ 'ok' => false, 'error' => 'org, package, and title are required' ]
  }
  return fetchRemoteGitJson('POST', '/api/repos/' . rawurlencode($scope) . '/' . rawurlencode($pkg) . '/issues', [
    'title' => $t,
    'body' => trim('' . $body)
  ])
}

function createRemoteRepoIssueComment($org, $name, $number, $body) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  $text = trim('' . $body)
  if ($scope === '' || $pkg === '' || $n <= 0 || $text === '') {
    return [ 'ok' => false, 'error' => 'org, package, issue, and comment body are required' ]
  }
  return fetchRemoteGitJson('POST', repoIssueCommentPath($scope, $pkg, $n), [
    'body' => $text
  ])
}

function fetchRemoteRepoPulls($org, $name, $state = 'open') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  if ($scope === '' || $pkg === '') {
    return [ 'ok' => false, 'error' => 'invalid pull target' ]
  }
  return fetchRemoteGitJson('GET', repoPullsPath($scope, $pkg, $state))
}

function fetchRemoteRepoPullDetail($org, $name, $number) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  if ($scope === '' || $pkg === '' || $n <= 0) {
    return [ 'ok' => false, 'error' => 'invalid pull target' ]
  }
  return fetchRemoteGitJson('GET', repoPullDetailPath($scope, $pkg, $n))
}

function createRemoteRepoPull($org, $name, $title, $sourceRef, $targetRef, $body = '') {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $t = trim('' . $title)
  $src = trim('' . $sourceRef)
  $dst = trim('' . $targetRef)
  if ($scope === '' || $pkg === '' || $t === '' || $src === '' || $dst === '') {
    return [ 'ok' => false, 'error' => 'org, package, title, source_ref, and target_ref are required' ]
  }
  return fetchRemoteGitJson('POST', '/api/repos/' . rawurlencode($scope) . '/' . rawurlencode($pkg) . '/pulls', [
    'title' => $t,
    'body' => trim('' . $body),
    'source_ref' => $src,
    'target_ref' => $dst
  ])
}

function createRemoteRepoPullComment($org, $name, $number, $body) {
  $scope = normalizeHandleName($org)
  $pkg = normalizePackageName($name)
  $n = (int) $number
  $text = trim('' . $body)
  if ($scope === '' || $pkg === '' || $n <= 0 || $text === '') {
    return [ 'ok' => false, 'error' => 'org, package, pull, and comment body are required' ]
  }
  return fetchRemoteGitJson('POST', repoPullCommentPath($scope, $pkg, $n), [
    'body' => $text
  ])
}

function fetchRepoRefResolution($owner, $repo, $ref = 'HEAD') {
  $org = normalizeHandleName($owner)
  $name = normalizePackageName($repo)
  $targetRef = trim('' . $ref)
  if ($targetRef === '') {
    $targetRef = 'HEAD'
  }
  if ($org === '' || $name === '') {
    return [ 'ok' => false, 'error' => 'invalid preview target' ]
  }
  return fetchRemoteGitJson('GET', repoResolvePath($org, $name, $targetRef))
}

function createRemoteRepoFork($sourceOwner, $sourceRepo, $targetRepo) {
  $owner = normalizeHandleName($sourceOwner)
  $repo = normalizePackageName($sourceRepo)
  $target = normalizePackageName($targetRepo)
  if ($owner === '' || $repo === '' || $target === '') {
    return [ 'ok' => false, 'error' => 'invalid fork target' ]
  }
  return fetchRemoteGitJson('POST', repoForkPath($owner, $repo), [
    'target_repo' => $target
  ])
}

function adwaBaseUrl() {
  return buildAdwaBaseUrl(envValue('LINKHASH_ADWA_BASE_URL', 'http://localhost:8600'))
}

function adwaPreviewUrl($owner, $repo, $commit) {
  return buildAdwaPreviewUrl(adwaBaseUrl(), normalizeHandleName($owner), normalizePackageName($repo), $commit)
}

function adwaEditUrl($owner, $repo, $commit = '') {
  return buildAdwaEditUrl(adwaBaseUrl(), normalizeHandleName($owner), normalizePackageName($repo), $commit)
}

function oauthConfig() {
  $clientId = '' . envValue('LINKHASH_OAUTH_CLIENT_ID', 'linkhash-dev')
  $clientSecret = '' . envValue('LINKHASH_OAUTH_CLIENT_SECRET', '')
  $callback = '' . envValue('LINKHASH_OAUTH_CALLBACK', 'http://localhost:8530/api/auth/callback')
  $authUrl = '' . envValue('LINKHASH_OAUTH_AUTH_URL', 'https://bsky.social/oauth/authorize')
  $tokenUrl = '' . envValue('LINKHASH_OAUTH_TOKEN_URL', 'https://bsky.social/oauth/token')
  $profileUrl = '' . envValue('LINKHASH_OAUTH_PROFILE_URL', 'https://bsky.social/xrpc/com.atproto.server.getSession')
  $scope = '' . envValue('LINKHASH_OAUTH_SCOPE', 'atproto transition:generic')
  return {
    clientId: $clientId,
    clientSecret: $clientSecret,
    callback: $callback,
    authUrl: $authUrl,
    tokenUrl: $tokenUrl,
    profileUrl: $profileUrl,
    scope: $scope
  }
}

function oauthCallbackAllowed($callback) {
  $allowlistRaw = '' . envValue('LINKHASH_OAUTH_CALLBACK_ALLOWLIST', '')
  if ($allowlistRaw === '') {
    return true
  }
  $target = '' . $callback
  $parts = explode(',', $allowlistRaw)
  foreach ($parts as $item) {
    $candidate = trim('' . $item)
    if ($candidate === '') {
      continue
    }
    if ($candidate === $target) {
      return true
    }
  }
  return false
}

function oauthFetchProfile($accessToken, $cfg) {
  $res = httpRequestRaw('GET', '' . $cfg->profileUrl, [
    'Authorization' => 'Bearer ' . $accessToken,
    'Accept' => 'application/json'
  ])
  if (!is_array($res) || !$res['ok']) {
    return [ 'ok' => false, 'error' => 'profile request failed' ]
  }
  if ((int) $res['status'] < 200 || (int) $res['status'] >= 300) {
    return [ 'ok' => false, 'error' => 'profile request rejected', 'status' => $res['status'], 'body' => $res['body'] ]
  }
  $decoded = json_decode_result($res['body'], true)
  if (!result_is_ok($decoded)) {
    return [ 'ok' => false, 'error' => 'invalid profile json' ]
  }
  $profile = $decoded->value
  if (!is_array($profile)) {
    return [ 'ok' => false, 'error' => 'invalid profile payload' ]
  }
  $did = array_key_exists('did', $profile) ? ('' . $profile['did']) : ''
  $handle = array_key_exists('handle', $profile) ? ('' . $profile['handle']) : ''
  if ($did === '' && array_key_exists('sub', $profile)) {
    $did = '' . $profile['sub']
  }
  if ($handle === '' && array_key_exists('preferred_username', $profile)) {
    $handle = '' . $profile['preferred_username']
  }
  if ($did === '' || $handle === '') {
    return [ 'ok' => false, 'error' => 'profile missing did/handle', 'profile' => $profile ]
  }
  $display = array_key_exists('displayName', $profile) ? ('' . $profile['displayName']) : $handle
  return [ 'ok' => true, 'did' => $did, 'handle' => $handle, 'displayName' => $display, 'profile' => $profile ]
}

function oauthPackContext($state, $pkceVerifier) {
  return ('' . $state) . '.' . ('' . $pkceVerifier)
}

function oauthUnpackContext($packed) {
  $raw = '' . $packed
  $pos = strpos($raw, '.')
  if ($pos === false) {
    return null
  }
  $state = substr($raw, 0, $pos)
  $pkce = substr($raw, $pos + 1)
  if ($state === '' || $pkce === '') {
    return null
  }
  return { state: '' . $state, pkce: '' . $pkce }
}

function requestCookie($name, $fallback = null) {
  $value = cookieGet($name, null)
  if ($value !== null && $value !== '') {
    return urldecode('' . $value)
  }
  if (!is_array($_SERVER) || !array_key_exists('HTTP_COOKIE', $_SERVER)) {
    return $fallback
  }
  $header = '' . $_SERVER['HTTP_COOKIE']
  if ($header === '') {
    return $fallback
  }
  $parts = explode(';', $header)
  $target = '' . $name
  foreach ($parts as $part) {
    $piece = trim($part)
    $eqPos = strpos($piece, '=')
    if ($eqPos === false) {
      continue
    }
    $k = trim(substr($piece, 0, $eqPos))
    $v = trim(substr($piece, $eqPos + 1))
    if ($k === $target) {
      return urldecode($v)
    }
  }
  return $fallback
}

function authRequestToken() {
  $token = requestCookie('lh_session', null)
  if ($token !== null && $token !== '') {
    return $token
  }
  $allowQuery = strtolower('' . envValue('LINKHASH_ALLOW_QUERY_SESSION', '0'))
  if ($allowQuery === '1' || $allowQuery === 'true' || $allowQuery === 'yes' || $allowQuery === 'on') {
    $q = queryValue('session', null)
    if ($q !== null && $q !== '') {
      return '' . $q
    }
  }
  if (is_array($_SERVER) && array_key_exists('HTTP_AUTHORIZATION', $_SERVER)) {
    $raw = '' . $_SERVER['HTTP_AUTHORIZATION']
    if (strlen($raw) >= 7 && strtolower(substr($raw, 0, 7)) === 'bearer ') {
      $bearer = trim(substr($raw, 7))
      if ($bearer !== '') {
        return $bearer
      }
    }
  }
  return null
}

function requestMethod() {
  if (is_array($_SERVER) && array_key_exists('REQUEST_METHOD', $_SERVER)) {
    return strtoupper('' . $_SERVER['REQUEST_METHOD'])
  }
  return 'GET'
}

function requireMethod($expected) {
  $actual = requestMethod()
  $want = strtoupper('' . $expected)
  if ($actual !== $want) {
    return [ 'ok' => false, 'error' => 'method not allowed', 'expected' => $want, 'actual' => $actual ]
  }
  return [ 'ok' => true ]
}

function normalizeJsonValue($value, $depth = 0) {
  if ($depth > 32) {
    return null
  }
  $t = gettype($value)
  if ($t === 'NULL' || $t === 'boolean' || $t === 'integer' || $t === 'double' || $t === 'string') {
    return $value
  }
  if (is_array($value)) {
    $out = []
    foreach ($value as $k => $v) {
      $out[$k] = normalizeJsonValue($v, $depth + 1)
    }
    return $out
  }
  if (is_object($value)) {
    $out = []
    foreach ($value as $k => $v) {
      $out['' . $k] = normalizeJsonValue($v, $depth + 1)
    }
    if (count($out) > 0) {
      return $out
    }

    $arr = (array) $value
    if (count($arr) === 1 && array_key_exists(0, $arr) && (is_object($arr[0]) || is_array($arr[0]))) {
      return normalizeJsonValue($arr[0], $depth + 1)
    }
    if (count($arr) === 1 && array_key_exists('0', $arr) && (is_object($arr['0']) || is_array($arr['0']))) {
      return normalizeJsonValue($arr['0'], $depth + 1)
    }
    foreach ($arr as $k => $v) {
      $out['' . $k] = normalizeJsonValue($v, $depth + 1)
    }
    return $out
  }
  if ($t === 'resource') {
    return null
  }
  return '' . $value
}

function jsonReply($value) {
  $encoded = encodeJson(normalizeJsonValue($value))
  if (!is_string($encoded)) {
    return '{"ok":false,"error":"encode failed"}'
  }
  return $encoded
}

function wantsHtmlResponse() {
  if (!is_array($_SERVER) || !array_key_exists('HTTP_ACCEPT', $_SERVER)) {
    return false
  }
  $accept = strtolower('' . $_SERVER['HTTP_ACCEPT'])
  return strpos($accept, 'text/html') !== false
}

function redirectTo($url, $status = '302 Found') {
  header('HTTP/1.1 ' . $status)
  header('Location: ' . $url)
}

function cookieSecureFlag() {
  $raw = strtolower(trim('' . envValue('LINKHASH_SECURE_COOKIES', 'false')))
  return $raw === '1' || $raw === 'true' || $raw === 'yes'
}

function requestMethod() {
  if (is_array($_SERVER) && array_key_exists('REQUEST_METHOD', $_SERVER)) {
    return strtoupper('' . $_SERVER['REQUEST_METHOD'])
  }
  return 'GET'
}

function requestPath() {
  if (is_array($_SERVER) && array_key_exists('REQUEST_URI', $_SERVER)) {
    $uri = '' . $_SERVER['REQUEST_URI']
    $parts = explode('?', $uri)
    return count($parts) > 0 ? ('' . $parts[0]) : $uri
  }
  return '/'
}

function requestId() {
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_request_id', $GLOBALS) && ('' . $GLOBALS['__lh_request_id']) !== '') {
    return '' . $GLOBALS['__lh_request_id']
  }
  $incoming = is_array($_SERVER) && array_key_exists('HTTP_X_REQUEST_ID', $_SERVER) ? ('' . $_SERVER['HTTP_X_REQUEST_ID']) : ''
  $rid = $incoming !== '' ? $incoming : ('req_' . devRandomHex(24))
  if (isset($GLOBALS) && is_array($GLOBALS)) {
    $GLOBALS['__lh_request_id'] = $rid
  }
  return $rid
}

function logDirPath() {
  return '' . envValue('LINKHASH_LOG_DIR', 'storage/logs')
}

function ensureLogDir() {
  $dir = trim(logDirPath())
  if ($dir === '') {
    return false
  }
  if (is_dir($dir)) {
    return true
  }
  $parts = explode('/', $dir)
  $current = ''
  foreach ($parts as $part) {
    $seg = trim('' . $part)
    if ($seg === '') {
      continue
    }
    $current = $current === '' ? $seg : ($current . '/' . $seg)
    if (!is_dir($current)) {
      @mkdir($current)
    }
  }
  return is_dir($dir)
}

function appendLogLine($line) {
  $clean = trim('' . $line)
  $logFile = '' . envValue('LINKHASH_LOG_FILE', '')
  if (function_exists('error_log')) {
    if ($logFile !== '') {
      @error_log($clean . "\n", 3, $logFile)
    }
    @error_log('[linkhash] ' . $clean)
    return true
  }
  return false
}

function ensureEventLogSchema($db) {
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_event_log_schema_ready', $GLOBALS) && $GLOBALS['__lh_event_log_schema_ready'] === true) {
    return
  }
  dbExec(
    $db,
    'create table if not exists lh_event_log (
      id bigserial primary key,
      ts timestamptz not null default now(),
      level text not null,
      event text not null,
      request_id text,
      method text,
      path text,
      meta_json text
    )',
    []
  )
  if (isset($GLOBALS) && is_array($GLOBALS)) {
    $GLOBALS['__lh_event_log_schema_ready'] = true
  }
}

function logEventDb($payload) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return
  }
  $db = $conn->value
  ensureEventLogSchema($db)
  $metaJson = encodeJson(normalizeJsonValue(rowValue($payload, 'meta', {})))
  if (!is_string($metaJson)) {
    $metaJson = '{}'
  }
  dbExec(
    $db,
    'insert into lh_event_log (level, event, request_id, method, path, meta_json) values ($1, $2, $3, $4, $5, $6)',
    [
      '' . rowValue($payload, 'level', 'info'),
      '' . rowValue($payload, 'event', 'unknown'),
      '' . rowValue($payload, 'requestId', ''),
      '' . rowValue($payload, 'method', ''),
      '' . rowValue($payload, 'path', ''),
      $metaJson
    ]
  )
  dbClose($db)
}

function logEvent($level, $event, $meta = []) {
  $payload = {
    ts: gmdate('c'),
    level: '' . $level,
    event: '' . $event,
    requestId: requestId(),
    method: requestMethod(),
    path: requestPath(),
    meta: normalizeJsonValue($meta)
  }
  $line = jsonReply($payload)
  appendLogLine($line . "\n")
  $backend = strtolower('' . envValue('LINKHASH_LOG_BACKEND', 'db'))
  if ($backend === 'db') {
    logEventDb($payload)
  }
}

function ensureAuditSchema($db) {
  if (isset($GLOBALS) && is_array($GLOBALS) && array_key_exists('__lh_audit_schema_ready', $GLOBALS) && $GLOBALS['__lh_audit_schema_ready'] === true) {
    return
  }
  dbExec(
    $db,
    'create table if not exists lh_audit_log (
      id bigserial primary key,
      created_at timestamptz not null default now(),
      action text not null,
      result text not null default \'ok\',
      actor_user_id bigint,
      actor_handle text,
      auth_kind text,
      scope_mask integer not null default 0,
      subject_kind text,
      subject_ref text,
      request_id text,
      method text,
      path text,
      ip_address text,
      detail_json text
    )',
    []
  )
  if (isset($GLOBALS) && is_array($GLOBALS)) {
    $GLOBALS['__lh_audit_schema_ready'] = true
  }
}

function auditEvent($action, $auth, $result = 'ok', $subjectKind = '', $subjectRef = '', $details = []) {
  $authKind = 'anonymous'
  $scopeMask = 0
  $actorUserId = null
  $actorHandle = ''
  if (is_array($auth) && rowValue($auth, 'ok', false)) {
    $authKind = '' . rowValue($auth, 'kind', 'session')
    $scopeMask = (int) rowValue($auth, 'scopeMask', 0)
    $user = rowValue($auth, 'user', null)
    if ($user !== null) {
      $uid = (int) rowValue($user, 'id', 0)
      if ($uid > 0) {
        $actorUserId = $uid
      }
      $actorHandle = '' . rowValue($user, 'handle', '')
    }
  }
  $detailJson = encodeJson(normalizeJsonValue($details))
  if (!is_string($detailJson)) {
    $detailJson = '{}'
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  ensureAuditSchema($db)
  dbExec(
    $db,
    'insert into lh_audit_log (action, result, actor_user_id, actor_handle, auth_kind, scope_mask, subject_kind, subject_ref, detail_json) values ($1, $2, nullif($3, \'\')::bigint, $4, $5, ($6)::text::integer, $7, $8, $9)',
    [
      '' . $action,
      '' . $result,
      $actorUserId === null ? '' : ('' . $actorUserId),
      $actorHandle,
      $authKind,
      '' . $scopeMask,
      '' . $subjectKind,
      '' . $subjectRef,
      $detailJson
    ]
  )
  dbClose($db)
}

function linkhashErrorHandler($errno, $errstr, $errfile, $errline) {
  logEvent('error', 'php.warning', {
    errno: (int) $errno,
    message: '' . $errstr,
    file: '' . $errfile,
    line: (int) $errline
  })
  return false
}

function linkhashShutdownHandler() {
  if (!function_exists('error_get_last')) {
    return
  }
  $last = error_get_last()
  if (!is_array($last) || count($last) === 0) {
    return
  }
  logEvent('error', 'php.shutdown', {
    type: rowValue($last, 'type', null),
    message: rowValue($last, 'message', ''),
    file: rowValue($last, 'file', ''),
    line: rowValue($last, 'line', 0)
  })
}

function installRuntimeHandlers() {
  if (function_exists('set_error_handler')) {
    set_error_handler('linkhashErrorHandler')
  }
  if (function_exists('register_shutdown_function')) {
    register_shutdown_function('linkhashShutdownHandler')
  }
}

function authScopeMask($scopeText) {
  $mask = 0
  $parts = explode(',', strtolower('' . $scopeText))
  foreach ($parts as $part) {
    $item = trim($part)
    if ($item === 'read') {
      $mask = $mask | 1
    } else if ($item === 'read:write') {
      $mask = $mask | 3
    } else if ($item === 'read:write:delete') {
      $mask = $mask | 7
    }
  }
  if ($mask === 0) {
    $mask = 1
  }
  return $mask
}

function authScopeText($mask) {
  $out = []
  $m = (int) $mask
  if (($m & 1) !== 0) {
    $out[] = 'read'
  }
  if (($m & 2) !== 0) {
    $out[] = 'read:write'
  }
  if (($m & 4) !== 0) {
    $out[] = 'read:write:delete'
  }
  return implode(',', $out)
}

function authTokenHash($token) {
  return sha256Hex('' . $token)
}

function secureStringEquals($a, $b): bool {
  $left = '' . $a
  $right = '' . $b
  if (function_exists('hash_equals')) {
    return hash_equals($left, $right)
  }
  $leftLen = strlen($left)
  $rightLen = strlen($right)
  $len = max($leftLen, $rightLen)
  $diff = $leftLen ^ $rightLen
  for ($i = 0; $i < $len; $i = $i + 1) {
    $lc = $i < $leftLen ? ord(substr($left, $i, 1)) : 0
    $rc = $i < $rightLen ? ord(substr($right, $i, 1)) : 0
    $diff = $diff | ($lc ^ $rc)
  }
  return $diff === 0
}

function authSessionExpiresAt($seconds = 604800) {
  return gmdate('Y-m-d H:i:s', time() + (int) $seconds)
}

function authIdleTimeoutSeconds() {
  return max(300, (int) envValue('LINKHASH_SESSION_IDLE_SECONDS', '86400'))
}

function authMaxTimeoutSeconds() {
  return max(300, (int) envValue('LINKHASH_SESSION_MAX_SECONDS', '604800'))
}

function isNoRowsError($error): bool {
  $msg = strtolower('' . $error)
  return strpos($msg, 'no rows') !== false || strpos($msg, 'not found') !== false
}

function authSelectUserByDid($db, $did) {
  return dbQueryOne(
    $db,
    "select id, did, handle, display_name as displayName from lh_users where did = $1 limit 1",
    [$did]
  )
}

function authUpsertUserByDid($db, $did, $handle, $displayName) {
  $existing = authSelectUserByDid($db, $did)
  if (result_is_ok($existing)) {
    $up = dbExec(
      $db,
      "update lh_users set handle = $1, display_name = $2, updated_at = now() where did = $3",
      [$handle, $displayName, $did]
    )
    if (!result_is_ok($up)) {
      return $up
    }
    return authSelectUserByDid($db, $did)
  }
  if (!isNoRowsError($existing->error)) {
    return $existing
  }

  $ins = dbExec(
    $db,
    "insert into lh_users (did, handle, display_name, created_at, updated_at) values ($1, $2, $3, now(), now())",
    [$did, $handle, $displayName]
  )
  if (!result_is_ok($ins)) {
    return $ins
  }
  return authSelectUserByDid($db, $did)
}

function clientIp() {
  if (is_array($_SERVER) && array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) {
    $raw = '' . $_SERVER['HTTP_X_FORWARDED_FOR']
    $parts = explode(',', $raw)
    if (count($parts) > 0) {
      $first = trim('' . $parts[0])
      if ($first !== '') {
        return $first
      }
    }
  }
  if (is_array($_SERVER) && array_key_exists('REMOTE_ADDR', $_SERVER)) {
    $ip = trim('' . $_SERVER['REMOTE_ADDR'])
    if ($ip !== '') {
      return $ip
    }
  }
  return 'unknown'
}

function reservedHandles() {
  return [
    'deka', 'linkhash', 'admin', 'support', 'system', 'root', 'security',
    'api', 'auth', 'www', 'assets', 'cdn', 'status', 'ops', 'infra',
    'help', 'docs', 'mail', 'postmaster', 'abuse', 'owner', 'owners',
    'maintainer', 'maintainers', 'publisher', 'publishers', 'billing',
    'payments', 'legal', 'privacy', 'terms', 'contact', 'team', 'teams',
    'about', 'blog', 'news', 'download', 'downloads', 'search', 'new',
    'create', 'dashboard', 'settings', 'login', 'logout', 'signin',
    'signup', 'register', 'account', 'accounts', 'user', 'users'
  ]
}

function reservedPackageNames() {
  return [
    'core', 'runtime', 'php', 'phpx', 'stdlib', 'modules', 'internal',
    'deka', 'linkhash', 'api', 'auth', 'system', 'root', 'admin',
    'support', 'security', 'test', 'tests', 'example', 'examples'
  ]
}

function normalizeHandleName($handle) {
  $h = strtolower(trim('' . $handle))
  if (strStartsWith($h, '@')) {
    $h = substr($h, 1)
  }
  return $h
}

function normalizePackageName($name) {
  return strtolower(trim('' . $name))
}

function isReservedHandle($handle) {
  $h = normalizeHandleName($handle)
  if ($h === '') {
    return true
  }
  foreach (reservedHandles() as $reserved) {
    if ($h === $reserved) {
      return true
    }
  }
  return false
}

function isValidHandleName($handle) {
  $h = normalizeHandleName($handle)
  if ($h === '') {
    return false
  }
  return preg_match('/^[a-z0-9](?:[a-z0-9.-]{0,62}[a-z0-9])?$/', $h) === 1
}

function isReservedPackageName($name) {
  $n = normalizePackageName($name)
  if ($n === '') {
    return true
  }
  foreach (reservedPackageNames() as $reserved) {
    if ($n === $reserved) {
      return true
    }
  }
  return false
}

function isValidPackageName($name) {
  $n = normalizePackageName($name)
  if ($n === '') {
    return false
  }
  return preg_match('/^[a-z0-9](?:[a-z0-9._-]{0,126}[a-z0-9])?$/', $n) === 1
}

function ensureAuthSchema($db) {
  dbExec($db, 'create table if not exists lh_users (id bigserial primary key, did text not null unique, handle text not null unique, display_name text, avatar_url text, created_at timestamptz not null default now(), updated_at timestamptz not null default now())', [])
  dbExec($db, 'create table if not exists lh_sessions (id bigserial primary key, user_id bigint not null references lh_users(id) on delete cascade, session_token_hash text not null unique, csrf_token_hash text, ip_address text, user_agent text, last_seen_at timestamptz not null default now(), expires_at timestamptz not null, created_at timestamptz not null default now(), revoked_at timestamptz)', [])
  dbExec($db, 'alter table lh_sessions add column if not exists csrf_token_hash text', [])
  dbExec($db, 'create table if not exists lh_api_tokens (id bigserial primary key, user_id bigint not null references lh_users(id) on delete cascade, token_prefix text not null, token_hash text not null unique, scope_mask integer not null, label text, last_used_at timestamptz, expires_at timestamptz, created_at timestamptz not null default now(), revoked_at timestamptz)', [])
  dbExec($db, "create table if not exists lh_orgs (id bigserial primary key, handle text not null unique, visibility text not null default 'public', created_at timestamptz not null default now(), updated_at timestamptz not null default now())", [])
  dbExec($db, "create table if not exists lh_org_members (id bigserial primary key, org_id bigint not null references lh_orgs(id) on delete cascade, user_id bigint not null references lh_users(id) on delete cascade, role text not null, created_at timestamptz not null default now(), revoked_at timestamptz, unique (org_id, user_id))", [])
  dbExec($db, "update lh_org_members set role = 'publisher' where lower(role) = 'owner'", [])
  dbExec($db, "create index if not exists lh_org_members_org_idx on lh_org_members(org_id)", [])
  dbExec($db, "create index if not exists lh_org_members_user_idx on lh_org_members(user_id)", [])
  dbExec($db, "create table if not exists lh_rate_limit_hits (id bigserial primary key, bucket text not null, subject_key text not null, created_at timestamptz not null default now())", [])
  dbExec($db, "create index if not exists lh_rate_limit_bucket_subject_idx on lh_rate_limit_hits(bucket, subject_key, created_at)", [])
  dbExec($db, "create table if not exists lh_audit_log (id bigserial primary key, created_at timestamptz not null default now(), action text not null, result text not null default 'ok', actor_user_id bigint, actor_handle text, auth_kind text, scope_mask integer not null default 0, subject_kind text, subject_ref text, request_id text, method text, path text, ip_address text, detail_json text)", [])
  dbExec($db, "create index if not exists lh_audit_log_created_idx on lh_audit_log(created_at)", [])
  dbExec($db, "create table if not exists packages (id bigserial primary key, org_id bigint not null, name text not null, description text not null default '', latest_version text not null default '0.1.0', download_count bigint not null default 0, visibility text not null default 'public', private_read_mask integer not null default 0, created_at timestamptz not null default now(), updated_at timestamptz not null default now())", [])
  dbExec($db, "create unique index if not exists idx_packages_org_name on packages(org_id, lower(name))", [])
  dbExec($db, "alter table packages add column if not exists visibility text not null default 'public'", [])
  dbExec($db, "alter table packages add column if not exists private_read_mask integer not null default 0", [])
  dbExec($db, "create table if not exists package_versions (id bigserial primary key, package_id bigint not null references packages(id) on delete cascade, version text not null, main_file text default 'index.phpx', files jsonb not null default '[]'::jsonb, dependencies jsonb not null default '{}'::jsonb, readme text not null default '', published_at timestamptz not null default now(), r2_key text, sha256 text, canonical_id text, lock_hash text, artifact_backend text not null default 'local', artifact_key text, artifact_mime text not null default 'application/octet-stream', artifact_size_bytes bigint not null default 0)", [])
  dbExec($db, "alter table package_versions add column if not exists artifact_inline_b64 text", [])
  dbExec($db, "alter table package_versions add column if not exists capability_metadata jsonb", [])
  dbExec($db, "create unique index if not exists idx_package_versions_package_version on package_versions(package_id, version)", [])
  dbExec($db, "create unique index if not exists idx_package_versions_canonical_id on package_versions(canonical_id) where canonical_id is not null", [])
  dbExec($db, "create table if not exists downloads (id bigserial primary key, package_id bigint not null references packages(id) on delete cascade, version_id bigint not null references package_versions(id) on delete cascade, downloaded_at timestamptz not null default now(), ip_address text, user_agent text)", [])
}

function bootstrapSchema() {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    logEvent('error', 'schema.bootstrap_failed', { error: $conn->error })
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  dbClose($db)
}

function ensureUserOrgMembership($db, $user) {
  $userId = '' . rowValue($user, 'id', '0')
  $handle = '' . rowValue($user, 'handle', '')
  $normalized = normalizeHandleName($handle)
  if ($normalized === '' || isReservedHandle($normalized)) {
    return [ 'ok' => false, 'error' => 'reserved or invalid org handle' ]
  }

  $org = dbQueryOne(
    $db,
    "insert into lh_orgs (handle, visibility, created_at, updated_at) values ($1, 'public', now(), now()) on conflict (handle) do update set updated_at = now() returning id, handle, visibility",
    [$normalized]
  )
  if (!result_is_ok($org)) {
    return [ 'ok' => false, 'error' => $org->error ]
  }

  $orgId = '' . rowValue($org->value, 'id', '0')
  $membership = dbExec(
    $db,
    "insert into lh_org_members (org_id, user_id, role, created_at) values (($1)::text::bigint, ($2)::text::bigint, 'publisher', now()) on conflict (org_id, user_id) do update set role = 'publisher', revoked_at = null",
    [$orgId, $userId]
  )
  if (!result_is_ok($membership)) {
    return [ 'ok' => false, 'error' => $membership->error ]
  }

  return [ 'ok' => true, 'org' => $org->value ]
}

function canonicalOrgRole($role) {
  $r = strtolower(trim('' . $role))
  if ($r === 'owner') {
    return 'publisher'
  }
  return $r
}

function orgMemberRole($db, $orgId, $userId) {
  $row = dbQueryOne(
    $db,
    "select role from lh_org_members where org_id = ($1)::text::bigint and user_id = ($2)::text::bigint and revoked_at is null limit 1",
    ['' . $orgId, '' . $userId]
  )
  if (!result_is_ok($row)) {
    return null
  }
  return canonicalOrgRole(rowValue($row->value, 'role', ''))
}

function canEditOrg($db, $orgId, $userId) {
  $role = orgMemberRole($db, $orgId, $userId)
  return $role === 'publisher' || $role === 'maintainer'
}

function canManageOrg($db, $orgId, $userId) {
  $role = orgMemberRole($db, $orgId, $userId)
  return $role === 'publisher'
}

function allowedMemberRole($role) {
  $r = strtolower(trim('' . $role))
  return $r === 'publisher' || $r === 'maintainer' || $r === 'public'
}

function rateLimitCheck($db, $bucket, $subjectKey, $limit, $windowSeconds) {
  $bucketName = '' . $bucket
  $subject = '' . $subjectKey
  $maxCount = max(1, (int) $limit)
  $window = max(1, (int) $windowSeconds)

  dbExec(
    $db,
    "delete from lh_rate_limit_hits where bucket = $1 and subject_key = $2 and created_at < now() - (($3)::text::integer * interval '1 second')",
    [$bucketName, $subject, '' . $window]
  )
  $ins = dbExec(
    $db,
    "insert into lh_rate_limit_hits (bucket, subject_key, created_at) values ($1, $2, now())",
    [$bucketName, $subject]
  )
  if (!result_is_ok($ins)) {
    return [ 'ok' => false, 'error' => $ins->error ]
  }
  $count = dbQueryOne(
    $db,
    "select count(*) as c from lh_rate_limit_hits where bucket = $1 and subject_key = $2 and created_at >= now() - (($3)::text::integer * interval '1 second')",
    [$bucketName, $subject, '' . $window]
  )
  if (!result_is_ok($count)) {
    return [ 'ok' => false, 'error' => $count->error ]
  }
  $seen = (int) rowValue($count->value, 'c', 0)
  if ($seen > $maxCount) {
    return [ 'ok' => false, 'error' => 'rate limit exceeded', 'bucket' => $bucketName, 'limit' => $maxCount, 'window' => $window ]
  }
  return [ 'ok' => true, 'count' => $seen ]
}

function enforceRateLimit($bucket, $subjectKey, $limit, $windowSeconds) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => 'authIssueSession.open: ' . $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $res = rateLimitCheck($db, $bucket, $subjectKey, $limit, $windowSeconds)
  dbClose($db)
  return $res
}

function enforceIpRateLimit($bucket, $limit, $windowSeconds) {
  return enforceRateLimit($bucket, 'ip:' . clientIp(), $limit, $windowSeconds)
}

function enforceUserRateLimit($bucket, $userId, $limit, $windowSeconds) {
  return enforceRateLimit($bucket, 'user:' . ('' . $userId), $limit, $windowSeconds)
}

function parseVisibility($raw, $fallback = 'public') {
  $value = strtolower(trim('' . $raw))
  if ($value === '') {
    return $fallback
  }
  if ($value === 'public' || $value === 'private') {
    return $value
  }
  return null
}

function authUserId($auth) {
  if (!rowValue($auth, 'ok', false)) {
    return 0
  }
  $user = rowValue($auth, 'user', null)
  if ($user === null) {
    return 0
  }
  return (int) rowValue($user, 'id', 0)
}

function fetchVisiblePackageRows($db, $limit = 25, $query = '', $userId = 0) {
  $max = max(1, (int) $limit)
  $maxSql = '' . $max
  $q = trim('' . $query)
  $uid = (int) $userId

  if ($uid > 0) {
    $publicSql = 'select p.id, p.org_id as orgId, o.handle as orgHandle, p.name, p.description, p.latest_version as latestVersion, p.download_count as downloadCount, p.created_at as createdAt, p.updated_at as updatedAt, p.visibility, lv.canonical_id as canonicalId
      from packages p
      join lh_orgs o on o.id = p.org_id
      left join package_versions lv on lv.package_id = p.id and lv.version = p.latest_version
      where p.visibility = \'public\''
    $publicParams = []
    if ($q !== '') {
      $publicSql = $publicSql . ' and (p.name ilike $1 or p.description ilike $1)'
      $publicParams = ['%' . $q . '%']
    }
    $publicSql = $publicSql . ' order by p.download_count desc, p.id desc limit ' . $maxSql
    $publicRes = dbQuery($db, $publicSql, $publicParams)
    if (!result_is_ok($publicRes)) {
      return { ok: false, error: $publicRes->error }
    }
    $publicRows = rowsFromQueryResult($publicRes)

    $privateSql = 'select p.id, p.org_id as orgId, o.handle as orgHandle, p.name, p.description, p.latest_version as latestVersion, p.download_count as downloadCount, p.created_at as createdAt, p.updated_at as updatedAt, p.visibility, lv.canonical_id as canonicalId
      from packages p
      join lh_orgs o on o.id = p.org_id
      left join package_versions lv on lv.package_id = p.id and lv.version = p.latest_version
      where p.visibility = \'private\'
        and exists (
          select 1
          from lh_org_members m
          where m.org_id = p.org_id
            and m.user_id = ($1)::text::bigint
            and m.revoked_at is null
            and lower(m.role) in (\'publisher\', \'maintainer\')
        )'
    $privateParams = ['' . $uid]
    if ($q !== '') {
      $privateSql = $privateSql . ' and (p.name ilike $2 or p.description ilike $2)'
      $privateParams[] = '%' . $q . '%'
    }
    $privateSql = $privateSql . ' order by p.download_count desc, p.id desc limit ' . $maxSql
    $privateRes = dbQuery($db, $privateSql, $privateParams)
    if (!result_is_ok($privateRes)) {
      return { ok: false, error: $privateRes->error }
    }
    $privateRows = rowsFromQueryResult($privateRes)

    $seen = []
    $out = []
    foreach ($publicRows as $row) {
      $idKey = '' . rowValue($row, 'id', rowValue($row, 'ID', null))
      if ($idKey === '') {
        continue
      }
      if (!array_key_exists($idKey, $seen)) {
        $seen[$idKey] = true
        $out[] = $row
      }
    }
    foreach ($privateRows as $row) {
      $idKey = '' . rowValue($row, 'id', rowValue($row, 'ID', null))
      if ($idKey === '') {
        continue
      }
      if (!array_key_exists($idKey, $seen)) {
        $seen[$idKey] = true
        $out[] = $row
      }
    }
    return { ok: true, rows: $out }
  }

  $term = $q === '' ? '%' : ('%' . $q . '%')
  $rows = dbQuery(
    $db,
    'select p.id, p.org_id as orgId, o.handle as orgHandle, p.name, p.description, p.latest_version as latestVersion, p.download_count as downloadCount, p.created_at as createdAt, p.updated_at as updatedAt, p.visibility, lv.canonical_id as canonicalId
       from packages p
       join lh_orgs o on o.id = p.org_id
       left join package_versions lv on lv.package_id = p.id and lv.version = p.latest_version
      where p.visibility = \'public\'
        and (p.name ilike $1 or p.description ilike $1)
      order by p.download_count desc, p.id desc
      limit ' . $maxSql,
    [$term]
  )
  if (!result_is_ok($rows)) {
    return { ok: false, error: $rows->error }
  }
  return { ok: true, rows: rowsFromQueryResult($rows) }
}

function devRandomHex($len = 32) {
  $need = max(2, (int) $len)
  $rand = random_hex($need)
  if (result_is_ok($rand)) {
    $value = result_unwrap($rand)
    if (is_string($value) && strlen($value) >= $need) {
      return substr($value, 0, $need)
    }
  }
  $buf = ''
  while (strlen($buf) < $need) {
    $micros = (int) (microtime(true) * 1000000)
    $salt = mt_rand(0, 0x7fffffff)
    $buf = $buf . dechex($micros) . dechex($salt)
  }
  return substr($buf, 0, $need)
}

function authIssueSession($handle, $userId) {
  $token = 'lhs_' . devRandomHex(32)
  $csrf = 'lhcsrf_' . devRandomHex(32)
  $tokenHash = authTokenHash($token)
  $csrfHash = authTokenHash($csrf)
  $maxSecs = (int) authMaxTimeoutSeconds()
  $ipAddress = isset($_SERVER['REMOTE_ADDR']) ? ('' . $_SERVER['REMOTE_ADDR']) : ''
  $userAgent = isset($_SERVER['HTTP_USER_AGENT']) ? ('' . $_SERVER['HTTP_USER_AGENT']) : ''

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  dbExec(
    $db,
    "update lh_sessions set revoked_at = now() where user_id = ($1)::text::bigint and revoked_at is null",
    ['' . $userId]
  )
  $insExec = dbQuery(
    $db,
    "insert into lh_sessions (user_id, session_token_hash, csrf_token_hash, last_seen_at, expires_at, created_at, ip_address, user_agent) values (($1)::text::bigint, $2, $3, now(), now() + interval '7 days', now(), $4, $5) returning id",
    ['' . $userId, $tokenHash, $csrfHash, $ipAddress, $userAgent]
  )
  if (!result_is_ok($insExec)) {
    $diag = [
      'userIdType' => gettype($userId),
      'tokenHashType' => gettype($tokenHash),
      'tokenHashLen' => strlen('' . $tokenHash),
      'csrfHashType' => gettype($csrfHash),
      'csrfHashLen' => strlen('' . $csrfHash),
      'ipType' => gettype($ipAddress),
      'uaType' => gettype($userAgent),
      'ttl' => '7 days'
    ]
    return [ 'ok' => false, 'error' => 'authIssueSession.insert: ' . $insExec->error, 'diag' => $diag ]
  }
  $lookup = dbQueryOne($db, "select id from lh_sessions where session_token_hash = $1 limit 1", [$tokenHash])
  dbClose($db)
  if (!result_is_ok($lookup)) {
    return [ 'ok' => false, 'error' => 'authIssueSession.lookup: ' . $lookup->error ]
  }

  cookieSetHeader('lh_session', $token, [
    'path' => '/',
    'max_age' => (int) $maxSecs,
    'same_site' => 'Lax',
    'http_only' => true,
    'secure' => cookieSecureFlag()
  ])

  return [ 'ok' => true, 'token' => $token, 'csrf' => $csrf, 'session' => $lookup->value ]
}

function authCurrentUser() {
  $sessionToken = authRequestToken()
  if ($sessionToken === null || $sessionToken === '') {
    return [ 'ok' => false, 'error' => 'not authenticated' ]
  }
  if (strStartsWith($sessionToken, 'lhs_dev:')) {
    $parts = explode(':', $sessionToken)
    if (count($parts) >= 4) {
      $devUid = (int) $parts[1]
      $devCsrf = '' . $parts[2]
      if ($devUid > 0) {
      $conn = openDbHandle()
      if (!result_is_ok($conn)) {
        return [ 'ok' => false, 'error' => $conn->error ]
      }
      $db = $conn->value
      $user = dbQueryOne(
        $db,
        "select id, did, handle, display_name as displayName, avatar_url as avatarUrl from lh_users where id = ($1)::text::bigint limit 1",
        ['' . $devUid]
      )
      dbClose($db)
      if (result_is_ok($user)) {
        $u = $user->value
        if (is_array($u)) {
          $u['csrfHash'] = authTokenHash($devCsrf)
        } else {
          $u->csrfHash = authTokenHash($devCsrf)
        }
        return [ 'ok' => true, 'user' => $u ]
      }
      return [ 'ok' => false, 'error' => 'dev session user lookup failed: ' . $user->error ]
    }
    }
  }
  $tokenHash = authTokenHash($sessionToken)
  $idleSecs = '' . authIdleTimeoutSeconds()
  $maxSecs = '' . authMaxTimeoutSeconds()
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $row = dbQueryOne(
    $db,
    "select u.id, u.did, u.handle, u.display_name as displayName, u.avatar_url as avatarUrl, s.csrf_token_hash as csrfHash from lh_sessions s join lh_users u on u.id = s.user_id where s.session_token_hash = $1 and s.revoked_at is null and s.expires_at > now() and s.last_seen_at > now() - (($2)::text::integer * interval '1 second') and s.created_at > now() - (($3)::text::integer * interval '1 second') limit 1",
    [$tokenHash, $idleSecs, $maxSecs]
  )
  if (result_is_ok($row)) {
    dbExec($db, 'update lh_sessions set last_seen_at = now() where session_token_hash = $1', [$tokenHash])
  }
  dbClose($db)
  if (!result_is_ok($row)) {
    return [ 'ok' => false, 'error' => 'not authenticated' ]
  }
  return [ 'ok' => true, 'user' => $row->value ]
}

function authValidateCsrfForSessionUser($user) {
  $expectedHash = '' . rowValue($user, 'csrfHash', rowValue($user, 'csrfhash', ''))
  if ($expectedHash === '') {
    return [ 'ok' => false, 'error' => 'missing csrf token for session' ]
  }
  $presented = is_array($_SERVER) && array_key_exists('HTTP_X_CSRF_TOKEN', $_SERVER)
    ? trim('' . $_SERVER['HTTP_X_CSRF_TOKEN'])
    : ''
  if ($presented === '') {
    $body = requestData()
    if (is_array($body) && array_key_exists('csrf', $body)) {
      $presented = trim('' . $body['csrf'])
    }
  }
  if ($presented === '') {
    $presented = trim('' . queryValue('csrf', ''))
  }
  if ($presented === '') {
    return [ 'ok' => false, 'error' => 'missing csrf token' ]
  }
  $presentedHash = authTokenHash($presented)
  if (!secureStringEquals($expectedHash, $presentedHash)) {
    return [ 'ok' => false, 'error' => 'invalid csrf token' ]
  }
  return [ 'ok' => true ]
}

function authValidateCsrfForAuth($auth) {
  if (!is_array($auth) || !array_key_exists('ok', $auth) || !$auth['ok']) {
    return [ 'ok' => false, 'error' => 'not authenticated' ]
  }
  if (!array_key_exists('kind', $auth) || $auth['kind'] !== 'session') {
    return [ 'ok' => true ]
  }
  return authValidateCsrfForSessionUser($auth['user'])
}

function authHasScopeMask($actualMask, $requiredMask) {
  $actual = (int) $actualMask
  $required = (int) $requiredMask
  return ($actual & $required) === $required
}

function authPatFromBearer($requiredMask = 1) {
  if (!is_array($_SERVER) || !array_key_exists('HTTP_AUTHORIZATION', $_SERVER)) {
    return [ 'ok' => false, 'error' => 'missing authorization header' ]
  }
  $raw = '' . $_SERVER['HTTP_AUTHORIZATION']
  if (!(strlen($raw) >= 7 && strtolower(substr($raw, 0, 7)) === 'bearer ')) {
    return [ 'ok' => false, 'error' => 'invalid authorization scheme' ]
  }
  $token = trim(substr($raw, 7))
  if ($token === '' || strpos($token, 'lh_pat_') !== 0) {
    return [ 'ok' => false, 'error' => 'invalid PAT token' ]
  }
  $tokenHash = authTokenHash($token)
  $required = '' . (int) $requiredMask

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $row = dbQueryOne(
    $db,
    "select t.id as tokenId, t.scope_mask as scopeMask, u.id, u.did, u.handle, u.display_name as displayName, u.avatar_url as avatarUrl from lh_api_tokens t join lh_users u on u.id = t.user_id where t.token_hash = $1 and t.revoked_at is null and (t.expires_at is null or t.expires_at > now()) and ((t.scope_mask)::text::integer & ($2)::text::integer) = ($2)::text::integer limit 1",
    [$tokenHash, $required]
  )
  if (result_is_ok($row)) {
    dbExec($db, 'update lh_api_tokens set last_used_at = now() where token_hash = $1', [$tokenHash])
  }
  dbClose($db)
  if (!result_is_ok($row)) {
    return [ 'ok' => false, 'error' => 'invalid or insufficient PAT scope' ]
  }
  return [
    'ok' => true,
    'kind' => 'pat',
    'scopeMask' => (int) rowValue($row->value, 'scopeMask', 0),
    'user' => $row->value
  ]
}

function authWithScope($requiredMask = 1) {
  $required = (int) $requiredMask
  $session = authCurrentUser()
  if ($session['ok']) {
    return [
      'ok' => true,
      'kind' => 'session',
      'scopeMask' => 7,
      'user' => $session['user']
    ]
  }
  $pat = authPatFromBearer($required)
  if ($pat['ok']) {
    return $pat
  }
  return [ 'ok' => false, 'error' => 'not authenticated or insufficient scope' ]
}

function oauthBeginFlow() {
  $rateIp = enforceIpRateLimit('auth.login.ip', 30, 60)
  if (!$rateIp['ok']) {
    return [ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.login.ip' ]
  }
  $cfg = oauthConfig()
  if ($cfg->clientId === '') {
    return [ 'ok' => false, 'error' => 'oauth client id is not configured (LINKHASH_OAUTH_CLIENT_ID)' ]
  }
  if (!oauthCallbackAllowed($cfg->callback)) {
    return [ 'ok' => false, 'error' => 'oauth callback is not allowlisted', 'callback' => $cfg->callback ]
  }
  $state = devRandomHex(16)
  $verifier = devRandomHex(64)
  $challenge = oauthPkceChallenge($verifier)
  cookieSetHeader('lh_oauth_ctx', oauthPackContext($state, $verifier), [
    'path' => '/',
    'max_age' => 600,
    'same_site' => 'Lax',
    'http_only' => true,
    'secure' => cookieSecureFlag()
  ])
  $authUrl = $cfg->authUrl . '?' . formUrlEncode([
    'client_id' => $cfg->clientId,
    'redirect_uri' => $cfg->callback,
    'response_type' => 'code',
    'state' => $state,
    'scope' => $cfg->scope,
    'code_challenge' => $challenge,
    'code_challenge_method' => 'S256'
  ])
  return [
    'ok' => true,
    'auth_url' => $authUrl,
    'provider' => 'bluesky',
    'pkce' => 'S256'
  ]
}

function apiAuthLogin() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $start = oauthBeginFlow()
  if (!$start['ok']) {
    auditEvent('auth.login', [ 'ok' => false ], 'error', 'oauth', 'start', [ 'error' => $start['error'] ])
    echo jsonReply($start)
    return
  }
  auditEvent('auth.login', [ 'ok' => false ], 'ok', 'oauth', 'start', [])
  if (wantsHtmlResponse()) {
    redirectTo($start['auth_url'])
    return
  }
  echo jsonReply($start)
}

function apiAuthCallback() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $rateIp = enforceIpRateLimit('auth.callback.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.callback.ip' ])
    return
  }
  $cfg = oauthConfig()
  if ($cfg->clientId === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'oauth client id is not configured (LINKHASH_OAUTH_CLIENT_ID)' ])
    return
  }
  if (!oauthCallbackAllowed($cfg->callback)) {
    echo jsonReply([ 'ok' => false, 'error' => 'oauth callback is not allowlisted', 'callback' => $cfg->callback ])
    return
  }

  $state = '' . queryValue('state', '')
  $code = '' . queryValue('code', '')
  $ctx = oauthUnpackContext(requestCookie('lh_oauth_ctx', ''))
  $expectedState = $ctx === null ? ('' . requestCookie('lh_oauth_state', '')) : ('' . $ctx->state)
  $pkce = $ctx === null ? ('' . requestCookie('lh_oauth_pkce', '')) : ('' . $ctx->pkce)
  if ($state === '' || $state !== $expectedState) {
    echo jsonReply([ 'ok' => false, 'error' => 'invalid oauth state' ])
    return
  }
  if ($code === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'missing oauth code' ])
    return
  }
  if ($pkce === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'missing pkce verifier cookie' ])
    return
  }

  $tokenBody = [
    'grant_type' => 'authorization_code',
    'client_id' => $cfg->clientId,
    'code' => $code,
    'redirect_uri' => $cfg->callback,
    'code_verifier' => $pkce
  ]
  if ($cfg->clientSecret !== '') {
    $tokenBody['client_secret'] = $cfg->clientSecret
  }
  $tokenRes = httpRequestRaw('POST', $cfg->tokenUrl, [
    'Content-Type' => 'application/x-www-form-urlencoded',
    'Accept' => 'application/json'
  ], formUrlEncode($tokenBody))
  if (!is_array($tokenRes) || !$tokenRes['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => 'token exchange request failed', 'details' => $tokenRes ])
    return
  }
  if ((int) $tokenRes['status'] < 200 || (int) $tokenRes['status'] >= 300) {
    echo jsonReply([ 'ok' => false, 'error' => 'token exchange rejected', 'status' => $tokenRes['status'], 'body' => $tokenRes['body'] ])
    return
  }
  $tokenDecoded = json_decode_result($tokenRes['body'], true)
  if (!result_is_ok($tokenDecoded) || !is_array($tokenDecoded->value)) {
    echo jsonReply([ 'ok' => false, 'error' => 'invalid token response json' ])
    return
  }
  $tokens = $tokenDecoded->value
  if (!array_key_exists('access_token', $tokens) || ('' . $tokens['access_token']) === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'token response missing access_token', 'response' => $tokens ])
    return
  }
  $accessToken = '' . $tokens['access_token']
  $profileRes = oauthFetchProfile($accessToken, $cfg)
  if (!$profileRes['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => 'failed to fetch oauth profile', 'details' => $profileRes ])
    return
  }

  $did = '' . $profileRes['did']
  $handle = '' . $profileRes['handle']
  $displayName = '' . $profileRes['displayName']
  if (!isValidHandleName($handle) || isReservedHandle($handle)) {
    echo jsonReply([ 'ok' => false, 'error' => 'reserved or invalid handle' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $user = authUpsertUserByDid($db, $did, $handle, $displayName)
  if (result_is_ok($user)) {
    ensureUserOrgMembership($db, $user->value)
  }
  dbClose($db)
  if (!result_is_ok($user)) {
    auditEvent('auth.callback', [ 'ok' => false ], 'error', 'user', $handle, [ 'error' => $user->error ])
    echo jsonReply([ 'ok' => false, 'error' => $user->error ])
    return
  }
  $issue = authIssueSession($handle, '' . rowValue($user->value, 'id', '0'))
  if (!$issue['ok']) {
    auditEvent('auth.callback', [ 'ok' => false ], 'error', 'user', $handle, [ 'error' => $issue['error'] ])
    echo jsonReply([ 'ok' => false, 'error' => $issue['error'] ])
    return
  }
  auditEvent('auth.callback', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $user->value ], 'ok', 'user', '' . rowValue($user->value, 'id', '0'), [ 'handle' => $handle ])
  cookieClearHeader('lh_oauth_ctx', ['path' => '/'])
  cookieClearHeader('lh_oauth_state', ['path' => '/'])
  cookieClearHeader('lh_oauth_pkce', ['path' => '/'])
  if (wantsHtmlResponse()) {
    redirectTo('/account')
    return
  }
  echo jsonReply([
    'ok' => true,
    'user' => $user->value,
    'provider' => 'bluesky',
    'session' => $issue['token'],
    'csrf' => $issue['csrf']
  ])
}

function apiAuthDevLogin() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $rateIp = enforceIpRateLimit('auth.dev_login.ip', 30, 60)
  if (!$rateIp['ok']) {
    logEvent('warn', 'auth.dev_login.rate_limit_unavailable', { error: $rateIp['error'] })
  }
  $handle = '' . queryValue('handle', 'samifou.ad')
  if (!isValidHandleName($handle) || isReservedHandle($handle)) {
    echo jsonReply([ 'ok' => false, 'error' => 'reserved or invalid handle' ])
    return
  }
  $did = '' . queryValue('did', ('did:plc:' . str_replace('.', '', $handle)))
  $displayName = '' . queryValue('display_name', $handle)
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $user = authUpsertUserByDid($db, $did, $handle, $displayName)
  if (result_is_ok($user)) {
    ensureUserOrgMembership($db, $user->value)
  }
  dbClose($db)
  if (!result_is_ok($user)) {
    auditEvent('auth.dev_login', [ 'ok' => false ], 'error', 'user', $handle, [ 'error' => $user->error ])
    echo jsonReply([ 'ok' => false, 'error' => $user->error ])
    return
  }
  $issue = authIssueSession($handle, '' . rowValue($user->value, 'id', '0'))
  if ($issue['ok']) {
    auditEvent('auth.dev_login', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $user->value ], 'ok', 'user', '' . rowValue($user->value, 'id', '0'), [ 'handle' => $handle, 'mode' => 'db-session' ])
    if (wantsHtmlResponse()) {
      redirectTo('/account')
      return
    }
    echo jsonReply([ 'ok' => true, 'user' => $user->value, 'session' => $issue['token'], 'csrf' => $issue['csrf'], 'mode' => 'db-session' ])
    return
  }

  $csrf = 'lhcsrf_' . devRandomHex(32)
  $devSession = 'lhs_dev:' . rowValue($user->value, 'id', '0') . ':' . $csrf . ':' . devRandomHex(12)
  $maxSecs = (int) authMaxTimeoutSeconds()
  cookieSetHeader('lh_session', $devSession, [
    'path' => '/',
    'max_age' => $maxSecs,
    'same_site' => 'Lax',
    'http_only' => true,
    'secure' => cookieSecureFlag()
  ])
  auditEvent('auth.dev_login', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $user->value ], 'warn', 'user', '' . rowValue($user->value, 'id', '0'), [ 'handle' => $handle, 'mode' => 'dev-cookie-fallback', 'issueError' => $issue['error'] ])
  if (wantsHtmlResponse()) {
    redirectTo('/account')
    return
  }
  echo jsonReply([ 'ok' => true, 'user' => $user->value, 'session' => $devSession, 'csrf' => $csrf, 'mode' => 'dev-cookie', 'warning' => $issue['error'] ])
}

function apiAuthLogout() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $sessionToken = authRequestToken()
  if ($sessionToken === null || $sessionToken === '') {
    cookieClearHeader('lh_session', ['path' => '/'])
    auditEvent('auth.logout', [ 'ok' => false ], 'ok', 'session', 'none', [])
    echo jsonReply([ 'ok' => true ])
    return
  }
  $me = authCurrentUser()
  if ($me['ok']) {
    $csrf = authValidateCsrfForSessionUser($me['user'])
    if (!$csrf['ok']) {
      echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
      return
    }
  }
  if ($sessionToken !== null && $sessionToken !== '') {
    $tokenHash = authTokenHash($sessionToken)
    $conn = openDbHandle()
    if (result_is_ok($conn)) {
      $db = $conn->value
      dbExec($db, 'update lh_sessions set revoked_at = now() where session_token_hash = $1', [$tokenHash])
      dbClose($db)
    }
  }
  cookieClearHeader('lh_session', ['path' => '/'])
  auditEvent('auth.logout', $me['ok'] ? [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ] : [ 'ok' => false ], 'ok', 'session', 'active', [])
  if (wantsHtmlResponse()) {
    redirectTo('/')
    return
  }
  echo jsonReply([ 'ok' => true ])
}

function apiAuthMe() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $u = $me['user']
  echo jsonReply([
    'ok' => true,
    'user' => [
      'id' => rowValue($u, 'id', null),
      'did' => rowValue($u, 'did', null),
      'handle' => rowValue($u, 'handle', null),
      'displayName' => rowValue($u, 'displayName', rowValue($u, 'displayname', null)),
      'avatarUrl' => rowValue($u, 'avatarUrl', rowValue($u, 'avatarurl', null))
    ]
  ])
}

function apiAuthPatCreate() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $userId = (int) rowValue($me['user'], 'id', 0)
  $rateUser = enforceUserRateLimit('auth.pat_mutate.user', $userId, 10, 60)
  if (!$rateUser['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateUser['error'], 'bucket' => 'auth.pat_mutate.user' ])
    return
  }
  $rateIp = enforceIpRateLimit('auth.pat_mutate.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.pat_mutate.ip' ])
    return
  }
  $csrf = authValidateCsrfForSessionUser($me['user'])
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $body = requestData()
  $label = array_key_exists('label', $body) ? ('' . $body['label']) : ('' . queryValue('label', 'default'))
  $scopeText = array_key_exists('scope', $body) ? ('' . $body['scope']) : ('' . queryValue('scope', 'read:write'))
  $expiresDays = (int) (array_key_exists('expires_days', $body) ? $body['expires_days'] : queryValue('expires_days', 30))

  $prefix = devRandomHex(8)
  $rawToken = 'lh_pat_' . $prefix . '_' . devRandomHex(24)
  $tokenHash = authTokenHash($rawToken)
  $scopeMask = authScopeMask($scopeText)
  $expiresDaysClamped = '' . max(1, $expiresDays)

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $ins = dbQueryOne(
    $db,
    "insert into lh_api_tokens (user_id, token_prefix, token_hash, scope_mask, label, expires_at, created_at) values (($1)::text::bigint, $2, $3, ($4)::text::integer, $5, now() + (($6)::text::integer * interval '1 day'), now()) returning id, token_prefix as tokenPrefix, scope_mask as scopeMask, label, (expires_at)::text as expiresAt, (created_at)::text as createdAt",
    ['' . rowValue($me['user'], 'id', '0'), $prefix, $tokenHash, '' . $scopeMask, $label, $expiresDaysClamped]
  )
  dbClose($db)
  if (!result_is_ok($ins)) {
    auditEvent('pat.create', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'error', 'pat', 'create', [ 'error' => $ins->error ])
    echo jsonReply([ 'ok' => false, 'error' => $ins->error ])
    return
  }
  auditEvent('pat.create', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'ok', 'pat', '' . rowValue($ins->value, 'id', '0'), [ 'label' => $label, 'scopeMask' => $scopeMask, 'expiresDays' => $expiresDaysClamped ])

  echo jsonReply([
    'ok' => true,
    'token' => $rawToken,
    'token_hint' => $prefix,
    'meta' => $ins->value
  ])
}

function apiAuthPatList() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $rows = dbQuery(
    $db,
    'select id, token_prefix as tokenprefix, scope_mask as scopemask, label, (last_used_at is not null) as used, (last_used_at)::text as lastusedat, (expires_at)::text as expiresat, (created_at)::text as createdat, (revoked_at)::text as revokedat from lh_api_tokens where user_id = ($1)::text::bigint order by created_at desc',
    ['' . rowValue($me['user'], 'id', '0')]
  )
  dbClose($db)
  if (!result_is_ok($rows)) {
    echo jsonReply([ 'ok' => false, 'error' => $rows->error ])
    return
  }
  $out = []
  $rowsList = rowsFromQueryResult($rows)
  foreach ($rowsList as $row) {
    if (rowValue($row, 'revokedat', rowValue($row, 'revoked_at', null)) !== null) {
      continue
    }
    $scopeMask = (int) rowValue($row, 'scopemask', rowValue($row, 'scope_mask', 0))
    $out[] = [
      'id' => rowValue($row, 'id', 0),
      'tokenPrefix' => rowValue($row, 'tokenprefix', rowValue($row, 'token_prefix', '')),
      'label' => rowValue($row, 'label', ''),
      'scopeMask' => $scopeMask,
      'scope' => authScopeText($scopeMask),
      'used' => (bool) rowValue($row, 'used', false),
      'lastUsedAt' => rowValue($row, 'lastusedat', rowValue($row, 'last_used_at', null)),
      'expiresAt' => rowValue($row, 'expiresat', rowValue($row, 'expires_at', null)),
      'createdAt' => rowValue($row, 'createdat', rowValue($row, 'created_at', null))
    ]
  }
  echo jsonReply([ 'ok' => true, 'tokens' => $out ])
}

function apiAuthPatRevoke() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $userId = (int) rowValue($me['user'], 'id', 0)
  $rateUser = enforceUserRateLimit('auth.pat_mutate.user', $userId, 10, 60)
  if (!$rateUser['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateUser['error'], 'bucket' => 'auth.pat_mutate.user' ])
    return
  }
  $rateIp = enforceIpRateLimit('auth.pat_mutate.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.pat_mutate.ip' ])
    return
  }
  $csrf = authValidateCsrfForSessionUser($me['user'])
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $body = requestData()
  $id = (int) (array_key_exists('id', $body) ? $body['id'] : queryValue('id', 0))
  if ($id <= 0) {
    echo jsonReply([ 'ok' => false, 'error' => 'id is required' ])
    return
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $res = dbExec(
    $db,
    'update lh_api_tokens set revoked_at = now() where id = ($1)::text::bigint and user_id = ($2)::text::bigint',
    ['' . $id, '' . rowValue($me['user'], 'id', '0')]
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    auditEvent('pat.revoke', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'error', 'pat', '' . $id, [ 'error' => $res->error ])
    echo jsonReply([ 'ok' => false, 'error' => $res->error ])
    return
  }
  auditEvent('pat.revoke', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'ok', 'pat', '' . $id, [])
  echo jsonReply([ 'ok' => true, 'id' => $id ])
}

function apiAuthPatRevokeAll() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $me = authCurrentUser()
  if (!$me['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $me['error'] ])
    return
  }
  $userId = (int) rowValue($me['user'], 'id', 0)
  $rateUser = enforceUserRateLimit('auth.pat_mutate.user', $userId, 10, 60)
  if (!$rateUser['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateUser['error'], 'bucket' => 'auth.pat_mutate.user' ])
    return
  }
  $rateIp = enforceIpRateLimit('auth.pat_mutate.ip', 30, 60)
  if (!$rateIp['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $rateIp['error'], 'bucket' => 'auth.pat_mutate.ip' ])
    return
  }
  $csrf = authValidateCsrfForSessionUser($me['user'])
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  $res = dbExec(
    $db,
    'update lh_api_tokens set revoked_at = now() where user_id = ($1)::text::bigint and revoked_at is null',
    ['' . rowValue($me['user'], 'id', '0')]
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    auditEvent('pat.revoke_all', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'error', 'pat', 'all', [ 'error' => $res->error ])
    echo jsonReply([ 'ok' => false, 'error' => $res->error ])
    return
  }
  auditEvent('pat.revoke_all', [ 'ok' => true, 'kind' => 'session', 'scopeMask' => 7, 'user' => $me['user'] ], 'ok', 'pat', 'all', [])
  echo jsonReply([ 'ok' => true ])
}

function fetchPatListForUserId($userId) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error, 'tokens' => [] ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $rows = dbQuery(
    $db,
    'select id, token_prefix as tokenprefix, scope_mask as scopemask, label, (last_used_at)::text as lastusedat, (expires_at)::text as expiresat, (created_at)::text as createdat from lh_api_tokens where user_id = ($1)::text::bigint and revoked_at is null order by created_at desc',
    ['' . $userId]
  )
  dbClose($db)
  if (!result_is_ok($rows)) {
    return [ 'ok' => false, 'error' => $rows->error, 'tokens' => [] ]
  }
  $out = []
  foreach (rowsFromQueryResult($rows) as $row) {
    $scopeMask = (int) rowValue($row, 'scopemask', rowValue($row, 'scope_mask', 0))
    $out[] = [
      'id' => (int) rowValue($row, 'id', 0),
      'tokenPrefix' => rowValue($row, 'tokenprefix', rowValue($row, 'token_prefix', '')),
      'label' => rowValue($row, 'label', ''),
      'scopeMask' => $scopeMask,
      'scope' => authScopeText($scopeMask),
      'lastUsedAt' => rowValue($row, 'lastusedat', rowValue($row, 'last_used_at', null)),
      'expiresAt' => rowValue($row, 'expiresat', rowValue($row, 'expires_at', null)),
      'createdAt' => rowValue($row, 'createdat', rowValue($row, 'created_at', null))
    ]
  }
  return [ 'ok' => true, 'tokens' => $out ]
}

function fetchOrgsForUserId($userId) {
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error, 'orgs' => [] ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $rows = dbQuery(
    $db,
    "select o.id, o.handle, o.visibility, m.role
       from lh_org_members m
       join lh_orgs o on o.id = m.org_id
      where m.user_id = ($1)::text::bigint
        and m.revoked_at is null
      order by o.handle asc",
    ['' . $userId]
  )
  dbClose($db)
  if (!result_is_ok($rows)) {
    return [ 'ok' => false, 'error' => $rows->error, 'orgs' => [] ]
  }
  $out = []
  foreach (rowsFromQueryResult($rows) as $row) {
    $out[] = [
      'id' => (int) rowValue($row, 'id', 0),
      'handle' => rowValue($row, 'handle', ''),
      'visibility' => rowValue($row, 'visibility', 'public'),
      'role' => rowValue($row, 'role', 'maintainer')
    ]
  }
  return [ 'ok' => true, 'orgs' => $out ]
}

function accountCreatePat($user, $label, $scope, $days) {
  $userId = (int) rowValue($user, 'id', 0)
  if ($userId <= 0) {
    return [ 'ok' => false, 'error' => 'invalid user' ]
  }
  $prefix = devRandomHex(8)
  $rawToken = 'lh_pat_' . $prefix . '_' . devRandomHex(24)
  $tokenHash = authTokenHash($rawToken)
  $scopeMask = authScopeMask($scope)
  $expiresDays = max(1, (int) $days)

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $ins = dbQueryOne(
    $db,
    "insert into lh_api_tokens (user_id, token_prefix, token_hash, scope_mask, label, expires_at, created_at)
     values (($1)::text::bigint, $2, $3, ($4)::text::integer, $5, now() + (($6)::text::integer * interval '1 day'), now())
     returning id",
    ['' . $userId, $prefix, $tokenHash, '' . $scopeMask, '' . $label, '' . $expiresDays]
  )
  dbClose($db)
  if (!result_is_ok($ins)) {
    return [ 'ok' => false, 'error' => $ins->error ]
  }
  return [ 'ok' => true, 'token' => $rawToken, 'id' => rowValue($ins->value, 'id', 0) ]
}

function accountRevokePat($user, $id) {
  $userId = (int) rowValue($user, 'id', 0)
  $tokenId = (int) $id
  if ($userId <= 0 || $tokenId <= 0) {
    return [ 'ok' => false, 'error' => 'invalid revoke request' ]
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $res = dbExec(
    $db,
    'update lh_api_tokens set revoked_at = now() where id = ($1)::text::bigint and user_id = ($2)::text::bigint',
    ['' . $tokenId, '' . $userId]
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    return [ 'ok' => false, 'error' => $res->error ]
  }
  return [ 'ok' => true ]
}

function accountRevokeAllPat($user) {
  $userId = (int) rowValue($user, 'id', 0)
  if ($userId <= 0) {
    return [ 'ok' => false, 'error' => 'invalid user' ]
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $res = dbExec(
    $db,
    'update lh_api_tokens set revoked_at = now() where user_id = ($1)::text::bigint and revoked_at is null',
    ['' . $userId]
  )
  dbClose($db)
  if (!result_is_ok($res)) {
    return [ 'ok' => false, 'error' => $res->error ]
  }
  return [ 'ok' => true ]
}

function apiOrgsMine() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $userId = authUserId($auth)

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $rows = dbQuery(
    $db,
    "select o.id, o.handle, o.visibility, m.role
       from lh_org_members m
       join lh_orgs o on o.id = m.org_id
      where m.user_id = ($1)::text::bigint
        and m.revoked_at is null
      order by o.handle asc",
    ['' . $userId]
  )
  dbClose($db)
  if (!result_is_ok($rows)) {
    echo jsonReply([ 'ok' => false, 'error' => $rows->error ])
    return
  }
  $out = []
  foreach (rowsFromQueryResult($rows) as $row) {
    $out[] = [
      'id' => rowValue($row, 'id', null),
      'handle' => rowValue($row, 'handle', ''),
      'visibility' => rowValue($row, 'visibility', 'public'),
      'role' => rowValue($row, 'role', '')
    ]
  }
  echo jsonReply([ 'ok' => true, 'orgs' => $out, 'total' => count($out) ])
}

function apiOrgsCreate() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(4)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $handle = normalizeHandleName(queryValue('handle', array_key_exists('handle', $body) ? $body['handle'] : ''))
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : 'public'), 'public')
  if (!isValidHandleName($handle) || isReservedHandle($handle)) {
    echo jsonReply([ 'ok' => false, 'error' => 'reserved or invalid org handle' ])
    return
  }
  if ($visibility === null) {
    echo jsonReply({ ok: false, error: 'visibility must be public or private' })
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)

  $org = dbQueryOne(
    $db,
    "insert into lh_orgs (handle, visibility, created_at, updated_at)
     values ($1, $2, now(), now())
     on conflict (handle) do update set updated_at = now()
     returning id, handle, visibility",
    [$handle, $visibility]
  )
  if (!result_is_ok($org)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => $org->error ])
    return
  }
  $orgId = '' . rowValue($org->value, 'id', '0')
  $member = dbExec(
    $db,
    "insert into lh_org_members (org_id, user_id, role, created_at)
     values (($1)::text::bigint, ($2)::text::bigint, 'publisher', now())
     on conflict (org_id, user_id) do update set role = 'publisher', revoked_at = null",
    [$orgId, '' . $userId]
  )
  dbClose($db)
  if (!result_is_ok($member)) {
    auditEvent('org.create', $auth, 'error', 'org', $handle, [ 'error' => $member->error ])
    echo jsonReply([ 'ok' => false, 'error' => $member->error ])
    return
  }
  auditEvent('org.create', $auth, 'ok', 'org', $handle, [ 'orgId' => $orgId, 'visibility' => $visibility ])
  echo jsonReply([ 'ok' => true, 'org' => $org->value ])
}

function apiOrgMembersList() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $userId = authUserId($auth)
  $orgId = (int) queryValue('orgId', 0)
  if ($orgId <= 0) {
    echo jsonReply([ 'ok' => false, 'error' => 'orgId is required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  if (!canEditOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org access' ])
    return
  }
  $rows = dbQuery(
    $db,
    "select m.user_id as userId, u.handle, u.display_name as displayName, m.role
       from lh_org_members m
       join lh_users u on u.id = m.user_id
      where m.org_id = ($1)::text::bigint
        and m.revoked_at is null
      order by m.created_at asc",
    ['' . $orgId]
  )
  dbClose($db)
  if (!result_is_ok($rows)) {
    echo jsonReply([ 'ok' => false, 'error' => $rows->error ])
    return
  }
  $out = []
  foreach (rowsFromQueryResult($rows) as $row) {
    $out[] = [
      'userId' => rowValue($row, 'userId', rowValue($row, 'userid', null)),
      'handle' => rowValue($row, 'handle', ''),
      'displayName' => rowValue($row, 'displayName', rowValue($row, 'displayname', null)),
      'role' => rowValue($row, 'role', '')
    ]
  }
  echo jsonReply([ 'ok' => true, 'members' => $out, 'total' => count($out) ])
}

function apiOrgMembersUpsert() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(4)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $targetHandle = normalizeHandleName(queryValue('handle', array_key_exists('handle', $body) ? $body['handle'] : ''))
  $role = strtolower(trim('' . queryValue('role', array_key_exists('role', $body) ? $body['role'] : 'maintainer')))
  if ($orgId <= 0 || $targetHandle === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'orgId and handle are required' ])
    return
  }
  if (!allowedMemberRole($role)) {
    echo jsonReply([ 'ok' => false, 'error' => 'role must be publisher, maintainer, or public' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  if (!canManageOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org manage access' ])
    return
  }
  $target = dbQueryOne(
    $db,
    "select id from lh_users where lower(handle) = lower($1) limit 1",
    [$targetHandle]
  )
  if (!result_is_ok($target)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $targetId = '' . rowValue($target->value, 'id', '0')
  if ($targetId === '0') {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $up = dbExec(
    $db,
    "insert into lh_org_members (org_id, user_id, role, created_at)
     values (($1)::text::bigint, ($2)::text::bigint, $3, now())
     on conflict (org_id, user_id) do update set role = excluded.role, revoked_at = null",
    ['' . $orgId, $targetId, $role]
  )
  dbClose($db)
  if (!result_is_ok($up)) {
    auditEvent('org.member.upsert', $auth, 'error', 'org', '' . $orgId, [ 'handle' => $targetHandle, 'role' => $role, 'error' => $up->error ])
    echo jsonReply([ 'ok' => false, 'error' => $up->error ])
    return
  }
  auditEvent('org.member.upsert', $auth, 'ok', 'org', '' . $orgId, [ 'handle' => $targetHandle, 'role' => $role ])
  echo jsonReply([ 'ok' => true, 'orgId' => $orgId, 'handle' => $targetHandle, 'role' => $role ])
}

function apiOrgMembersRemove() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(4)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $targetHandle = normalizeHandleName(queryValue('handle', array_key_exists('handle', $body) ? $body['handle'] : ''))
  if ($orgId <= 0 || $targetHandle === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'orgId and handle are required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  if (!canManageOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org manage access' ])
    return
  }
  $target = dbQueryOne(
    $db,
    "select id from lh_users where lower(handle) = lower($1) limit 1",
    [$targetHandle]
  )
  if (!result_is_ok($target)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $targetId = '' . rowValue($target->value, 'id', '0')
  if ($targetId === '0') {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'target user not found' ])
    return
  }
  $selfId = '' . $userId
  if ($targetId === $selfId) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'cannot remove your own membership' ])
    return
  }
  $up = dbExec(
    $db,
    "update lh_org_members
        set revoked_at = now()
      where org_id = ($1)::text::bigint
        and user_id = ($2)::text::bigint
        and revoked_at is null",
    ['' . $orgId, $targetId]
  )
  dbClose($db)
  if (!result_is_ok($up)) {
    auditEvent('org.member.remove', $auth, 'error', 'org', '' . $orgId, [ 'handle' => $targetHandle, 'error' => $up->error ])
    echo jsonReply([ 'ok' => false, 'error' => $up->error ])
    return
  }
  auditEvent('org.member.remove', $auth, 'ok', 'org', '' . $orgId, [ 'handle' => $targetHandle ])
  echo jsonReply([ 'ok' => true, 'orgId' => $orgId, 'handle' => $targetHandle ])
}

function apiPackageSetVisibility() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $name = normalizePackageName(queryValue('name', array_key_exists('name', $body) ? $body['name'] : ''))
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : ''), null)
  if ($name === '' || $visibility === null) {
    echo jsonReply([ 'ok' => false, 'error' => 'name and valid visibility are required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $pkg = dbQueryOne(
    $db,
    "select id, org_id as orgId from packages where lower(name) = lower($1) limit 1",
    [$name]
  )
  if (!result_is_ok($pkg)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'package not found' ])
    return
  }
  $orgId = (int) rowValue($pkg->value, 'orgId', rowValue($pkg->value, 'org_id', 0))
  if ($orgId <= 0 || !canEditOrg($db, $orgId, $userId)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org edit access' ])
    return
  }
  $up = dbExec(
    $db,
    "update packages set visibility = $1 where id = ($2)::text::bigint",
    [$visibility, '' . rowValue($pkg->value, 'id', 0)]
  )
  dbClose($db)
  if (!result_is_ok($up)) {
    echo jsonReply([ 'ok' => false, 'error' => $up->error ])
    return
  }
  echo jsonReply([ 'ok' => true, 'name' => $name, 'visibility' => $visibility ])
}

function sha256Hex($value) {
  if (function_exists('hash')) {
    return strtolower(hash('sha256', '' . $value))
  }
  return stableDigestHex($value, 64)
}

function hmacSha256Hex($key, $data) {
  if (function_exists('hash_hmac')) {
    return strtolower(hash_hmac('sha256', '' . $data, '' . $key))
  }
  return stableDigestHex(('' . $key) . ':' . ('' . $data), 64)
}

function hmacSha256Raw($key, $data) {
  if (function_exists('hash_hmac')) {
    return hash_hmac('sha256', '' . $data, '' . $key, true)
  }
  return sha256Raw(('' . $key) . ':' . ('' . $data))
}

function r2BackendMode() {
  return strtolower(trim('' . envValue('LINKHASH_ARTIFACT_BACKEND', 'local')))
}

function r2Enabled() {
  $mode = r2BackendMode()
  return $mode === 'r2' || $mode === 'auto'
}

function r2Bucket() {
  return trim('' . envValue('LINKHASH_R2_BUCKET', ''))
}

function r2AccountId() {
  return trim('' . envValue('LINKHASH_R2_ACCOUNT_ID', ''))
}

function r2AccessKeyId() {
  return trim('' . envValue('LINKHASH_R2_ACCESS_KEY_ID', ''))
}

function r2SecretAccessKey() {
  return trim('' . envValue('LINKHASH_R2_SECRET_ACCESS_KEY', ''))
}

function r2Region() {
  $v = trim('' . envValue('LINKHASH_R2_REGION', 'auto'))
  return $v === '' ? 'auto' : $v
}

function r2EndpointHost() {
  $explicit = trim('' . envValue('LINKHASH_R2_ENDPOINT', ''))
  if ($explicit !== '') {
    if (strpos($explicit, 'http://') === 0) {
      return substr($explicit, strlen('http://'))
    }
    if (strpos($explicit, 'https://') === 0) {
      return substr($explicit, strlen('https://'))
    }
    return $explicit
  }
  $acct = r2AccountId()
  if ($acct === '') {
    return ''
  }
  return $acct . '.r2.cloudflarestorage.com'
}

function r2ConfigValid() {
  return r2Bucket() !== '' && r2EndpointHost() !== '' && r2AccessKeyId() !== '' && r2SecretAccessKey() !== ''
}

function r2EncodePath($bucket, $key) {
  $parts = explode('/', '' . $key)
  $encoded = []
  foreach ($parts as $part) {
    $encoded[] = rawurlencode($part)
  }
  return '/' . rawurlencode('' . $bucket) . '/' . implode('/', $encoded)
}

function r2SignV4($method, $canonicalPath, $payload, $host) {
  $accessKey = r2AccessKeyId()
  $secret = r2SecretAccessKey()
  $region = r2Region()
  $amzDate = gmdate('Ymd\THis\Z')
  $dateStamp = gmdate('Ymd')
  $payloadHash = sha256Hex($payload)

  $canonicalHeaders =
    'host:' . strtolower('' . $host) . "\n" .
    'x-amz-content-sha256:' . $payloadHash . "\n" .
    'x-amz-date:' . $amzDate . "\n"
  $signedHeaders = 'host;x-amz-content-sha256;x-amz-date'
  $canonicalRequest =
    strtoupper('' . $method) . "\n" .
    $canonicalPath . "\n" .
    "\n" .
    $canonicalHeaders . "\n" .
    $signedHeaders . "\n" .
    $payloadHash

  $scope = $dateStamp . '/' . $region . '/s3/aws4_request'
  $stringToSign =
    'AWS4-HMAC-SHA256' . "\n" .
    $amzDate . "\n" .
    $scope . "\n" .
    sha256Hex($canonicalRequest)

  $kDate = hmacSha256Raw('AWS4' . $secret, $dateStamp)
  $kRegion = hmacSha256Raw($kDate, $region)
  $kService = hmacSha256Raw($kRegion, 's3')
  $kSigning = hmacSha256Raw($kService, 'aws4_request')
  $signature = strtolower(bin2hex(hmacSha256Raw($kSigning, $stringToSign)))

  $authHeader = 'AWS4-HMAC-SHA256 Credential=' . $accessKey . '/' . $scope . ', SignedHeaders=' . $signedHeaders . ', Signature=' . $signature

  return [
    'Authorization' => $authHeader,
    'x-amz-content-sha256' => $payloadHash,
    'x-amz-date' => $amzDate
  ]
}

function r2PutObject($key, $bytes, $mime = 'application/octet-stream') {
  if (!r2ConfigValid()) {
    return [ 'ok' => false, 'error' => 'r2 config incomplete' ]
  }
  $host = r2EndpointHost()
  $path = r2EncodePath(r2Bucket(), $key)
  $url = 'https://' . $host . $path
  $sigHeaders = r2SignV4('PUT', $path, $bytes, $host)
  $headers = [
    'Host' => $host,
    'Content-Type' => $mime,
    'x-amz-content-sha256' => $sigHeaders['x-amz-content-sha256'],
    'x-amz-date' => $sigHeaders['x-amz-date'],
    'Authorization' => $sigHeaders['Authorization']
  ]
  $res = httpRequestRaw('PUT', $url, $headers, $bytes)
  if (!is_array($res) || !$res['ok']) {
    return [ 'ok' => false, 'error' => 'r2 request failed', 'details' => $res ]
  }
  $status = (int) $res['status']
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'r2 put rejected', 'status' => $status, 'body' => $res['body'] ]
  }
  return [ 'ok' => true ]
}

function r2GetObject($key) {
  if (!r2ConfigValid()) {
    return [ 'ok' => false, 'error' => 'r2 config incomplete' ]
  }
  $host = r2EndpointHost()
  $path = r2EncodePath(r2Bucket(), $key)
  $url = 'https://' . $host . $path
  $sigHeaders = r2SignV4('GET', $path, '', $host)
  $headers = [
    'Host' => $host,
    'x-amz-content-sha256' => $sigHeaders['x-amz-content-sha256'],
    'x-amz-date' => $sigHeaders['x-amz-date'],
    'Authorization' => $sigHeaders['Authorization']
  ]
  $res = httpRequestRaw('GET', $url, $headers, '')
  if (!is_array($res) || !$res['ok']) {
    return [ 'ok' => false, 'error' => 'r2 request failed', 'details' => $res ]
  }
  $status = (int) $res['status']
  if ($status < 200 || $status >= 300) {
    return [ 'ok' => false, 'error' => 'r2 get rejected', 'status' => $status, 'body' => $res['body'] ]
  }
  $headersOut = is_array($res['headers']) ? $res['headers'] : []
  $mime = array_key_exists('content-type', $headersOut) ? ('' . $headersOut['content-type']) : 'application/octet-stream'
  return [ 'ok' => true, 'body' => '' . $res['body'], 'mime' => $mime ]
}

function packageIsVisibleTo($db, $pkgRow, $auth) {
  $visibility = '' . rowValue($pkgRow, 'visibility', 'public')
  if ($visibility === 'public') {
    return true
  }
  if (!rowValue($auth, 'ok', false)) {
    return false
  }
  $userId = authUserId($auth)
  $orgId = (int) rowValue($pkgRow, 'orgId', rowValue($pkgRow, 'org_id', 0))
  if ($userId <= 0 || $orgId <= 0) {
    return false
  }
  return canEditOrg($db, $orgId, $userId)
}

function apiPublishPackage() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $auth['error'] ])
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply([ 'ok' => false, 'error' => $csrf['error'] ])
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }

  $body = requestData()
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $name = normalizePackageName(queryValue('name', array_key_exists('name', $body) ? $body['name'] : ''))
  $version = trim('' . queryValue('version', array_key_exists('version', $body) ? $body['version'] : ''))
  $lockHash = trim('' . queryValue('lockHash', array_key_exists('lockHash', $body) ? $body['lockHash'] : 'dev'))
  $sha256 = trim('' . queryValue('sha256', array_key_exists('sha256', $body) ? $body['sha256'] : ''))
  $mime = trim('' . queryValue('mime', array_key_exists('mime', $body) ? $body['mime'] : 'application/octet-stream'))
  $mainFile = trim('' . queryValue('mainFile', array_key_exists('mainFile', $body) ? $body['mainFile'] : 'index.phpx'))
  $artifactB64 = '' . queryValue('artifactBase64', array_key_exists('artifactBase64', $body) ? $body['artifactBase64'] : '')
  $description = '' . queryValue('description', array_key_exists('description', $body) ? $body['description'] : 'Published package')
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : 'public'), 'public')
  $filesInput = array_key_exists('files', $body) ? $body['files'] : []
  $depsInput = array_key_exists('dependencies', $body) ? $body['dependencies'] : []
  $readme = '' . queryValue('readme', array_key_exists('readme', $body) ? $body['readme'] : '')
  $capabilityInput = array_key_exists('capabilityMetadata', $body) ? $body['capabilityMetadata'] : (array_key_exists('capabilities', $body) ? [ 'declared' => $body['capabilities'] ] : null)

  $filesDecoded = decodeJsonLike($filesInput, [])
  $depsDecoded = decodeJsonLike($depsInput, [])
  $capabilityDecoded = decodeJsonLike($capabilityInput, null)
  $filesJson = encodeJson(normalizeJsonValue(is_array($filesDecoded) ? $filesDecoded : []))
  $depsJson = encodeJson(normalizeJsonValue(is_array($depsDecoded) ? $depsDecoded : []))
  $capabilityJson = $capabilityDecoded === null
    ? 'null'
    : encodeJson(normalizeJsonValue($capabilityDecoded))

  if ($orgId <= 0 || !isValidPackageName($name) || isReservedPackageName($name) || $version === '' || $visibility === null) {
    auditEvent('package.publish', $auth, 'error', 'package', '@' . $orgId . '/' . $name . '@' . $version, [ 'error' => 'invalid publish parameters' ])
    echo jsonReply([ 'ok' => false, 'error' => 'orgId, valid name, version, and visibility are required' ])
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  if (!canEditOrg($db, $orgId, $userId)) {
    auditEvent('package.publish', $auth, 'forbidden', 'org', '' . $orgId, [ 'name' => $name, 'version' => $version ])
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: missing org edit access' ])
    return
  }

  $pkg = dbQueryOne(
    $db,
    "select id, org_id as orgId, name from packages where org_id = ($1)::text::bigint and lower(name) = lower($2) limit 1",
    ['' . $orgId, $name]
  )
  $packageId = 0
  if (result_is_ok($pkg)) {
    $packageId = (int) rowValue($pkg->value, 'id', 0)
  } else {
    $created = dbQueryOne(
      $db,
      "insert into packages (org_id, name, description, latest_version, download_count, visibility)
       values (($1)::text::bigint, $2, $3, $4, 0, $5)
       returning id",
      ['' . $orgId, $name, $description, $version, $visibility]
    )
    if (!result_is_ok($created)) {
      dbClose($db)
      echo jsonReply([ 'ok' => false, 'error' => $created->error ])
      return
    }
    $packageId = (int) rowValue($created->value, 'id', 0)
  }
  if ($packageId <= 0) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'failed to resolve package id' ])
    return
  }

  $owner = dbQueryOne($db, "select handle from lh_orgs where id = ($1)::text::bigint limit 1", ['' . $orgId])
  $ownerHandle = result_is_ok($owner) ? ('' . rowValue($owner->value, 'handle', 'org')) : 'org'
  $canonicalId = registryCanonicalId($ownerHandle, $name, $version, $lockHash)
  $artifactKey = registryArtifactKey($ownerHandle, $name, $version, $lockHash)

  $artifactBytes = $artifactB64 !== '' ? base64_decode($artifactB64) : ''
  if ($artifactBytes === false) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'artifactBase64 is invalid' ])
    return
  }
  $artifactSize = (int) strlen($artifactBytes)
  $artifactBackend = 'local'
  $artifactNotice = null
  if (r2Enabled()) {
    $put = r2PutObject($artifactKey, $artifactBytes, $mime)
    if ($put['ok']) {
      $artifactBackend = 'r2'
    } else {
      $artifactNotice = 'r2 upload failed; using inline postgres fallback'
    }
  }

  $upVer = dbQueryOne(
    $db,
    "insert into package_versions (package_id, version, main_file, files, dependencies, readme, published_at, r2_key, sha256, canonical_id, lock_hash, artifact_backend, artifact_key, artifact_mime, artifact_size_bytes, artifact_inline_b64, capability_metadata)
     values (($1)::text::bigint, $2, $3, ($4)::jsonb, ($5)::jsonb, $6, now(), null, $7, $8, $9, $10, $11, $12, ($13)::text::bigint, $14, ($15)::jsonb)
     on conflict (package_id, version) do update set main_file = excluded.main_file, files = excluded.files, dependencies = excluded.dependencies, readme = excluded.readme, sha256 = excluded.sha256, canonical_id = excluded.canonical_id, lock_hash = excluded.lock_hash, artifact_backend = excluded.artifact_backend, artifact_key = excluded.artifact_key, artifact_mime = excluded.artifact_mime, artifact_size_bytes = excluded.artifact_size_bytes, artifact_inline_b64 = excluded.artifact_inline_b64, capability_metadata = excluded.capability_metadata, published_at = now()
     returning id, version, canonical_id as canonicalId, artifact_key as artifactKey",
    ['' . $packageId, $version, $mainFile, $filesJson, $depsJson, $readme, $sha256, $canonicalId, $lockHash, $artifactBackend, $artifactKey, $mime, '' . $artifactSize, $artifactB64, $capabilityJson]
  )
  if (!result_is_ok($upVer)) {
    auditEvent('package.publish', $auth, 'error', 'package', '@' . $ownerHandle . '/' . $name . '@' . $version, [ 'error' => $upVer->error ])
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => $upVer->error ])
    return
  }

  dbExec(
    $db,
    "update packages set latest_version = $1, visibility = $2, updated_at = now() where id = ($3)::text::bigint",
    [$version, $visibility, '' . $packageId]
  )
  dbClose($db)

  echo jsonReply([
    'ok' => true,
    'package' => [ 'orgId' => $orgId, 'name' => $name, 'version' => $version, 'visibility' => $visibility ],
    'artifact' => [ 'backend' => $artifactBackend, 'key' => $artifactKey, 'sizeBytes' => $artifactSize ],
    'notice' => $artifactNotice,
    'canonicalId' => $canonicalId,
    'downloadUrl' => '/api/artifacts/' . $canonicalId
  ])
  auditEvent('package.publish', $auth, 'ok', 'package', '@' . $ownerHandle . '/' . $name . '@' . $version, [ 'canonicalId' => $canonicalId, 'visibility' => $visibility, 'artifactBackend' => $artifactBackend ])
}

function apiInstallPackage() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $orgHandle = normalizeHandleName(queryValue('org', ''))
  $name = normalizePackageName(queryValue('name', ''))
  $version = trim('' . queryValue('version', 'latest'))
  if ($orgHandle === '' || $name === '') {
    echo jsonReply([ 'ok' => false, 'error' => 'org and name are required' ])
    return
  }
  $auth = authWithScope(1)

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $org = dbQueryOne($db, "select id, handle from lh_orgs where lower(handle) = lower($1) limit 1", [$orgHandle])
  if (!result_is_ok($org)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'org not found' ])
    return
  }
  $orgId = (int) rowValue($org->value, 'id', 0)
  $pkg = dbQueryOne(
    $db,
    "select id, org_id as orgId, name, latest_version as latestVersion, visibility from packages where org_id = ($1)::text::bigint and lower(name) = lower($2) limit 1",
    ['' . $orgId, $name]
  )
  if (!result_is_ok($pkg)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'package not found' ])
    return
  }
  if (!packageIsVisibleTo($db, $pkg->value, $auth)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: package is private' ])
    return
  }
  $packageId = (int) rowValue($pkg->value, 'id', 0)
  $resolvedVersion = $version === 'latest' ? ('' . rowValue($pkg->value, 'latestVersion', rowValue($pkg->value, 'latest_version', ''))) : $version
  $ver = dbQueryOne(
    $db,
    "select id, version, canonical_id as canonicalId, lock_hash as lockHash, sha256, artifact_backend as artifactBackend, artifact_key as artifactKey, artifact_mime as artifactMime, artifact_size_bytes as artifactSizeBytes from package_versions where package_id = ($1)::text::bigint and version = $2 limit 1",
    ['' . $packageId, $resolvedVersion]
  )
  if (!result_is_ok($ver)) {
    dbClose($db)
    echo jsonReply([ 'ok' => false, 'error' => 'version not found' ])
    return
  }
  $versionId = (int) rowValue($ver->value, 'id', 0)
  $canonicalId = '' . rowValue($ver->value, 'canonicalId', rowValue($ver->value, 'canonical_id', ''))
  if ($canonicalId === '') {
    $lockHash = '' . rowValue($ver->value, 'lockHash', rowValue($ver->value, 'lock_hash', 'dev'))
    $canonicalId = registryCanonicalId($orgHandle, $name, $resolvedVersion, $lockHash === '' ? 'dev' : $lockHash)
  }
  dbExec(
    $db,
    "insert into downloads (package_id, version_id, downloaded_at, ip_address, user_agent) values (($1)::text::bigint, ($2)::text::bigint, now(), $3, $4)",
    ['' . $packageId, '' . $versionId, clientIp(), (is_array($_SERVER) && array_key_exists('HTTP_USER_AGENT', $_SERVER)) ? $_SERVER['HTTP_USER_AGENT'] : '']
  )
  dbExec($db, "update packages set download_count = download_count + 1 where id = ($1)::text::bigint", ['' . $packageId])
  dbClose($db)

  echo jsonReply([
    'ok' => true,
    'org' => $orgHandle,
    'name' => $name,
    'version' => $resolvedVersion,
    'canonicalId' => $canonicalId,
    'artifact' => [
      'backend' => rowValue($ver->value, 'artifactBackend', rowValue($ver->value, 'artifact_backend', 'local')),
      'key' => rowValue($ver->value, 'artifactKey', rowValue($ver->value, 'artifact_key', null)),
      'mime' => rowValue($ver->value, 'artifactMime', rowValue($ver->value, 'artifact_mime', 'application/octet-stream')),
      'sizeBytes' => (int) rowValue($ver->value, 'artifactSizeBytes', rowValue($ver->value, 'artifact_size_bytes', 0))
    ],
    'downloadUrl' => '/api/artifacts/' . $canonicalId
  ])
}

function fetchPackageDetail($orgHandle, $name, $auth) {
  $org = normalizeHandleName($orgHandle)
  $pkgName = normalizePackageName($name)
  if ($org === '' || $pkgName === '') {
    return [ 'ok' => false, 'error' => 'org and name are required' ]
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)

  $orgRow = dbQueryOne($db, "select id, handle from lh_orgs where lower(handle) = lower($1) limit 1", [$org])
  if (!result_is_ok($orgRow)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'org lookup failed', 'detail' => $orgRow->error ]
  }
  $orgId = (int) rowValue($orgRow->value, 'id', 0)
  $pkgRow = dbQueryOne(
    $db,
    "select id, org_id as orgId, name, description, latest_version as latestVersion, download_count as downloadCount, visibility
       from packages
      where org_id = ($1)::text::bigint and lower(name) = lower($2)
      limit 1",
    ['' . $orgId, $pkgName]
  )
  if (!result_is_ok($pkgRow)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'package not found' ]
  }
  if (!packageIsVisibleTo($db, $pkgRow->value, $auth)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'forbidden: package is private' ]
  }

  $versions = dbQuery(
    $db,
    "select version, published_at as publishedAt, sha256, canonical_id as canonicalId, artifact_backend as artifactBackend, artifact_key as artifactKey, artifact_size_bytes as artifactSizeBytes, main_file as mainFile, files, dependencies, readme, lock_hash as lockHash, capability_metadata as capabilityMetadata
       from package_versions
      where package_id = ($1)::text::bigint
      order by published_at desc",
    ['' . rowValue($pkgRow->value, 'id', 0)]
  )
  $versionRows = result_is_ok($versions) ? rowsFromQueryResult($versions) : []
  $activeVersion = count($versionRows) > 0 ? ('' . rowValue($versionRows[0], 'version', '')) : ''
  $docsSymbols = []
  $docsError = ''
  $treeEntries = []
  $treeError = ''
  $selectedFile = trim('' . queryValue('file', ''))
  $selectedFileContent = ''
  $selectedFileError = ''
  $issues = []
  $issuesError = ''
  $activeIssueNumber = (int) queryValue('issue', 0)
  $activeIssue = null
  $activeIssueComments = []
  $activeIssueError = ''
  $pulls = []
  $pullsError = ''
  $activePullNumber = (int) queryValue('pull', 0)
  $activePull = null
  $activePullComments = []
  $activePullError = ''
  if ($activeVersion !== '') {
    $docs = fetchRemoteReleaseDocs($org, $pkgName, $activeVersion)
    if (rowValue($docs, 'ok', false)) {
      $docsSymbols = rowValue(rowValue($docs, 'value', []), 'symbols', [])
    } else {
      $docsError = '' . rowValue($docs, 'error', '')
    }

    $tree = fetchRemoteReleaseTree($org, $pkgName, $activeVersion)
    if (rowValue($tree, 'ok', false)) {
      $treeEntries = rowValue(rowValue($tree, 'value', []), 'entries', [])
      if ($selectedFile === '' && is_array($treeEntries) && count($treeEntries) > 0) {
        $selectedFile = '' . rowValue($treeEntries[0], 'path', '')
      }
      if ($selectedFile !== '') {
        $blob = fetchRemoteReleaseBlob($org, $pkgName, $activeVersion, $selectedFile)
        if (rowValue($blob, 'ok', false)) {
          $selectedFileContent = '' . rowValue(rowValue($blob, 'value', []), 'content', '')
        } else {
          $selectedFileError = '' . rowValue($blob, 'error', '')
        }
      }
    } else {
      $treeError = '' . rowValue($tree, 'error', '')
    }
  }

  $issueList = fetchRemoteRepoIssues($org, $pkgName, 'open')
  if (rowValue($issueList, 'ok', false)) {
    $issues = rowValue(rowValue($issueList, 'value', []), 'issues', [])
  } else {
    $issuesError = '' . rowValue($issueList, 'error', '')
  }
  if ($activeIssueNumber > 0) {
    $issueDetail = fetchRemoteRepoIssueDetail($org, $pkgName, $activeIssueNumber)
    if (rowValue($issueDetail, 'ok', false)) {
      $activeIssue = rowValue(rowValue($issueDetail, 'value', []), 'issue', null)
      $activeIssueComments = rowValue(rowValue($issueDetail, 'value', []), 'comments', [])
    } else {
      $activeIssueError = '' . rowValue($issueDetail, 'error', '')
    }
  }

  $pullList = fetchRemoteRepoPulls($org, $pkgName, 'open')
  if (rowValue($pullList, 'ok', false)) {
    $pulls = rowValue(rowValue($pullList, 'value', []), 'pulls', [])
  } else {
    $pullsError = '' . rowValue($pullList, 'error', '')
  }
  if ($activePullNumber > 0) {
    $pullDetail = fetchRemoteRepoPullDetail($org, $pkgName, $activePullNumber)
    if (rowValue($pullDetail, 'ok', false)) {
      $activePull = rowValue(rowValue($pullDetail, 'value', []), 'pull', null)
      $activePullComments = rowValue(rowValue($pullDetail, 'value', []), 'comments', [])
    } else {
      $activePullError = '' . rowValue($pullDetail, 'error', '')
    }
  }
  dbClose($db)

  return [
    'ok' => true,
    'org' => rowValue($orgRow->value, 'handle', $org),
    'package' => [
      'id' => rowValue($pkgRow->value, 'id', null),
      'name' => rowValue($pkgRow->value, 'name', $pkgName),
      'description' => rowValue($pkgRow->value, 'description', ''),
      'latestVersion' => rowValue($pkgRow->value, 'latestVersion', rowValue($pkgRow->value, 'latest_version', null)),
      'downloadCount' => (int) rowValue($pkgRow->value, 'downloadCount', rowValue($pkgRow->value, 'download_count', 0)),
      'visibility' => rowValue($pkgRow->value, 'visibility', 'public')
    ],
    'versions' => $versionRows,
    'docsSymbols' => $docsSymbols,
    'docsError' => $docsError,
    'treeEntries' => $treeEntries,
    'treeError' => $treeError,
    'selectedFile' => $selectedFile,
    'selectedFileContent' => $selectedFileContent,
    'selectedFileError' => $selectedFileError,
    'issues' => $issues,
    'issuesError' => $issuesError,
    'activeIssue' => $activeIssue,
    'activeIssueComments' => $activeIssueComments,
    'activeIssueError' => $activeIssueError,
    'pulls' => $pulls,
    'pullsError' => $pullsError,
    'activePull' => $activePull,
    'activePullComments' => $activePullComments,
    'activePullError' => $activePullError,
    'repoAction' => '' . queryValue('repo_action', ''),
    'repoMessage' => '' . queryValue('repo_message', '')
  ]
}

function decodeJsonLike($value, $fallback = null) {
  if (is_array($value)) {
    return $value
  }
  if (is_object($value)) {
    return (array) $value
  }
  $raw = trim('' . $value)
  if ($raw === '') {
    return $fallback
  }
  $parsed = json_decode($raw, true)
  if (is_array($parsed)) {
    return $parsed
  }
  return $fallback
}

function normalizeCapabilityToken($value) {
  $cap = strtolower(trim('' . $value))
  if ($cap === '') {
    return ''
  }
  if (preg_match('/^[a-z][a-z0-9._-]{0,63}$/', $cap) !== 1) {
    return ''
  }
  return $cap
}

function normalizeCapabilityList($raw): array {
  $items = []
  if (is_array($raw)) {
    foreach ($raw as $entry) {
      $cap = normalizeCapabilityToken($entry)
      if ($cap !== '') {
        $items[] = $cap
      }
    }
  } else {
    $text = trim('' . $raw)
    if ($text !== '') {
      $parts = explode(',', $text)
      foreach ($parts as $entry) {
        $cap = normalizeCapabilityToken($entry)
        if ($cap !== '') {
          $items[] = $cap
        }
      }
    }
  }
  $seen = []
  $out = []
  foreach ($items as $cap) {
    if (!array_key_exists($cap, $seen)) {
      $seen[$cap] = true
      $out[] = $cap
    }
  }
  return $out
}

function extractVersionCapabilities($versionRow): array {
  $meta = rowValue($versionRow, 'capabilityMetadata', rowValue($versionRow, 'capability_metadata', null))
  $metaObj = decodeJsonLike($meta, [])
  $declared = normalizeCapabilityList(rowValue($metaObj, 'declared', []))
  $detected = normalizeCapabilityList(rowValue($metaObj, 'detected', []))
  $flat = normalizeCapabilityList(rowValue($metaObj, 'capabilities', []))

  if (count($declared) > 0) {
    return $declared
  }
  if (count($detected) > 0) {
    return $detected
  }
  if (count($flat) > 0) {
    return $flat
  }
  return []
}

function normalizeVersionFiles($rawFiles, $mainFile = 'index.phpx'): array {
  $files = decodeJsonLike($rawFiles, [])
  $out = []
  if (!is_array($files)) {
    $files = []
  }

  $isList = true
  foreach ($files as $k => $_v) {
    if (!(is_int($k) || preg_match('/^\d+$/', '' . $k) === 1)) {
      $isList = false
      break
    }
  }
  if ($isList) {
    foreach ($files as $entry) {
      if (is_string($entry)) {
        $path = trim($entry)
        if ($path !== '') {
          $out[] = [ 'path' => $path, 'sizeBytes' => null ]
        }
        continue
      }
      if (is_array($entry) || is_object($entry)) {
        $row = is_array($entry) ? $entry : (array) $entry
        $path = trim('' . rowValue($row, 'path', rowValue($row, 'name', rowValue($row, 'file', ''))))
        if ($path === '') {
          continue
        }
        $size = rowValue($row, 'sizeBytes', rowValue($row, 'size', null))
        $out[] = [ 'path' => $path, 'sizeBytes' => is_numeric($size) ? (int) $size : null ]
      }
    }
  } else {
    foreach ($files as $path => $value) {
      $p = trim('' . $path)
      if ($p === '') {
        continue
      }
      $size = null
      if (is_string($value)) {
        $size = strlen($value)
      } else if (is_array($value) || is_object($value)) {
        $row = is_array($value) ? $value : (array) $value
        $sizeRaw = rowValue($row, 'sizeBytes', rowValue($row, 'size', null))
        if (is_numeric($sizeRaw)) {
          $size = (int) $sizeRaw
        }
      }
      $out[] = [ 'path' => $p, 'sizeBytes' => $size ]
    }
  }

  if (count($out) === 0) {
    $fallbackMain = trim('' . $mainFile)
    if ($fallbackMain !== '') {
      $out[] = [ 'path' => $fallbackMain, 'sizeBytes' => null ]
    }
  }
  return $out
}

function versionReadmeText($versionRow, $packageCoord, $versionTag) {
  $readme = trim('' . rowValue($versionRow, 'readme', ''))
  if ($readme !== '') {
    return $readme
  }
  return '# ' . $packageCoord . "\n\n" .
    'No README published for `' . $versionTag . '` yet.' . "\n\n" .
    'Publish with `readme` metadata to show installation and usage docs here.'
}

function parseAliasPackagePath($path) {
  $raw = '' . $path
  if (!strStartsWith($raw, '/@')) {
    return null
  }
  $trimmed = trim($raw, '/')
  if (!strStartsWith($trimmed, '@')) {
    return null
  }
  $parts = explode('/', $trimmed)
  if (count($parts) < 2) {
    return null
  }
  $org = normalizeHandleName(substr($parts[0], 1))
  $pkgVersion = '' . $parts[1]
  $atPos = strrpos($pkgVersion, '@')
  $pkg = $atPos === false ? $pkgVersion : substr($pkgVersion, 0, $atPos)
  $ver = $atPos === false ? '' : substr($pkgVersion, $atPos + 1)
  $pkg = normalizePackageName($pkg)
  if (!isValidHandleName($org) || isReservedHandle($org) || !isValidPackageName($pkg) || isReservedPackageName($pkg)) {
    return null
  }
  return [
    'org' => $org,
    'name' => $pkg,
    'version' => trim('' . $ver)
  ]
}

function parsePreviewRepoPath($path) {
  $raw = '' . $path
  if (!strStartsWith($raw, '/@')) {
    return null
  }
  $trimmed = trim($raw, '/')
  $parts = explode('/', $trimmed)
  if (count($parts) < 3) {
    return null
  }
  $owner = normalizeHandleName(substr($parts[0], 1))
  $repo = normalizePackageName($parts[1])
  $ref = trim('' . $parts[2])
  if ($owner === '' || $repo === '' || $ref === '') {
    return null
  }
  return [ 'owner' => $owner, 'repo' => $repo, 'ref' => $ref ]
}

function findVersionInRows($versions, $targetVersion) {
  if (!is_array($versions)) {
    return null
  }
  $wanted = trim('' . $targetVersion)
  if ($wanted === '') {
    return null
  }
  foreach ($versions as $v) {
    if (('' . rowValue($v, 'version', '')) === $wanted) {
      return $v
    }
  }
  return null
}

function fetchCanonicalTarget($canonicalId, $auth) {
  $id = trim('' . $canonicalId)
  if ($id === '' || !strStartsWith($id, 'lh_')) {
    return [ 'ok' => false, 'error' => 'invalid canonical id' ]
  }
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $row = dbQueryOne(
    $db,
    "select v.version, v.canonical_id as canonicalId, o.handle as orgHandle, p.name, p.visibility, p.org_id as orgId
       from package_versions v
       join packages p on p.id = v.package_id
       join lh_orgs o on o.id = p.org_id
      where v.canonical_id = $1
      limit 1",
    [$id]
  )
  if (!result_is_ok($row)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'canonical package not found' ]
  }
  if (!packageIsVisibleTo($db, $row->value, $auth)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'forbidden: package is private' ]
  }
  $target = [
    'org' => '' . rowValue($row->value, 'orgHandle', ''),
    'name' => '' . rowValue($row->value, 'name', ''),
    'version' => '' . rowValue($row->value, 'version', ''),
    'canonicalId' => '' . rowValue($row->value, 'canonicalId', '')
  ]
  dbClose($db)
  return [ 'ok' => true, 'target' => $target ]
}

function packageRoutePath($org, $name) {
  return '/package/' . rawurlencode(normalizeHandleName($org)) . '/' . rawurlencode(normalizePackageName($name))
}

function repoActionRedirect($org, $name, $action, $message = '', $numberKey = '', $number = 0) {
  redirectTo(buildRepoActionRedirectPath(packageRoutePath($org, $name), $action, $message, $numberKey, $number))
}

function apiRepoIssueCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $title = '' . rowValue($data, 'title', '')
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoIssue($org, $name, $title, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      $issue = rowValue(rowValue($res, 'value', []), 'issue', [])
      repoActionRedirect($org, $name, 'issue_created', 'Issue created.', 'issue', (int) rowValue($issue, 'number', 0))
    } else {
      repoActionRedirect($org, $name, 'issue_failed', '' . rowValue($res, 'error', 'Issue create failed'))
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoIssueCommentCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $number = (int) rowValue($data, 'number', 0)
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoIssueComment($org, $name, $number, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      repoActionRedirect($org, $name, 'issue_comment_created', 'Issue comment created.', 'issue', $number)
    } else {
      repoActionRedirect($org, $name, 'issue_comment_failed', '' . rowValue($res, 'error', 'Issue comment failed'), 'issue', $number)
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoPullCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $title = '' . rowValue($data, 'title', '')
  $sourceRef = '' . rowValue($data, 'source_ref', '')
  $targetRef = '' . rowValue($data, 'target_ref', '')
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoPull($org, $name, $title, $sourceRef, $targetRef, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      $pull = rowValue(rowValue($res, 'value', []), 'pull', [])
      repoActionRedirect($org, $name, 'pull_created', 'Pull request created.', 'pull', (int) rowValue($pull, 'number', 0))
    } else {
      repoActionRedirect($org, $name, 'pull_failed', '' . rowValue($res, 'error', 'Pull create failed'))
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoPullCommentCreate() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $org = '' . rowValue($data, 'org', '')
  $name = '' . rowValue($data, 'name', '')
  $number = (int) rowValue($data, 'number', 0)
  $body = '' . rowValue($data, 'body', '')
  $res = createRemoteRepoPullComment($org, $name, $number, $body)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      repoActionRedirect($org, $name, 'pull_comment_created', 'Pull request comment created.', 'pull', $number)
    } else {
      repoActionRedirect($org, $name, 'pull_comment_failed', '' . rowValue($res, 'error', 'Pull request comment failed'), 'pull', $number)
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiRepoFork() {
  $method = requireMethod('POST')
  if (!$method['ok']) {
    header('Content-Type: application/json')
    echo jsonReply($method)
    return
  }
  $data = requestData()
  $sourceOwner = '' . rowValue($data, 'source_owner', rowValue($data, 'org', ''))
  $sourceRepo = '' . rowValue($data, 'source_repo', rowValue($data, 'name', ''))
  $targetRepo = '' . rowValue($data, 'target_repo', ($sourceRepo === '' ? '' : ($sourceRepo . '-fork')))
  $res = createRemoteRepoFork($sourceOwner, $sourceRepo, $targetRepo)
  if (wantsHtmlResponse()) {
    if (rowValue($res, 'ok', false)) {
      $payload = rowValue($res, 'value', [])
      $targetOwner = '' . rowValue($payload, 'targetOwner', $sourceOwner)
      $targetName = '' . rowValue($payload, 'targetRepo', $targetRepo)
      $commit = '' . rowValue($payload, 'commit', '')
      auditEvent(
        'repo.fork',
        [ 'ok' => true, 'kind' => 'service-token' ],
        'ok',
        'repo',
        '@' . $targetOwner . '/' . $targetName,
        [ 'sourceOwner' => $sourceOwner, 'sourceRepo' => $sourceRepo, 'targetRepo' => $targetName, 'commit' => $commit ]
      )
      $url = '/fork/result?source_owner=' . rawurlencode($sourceOwner)
        . '&source_repo=' . rawurlencode($sourceRepo)
        . '&target_owner=' . rawurlencode($targetOwner)
        . '&target_repo=' . rawurlencode($targetName)
        . '&commit=' . rawurlencode($commit)
      redirectTo($url)
    } else {
      auditEvent(
        'repo.fork',
        [ 'ok' => false, 'kind' => 'service-token' ],
        'error',
        'repo',
        '@' . $sourceOwner . '/' . $sourceRepo,
        [ 'targetRepo' => $targetRepo, 'error' => rowValue($res, 'error', 'fork failed') ]
      )
      repoActionRedirect($sourceOwner, $sourceRepo, 'fork_failed', '' . rowValue($res, 'error', 'fork failed'))
    }
    return
  }
  header('Content-Type: application/json')
  echo jsonReply($res)
}

function apiPackageDetail() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  $org = queryValue('org', '')
  $name = queryValue('name', '')
  $detail = fetchPackageDetail($org, $name, $auth)
  echo jsonReply($detail)
}

function fetchOrgProfile($handle, $auth) {
  $orgHandle = normalizeHandleName($handle)
  if ($orgHandle === '') {
    return [ 'ok' => false, 'error' => 'org handle is required' ]
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    return [ 'ok' => false, 'error' => $conn->error ]
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $org = dbQueryOne(
    $db,
    "select id, handle, visibility from lh_orgs where lower(handle) = lower($1) limit 1",
    [$orgHandle]
  )
  if (!result_is_ok($org)) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'org lookup failed', 'detail' => $org->error ]
  }
  $orgRow = $org->value
  $orgId = (int) rowValue($orgRow, 'id', 0)
  $orgVisibility = '' . rowValue($orgRow, 'visibility', 'public')
  $viewerId = authUserId($auth)
  $memberAccess = $viewerId > 0 && canEditOrg($db, $orgId, $viewerId)
  if ($orgVisibility === 'private' && !$memberAccess) {
    dbClose($db)
    return [ 'ok' => false, 'error' => 'forbidden: org is private' ]
  }
  $sql = "select id, org_id as orgId, name, description, latest_version as latestVersion, download_count as downloadCount, visibility from packages where org_id = ($1)::text::bigint"
  if (!$memberAccess) {
    $sql = $sql . " and visibility = 'public'"
  }
  $sql = $sql . " order by download_count desc, id desc limit 100"
  $pkgRows = rowsFromQueryResult(dbQuery($db, $sql, ['' . $orgId]))
  dbClose($db)

  $packages = []
  foreach ($pkgRows as $row) {
    $packages[] = normalizePackage($row)
  }
  return [
    'ok' => true,
    'org' => [ 'id' => $orgId, 'handle' => rowValue($orgRow, 'handle', $orgHandle), 'visibility' => $orgVisibility ],
    'packages' => $packages
  ]
}

function apiOrgDetail() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $auth = authWithScope(1)
  $detail = fetchOrgProfile(queryValue('handle', ''), $auth)
  echo jsonReply($detail)
}

function apiArtifactDownload($canonicalId) {
  $id = trim('' . $canonicalId)
  if ($id === '') {
    header('HTTP/1.1 400 Bad Request')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => 'canonical id is required' ])
    return
  }
  $auth = authWithScope(1)
  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    header('HTTP/1.1 500 Internal Server Error')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => $conn->error ])
    return
  }
  $db = $conn->value
  ensureAuthSchema($db)
  $row = dbQueryOne(
    $db,
    "select v.artifact_inline_b64 as artifactInlineB64, v.artifact_mime as artifactMime, v.artifact_backend as artifactBackend, v.artifact_key as artifactKey, p.org_id as orgId, p.visibility
       from package_versions v
       join packages p on p.id = v.package_id
      where v.canonical_id = $1
      limit 1",
    [$id]
  )
  if (!result_is_ok($row)) {
    dbClose($db)
    header('HTTP/1.1 404 Not Found')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => 'artifact not found' ])
    return
  }

  if (!packageIsVisibleTo($db, $row->value, $auth)) {
    dbClose($db)
    header('HTTP/1.1 403 Forbidden')
    header('Content-Type: application/json')
    echo jsonReply([ 'ok' => false, 'error' => 'forbidden: package is private' ])
    return
  }
  $backend = '' . rowValue($row->value, 'artifactBackend', rowValue($row->value, 'artifact_backend', 'local'))
  $mime = '' . rowValue($row->value, 'artifactMime', rowValue($row->value, 'artifact_mime', 'application/octet-stream'))
  $artifactKey = '' . rowValue($row->value, 'artifactKey', rowValue($row->value, 'artifact_key', ''))
  $bytes = null
  if ($backend === 'r2' && $artifactKey !== '') {
    $fromR2 = r2GetObject($artifactKey)
    if ($fromR2['ok']) {
      $bytes = '' . $fromR2['body']
      $mime = '' . $fromR2['mime']
    }
  }
  if ($bytes === null) {
    $b64 = '' . rowValue($row->value, 'artifactInlineB64', rowValue($row->value, 'artifact_inline_b64', ''))
    if ($b64 === '') {
      dbClose($db)
      header('HTTP/1.1 404 Not Found')
      header('Content-Type: application/json')
      echo jsonReply([ 'ok' => false, 'error' => 'artifact bytes missing' ])
      return
    }
    $decoded = base64_decode($b64)
    if ($decoded === false) {
      dbClose($db)
      header('HTTP/1.1 500 Internal Server Error')
      header('Content-Type: application/json')
      echo jsonReply([ 'ok' => false, 'error' => 'artifact decode failed' ])
      return
    }
    $bytes = $decoded
  }
  dbClose($db)
  header('Content-Type: ' . ($mime === '' ? 'application/octet-stream' : $mime))
  header('Content-Length: ' . strlen($bytes))
  header('Content-Disposition: attachment; filename="' . $id . '.bin"')
  echo $bytes
}

function PackageDetailPage($props) {
  if (!$props->ok) {
    return <Layout>
      <section class="rounded-2xl bg-white p-8 shadow-sm">
        <h2 class="text-2xl font-bold text-gray-900">Package Not Available</h2>
        <p class="mt-3 text-sm text-gray-600">{'' . rowValue($props, 'error', 'not found')}</p>
      </section>
    </Layout>
  }

  $pkg = rowValue($props, 'package', [])
  $versions = rowValue($props, 'versions', [])
  $activeVersion = count($versions) > 0 ? $versions[0] : []
  $activeVersionName = '' . rowValue($activeVersion, 'version', rowValue($pkg, 'latestVersion', ''))
  $mainFile = '' . rowValue($activeVersion, 'mainFile', rowValue($activeVersion, 'main_file', 'index.phpx'))
  $fileRows = normalizeVersionFiles(rowValue($activeVersion, 'files', []), $mainFile)
  $treeEntries = rowValue($props, 'treeEntries', [])
  $treeError = '' . rowValue($props, 'treeError', '')
  $selectedFile = '' . rowValue($props, 'selectedFile', '')
  $selectedFileContent = '' . rowValue($props, 'selectedFileContent', '')
  $selectedFileError = '' . rowValue($props, 'selectedFileError', '')
  $capabilities = extractVersionCapabilities($activeVersion)
  $docsSymbols = rowValue($props, 'docsSymbols', [])
  $docsError = '' . rowValue($props, 'docsError', '')
  $issues = rowValue($props, 'issues', [])
  $issuesError = '' . rowValue($props, 'issuesError', '')
  $activeIssue = rowValue($props, 'activeIssue', null)
  $activeIssueComments = rowValue($props, 'activeIssueComments', [])
  $activeIssueError = '' . rowValue($props, 'activeIssueError', '')
  $pulls = rowValue($props, 'pulls', [])
  $pullsError = '' . rowValue($props, 'pullsError', '')
  $activePull = rowValue($props, 'activePull', null)
  $activePullComments = rowValue($props, 'activePullComments', [])
  $activePullError = '' . rowValue($props, 'activePullError', '')
  $repoAction = '' . rowValue($props, 'repoAction', '')
  $repoMessage = '' . rowValue($props, 'repoMessage', '')
  $packageCoord = '@' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '')
  $previewRoute = '/@' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '') . '/HEAD'
  $forkDefaultRepo = '' . rowValue($pkg, 'name', '') . '-fork'
  $readmeText = versionReadmeText($activeVersion, $packageCoord, $activeVersionName)
  $items = []
  foreach ($versions as $v) {
    $ver = rowValue($v, 'version', '')
    $cid = '' . rowValue($v, 'canonicalId', rowValue($v, 'canonical_id', ''))
    $size = (int) rowValue($v, 'artifactSizeBytes', rowValue($v, 'artifact_size_bytes', 0))
    $items[] = <li class="rounded-lg border border-gray-200 p-3">
      <div class="flex items-center justify-between gap-3">
        <div class="text-sm font-semibold text-gray-900">{'v' . $ver}</div>
        <a class="text-xs text-blue-600 hover:text-blue-800" href={'/api/artifacts/' . $cid}>download</a>
      </div>
      <div class="mt-1 text-xs text-gray-500">{'size: ' . $size . ' bytes'}</div>
    </li>
  }

  $knownCapabilities = ['read', 'write', 'net', 'env', 'db', 'run', 'dynamic', 'wasm']
  $capabilityLookup = []
  foreach ($capabilities as $cap) {
    $capabilityLookup['' . $cap] = true
  }
  $capabilityRows = []
  foreach ($knownCapabilities as $cap) {
    $enabled = array_key_exists($cap, $capabilityLookup)
    $capabilityRows[] = <div class="flex items-center justify-between rounded border border-gray-200 bg-gray-50 px-3 py-2">
      <span class="font-mono text-xs text-gray-700">{$cap}</span>
      <span class={'rounded px-2 py-0.5 text-[11px] font-semibold ' . ($enabled ? 'bg-emerald-100 text-emerald-700' : 'bg-gray-200 text-gray-500')}>
        {$enabled ? 'required' : 'none'}
      </span>
    </div>
  }

  $capabilityPills = []
  foreach ($capabilities as $cap) {
    $capabilityPills[] = <span class="rounded-full bg-blue-100 px-2 py-1 text-[11px] font-semibold text-blue-700">{$cap}</span>
  }

  $fileSource = (is_array($treeEntries) && count($treeEntries) > 0) ? $treeEntries : $fileRows
  $fileItems = []
  $fileLimit = min(120, count($fileSource))
  $packagePath = '/package/' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '')
  for ($i = 0; $i < $fileLimit; $i = $i + 1) {
    $f = $fileSource[$i]
    $path = '' . rowValue($f, 'path', '')
    $sizeRaw = rowValue($f, 'sizeBytes', rowValue($f, 'size', null))
    $sizeText = is_numeric($sizeRaw) ? ((string) ((int) $sizeRaw) . ' B') : ''
    $isSelected = $selectedFile !== '' && $selectedFile === $path
    $fileItems[] = <li class="flex items-center justify-between gap-2 rounded border border-gray-200 bg-gray-50 px-3 py-1.5">
      <a class={'truncate font-mono text-xs ' . ($isSelected ? 'text-blue-700 font-semibold' : 'text-gray-700 hover:text-blue-700')} href={$packagePath . '?file=' . rawurlencode($path)}>{$path}</a>
      {$sizeText !== '' ? <span class="text-[11px] text-gray-500">{$sizeText}</span> : <span class="text-[11px] text-gray-400">-</span>}
    </li>
  }
  $hasMoreFiles = count($fileSource) > $fileLimit
  $docRows = []
  $docLimit = min(12, is_array($docsSymbols) ? count($docsSymbols) : 0)
  for ($i = 0; $i < $docLimit; $i = $i + 1) {
    $d = $docsSymbols[$i]
    $docRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2">
      <div class="flex items-center justify-between gap-2">
        <span class="font-mono text-xs text-gray-700">{'' . rowValue($d, 'symbol', '')}</span>
        <span class="rounded bg-gray-200 px-2 py-0.5 text-[11px] text-gray-600">{'' . rowValue($d, 'kind', '')}</span>
      </div>
      <div class="mt-1 text-xs text-gray-600">{'' . rowValue($d, 'summary', '')}</div>
    </li>
  }
  $hasMoreDocs = is_array($docsSymbols) && count($docsSymbols) > $docLimit
  $issueRows = []
  if (is_array($issues)) {
    foreach ($issues as $item) {
      $number = (int) rowValue($item, 'number', 0)
      $href = $packagePath . '?issue=' . (string) $number
      $issueRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2">
        <a class="text-sm font-semibold text-blue-700 hover:text-blue-900" href={$href}>{'#' . (string) $number . ' ' . rowValue($item, 'title', '')}</a>
        <div class="mt-1 text-xs text-gray-500">{'by ' . rowValue($item, 'author', '') . '  ' . rowValue($item, 'state', 'open')}</div>
      </li>
    }
  }
  $pullRows = []
  if (is_array($pulls)) {
    foreach ($pulls as $item) {
      $number = (int) rowValue($item, 'number', 0)
      $href = $packagePath . '?pull=' . (string) $number
      $pullRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2">
        <a class="text-sm font-semibold text-blue-700 hover:text-blue-900" href={$href}>{'#' . (string) $number . ' ' . rowValue($item, 'title', '')}</a>
        <div class="mt-1 text-xs text-gray-500">{'by ' . rowValue($item, 'author', '') . '  ' . rowValue($item, 'state', 'open') . '  ' . rowValue($item, 'source_ref', rowValue($item, 'sourceRef', '?')) . ' -> ' . rowValue($item, 'target_ref', rowValue($item, 'targetRef', '?'))}</div>
      </li>
    }
  }
  $issueCommentRows = []
  if (is_array($activeIssueComments)) {
    foreach ($activeIssueComments as $comment) {
      $issueCommentRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2 text-xs text-gray-700">
        <div class="font-semibold text-gray-800">{rowValue($comment, 'author', '')}</div>
        <div class="mt-1 whitespace-pre-wrap">{rowValue($comment, 'body', '')}</div>
      </li>
    }
  }
  $pullCommentRows = []
  if (is_array($activePullComments)) {
    foreach ($activePullComments as $comment) {
      $pullCommentRows[] = <li class="rounded border border-gray-200 bg-gray-50 px-3 py-2 text-xs text-gray-700">
        <div class="font-semibold text-gray-800">{rowValue($comment, 'author', '')}</div>
        <div class="mt-1 whitespace-pre-wrap">{rowValue($comment, 'body', '')}</div>
      </li>
    }
  }

  return <Layout>
    <section class="rounded-xl border border-gray-200 bg-white shadow-sm">
      <div class="border-b border-gray-200 px-6 py-4">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <div>
            <div class="text-sm text-gray-500">{rowValue($props, 'org', '')}</div>
            <h1 class="text-2xl font-semibold text-blue-700">{rowValue($pkg, 'name', '')}</h1>
            <p class="mt-1 text-sm text-gray-600">{rowValue($pkg, 'description', '')}</p>
          </div>
          <div class="flex flex-wrap gap-2">
            <a class="rounded border border-gray-300 px-3 py-1.5 text-sm font-semibold text-gray-700 hover:bg-gray-50" href={$previewRoute}>Preview</a>
            <form method="POST" action={repoForkRoute()} class="flex items-center gap-2">
              <input type="hidden" name="source_owner" value={rowValue($props, 'org', '')} />
              <input type="hidden" name="source_repo" value={rowValue($pkg, 'name', '')} />
              <input class="w-40 rounded border border-gray-300 px-2 py-1.5 text-sm" type="text" name="target_repo" value={$forkDefaultRepo} />
              <button class="rounded bg-indigo-600 px-3 py-1.5 text-sm font-semibold text-white hover:bg-indigo-700" type="submit">Fork</button>
            </form>
          </div>
        </div>
        <PackageStatPills latestVersion={rowValue($pkg, 'latestVersion', 'n/a')} downloadCount={rowValue($pkg, 'downloadCount', 0)} visibility={rowValue($pkg, 'visibility', 'public')} />
      </div>

      <div class="border-b border-gray-200 px-6">
        <div class="flex flex-wrap gap-5 text-sm">
          <span class="border-b-2 border-blue-600 py-3 font-semibold text-gray-900">Code</span>
          <span class="py-3 text-gray-600">Issues ({is_array($issues) ? (string) count($issues) : '0'})</span>
          <span class="py-3 text-gray-600">Pull requests ({is_array($pulls) ? (string) count($pulls) : '0'})</span>
          <span class="py-3 text-gray-600">Security</span>
          <span class="py-3 text-gray-600">Releases ({(string) count($items)})</span>
        </div>
      </div>

      {$repoAction !== '' ? <div class={'mx-6 mt-4 rounded border px-3 py-2 text-xs ' . ((strpos($repoAction, 'failed') !== false) ? 'border-rose-200 bg-rose-50 text-rose-700' : 'border-emerald-200 bg-emerald-50 text-emerald-700')}>
        {$repoMessage === '' ? $repoAction : $repoMessage}
      </div> : null}

      <div class="grid gap-6 p-6 lg:grid-cols-12">
        <aside class="space-y-4 lg:col-span-4">
          <section class="rounded-lg border border-gray-200 p-4">
            <h3 class="text-sm font-semibold text-gray-900">Files</h3>
            <p class="mt-1 text-xs text-gray-500">{'entrypoint: ' . ($mainFile === '' ? 'index.phpx' : $mainFile)}</p>
            {$treeError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-2 py-1 text-xs text-amber-800">{'Tree: ' . $treeError}</div> : null}
            <ul class="mt-3 grid gap-1.5">
              {$fileItems}
            </ul>
            {$hasMoreFiles ? <div class="mt-2 text-xs text-gray-500">{'showing first ' . (string) $fileLimit . ' files'}</div> : null}
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <h3 class="text-sm font-semibold text-gray-900">Security</h3>
            <div class="mt-2 flex flex-wrap gap-2">
              {$capabilityPills}
            </div>
            <div class="mt-3 grid gap-2">
              {$capabilityRows}
            </div>
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <h3 class="text-sm font-semibold text-gray-900">Releases</h3>
            <div class="mt-3">
              <PackageVersionRows items={$items} />
            </div>
          </section>
        </aside>

        <main class="space-y-4 lg:col-span-8">
          <section class="rounded-lg border border-gray-200">
            <div class="border-b border-gray-200 bg-gray-50 px-4 py-2 text-xs text-gray-600">
              {$selectedFile !== '' ? $selectedFile : 'Select a file'}
            </div>
            {$selectedFileError !== '' ? <div class="px-4 py-2 text-xs text-amber-800">{'Blob source: ' . $selectedFileError}</div> : null}
            {$selectedFileContent !== '' ? <pre class="max-h-[420px] overflow-auto bg-gray-900 p-4 text-[12px] leading-5 text-gray-100 whitespace-pre-wrap">{$selectedFileContent}</pre> : <div class="p-4 text-sm text-gray-500">Select a file from the left panel.</div>}
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <div class="flex items-center justify-between gap-3">
              <h3 class="text-sm font-semibold text-gray-900">README</h3>
              <span class="text-xs text-gray-500">{'@' . rowValue($props, 'org', '') . '/' . rowValue($pkg, 'name', '')}</span>
            </div>
            <pre class="mt-3 max-h-[520px] overflow-auto rounded bg-gray-50 p-4 text-xs leading-6 text-gray-700 whitespace-pre-wrap">{'' . $readmeText}</pre>
          </section>

          <section class="rounded-lg border border-gray-200 p-4">
            <div class="flex items-center justify-between gap-3">
              <h3 class="text-sm font-semibold text-gray-900">API Docs</h3>
              <span class="text-xs text-gray-500">{is_array($docsSymbols) ? ((string) count($docsSymbols) . ' symbols') : '0 symbols'}</span>
            </div>
            {$docsError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Docs source: ' . $docsError}</div> : null}
            <ul class="mt-3 grid gap-2">
              {$docRows}
            </ul>
            {$hasMoreDocs ? <div class="mt-2 text-xs text-gray-500">{'showing first ' . (string) $docLimit . ' docs entries'}</div> : null}
          </section>
        </main>
      </div>

      <div class="grid gap-6 border-t border-gray-200 p-6 lg:grid-cols-2">
        <section class="rounded-lg border border-gray-200 p-4">
          <div class="flex items-center justify-between gap-3">
            <h3 class="text-sm font-semibold text-gray-900">Issues</h3>
            <span class="text-xs text-gray-500">{is_array($issues) ? ((string) count($issues) . ' open') : '0 open'}</span>
          </div>
          {$issuesError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Issues source: ' . $issuesError . '. Set LINKHASH_GIT_TOKEN to enable issue APIs.'}</div> : null}
          <ul class="mt-3 grid gap-2">{$issueRows}</ul>
          <form class="mt-4 grid gap-2" method="POST" action={repoIssueCreateRoute()}>
            <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
            <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="title" placeholder="Issue title" />
            <textarea class="min-h-[90px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Describe the issue"></textarea>
            <button class="rounded bg-blue-600 px-3 py-2 text-sm font-semibold text-white hover:bg-blue-700" type="submit">Create issue</button>
          </form>
          {$activeIssueError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Issue detail: ' . $activeIssueError}</div> : null}
          {$activeIssue !== null ? <div class="mt-4 rounded border border-gray-200 bg-gray-50 p-3">
            <div class="text-sm font-semibold text-gray-900">{'#' . rowValue($activeIssue, 'number', 0) . ' ' . rowValue($activeIssue, 'title', '')}</div>
            <div class="mt-1 text-xs text-gray-600 whitespace-pre-wrap">{rowValue($activeIssue, 'body', '')}</div>
            <div class="mt-3 text-xs font-semibold text-gray-700">Comments</div>
            <ul class="mt-2 grid gap-2">{$issueCommentRows}</ul>
            <form class="mt-3 grid gap-2" method="POST" action={repoIssueCommentRoute()}>
              <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
              <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
              <input type="hidden" name="number" value={rowValue($activeIssue, 'number', 0)} />
              <textarea class="min-h-[80px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Add comment"></textarea>
              <button class="rounded border border-gray-300 px-3 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-100" type="submit">Comment on issue</button>
            </form>
          </div> : null}
        </section>

        <section class="rounded-lg border border-gray-200 p-4">
          <div class="flex items-center justify-between gap-3">
            <h3 class="text-sm font-semibold text-gray-900">Pull Requests</h3>
            <span class="text-xs text-gray-500">{is_array($pulls) ? ((string) count($pulls) . ' open') : '0 open'}</span>
          </div>
          {$pullsError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Pulls source: ' . $pullsError . '. Set LINKHASH_GIT_TOKEN to enable pull APIs.'}</div> : null}
          <ul class="mt-3 grid gap-2">{$pullRows}</ul>
          <form class="mt-4 grid gap-2" method="POST" action={repoPullCreateRoute()}>
            <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
            <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="title" placeholder="Pull request title" />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="source_ref" placeholder="source ref (feature/my-change)" />
            <input class="rounded border border-gray-300 px-3 py-2 text-sm" type="text" name="target_ref" value="main" />
            <textarea class="min-h-[90px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Describe the change"></textarea>
            <button class="rounded bg-indigo-600 px-3 py-2 text-sm font-semibold text-white hover:bg-indigo-700" type="submit">Create pull request</button>
          </form>
          {$activePullError !== '' ? <div class="mt-2 rounded border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800">{'Pull detail: ' . $activePullError}</div> : null}
          {$activePull !== null ? <div class="mt-4 rounded border border-gray-200 bg-gray-50 p-3">
            <div class="text-sm font-semibold text-gray-900">{'#' . rowValue($activePull, 'number', 0) . ' ' . rowValue($activePull, 'title', '')}</div>
            <div class="mt-1 text-xs text-gray-600">{rowValue($activePull, 'source_ref', rowValue($activePull, 'sourceRef', '?')) . ' -> ' . rowValue($activePull, 'target_ref', rowValue($activePull, 'targetRef', '?'))}</div>
            <div class="mt-1 text-xs text-gray-600 whitespace-pre-wrap">{rowValue($activePull, 'body', '')}</div>
            <div class="mt-3 text-xs font-semibold text-gray-700">Comments</div>
            <ul class="mt-2 grid gap-2">{$pullCommentRows}</ul>
            <form class="mt-3 grid gap-2" method="POST" action={repoPullCommentRoute()}>
              <input type="hidden" name="org" value={rowValue($props, 'org', '')} />
              <input type="hidden" name="name" value={rowValue($pkg, 'name', '')} />
              <input type="hidden" name="number" value={rowValue($activePull, 'number', 0)} />
              <textarea class="min-h-[80px] rounded border border-gray-300 px-3 py-2 text-sm" name="body" placeholder="Add comment"></textarea>
              <button class="rounded border border-gray-300 px-3 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-100" type="submit">Comment on pull request</button>
            </form>
          </div> : null}
        </section>
      </div>
    </section>
  </Layout>
}

function OrgProfilePage($props) {
  if (!$props->ok) {
    return <Layout>
      <section class="rounded-2xl bg-white p-8 shadow-sm">
        <h2 class="text-2xl font-bold text-gray-900">Organization Not Available</h2>
        <p class="mt-3 text-sm text-gray-600">{'' . rowValue($props, 'error', 'not found')}</p>
      </section>
    </Layout>
  }

  $org = rowValue($props, 'org', [])
  $packages = rowValue($props, 'packages', [])
  $cards = []
  foreach ($packages as $pkg) {
    $cards[] = <article class="rounded-xl border border-gray-200 p-4">
      <div class="flex items-center justify-between gap-3">
        <a class="text-base font-semibold text-blue-700 hover:text-blue-900" href={'/package/' . rowValue($org, 'handle', '') . '/' . rowValue($pkg, 'name', '')}>
          {rowValue($pkg, 'name', '')}
        </a>
        <span class="text-xs rounded bg-gray-100 px-2 py-1">{rowValue($pkg, 'visibility', 'public')}</span>
      </div>
      <p class="mt-2 text-sm text-gray-600">{rowValue($pkg, 'description', '')}</p>
    </article>
  }

  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Organization</div>
      <h1 class="mt-2 text-3xl font-bold text-gray-900">{'@' . rowValue($org, 'handle', '')}</h1>
      <div class="mt-3 text-xs rounded bg-gray-100 inline-flex px-2 py-1">{'visibility: ' . rowValue($org, 'visibility', 'public')}</div>
      <h3 class="mt-6 text-lg font-semibold text-gray-900">Packages</h3>
      <div class="mt-3 grid gap-3">
        {$cards}
      </div>
    </section>
  </Layout>
}

function AccountPage($props) {
  if (!$props->ok) {
    return <Layout>
      <section class="rounded-2xl bg-white p-8 shadow-sm">
        <h2 class="text-2xl font-bold text-gray-900">Sign in required</h2>
        <p class="mt-3 text-sm text-gray-600">Use Bluesky OAuth or local dev login to access account settings.</p>
        <div class="mt-6 flex gap-3">
          <a class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" href="/auth/start">Sign in with Bluesky</a>
          <a class="rounded-lg border border-gray-300 px-4 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-50" href="/api/auth/dev-login?handle=samifou.ad">Dev Login</a>
        </div>
      </section>
    </Layout>
  }

  $user = isset($props->user) ? $props->user : []
  $notice = isset($props->notice) ? ('' . $props->notice) : ''
  $newToken = isset($props->newToken) ? ('' . $props->newToken) : ''

  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Account</div>
      <h1 class="mt-2 text-3xl font-bold text-gray-900">{'@' . rowValue($user, 'handle', 'user')}</h1>
      <p class="mt-2 text-sm text-gray-600">{rowValue($user, 'did', '')}</p>
      {$notice !== '' ? <div class="mt-4 rounded-lg border border-blue-200 bg-blue-50 px-4 py-3 text-sm text-blue-700">{$notice}</div> : null}
      {$newToken !== '' ? <div class="mt-4 rounded-lg border border-emerald-200 bg-emerald-50 px-4 py-3 text-sm text-emerald-700">{'New token: ' . $newToken}</div> : null}
    </section>

    <section class="mt-6 grid gap-6 md:grid-cols-2">
      <div class="rounded-2xl bg-white p-6 shadow-sm">
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Personal Access Tokens</div>
        <p class="mt-2 text-sm text-gray-600">Create a token for CLI publish/install flows. Use API list/revoke endpoints below for full management.</p>
        <form class="mt-4 grid gap-3" method="GET" action="/account">
          <input type="hidden" name="action" value="create_pat" />
          <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" type="text" name="label" placeholder="token label" />
          <select class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="scope">
            <option value="read">read</option>
            <option value="read:write" selected>read:write</option>
            <option value="read:write:delete">read:write:delete</option>
          </select>
          <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" type="number" min="1" max="3650" name="expires_days" value="30" />
          <button class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" type="submit">Create token</button>
        </form>
        <form class="mt-3" method="GET" action="/account">
          <input type="hidden" name="action" value="revoke_all_pat" />
          <button class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" type="submit">Revoke all</button>
        </form>
        <div class="mt-4 text-xs text-gray-500">
          <div><a class="text-blue-600 hover:text-blue-800" href="/api/auth/token/list">GET /api/auth/token/list</a></div>
          <div class="mt-1"><a class="text-blue-600 hover:text-blue-800" href="/api/auth/me">GET /api/auth/me</a></div>
        </div>
      </div>

      <div class="rounded-2xl bg-white p-6 shadow-sm">
        <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Organization Access</div>
        <p class="mt-2 text-sm text-gray-600">View and manage org permissions through API routes while the full UI is being finished.</p>
        <div class="mt-4 text-xs text-gray-500">
          <div><a class="text-blue-600 hover:text-blue-800" href="/api/orgs/mine">GET /api/orgs/mine</a></div>
          <div class="mt-1"><a class="text-blue-600 hover:text-blue-800" href="/api/orgs/members?orgId=1">GET /api/orgs/members</a></div>
        </div>
      </div>
    </section>
  </Layout>
}

function PlaygroundPage($props) {
  $org = '' . rowValue($props, 'org', '')
  $name = '' . rowValue($props, 'name', '')
  $version = '' . rowValue($props, 'version', 'latest')
  $resolved = rowValue($props, 'resolved', null)
  $error = '' . rowValue($props, 'error', '')
  $install = rowValue($props, 'install', null)
  $artifactUrl = '' . rowValue($props, 'artifactUrl', '')
  $versions = rowValue($props, 'versions', [])

  $versionItems = []
  if (is_array($versions)) {
    foreach ($versions as $v) {
      $ver = '' . rowValue($v, 'version', '')
      if ($ver === '') {
        continue
      }
      $href = '/playground?org=' . rawurlencode($org) . '&name=' . rawurlencode($name) . '&version=' . rawurlencode($ver)
      $versionItems[] = <a class="inline-flex rounded bg-gray-100 px-2 py-1 text-xs text-gray-700 hover:bg-gray-200" href={$href}>{$ver}</a>
    }
  }

  return <Layout>
    <section class="rounded-2xl bg-white p-8 shadow-sm">
      <div class="text-sm font-semibold uppercase tracking-wide text-blue-600">Playground</div>
      <h1 class="mt-2 text-3xl font-bold text-gray-900">Package Inspector</h1>
      <p class="mt-2 text-sm text-gray-600">Resolve a package/version, inspect metadata, and fetch install/artifact endpoints.</p>
      <form class="mt-6 grid gap-4 md:grid-cols-4" method="GET" action="/playground">
        <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="org" placeholder="org handle" value={$org} />
        <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="name" placeholder="package name" value={$name} />
        <input class="rounded-lg border border-gray-300 px-3 py-2 text-sm" name="version" placeholder="latest" value={$version} />
        <button class="rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-700" type="submit">Resolve</button>
      </form>
      {$error !== '' ? <div class="mt-4 rounded-lg border border-rose-200 bg-rose-50 px-4 py-3 text-sm text-rose-700">{$error}</div> : null}
      {$resolved !== null ? <div class="mt-6 rounded-xl border border-gray-200 p-5">
        <div class="text-sm font-semibold text-gray-900">{'@' . $org . '/' . $name . ' @ ' . ('' . rowValue($resolved, 'version', $version))}</div>
        <div class="mt-2 text-sm text-gray-600">{'' . rowValue($resolved, 'description', '')}</div>
        <div class="mt-3 grid gap-2 text-xs text-gray-700 md:grid-cols-2">
          <div>{'canonicalId: ' . ('' . rowValue($resolved, 'canonicalId', ''))}</div>
          <div>{'artifact backend: ' . ('' . rowValue($resolved, 'artifactBackend', 'local'))}</div>
          <div>{'artifact size: ' . (string) rowValue($resolved, 'artifactSizeBytes', 0) . ' bytes'}</div>
          <div>{'visibility: ' . ('' . rowValue($resolved, 'visibility', 'public'))}</div>
        </div>
        {$install !== null ? <div class="mt-4 rounded-lg bg-gray-900 p-3 text-xs text-gray-100 whitespace-pre-wrap">{jsonReply($install)}</div> : null}
        <div class="mt-4 flex flex-wrap gap-2">
          {$artifactUrl !== '' ? <a class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" href={$artifactUrl}>Download artifact</a> : null}
          <a class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" href={'/api/package?org=' . rawurlencode($org) . '&name=' . rawurlencode($name)}>Package API</a>
          <a class="rounded border border-gray-300 px-3 py-1 text-xs text-gray-700 hover:bg-gray-50" href={'/api/install?org=' . rawurlencode($org) . '&name=' . rawurlencode($name) . '&version=' . rawurlencode($version === '' ? 'latest' : $version)}>Install API</a>
        </div>
        <div class="mt-4 flex flex-wrap gap-2">{$versionItems}</div>
      </div> : null}
    </section>
  </Layout>
}

function apiCreateDemoPackage() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply({ ok: false, error: $auth['error'] })
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply({ ok: false, error: $csrf['error'] })
    return
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply({ ok: false, error: $conn->error })
    return
  }

  $body = requestData()
  $seed = (int) (microtime(true) * 1000)
  $orgId = (int) queryValue('orgId', array_key_exists('orgId', $body) ? $body['orgId'] : 0)
  $pkgName = normalizePackageName('' . queryValue('name', array_key_exists('name', $body) ? $body['name'] : ('demo_pkg_' . (string) ($seed % 100000))))
  $visibility = parseVisibility(queryValue('visibility', array_key_exists('visibility', $body) ? $body['visibility'] : 'public'), 'public')

  if ($orgId <= 0) {
    dbClose($conn->value)
    echo jsonReply({ ok: false, error: 'orgId is required' })
    return
  }
  if (!isValidPackageName($pkgName) || isReservedPackageName($pkgName)) {
    dbClose($conn->value)
    echo jsonReply({ ok: false, error: 'invalid or reserved package name' })
    return
  }
  if ($visibility === null) {
    dbClose($conn->value)
    echo jsonReply({ ok: false, error: 'visibility must be public or private' })
    return
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  if (!canEditOrg($handle, $orgId, $userId)) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'forbidden: missing org edit access' })
    return
  }
  $pkgInsert = dbQueryOne(
    $handle,
    "insert into packages (org_id, name, description, latest_version, download_count, visibility)
     values (($1)::text::bigint, $2, $3, $4, ($5)::text::integer, $6)
     returning id, org_id as orgId, name, visibility",
    ['' . $orgId, $pkgName, 'Demo package created from API', '0.1.0', '0', $visibility]
  )
  dbClose($handle)

  echo jsonReply({
    ok: result_is_ok($pkgInsert),
    package: result_is_ok($pkgInsert) ? $pkgInsert->value : $pkgInsert->error,
    data: {
      orgId: $orgId,
      packageName: $pkgName,
      visibility: $visibility
    }
  })
}

function apiBumpPackageDownloads() {
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  $method = requireMethod('POST')
  if (!$method['ok']) {
    echo jsonReply($method)
    return
  }
  $auth = authWithScope(2)
  if (!$auth['ok']) {
    echo jsonReply({ ok: false, error: $auth['error'] })
    return
  }
  $userId = authUserId($auth)
  $rateUser = enforceUserRateLimit('publish.mutate.user', $userId, 5, 60)
  if (!$rateUser['ok']) {
    echo jsonReply({ ok: false, error: $rateUser['error'], bucket: 'publish.mutate.user' })
    return
  }
  $rateIp = enforceIpRateLimit('publish.mutate.ip', 20, 60)
  if (!$rateIp['ok']) {
    echo jsonReply({ ok: false, error: $rateIp['error'], bucket: 'publish.mutate.ip' })
    return
  }
  $csrf = authValidateCsrfForAuth($auth)
  if (!$csrf['ok']) {
    echo jsonReply({ ok: false, error: $csrf['error'] })
    return
  }

  $body = requestData()
  $name = '' . queryValue('name', array_key_exists('name', $body) ? $body['name'] : '')
  $by = (int) queryValue('by', array_key_exists('by', $body) ? $body['by'] : 1)
  if ($name === '') {
    echo jsonReply({ ok: false, error: 'name is required' })
    return
  }
  if ($by < 1) {
    $by = 1
  }

  $conn = openDbHandle()
  if (!result_is_ok($conn)) {
    echo jsonReply({ ok: false, error: $conn->error })
    return
  }

  $handle = $conn->value
  ensureAuthSchema($handle)
  $row = dbQueryOne($handle, 'select id, org_id as orgId, download_count as downloadCount from packages where name = $1 limit 1', [$name])
  if (!result_is_ok($row)) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'package not found' })
    return
  }

  $pkg = $row->value
  $id = (int) rowValue($pkg, 'id', 0)
  $orgId = (int) rowValue($pkg, 'orgId', rowValue($pkg, 'org_id', 0))
  if ($id <= 0) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'package not found' })
    return
  }
  if ($orgId <= 0 || !canEditOrg($handle, $orgId, $userId)) {
    dbClose($handle)
    echo jsonReply({ ok: false, error: 'forbidden: missing org edit access' })
    return
  }
  $current = (int) rowValue($pkg, 'downloadCount', rowValue($pkg, 'download_count', 0))
  $next = $current + $by
  $updated = dbExec($handle, 'update packages set download_count = $1 where id = $2', [$next, $id])
  dbClose($handle)

  if (!result_is_ok($updated)) {
    echo jsonReply({ ok: false, error: $updated->error })
    return
  }

  echo jsonReply({
    ok: true,
    package: $name,
    before: $current,
    after: $next
  })
}

loadDotEnv('.env')
installRuntimeHandlers()
bootstrapSchema()

$uri = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : '/'
$parts = explode('?', $uri)
$path = $parts[0]
if (strpos($path, '/api/') === 0) {
  header('X-Request-Id: ' . requestId())
  logEvent('info', 'api.request', { route: '' . $path })
}

if ($path === '/api/packages') {
  apiPackages()
  return
}

if ($path === '/api/search') {
  apiSearch()
  return
}

if ($path === '/api/db-stats') {
  apiDbStats()
  return
}

if ($path === '/api/stats/packages') {
  apiPackageStats()
  return
}

if ($path === '/api/runtime-checks') {
  apiRuntimeChecks()
  return
}

if ($path === '/api/runtime-action') {
  apiRuntimeAction()
  return
}

if ($path === '/api/registry/identity') {
  apiRegistryIdentity()
  return
}

if ($path === '/api/auth/login') {
  apiAuthLogin()
  return
}

if ($path === '/api/auth/callback') {
  apiAuthCallback()
  return
}

if ($path === '/api/auth/dev-login') {
  apiAuthDevLogin()
  return
}

if ($path === '/api/auth/logout') {
  apiAuthLogout()
  return
}

if ($path === '/api/auth/me') {
  apiAuthMe()
  return
}

if ($path === '/api/auth/token/create') {
  apiAuthPatCreate()
  return
}

if ($path === '/api/auth/token/list') {
  apiAuthPatList()
  return
}

if ($path === '/api/auth/token/revoke') {
  apiAuthPatRevoke()
  return
}

if ($path === '/api/auth/token/revoke-all') {
  apiAuthPatRevokeAll()
  return
}

if ($path === '/api/orgs/mine') {
  apiOrgsMine()
  return
}

if ($path === '/api/orgs/create') {
  apiOrgsCreate()
  return
}

if ($path === '/api/orgs/members') {
  apiOrgMembersList()
  return
}

if ($path === '/api/orgs/members/upsert') {
  apiOrgMembersUpsert()
  return
}

if ($path === '/api/orgs/members/remove') {
  apiOrgMembersRemove()
  return
}

if ($path === '/api/packages/visibility') {
  apiPackageSetVisibility()
  return
}

if ($path === '/api/package') {
  apiPackageDetail()
  return
}

if ($path === '/api/org') {
  apiOrgDetail()
  return
}

if ($path === '/api/publish') {
  apiPublishPackage()
  return
}

if ($path === '/api/install') {
  apiInstallPackage()
  return
}

if ($path === repoIssueCreateRoute()) {
  apiRepoIssueCreate()
  return
}

if ($path === repoIssueCommentRoute()) {
  apiRepoIssueCommentCreate()
  return
}

if ($path === repoPullCreateRoute()) {
  apiRepoPullCreate()
  return
}

if ($path === repoPullCommentRoute()) {
  apiRepoPullCommentCreate()
  return
}

if ($path === repoForkRoute()) {
  apiRepoFork()
  return
}

if (strpos($path, '/api/artifacts/') === 0) {
  $canonical = substr($path, strlen('/api/artifacts/'))
  apiArtifactDownload($canonical)
  return
}

if ($path === '/api/dev/create-package') {
  apiCreateDemoPackage()
  return
}

if ($path === '/api/dev/bump-downloads') {
  apiBumpPackageDownloads()
  return
}


if ($path === '/auth/start') {
  $start = oauthBeginFlow()
  if (!$start['ok']) {
    header('Content-Type: application/json')
    header('X-Powered-By: linkha.sh')
    echo jsonReply($start)
    return
  }
  redirectTo($start['auth_url'])
  return
}

if (strpos($path, '/api/') === 0) {
  header('HTTP/1.1 404 Not Found')
  header('Content-Type: application/json')
  header('X-Powered-By: linkha.sh')
  header('X-Request-Id: ' . requestId())
  logEvent('warn', 'api.not_found', { route: '' . $path })
  echo jsonReply({
    ok: false,
    error: 'not found'
  })
  return
}

$title = 'linkha.sh - PHPX registry'
$viewer = authCurrentUser()
$viewerId = $viewer['ok'] ? (int) rowValue($viewer['user'], 'id', 0) : 0
$topPackages = []
$registryStats = []
$runtimeStats = []
$checks = []
$node = null
if (strpos($path, '/package/') === 0) {
  $parts = explode('/', trim($path, '/'))
  $org = count($parts) >= 2 ? $parts[1] : ''
  $pkg = count($parts) >= 3 ? $parts[2] : ''
  $auth = authWithScope(1)
  $detail = fetchPackageDetail($org, $pkg, $auth)
  $node = <PackageDetailPage ok={$detail['ok']} org={rowValue($detail, 'org', '')} package={rowValue($detail, 'package', [])} versions={rowValue($detail, 'versions', [])} docsSymbols={rowValue($detail, 'docsSymbols', [])} docsError={rowValue($detail, 'docsError', '')} treeEntries={rowValue($detail, 'treeEntries', [])} treeError={rowValue($detail, 'treeError', '')} selectedFile={rowValue($detail, 'selectedFile', '')} selectedFileContent={rowValue($detail, 'selectedFileContent', '')} selectedFileError={rowValue($detail, 'selectedFileError', '')} error={rowValue($detail, 'error', '')} />
} else if (strStartsWith($path, '/@')) {
  $preview = parsePreviewRepoPath($path)
  if ($preview !== null) {
    $resolved = fetchRepoRefResolution(rowValue($preview, 'owner', ''), rowValue($preview, 'repo', ''), rowValue($preview, 'ref', 'HEAD'))
    if (rowValue($resolved, 'ok', false)) {
      $value = rowValue($resolved, 'value', [])
      $owner = rowValue($preview, 'owner', '')
      $repo = rowValue($preview, 'repo', '')
      $ref = rowValue($preview, 'ref', '')
      $commit = '' . rowValue($value, 'commit', '')
      $shortCommit = '' . rowValue($value, 'shortCommit', (strlen($commit) > 12 ? substr($commit, 0, 12) : $commit))
      auditEvent(
        'repo.preview.resolve',
        [ 'ok' => true, 'kind' => 'anonymous' ],
        'ok',
        'repo',
        '@' . $owner . '/' . $repo,
        [ 'requestedRef' => $ref, 'commit' => $commit ]
      )
      $node = <Layout>
        <PreviewRouteSection ok={true} owner={$owner} repo={$repo} ref={$ref} shortCommit={$shortCommit} previewUrl={adwaPreviewUrl($owner, $repo, $commit)} editUrl={adwaEditUrl($owner, $repo, $commit)} />
      </Layout>
    } else {
      $owner = rowValue($preview, 'owner', '')
      $repo = rowValue($preview, 'repo', '')
      $ref = rowValue($preview, 'ref', '')
      auditEvent(
        'repo.preview.resolve',
        [ 'ok' => false, 'kind' => 'anonymous' ],
        'error',
        'repo',
        '@' . $owner . '/' . $repo,
        [ 'requestedRef' => $ref, 'error' => rowValue($resolved, 'error', 'resolve failed') ]
      )
      $node = <Layout>
        <PreviewRouteSection ok={false} owner={$owner} repo={$repo} ref={$ref} error={rowValue($resolved, 'error', 'resolve failed')} />
      </Layout>
    }
  } else {
    $alias = parseAliasPackagePath($path)
    if ($alias === null) {
      $node = <PackageDetailPage ok={false} org={''} package={[]} versions={[]} docsSymbols={[]} docsError={''} treeEntries={[]} treeError={''} selectedFile={''} selectedFileContent={''} selectedFileError={''} error={'invalid package route'} />
    } else {
      $auth = authWithScope(1)
      $detail = fetchPackageDetail($alias['org'], $alias['name'], $auth)
      if ($detail['ok'] && ('' . $alias['version']) !== '') {
        $picked = findVersionInRows(rowValue($detail, 'versions', []), $alias['version'])
        if ($picked === null) {
          $detail = [ 'ok' => false, 'error' => 'version not found' ]
        } else {
          $pkgDetail = rowValue($detail, 'package', [])
          $pkgDetail['latestVersion'] = '' . $alias['version']
          $detail['package'] = $pkgDetail
          $detail['versions'] = [$picked]
        }
      }
      $node = <PackageDetailPage ok={rowValue($detail, 'ok', false)} org={rowValue($detail, 'org', '')} package={rowValue($detail, 'package', [])} versions={rowValue($detail, 'versions', [])} docsSymbols={rowValue($detail, 'docsSymbols', [])} docsError={rowValue($detail, 'docsError', '')} treeEntries={rowValue($detail, 'treeEntries', [])} treeError={rowValue($detail, 'treeError', '')} selectedFile={rowValue($detail, 'selectedFile', '')} selectedFileContent={rowValue($detail, 'selectedFileContent', '')} selectedFileError={rowValue($detail, 'selectedFileError', '')} error={rowValue($detail, 'error', '')} />
    }
  }
} else if (strStartsWith($path, '/lh_')) {
  $cid = substr($path, 1)
  $auth = authWithScope(1)
  $resolved = fetchCanonicalTarget($cid, $auth)
  if (!rowValue($resolved, 'ok', false)) {
    $node = <PackageDetailPage ok={false} org={''} package={[]} versions={[]} docsSymbols={[]} docsError={''} treeEntries={[]} treeError={''} selectedFile={''} selectedFileContent={''} selectedFileError={''} error={rowValue($resolved, 'error', 'not found')} />
  } else {
    $target = rowValue($resolved, 'target', [])
    $detail = fetchPackageDetail(rowValue($target, 'org', ''), rowValue($target, 'name', ''), $auth)
    if ($detail['ok']) {
      $picked = findVersionInRows(rowValue($detail, 'versions', []), rowValue($target, 'version', ''))
      if ($picked !== null) {
        $pkgDetail = rowValue($detail, 'package', [])
        $pkgDetail['latestVersion'] = '' . rowValue($target, 'version', '')
        $detail['package'] = $pkgDetail
        $detail['versions'] = [$picked]
      }
    }
    $node = <PackageDetailPage ok={rowValue($detail, 'ok', false)} org={rowValue($detail, 'org', '')} package={rowValue($detail, 'package', [])} versions={rowValue($detail, 'versions', [])} docsSymbols={rowValue($detail, 'docsSymbols', [])} docsError={rowValue($detail, 'docsError', '')} treeEntries={rowValue($detail, 'treeEntries', [])} treeError={rowValue($detail, 'treeError', '')} selectedFile={rowValue($detail, 'selectedFile', '')} selectedFileContent={rowValue($detail, 'selectedFileContent', '')} selectedFileError={rowValue($detail, 'selectedFileError', '')} error={rowValue($detail, 'error', '')} />
  }
} else if (strpos($path, '/org/') === 0) {
  $parts = explode('/', trim($path, '/'))
  $org = count($parts) >= 2 ? $parts[1] : ''
  $auth = authWithScope(1)
  $detail = fetchOrgProfile($org, $auth)
  $node = <OrgProfilePage ok={$detail['ok']} org={rowValue($detail, 'org', [])} packages={rowValue($detail, 'packages', [])} error={rowValue($detail, 'error', '')} />
} else if ($path === '/playground') {
  $auth = authWithScope(1)
  $org = '' . queryValue('org', '')
  $pkg = '' . queryValue('name', '')
  $requestedVersion = '' . queryValue('version', 'latest')
  $error = ''
  $resolved = null
  $install = null
  $artifactUrl = ''
  $versions = []
  if ($org !== '' && $pkg !== '') {
    $detail = fetchPackageDetail($org, $pkg, $auth)
    if (!rowValue($detail, 'ok', false)) {
      $error = '' . rowValue($detail, 'error', 'resolve failed')
    } else {
      $versions = rowValue($detail, 'versions', [])
      $package = rowValue($detail, 'package', [])
      $effectiveVersion = ($requestedVersion === '' || $requestedVersion === 'latest')
        ? ('' . rowValue($package, 'latestVersion', ''))
        : $requestedVersion
      $picked = null
      foreach ($versions as $v) {
        if ('' . rowValue($v, 'version', '') === $effectiveVersion) {
          $picked = $v
          break
        }
      }
      if ($picked === null && is_array($versions) && count($versions) > 0) {
        $picked = $versions[0]
        $effectiveVersion = '' . rowValue($picked, 'version', $effectiveVersion)
      }
      if ($picked === null) {
        $error = 'no published versions found'
      } else {
        $cid = '' . rowValue($picked, 'canonicalId', rowValue($picked, 'canonical_id', ''))
        $artifactUrl = $cid === '' ? '' : ('/api/artifacts/' . $cid)
        $resolved = [
          'version' => $effectiveVersion,
          'description' => rowValue($package, 'description', ''),
          'visibility' => rowValue($package, 'visibility', 'public'),
          'canonicalId' => $cid,
          'artifactBackend' => rowValue($picked, 'artifactBackend', rowValue($picked, 'artifact_backend', 'local')),
          'artifactSizeBytes' => rowValue($picked, 'artifactSizeBytes', rowValue($picked, 'artifact_size_bytes', 0))
        ]
        $install = [
          'ok' => true,
          'org' => normalizeHandleName($org),
          'name' => normalizePackageName($pkg),
          'version' => $effectiveVersion,
          'canonicalId' => $cid,
          'downloadUrl' => $artifactUrl
        ]
        $requestedVersion = $effectiveVersion
      }
    }
  }
  $node = <PlaygroundPage org={$org} name={$pkg} version={$requestedVersion} error={$error} resolved={$resolved} install={$install} artifactUrl={$artifactUrl} versions={$versions} />
} else if ($path === '/fork/result') {
  $sourceOwner = '' . queryValue('source_owner', '')
  $sourceRepo = '' . queryValue('source_repo', '')
  $targetOwner = '' . queryValue('target_owner', '')
  $targetRepo = '' . queryValue('target_repo', '')
  $commit = '' . queryValue('commit', '')
  $short = strlen($commit) > 12 ? substr($commit, 0, 12) : $commit
  $cloneUrl = 'http://localhost:8508/' . $targetOwner . '/' . $targetRepo . '.git'
  $node = <Layout>
    <ForkResultSection
      sourceOwner={$sourceOwner}
      sourceRepo={$sourceRepo}
      targetOwner={$targetOwner}
      targetRepo={$targetRepo}
      shortCommit={$short}
      cloneCommand={'git clone ' . $cloneUrl}
      upstreamCommand={'cd ' . $targetRepo . ' && git remote add upstream http://localhost:8508/' . $sourceOwner . '/' . $sourceRepo . '.git'}
      previewUrl={'/@' . $targetOwner . '/' . $targetRepo . '/HEAD'}
      editUrl={adwaEditUrl($targetOwner, $targetRepo, $commit)}
      packageUrl={'/package/' . $targetOwner . '/' . $targetRepo}
    />
  </Layout>
} else if ($path === '/account') {
  $auth = authWithScope(1)
  if (!$auth['ok']) {
    $node = <AccountPage ok={false} />
  } else {
    $user = rowValue($auth, 'user', [])
    $notice = ''
    $newToken = ''
    $action = '' . queryValue('action', '')
    if ($action === 'create_pat') {
      $label = '' . queryValue('label', 'default')
      $scope = '' . queryValue('scope', 'read:write')
      $expires = (int) queryValue('expires_days', 30)
      $created = accountCreatePat($user, $label, $scope, $expires)
      if ($created['ok']) {
        $notice = 'token created'
        $newToken = '' . rowValue($created, 'token', '')
      } else {
        $notice = '' . rowValue($created, 'error', 'token create failed')
      }
    } else if ($action === 'revoke_pat') {
      $id = (int) queryValue('id', 0)
      $revoked = accountRevokePat($user, $id)
      $notice = $revoked['ok'] ? 'token revoked' : ('' . rowValue($revoked, 'error', 'token revoke failed'))
    } else if ($action === 'revoke_all_pat') {
      $all = accountRevokeAllPat($user)
      $notice = $all['ok'] ? 'all tokens revoked' : ('' . rowValue($all, 'error', 'token revoke failed'))
    }
    $node = <AccountPage
      ok={true}
      user={$user}
      notice={$notice}
      newToken={$newToken}
    />
  }
} else if ($path === '/runtime') {
  $checks = collectRuntimeChecks()
  $node = <RuntimeLab checks={$checks} />
} else if ($path === '/hmr-demo') {
  $node = <HmrDemo />
} else {
  $topPackages = fetchTopPackages(6, $viewerId)
  $registryStats = fetchRegistryStats()
  $statsResult = stats()
  $runtimeStats = result_is_ok($statsResult) ? $statsResult->value : []
  $node = <Home packages={$topPackages} stats={$runtimeStats} registryStats={$registryStats} />
}

if (isPartialRequest()) {
  echo renderPartialJson($node, $title)
  return
}
---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{$title}</title>
  </head>
  <body>
    <div id="app" dataLayout="registry">{$node}</div>
    <Hydration container="#app" layout="registry" />
  </body>
</html>
