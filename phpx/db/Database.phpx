import { connect as db_connect, close as db_close } from 'db/postgres'
import { result_ok, result_err, result_is_ok } from 'core/result'
import { selectMany, selectOne, insertOne, updateWhere, deleteWhere, loadRelation, transaction, eq, ilike, isNull, andWhere, orWhere, asc, desc, limit, offset } from '@/db'
import { meta } from '@/db/meta'

struct Database {
  $config: mixed
  $handle: int
  $client: mixed
}

function rowValue($row, $key, $fallback = null) {
  if (is_array($row) && array_key_exists($key, $row)) {
    return $row[$key]
  }
  if (is_object($row) && isset($row->{$key})) {
    return $row->{$key}
  }
  return $fallback
}

function orm($db: Database) {
  return $db->client
}

function makeClient($handle) {
  $m = meta()
  return { handle: (int) $handle, meta: $m, models: $m.models }
}

function clientSelectMany($client, $model, $where = null, $order = null, $limit = null, $offset = null, $includes = null) {
  return selectMany($client.handle, $client.meta, $model, $where, $order, $limit, $offset, $includes)
}

function clientSelectOne($client, $model, $where = null, $includes = null) {
  return selectOne($client.handle, $client.meta, $model, $where, $includes)
}

function clientInsertOne($client, $model, $row, $returning = false) {
  return insertOne($client.handle, $model, $row, $returning)
}

function clientUpdateWhere($client, $model, $where, $values, $returning = false) {
  return updateWhere($client.handle, $model, $where, $values, $returning)
}

function clientDeleteWhere($client, $model, $where, $returning = false) {
  return deleteWhere($client.handle, $model, $where, $returning)
}

function clientLoadRelation($client, $model, $row, $field) {
  return loadRelation($client.handle, $client.meta, $model, $row, $field)
}

function clientTransaction($client, $fn) {
  return transaction($client.handle, $fn)
}

export function connect($config) {
  $res = db_connect($config)

  if (!result_is_ok($res)) {
    return result_err($res->error)
  }

  return result_ok(Database {
    $config: $config,
    $handle: $res->value,
    $client: makeClient($res->value)
  })
}

export function close($db: Database) {
  return db_close($db->handle)
}

export function ping($db: Database) {
  $client = orm($db)
  $res = clientSelectMany($client, $client.models.LhOrg, null, null, limit(1))
  if (!result_is_ok($res)) {
    return $res
  }
  return result_ok([ 'ok' => 1 ])
}

export function findOrganizations($db: Database, $query: string): array {
  $client = orm($db)
  $term = trim('' . $query)
  if ($term === '') {
    $res = clientSelectMany($client, $client.models.LhOrg, null, asc('handle'), limit(20))
  } else {
    $res = clientSelectMany($client, $client.models.LhOrg, ilike('handle', '%' . $term . '%'), asc('handle'), limit(20))
  }
  if (!result_is_ok($res)) {
    return []
  }
  return $res->value
}

export function getOrganizationByHandle($db: Database, $handle: string) {
  $client = orm($db)
  $res = clientSelectOne($client, $client.models.LhOrg, ilike('handle', '' . $handle))
  if (!result_is_ok($res)) {
    return result_err($res->error)
  }
  return result_ok($res->value)
}

export function createOrganization($db: Database, $org) {
  $client = orm($db)
  $ins = clientInsertOne($client, $client.models.LhOrg, {
    handle: '' . $org['handle'],
    visibility: '' . ($org['visibility'] ?? 'public'),
    created_at: gmdate('c'),
    updated_at: gmdate('c')
  }, false)
  if (!result_is_ok($ins)) {
    return result_err($ins->error)
  }
  return getOrganizationByHandle($db, '' . $org['handle'])
}

export function findPackages($db: Database, $query: string): array {
  $client = orm($db)
  $term = trim('' . $query)
  $where = eq('visibility', 'public')
  if ($term !== '') {
    $where = andWhere(
      $where,
      orWhere(
        ilike('name', '%' . $term . '%'),
        ilike('description', '%' . $term . '%')
      )
    )
  }
  $res = clientSelectMany($client, $client.models.Package, $where, desc('download_count'), limit(20))
  if (!result_is_ok($res)) {
    return []
  }
  return $res->value
}

export function getPackage($db: Database, $org: string, $name: string) {
  $client = orm($db)
  $orgRes = clientSelectOne($client, $client.models.LhOrg, ilike('handle', '' . $org))
  if (!result_is_ok($orgRes)) {
    return result_err($orgRes->error)
  }
  $orgId = (int) ($orgRes->value['id'] ?? 0)
  $pkg = clientSelectOne($client, 
    $client.models.Package,
    andWhere(
      eq('org_id', $orgId),
      ilike('name', '' . $name)
    )
  )
  if (!result_is_ok($pkg)) {
    return result_err($pkg->error)
  }
  return result_ok($pkg->value)
}

export function createPackage($db: Database, $pkg) {
  $client = orm($db)
  $ins = clientInsertOne($client, 
    $client.models.Package,
    {
      org_id: (int) $pkg['orgId'],
      name: '' . $pkg['name'],
      description: '' . ($pkg['description'] ?? ''),
      latest_version: '' . ($pkg['latestVersion'] ?? '0.0.0'),
      download_count: (int) ($pkg['downloadCount'] ?? 0),
      visibility: '' . ($pkg['visibility'] ?? 'public'),
      private_read_mask: (int) ($pkg['privateReadMask'] ?? 0),
      created_at: gmdate('c'),
      updated_at: gmdate('c')
    },
    false
  )
  if (!result_is_ok($ins)) {
    return result_err($ins->error)
  }
  return result_ok($ins->value)
}

export function getPackageVersions($db: Database, $packageId: int): array {
  $client = orm($db)
  $res = clientSelectMany($client, 
    $client.models.PackageVersion,
    eq('package_id', (int) $packageId),
    desc('published_at')
  )
  if (!result_is_ok($res)) {
    return []
  }
  return $res->value
}

export function getPackageVersion($db: Database, $packageId: int, $version: string) {
  $client = orm($db)
  $res = clientSelectOne($client, 
    $client.models.PackageVersion,
    andWhere(
      eq('package_id', (int) $packageId),
      eq('version', '' . $version)
    )
  )
  if (!result_is_ok($res)) {
    return result_err($res->error)
  }
  return result_ok($res->value)
}

export function createPackageVersion($db: Database, $version) {
  $client = orm($db)
  $ins = clientInsertOne($client, 
    $client.models.PackageVersion,
    {
      package_id: (int) $version['packageId'],
      version: '' . $version['version'],
      main_file: '' . $version['mainFile'],
      files: $version['files'] ?? [],
      dependencies: $version['dependencies'] ?? [],
      readme: '' . ($version['readme'] ?? ''),
      published_at: gmdate('c'),
      r2_key: '' . ($version['r2Key'] ?? ''),
      sha256: '' . ($version['sha256'] ?? ''),
      canonical_id: '' . ($version['canonicalId'] ?? ''),
      lock_hash: '' . ($version['lockHash'] ?? ''),
      integrity_algo: '' . ($version['integrityAlgo'] ?? ''),
      module_graph_hash: '' . ($version['moduleGraphHash'] ?? ''),
      fs_graph_hash: '' . ($version['fsGraphHash'] ?? ''),
      artifact_backend: '' . ($version['artifactBackend'] ?? 'local'),
      artifact_key: '' . ($version['artifactKey'] ?? ''),
      artifact_mime: '' . ($version['artifactMime'] ?? 'application/octet-stream'),
      artifact_size_bytes: (int) ($version['artifactSizeBytes'] ?? 0),
      artifact_inline_b64: '' . ($version['artifactInlineB64'] ?? ''),
      capability_metadata: $version['capabilityMetadata'] ?? null
    },
    false
  )
  if (!result_is_ok($ins)) {
    return result_err($ins->error)
  }
  return result_ok($ins->value)
}

export function recordDownload($db: Database, $download) {
  $client = orm($db)
  $res = clientInsertOne($client, 
    $client.models.Download,
    {
      package_id: (int) $download['packageId'],
      version_id: (int) $download['versionId'],
      downloaded_at: gmdate('c'),
      ip_address: '' . ($download['ipAddress'] ?? ''),
      user_agent: '' . ($download['userAgent'] ?? '')
    },
    false
  )
  if (!result_is_ok($res)) {
    return result_err($res->error)
  }
  return result_ok($res->value)
}

export function upsertUserByDid($db: Database, $did: string, $handle: string, $displayName = null, $avatarUrl = null) {
  $client = orm($db)
  $existing = clientSelectOne($client, $client.models.LhUser, eq('did', '' . $did))
  if (result_is_ok($existing)) {
    $update = clientUpdateWhere($client, 
      $client.models.LhUser,
      eq('id', (int) rowValue($existing->value, 'id', 0)),
      {
        handle: '' . $handle,
        display_name: '' . ($displayName ?? ''),
        avatar_url: '' . ($avatarUrl ?? ''),
        updated_at: gmdate('c')
      },
      false
    )
    if (!result_is_ok($update)) {
      return result_err($update->error)
    }
    return result_ok($existing->value)
  }
  $ins = clientInsertOne($client, 
    $client.models.LhUser,
    {
      did: '' . $did,
      handle: '' . $handle,
      display_name: '' . ($displayName ?? ''),
      avatar_url: '' . ($avatarUrl ?? '')
    },
    false
  )
  if (!result_is_ok($ins)) {
    return result_err($ins->error)
  }
  return result_ok($ins->value)
}

export function createSession($db: Database, $userId: int, $sessionTokenHash: string, $expiresAt: string, $ipAddress = null, $userAgent = null) {
  $client = orm($db)
  $res = clientInsertOne($client, 
    $client.models.LhSession,
    {
      user_id: (int) $userId,
      session_token_hash: '' . $sessionTokenHash,
      csrf_token_hash: '',
      ip_address: '' . ($ipAddress ?? ''),
      user_agent: '' . ($userAgent ?? ''),
      last_seen_at: gmdate('c'),
      expires_at: '' . $expiresAt,
      created_at: gmdate('c')
    },
    false
  )
  if (!result_is_ok($res)) {
    return result_err($res->error)
  }
  return result_ok($res->value)
}

export function createApiToken($db: Database, $userId: int, $tokenPrefix: string, $tokenHash: string, $scopeMask: int, $label = null, $expiresAt = null) {
  $client = orm($db)
  $res = clientInsertOne($client, 
    $client.models.LhApiToken,
    {
      user_id: (int) $userId,
      token_prefix: '' . $tokenPrefix,
      token_hash: '' . $tokenHash,
      scope_mask: (int) $scopeMask,
      label: '' . ($label ?? ''),
      expires_at: $expiresAt === null ? null : ('' . $expiresAt),
      created_at: gmdate('c')
    },
    false
  )
  if (!result_is_ok($res)) {
    return result_err($res->error)
  }
  return result_ok($res->value)
}

export function getPopularPackages($db: Database, $limit: int = 10): array {
  $client = orm($db)
  $res = clientSelectMany($client, $client.models.Package, null, desc('download_count'), limit((int) $limit))
  if (!result_is_ok($res)) {
    return []
  }
  return $res->value
}

export function searchPackages($db: Database, $query: string): array {
  return findPackages($db, $query)
}
