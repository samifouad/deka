use std::collections::{HashMap, HashSet};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{bail, Context, Result};
use wit_parser::{
    Function, FunctionKind, Resolve, Results, Type, TypeDefKind, TypeId, World, WorldItem, WorldKey,
};

#[derive(Debug, Clone, Copy)]
enum RecordMode {
    Struct,
    Object,
}

#[derive(Debug)]
struct Args {
    input: PathBuf,
    output: PathBuf,
    world: Option<String>,
    record_mode: RecordMode,
    interface_prefix: bool,
}

fn main() -> Result<()> {
    let args = parse_args()?;

    let mut resolve = Resolve::default();
    let (pkg, _) = resolve
        .push_path(&args.input)
        .with_context(|| format!("failed to load WIT from {}", args.input.display()))?;
    let world_id = resolve
        .select_world(pkg, args.world.as_deref())
        .context("failed to select world")?;
    let world = &resolve.worlds[world_id];

    let output = emit_stub(&resolve, world, &args)?;
    if let Some(parent) = args.output.parent() {
        if !parent.as_os_str().is_empty() {
            fs::create_dir_all(parent).with_context(|| {
                format!("failed to create output directory {}", parent.display())
            })?;
        }
    }
    fs::write(&args.output, output)
        .with_context(|| format!("failed to write {}", args.output.display()))?;

    println!("Wrote {}", args.output.display());
    Ok(())
}

fn parse_args() -> Result<Args> {
    let mut input: Option<PathBuf> = None;
    let mut output: Option<PathBuf> = None;
    let mut world: Option<String> = None;
    let mut record_mode = RecordMode::Struct;
    let mut interface_prefix = true;

    let mut args = env::args().skip(1);
    while let Some(arg) = args.next() {
        match arg.as_str() {
            "-h" | "--help" => {
                print_usage();
                std::process::exit(0);
            }
            "--out" => {
                let value = args.next().context("--out expects a path")?;
                output = Some(PathBuf::from(value));
            }
            "--world" => {
                let value = args.next().context("--world expects a name")?;
                world = Some(value);
            }
            "--records" => {
                let value = args.next().context("--records expects struct|object")?;
                record_mode = match value.as_str() {
                    "struct" => RecordMode::Struct,
                    "object" => RecordMode::Object,
                    _ => bail!("--records expects struct|object"),
                };
            }
            "--no-interface-prefix" => {
                interface_prefix = false;
            }
            _ => {
                if input.is_none() {
                    input = Some(PathBuf::from(arg));
                } else {
                    bail!("unexpected argument: {arg}");
                }
            }
        }
    }

    let input = input.context("missing input .wit file")?;
    let output = match output {
        Some(path) => path,
        None => default_output_path(&input),
    };

    Ok(Args {
        input,
        output,
        world,
        record_mode,
        interface_prefix,
    })
}

fn print_usage() {
    eprintln!(
        "Usage: wit-phpx <module.wit> [--out path] [--world name] [--records struct|object] [--no-interface-prefix]"
    );
}

fn default_output_path(input: &Path) -> PathBuf {
    let mut path = input.to_path_buf();
    let file_name = match input.file_name().and_then(|n| n.to_str()) {
        Some(name) => name,
        None => return path,
    };
    if let Some(base) = file_name.strip_suffix(".wit") {
        path.set_file_name(format!("{base}.d.phpx"));
        return path;
    }
    path.set_file_name(format!("{file_name}.d.phpx"));
    path
}

fn emit_stub(resolve: &Resolve, world: &World, args: &Args) -> Result<String> {
    let mut type_names = collect_type_names(resolve, world, args.interface_prefix);
    let exported_types =
        collect_exported_types(resolve, world, &mut type_names, args.interface_prefix);

    let mut out = String::new();
    out.push_str("<?php\n");
    out.push_str("// Generated by wit-phpx. Do not edit by hand.\n");
    out.push_str("// This file is for PHPX tooling only (type stubs).\n");
    out.push_str(&format!("// World: {}\n", world.name));
    out.push_str(&format!(
        "// Records: {}\n\n",
        match args.record_mode {
            RecordMode::Struct => "struct",
            RecordMode::Object => "object",
        }
    ));

    emit_type_defs(
        resolve,
        &exported_types,
        args.record_mode,
        &type_names,
        &mut out,
    );
    emit_function_decls(resolve, world, args.interface_prefix, &type_names, &mut out);

    Ok(out)
}

fn collect_type_names(
    resolve: &Resolve,
    world: &World,
    interface_prefix: bool,
) -> HashMap<TypeId, String> {
    let mut names = HashMap::new();

    for (key, item) in world.exports.iter() {
        if let WorldItem::Interface { id, .. } = item {
            let iface_name = world_key_name(key);
            let prefix = if interface_prefix {
                to_pascal_case(&iface_name)
            } else {
                String::new()
            };
            let iface = &resolve.interfaces[*id];
            for (type_name, type_id) in iface.types.iter() {
                let local = to_pascal_case(type_name);
                let final_name = if prefix.is_empty() {
                    local
                } else {
                    format!("{prefix}{local}")
                };
                names.insert(*type_id, final_name);
            }
        }
    }

    names
}

fn collect_exported_types(
    resolve: &Resolve,
    world: &World,
    type_names: &mut HashMap<TypeId, String>,
    interface_prefix: bool,
) -> HashSet<TypeId> {
    let mut exported = HashSet::new();

    for (key, item) in world.exports.iter() {
        match item {
            WorldItem::Type(type_id) => {
                let name = world_key_name(key);
                let name = to_pascal_case(&name);
                type_names.entry(*type_id).or_insert(name);
                exported.insert(*type_id);
            }
            WorldItem::Interface { id, .. } => {
                let iface = &resolve.interfaces[*id];
                let iface_name = world_key_name(key);
                let prefix = if interface_prefix {
                    to_pascal_case(&iface_name)
                } else {
                    String::new()
                };
                for (type_name, type_id) in iface.types.iter() {
                    let local = to_pascal_case(type_name);
                    let final_name = if prefix.is_empty() {
                        local
                    } else {
                        format!("{prefix}{local}")
                    };
                    type_names.entry(*type_id).or_insert(final_name);
                    exported.insert(*type_id);
                }
            }
            _ => {}
        }
    }

    exported
}

fn emit_type_defs(
    resolve: &Resolve,
    exported_types: &HashSet<TypeId>,
    record_mode: RecordMode,
    type_names: &HashMap<TypeId, String>,
    out: &mut String,
) {
    for (type_id, type_def) in resolve.types.iter() {
        if !exported_types.contains(&type_id) {
            continue;
        }
        let name = type_names
            .get(&type_id)
            .cloned()
            .unwrap_or_else(|| format!("Type{}", type_id.index()));

        match &type_def.kind {
            TypeDefKind::Record(record) => match record_mode {
                RecordMode::Struct => {
                    out.push_str(&format!("struct {} {{\n", name));
                    for field in record.fields.iter() {
                        let field_name = sanitize_ident(&field.name);
                        let field_type = render_type(resolve, &field.ty, type_names);
                        out.push_str(&format!("    ${}: {};\n", field_name, field_type));
                    }
                    out.push_str("}\n\n");
                }
                RecordMode::Object => {
                    let mut fields = Vec::new();
                    for field in record.fields.iter() {
                        let field_name = sanitize_ident(&field.name);
                        let field_type = render_type(resolve, &field.ty, type_names);
                        fields.push(format!("{}: {}", field_name, field_type));
                    }
                    let body = fields.join(", ");
                    out.push_str(&format!(
                        "export type {} = Object<{{ {} }}>;\n\n",
                        name, body
                    ));
                }
            },
            TypeDefKind::Enum(enm) => {
                let cases = enm
                    .cases
                    .iter()
                    .map(|c| sanitize_ident(&c.name))
                    .collect::<Vec<_>>()
                    .join(" | ");
                out.push_str(&format!(
                    "export type {} = string; // enum: {}\n\n",
                    name, cases
                ));
            }
            TypeDefKind::Flags(flags) => {
                let cases = flags
                    .flags
                    .iter()
                    .map(|c| sanitize_ident(&c.name))
                    .collect::<Vec<_>>()
                    .join(", ");
                out.push_str(&format!(
                    "export type {} = array<string>; // flags: {}\n\n",
                    name, cases
                ));
            }
            TypeDefKind::Variant(variant) => {
                let cases = variant
                    .cases
                    .iter()
                    .map(|c| sanitize_ident(&c.name))
                    .collect::<Vec<_>>()
                    .join(" | ");
                out.push_str(&format!(
                    "export type {} = mixed; // variant: {}\n\n",
                    name, cases
                ));
            }
            TypeDefKind::Tuple(tuple) => {
                let items = tuple
                    .types
                    .iter()
                    .map(|t| render_type(resolve, t, type_names))
                    .collect::<Vec<_>>()
                    .join(", ");
                out.push_str(&format!(
                    "export type {} = array; // tuple: [{}]\n\n",
                    name, items
                ));
            }
            TypeDefKind::Option(inner) => {
                let inner_ty = render_type(resolve, inner, type_names);
                out.push_str(&format!("export type {} = {}|null;\n\n", name, inner_ty));
            }
            TypeDefKind::Result(res) => {
                let ok = res
                    .ok
                    .as_ref()
                    .map(|t| render_type(resolve, t, type_names))
                    .unwrap_or_else(|| "mixed".to_string());
                let err = res
                    .err
                    .as_ref()
                    .map(|t| render_type(resolve, t, type_names))
                    .unwrap_or_else(|| "mixed".to_string());
                out.push_str(&format!(
                    "export type {} = Result<{}, {}>;\n\n",
                    name, ok, err
                ));
            }
            TypeDefKind::List(inner) => {
                let inner_ty = render_type(resolve, inner, type_names);
                out.push_str(&format!("export type {} = array<{}>;\n\n", name, inner_ty));
            }
            TypeDefKind::Type(inner) => {
                let inner_ty = render_type(resolve, inner, type_names);
                out.push_str(&format!("export type {} = {};\n\n", name, inner_ty));
            }
            TypeDefKind::Resource
            | TypeDefKind::Handle(_)
            | TypeDefKind::Future(_)
            | TypeDefKind::Stream(_)
            | TypeDefKind::Unknown => {
                out.push_str(&format!(
                    "export type {} = mixed; // unsupported WIT kind\n\n",
                    name
                ));
            }
        }
    }
}

fn emit_function_decls(
    resolve: &Resolve,
    world: &World,
    interface_prefix: bool,
    type_names: &HashMap<TypeId, String>,
    out: &mut String,
) {
    for (key, item) in world.exports.iter() {
        match item {
            WorldItem::Function(func) => {
                emit_function(resolve, None, func, type_names, out);
            }
            WorldItem::Interface { id, .. } => {
                let iface = &resolve.interfaces[*id];
                let iface_name = world_key_name(key);
                let prefix = if interface_prefix {
                    Some(format!("{}__", to_snake_case(&iface_name)))
                } else {
                    None
                };
                for func in iface.functions.values() {
                    emit_function(resolve, prefix.as_deref(), func, type_names, out);
                }
            }
            WorldItem::Type(_) => {}
        }
    }
}

fn emit_function(
    resolve: &Resolve,
    prefix: Option<&str>,
    func: &Function,
    type_names: &HashMap<TypeId, String>,
    out: &mut String,
) {
    if !matches!(func.kind, FunctionKind::Freestanding) {
        out.push_str("// NOTE: resource methods are not supported yet.\n");
    }

    let mut params = Vec::new();
    for (name, ty) in func.params.iter() {
        let param_name = sanitize_ident(name);
        let param_type = render_type(resolve, ty, type_names);
        params.push(format!("{} ${}", param_type, param_name));
    }

    let return_type = match &func.results {
        Results::Anon(ty) => render_type(resolve, ty, type_names),
        Results::Named(named) => {
            if named.is_empty() {
                "void".to_string()
            } else if named.len() == 1 {
                render_type(resolve, &named[0].1, type_names)
            } else {
                let fields = named
                    .iter()
                    .map(|(name, ty)| {
                        format!(
                            "{}: {}",
                            sanitize_ident(name),
                            render_type(resolve, ty, type_names)
                        )
                    })
                    .collect::<Vec<_>>()
                    .join(", ");
                out.push_str(&format!("// returns {{ {} }}\n", fields));
                "array".to_string()
            }
        }
    };

    let func_name = sanitize_ident(&func.name);
    let name = match prefix {
        Some(prefix) => format!("{}{}", prefix, func_name),
        None => func_name,
    };

    out.push_str(&format!(
        "export function {}({}): {};\n\n",
        name,
        params.join(", "),
        return_type
    ));
}

fn render_type(resolve: &Resolve, ty: &Type, type_names: &HashMap<TypeId, String>) -> String {
    match ty {
        Type::Bool => "bool".to_string(),
        Type::U8 => "byte".to_string(),
        Type::U16 | Type::U32 | Type::U64 | Type::S8 | Type::S16 | Type::S32 | Type::S64 => {
            "int".to_string()
        }
        Type::F32 | Type::F64 => "float".to_string(),
        Type::Char | Type::String => "string".to_string(),
        Type::Id(id) => lookup_type_name(resolve, *id, type_names),
    }
}

fn lookup_type_name(resolve: &Resolve, id: TypeId, type_names: &HashMap<TypeId, String>) -> String {
    if let Some(name) = type_names.get(&id) {
        return name.clone();
    }
    if let Some(name) = &resolve.types[id].name {
        return to_pascal_case(name);
    }
    format!("Type{}", id.index())
}

fn world_key_name(key: &WorldKey) -> String {
    match key {
        WorldKey::Name(name) => name.clone(),
        WorldKey::Interface(id) => format!("interface_{}", id.index()),
    }
}

fn sanitize_ident(name: &str) -> String {
    let mut out = String::new();
    for ch in name.chars() {
        let mapped = match ch {
            'a'..='z' | 'A'..='Z' | '0'..='9' | '_' => ch,
            '-' => '_',
            _ => '_',
        };
        out.push(mapped);
    }
    if out.is_empty() {
        out.push('_');
    }
    if out
        .chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
    {
        out.insert(0, '_');
    }
    out
}

fn to_pascal_case(name: &str) -> String {
    let mut out = String::new();
    for part in name.split(|c: char| c == '-' || c == '_' || c == ' ' || c == '.') {
        if part.is_empty() {
            continue;
        }
        let mut chars = part.chars();
        if let Some(first) = chars.next() {
            out.push(first.to_ascii_uppercase());
            out.push_str(&chars.as_str().to_ascii_lowercase());
        }
    }
    if out.is_empty() {
        out.push_str("Type");
    }
    if out
        .chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
    {
        out.insert(0, '_');
    }
    out
}

fn to_snake_case(name: &str) -> String {
    let mut out = String::new();
    for ch in name.chars() {
        match ch {
            'a'..='z' | '0'..='9' => out.push(ch),
            'A'..='Z' => {
                out.push(ch.to_ascii_lowercase());
            }
            '-' | ' ' | '.' => out.push('_'),
            '_' => out.push('_'),
            _ => out.push('_'),
        }
    }
    if out.is_empty() {
        out.push('_');
    }
    if out
        .chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
    {
        out.insert(0, '_');
    }
    out
}
