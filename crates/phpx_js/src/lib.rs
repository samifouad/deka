use bumpalo::Bump;
use modules_php::compiler_api::{compile_phpx, compile_phpx_internal};
use modules_php::validation::format_multiple_errors;
use php_rs::parser::ast::{
    BinaryOp, ClassKind, ClassMember, Expr, ExprId, JsxChild, ObjectKey, Program, Stmt, StmtId,
    Type as AstType, UnaryOp,
};
use std::collections::HashSet;
use std::path::Path;

pub fn compile_phpx_source_to_js(
    source: &str,
    input: &str,
    meta: SourceModuleMeta,
) -> Result<String, String> {
    let arena = Bump::new();
    let path = Path::new(input);
    let result = if is_internal_phpx_path(path) {
        compile_phpx_internal(source, input, &arena)
    } else {
        compile_phpx(source, input, &arena)
    };
    if !result.errors.is_empty() {
        let formatted = format_multiple_errors(source, input, &result.errors, &result.warnings);
        return Err(formatted);
    }

    let js = if let Some(program) = result.ast {
        match emit_js_from_ast(&program, source.as_bytes(), meta) {
            Ok(emitted) => emitted,
            Err(reason) => emit_js_scaffold_with_reason(source, input, &reason),
        }
    } else {
        emit_js_scaffold_with_reason(source, input, "no AST available after validation")
    };

    Ok(js)
}

fn is_internal_phpx_path(path: &Path) -> bool {
    let normalized = path.to_string_lossy().replace('\\', "/");
    normalized.starts_with("php_modules/")
        || normalized.contains("/php_modules/")
}

pub fn emit_js_from_ast(
    program: &Program<'_>,
    source: &[u8],
    meta: SourceModuleMeta,
) -> Result<String, String> {
    let mut emitter = JsSubsetEmitter::new(source, meta);
    emitter.emit_program(program)?;
    Ok(emitter.finish())
}

pub fn emit_js_scaffold_with_reason(source: &str, file_path: &str, reason: &str) -> String {
    let escaped = serde_json::to_string(source).unwrap_or_else(|_| "\"\"".to_string());
    let escaped_path =
        serde_json::to_string(file_path).unwrap_or_else(|_| "\"unknown.phpx\"".to_string());
    let escaped_reason =
        serde_json::to_string(reason).unwrap_or_else(|_| "\"unknown\"".to_string());

    format!(
        "// Generated by deka build. Do not edit manually.\n\
// Source: {file_path}\n\
// Target semantics: JavaScript runtime semantics.\n\
// Fallback scaffold used because subset emitter could not lower this file.\n\
export const phpxBuildMode = \"scaffold\";\n\
export const phpxTargetSemantics = \"js\";\n\
export const phpxBuildReason = {escaped_reason};\n\
export const phpxSource = {escaped};\n\
export const phpxFile = {escaped_path};\n\
\n\
export async function runPhpx(runtime, props = {{}}) {{\n\
  if (!runtime || typeof runtime.executePhpx !== 'function') {{\n\
    throw new Error('runtime.executePhpx(source, file, props) is required');\n\
  }}\n\
  return await runtime.executePhpx(phpxSource, phpxFile, props);\n\
}}\n",
    )
}

#[derive(Debug, Clone)]
pub struct ImportSpec {
    pub imported: String,
    pub local: String,
}

#[derive(Debug, Clone)]
pub struct ImportDecl {
    pub from: String,
    pub specs: Vec<ImportSpec>,
}

#[derive(Debug, Clone)]
pub struct SourceModuleMeta {
    pub imports: Vec<ImportDecl>,
    pub exported_functions: HashSet<String>,
    pub export_specs: Vec<ImportSpec>,
}

impl SourceModuleMeta {
    pub fn empty() -> Self {
        Self {
            imports: Vec::new(),
            exported_functions: HashSet::new(),
            export_specs: Vec::new(),
        }
    }
}

pub fn parse_source_module_meta(source: &str) -> SourceModuleMeta {
    let mut meta = SourceModuleMeta::empty();
    let lines: Vec<&str> = source.lines().collect();
    let (start, end) = frontmatter_range(&lines).unwrap_or((0, lines.len()));

    for line in &lines[start..end] {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("//") {
            continue;
        }

        if let Some(decl) = parse_import_line(trimmed) {
            meta.imports.push(decl);
            continue;
        }

        if let Some(name) = parse_export_function_line(trimmed) {
            meta.exported_functions.insert(name);
            continue;
        }

        if let Some(specs) = parse_export_specs_line(trimmed) {
            meta.export_specs.extend(specs);
        }
    }

    meta
}

fn frontmatter_range(lines: &[&str]) -> Option<(usize, usize)> {
    let mut first = None;
    let mut second = None;
    for (idx, line) in lines.iter().enumerate() {
        if line.trim() == "---" {
            if first.is_none() {
                first = Some(idx);
            } else {
                second = Some(idx);
                break;
            }
        }
    }
    match (first, second) {
        (Some(a), Some(b)) if b > a => Some((a + 1, b)),
        _ => None,
    }
}

fn parse_import_line(line: &str) -> Option<ImportDecl> {
    let trimmed = line.trim_end_matches(';').trim();
    if !trimmed.starts_with("import ") {
        return None;
    }
    let open = trimmed.find('{')?;
    let close = trimmed[open..].find('}')? + open;
    let from_pos = trimmed[close + 1..].find("from")? + close + 1;

    let inside = trimmed[open + 1..close].trim();
    let from_part = trimmed[from_pos + 4..].trim();
    let module = unquote(from_part)?;

    let mut specs = Vec::new();
    for chunk in inside.split(',') {
        let part = chunk.trim();
        if part.is_empty() {
            continue;
        }
        if let Some(as_pos) = part.find(" as ") {
            let imported = part[..as_pos].trim();
            let local = part[as_pos + 4..].trim();
            if !imported.is_empty() && !local.is_empty() {
                specs.push(ImportSpec {
                    imported: imported.to_string(),
                    local: local.to_string(),
                });
            }
        } else {
            specs.push(ImportSpec {
                imported: part.to_string(),
                local: part.to_string(),
            });
        }
    }

    if specs.is_empty() {
        return None;
    }

    Some(ImportDecl {
        from: module.to_string(),
        specs,
    })
}

fn parse_export_function_line(line: &str) -> Option<String> {
    let trimmed = line.trim_start();
    if !trimmed.starts_with("export function ") {
        return None;
    }
    let rest = &trimmed[16..];
    let name = rest.split('(').next()?.trim();
    if name.is_empty() {
        return None;
    }
    Some(name.to_string())
}

fn parse_export_specs_line(line: &str) -> Option<Vec<ImportSpec>> {
    let trimmed = line.trim_end_matches(';').trim();
    if !trimmed.starts_with("export {") || !trimmed.ends_with('}') {
        return None;
    }
    let inner = &trimmed[8..trimmed.len() - 1];
    let mut specs = Vec::new();
    for chunk in inner.split(',') {
        let part = chunk.trim();
        if part.is_empty() {
            continue;
        }
        if let Some(as_pos) = part.find(" as ") {
            let local = part[..as_pos].trim();
            let exported = part[as_pos + 4..].trim();
            if !local.is_empty() && !exported.is_empty() {
                specs.push(ImportSpec {
                    imported: exported.to_string(),
                    local: local.to_string(),
                });
            }
        } else {
            specs.push(ImportSpec {
                imported: part.to_string(),
                local: part.to_string(),
            });
        }
    }
    Some(specs)
}

fn unquote(input: &str) -> Option<&str> {
    let s = input.trim();
    if s.len() < 2 {
        return None;
    }
    let first = s.as_bytes()[0] as char;
    let last = s.as_bytes()[s.len() - 1] as char;
    if (first == '\'' && last == '\'') || (first == '"' && last == '"') {
        Some(&s[1..s.len() - 1])
    } else {
        None
    }
}

struct JsSubsetEmitter<'a> {
    source: &'a [u8],
    body: String,
    uses_jsx_runtime: bool,
    uses_include_stub: bool,
    scopes: Vec<HashSet<String>>,
    meta: SourceModuleMeta,
    struct_schemas: Vec<(String, String)>,
}

impl<'a> JsSubsetEmitter<'a> {
    fn new(source: &'a [u8], meta: SourceModuleMeta) -> Self {
        Self {
            source,
            body: String::new(),
            uses_jsx_runtime: false,
            uses_include_stub: false,
            scopes: vec![HashSet::new()],
            meta,
            struct_schemas: Vec::new(),
        }
    }

    fn finish(self) -> String {
        let mut out = String::new();
        out.push_str("// Generated by deka build. Do not edit manually.\n");
        out.push_str("// Target semantics: JavaScript runtime semantics.\n");
        out.push_str("export const phpxBuildMode = \"subset-ast\";\n");
        out.push_str("export const phpxTargetSemantics = \"js\";\n\n");

        let mut imports = self.meta.imports.clone();
        if self.uses_jsx_runtime {
            add_or_merge_import(
                &mut imports,
                "component/core",
                vec![
                    ImportSpec {
                        imported: "jsx".to_string(),
                        local: "jsx".to_string(),
                    },
                    ImportSpec {
                        imported: "jsxs".to_string(),
                        local: "jsxs".to_string(),
                    },
                ],
            );
        }
        let deka_i_locals = extract_deka_i_imports(&mut imports);

        for decl in &imports {
            out.push_str("import { ");
            for (idx, spec) in decl.specs.iter().enumerate() {
                if idx > 0 {
                    out.push_str(", ");
                }
                if spec.imported == spec.local {
                    out.push_str(&spec.local);
                } else {
                    out.push_str(&format!("{} as {}", spec.imported, spec.local));
                }
            }
            out.push_str(&format!(" }} from '{}';\n", decl.from));
        }

        if !imports.is_empty() {
            out.push('\n');
        }

        if !deka_i_locals.is_empty() {
            out.push_str("const __phpxTypeRegistry = {};\n\n");
            for (name, schema) in &self.struct_schemas {
                out.push_str(&format!(
                    "__phpxTypeRegistry[{}] = {};\n",
                    json_string(name),
                    schema
                ));
            }
            out.push('\n');
            out.push_str(&emit_deka_i_runtime());
            for local in &deka_i_locals {
                out.push_str(&format!("const {} = __deka_i;\n", local));
            }
            out.push('\n');
        }

        if self.uses_include_stub {
            out.push_str("function __phpx_include(path, kind) {\n");
            out.push_str("  throw new Error(`include/require not supported in JS subset emitter: ${kind} ${path}`);\n");
            out.push_str("}\n\n");
        }

        out.push_str(&self.body);

        if !self.meta.export_specs.is_empty() {
            out.push('\n');
            out.push_str("export { ");
            for (idx, spec) in self.meta.export_specs.iter().enumerate() {
                if idx > 0 {
                    out.push_str(", ");
                }
                if spec.imported == spec.local {
                    out.push_str(&spec.local);
                } else {
                    out.push_str(&format!("{} as {}", spec.local, spec.imported));
                }
            }
            out.push_str(" };\n");
        }

        out
    }

    fn emit_program(&mut self, program: &Program<'_>) -> Result<(), String> {
        for stmt in program.statements {
            self.emit_stmt(*stmt)?;
        }
        Ok(())
    }

    fn emit_stmt(&mut self, stmt: StmtId<'_>) -> Result<(), String> {
        match stmt {
            Stmt::Namespace { .. } => {
                Err("namespace declarations are not supported in JS subset emitter".to_string())
            }
            Stmt::Use { .. } => {
                Err("use declarations are not supported in JS subset emitter".to_string())
            }
            Stmt::Class {
                kind: ClassKind::Struct,
                name,
                members,
                ..
            } => {
                let schema = self.emit_struct_schema(*members);
                self.struct_schemas.push((self.token_name(name), schema));
                Ok(())
            }
            Stmt::Class { .. }
            | Stmt::Trait { .. }
            | Stmt::Interface { .. }
            | Stmt::Enum { .. } => {
                Err("class-like declarations are not supported in JS subset emitter".to_string())
            }
            Stmt::TypeAlias { .. } => {
                Err("type aliases are not supported in JS subset emitter".to_string())
            }
            Stmt::Error { .. } => {
                Err("parser error statement reached JS subset emitter".to_string())
            }
            Stmt::Function {
                name, params, body, ..
            } => {
                let fn_name = self.token_name(name);
                let js_params = params
                    .iter()
                    .map(|p| self.token_name(p.name))
                    .collect::<Vec<_>>()
                    .join(", ");

                let exported =
                    self.scopes.len() == 1 && self.meta.exported_functions.contains(&fn_name);
                if exported {
                    self.body
                        .push_str(&format!("export function {}({}) {{\n", fn_name, js_params));
                } else {
                    self.body
                        .push_str(&format!("function {}({}) {{\n", fn_name, js_params));
                }

                self.push_scope();
                for p in *params {
                    self.declare_in_scope(&self.token_name(p.name));
                }
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();

                self.body.push_str("}\n\n");
                Ok(())
            }
            Stmt::If {
                condition,
                then_block,
                else_block,
                ..
            } => {
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("if ({}) {{\n", cond));
                self.push_scope();
                for inner in *then_block {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push('}');

                if let Some(else_stmts) = else_block {
                    self.body.push_str(" else {\n");
                    self.push_scope();
                    for inner in *else_stmts {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                    self.body.push('}');
                }
                self.body.push('\n');
                Ok(())
            }
            Stmt::Block { statements, .. } => {
                self.body.push_str("{\n");
                self.push_scope();
                for inner in *statements {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::While {
                condition, body, ..
            } => {
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("while ({}) {{\n", cond));
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::For {
                init,
                condition,
                loop_expr,
                body,
                ..
            } => {
                self.push_scope();
                let init_js = self.emit_for_init(init)?;
                let cond_js = self.emit_expr_list(condition)?;
                let loop_js = self.emit_expr_list(loop_expr)?;
                self.body
                    .push_str(&format!("for ({}; {}; {}) {{\n", init_js, cond_js, loop_js));
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.body.push_str("}\n");
                self.pop_scope();
                Ok(())
            }
            Stmt::Foreach {
                expr,
                key_var,
                value_var,
                body,
                ..
            } => {
                let iterable = self.emit_expr(*expr)?;
                let value_name = self.extract_var_name(*value_var)?;
                if let Some(key_var) = key_var {
                    let key_name = self.extract_var_name(*key_var)?;
                    self.body.push_str(&format!(
                        "for (const [{} , {}] of Object.entries({})) {{\n",
                        key_name, value_name, iterable
                    ));
                    self.push_scope();
                    self.declare_in_scope(&key_name);
                    self.declare_in_scope(&value_name);
                } else {
                    self.body
                        .push_str(&format!("for (const {} of {}) {{\n", value_name, iterable));
                    self.push_scope();
                    self.declare_in_scope(&value_name);
                }
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::DoWhile {
                body, condition, ..
            } => {
                self.body.push_str("do {\n");
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("}} while ({});\n", cond));
                Ok(())
            }
            Stmt::Switch {
                condition, cases, ..
            } => {
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("switch ({}) {{\n", cond));
                for case in *cases {
                    if let Some(case_cond) = case.condition {
                        let case_expr = self.emit_expr(case_cond)?;
                        self.body.push_str(&format!("case {}:\n", case_expr));
                    } else {
                        self.body.push_str("default:\n");
                    }
                    self.push_scope();
                    for inner in case.body {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                }
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::Const { consts, .. } => {
                for item in *consts {
                    let name = self.token_name(item.name);
                    let value = self.emit_expr(item.value)?;
                    self.body
                        .push_str(&format!("const {} = {};\n", name, value));
                    self.declare_in_scope(&name);
                }
                Ok(())
            }
            Stmt::Global { vars, .. } => {
                if !vars.is_empty() {
                    self.body
                        .push_str("// global declarations are no-ops in JS subset mode\n");
                }
                Ok(())
            }
            Stmt::Static { vars, .. } => {
                for item in *vars {
                    let mut init_expr = item.default;
                    let target_expr = match *item.var {
                        Expr::Assign { var, expr, .. } => {
                            if init_expr.is_none() {
                                init_expr = Some(expr);
                            }
                            var
                        }
                        _ => item.var,
                    };

                    if let Some(raw_name) = self.extract_static_var_name(target_expr) {
                        let var_name = self
                            .sanitize_name(raw_name.split('=').next().unwrap_or(raw_name.as_str()));
                        let init = if let Some(default) = init_expr {
                            self.emit_expr(default)?
                        } else {
                            "undefined".to_string()
                        };
                        if !self.is_declared(&var_name) {
                            self.body
                                .push_str(&format!("let {} = {};\n", var_name, init));
                            self.declare_in_scope(&var_name);
                        } else {
                            self.body.push_str(&format!("{} = {};\n", var_name, init));
                        }
                    } else {
                        self.body.push_str(
                            "// unsupported static declaration target in JS subset mode\n",
                        );
                    }
                }
                Ok(())
            }
            Stmt::Unset { vars, .. } => {
                for var in *vars {
                    let target = self.emit_expr(*var)?;
                    self.body
                        .push_str(&format!("{} = {};\n", target, "undefined"));
                }
                Ok(())
            }
            Stmt::Label { name, .. } => {
                self.body.push_str(&format!(
                    "// label {} ignored in JS subset mode\n",
                    self.token_name(name)
                ));
                Ok(())
            }
            Stmt::Goto { label, .. } => {
                self.body.push_str(&format!(
                    "// goto {} is not supported in JS subset mode\n",
                    self.token_name(label)
                ));
                Ok(())
            }
            Stmt::Declare { body, .. } => {
                // PHP declare directives have no JS equivalent; emit body directly.
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                Ok(())
            }
            Stmt::HaltCompiler { .. } => {
                self.body
                    .push_str("// __halt_compiler ignored in JS subset mode\n");
                Ok(())
            }
            Stmt::Break { .. } => {
                self.body.push_str("break;\n");
                Ok(())
            }
            Stmt::Continue { .. } => {
                self.body.push_str("continue;\n");
                Ok(())
            }
            Stmt::Return { expr, .. } => {
                if let Some(expr) = expr {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("return {};\n", value));
                } else {
                    self.body.push_str("return;\n");
                }
                Ok(())
            }
            Stmt::Throw { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                self.body.push_str(&format!("throw {};\n", value));
                Ok(())
            }
            Stmt::Try {
                body,
                catches,
                finally,
                ..
            } => {
                self.body.push_str("try {\n");
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}");

                if let Some(first_catch) = catches.first() {
                    let err_name = if let Some(var) = first_catch.var {
                        let name = self.token_name(var);
                        if name.is_empty() {
                            "err".to_string()
                        } else {
                            name
                        }
                    } else {
                        "err".to_string()
                    };
                    self.body.push_str(&format!(" catch ({}) {{\n", err_name));
                    self.push_scope();
                    self.declare_in_scope(&err_name);
                    for inner in first_catch.body {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                    self.body.push_str("}");
                }

                if let Some(finally_block) = finally {
                    self.body.push_str(" finally {\n");
                    self.push_scope();
                    for inner in *finally_block {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                    self.body.push_str("}");
                }

                self.body.push('\n');
                Ok(())
            }
            Stmt::Echo { exprs, .. } => {
                for expr in *exprs {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("console.log({});\n", value));
                }
                Ok(())
            }
            Stmt::Expression { expr, .. } => {
                if let Some((name, rhs)) = self.assignment_to_named_var(*expr)? {
                    if !self.is_declared(&name) {
                        self.declare_in_scope(&name);
                        self.body.push_str(&format!("let {} = {};\n", name, rhs));
                    } else {
                        self.body.push_str(&format!("{} = {};\n", name, rhs));
                    }
                } else {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("{};\n", value));
                }
                Ok(())
            }
            Stmt::InlineHtml { value, .. } => {
                let text = String::from_utf8_lossy(value);
                self.body
                    .push_str(&format!("// inline html: {}\n", text.replace('\n', "\\n")));
                Ok(())
            }
            Stmt::Nop { .. } => Ok(()),
        }
    }

    fn emit_expr(&mut self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            Expr::Integer { value, .. } | Expr::Float { value, .. } => {
                Ok(String::from_utf8_lossy(value).to_string())
            }
            Expr::Boolean { value, .. } => Ok(if *value { "true" } else { "false" }.to_string()),
            Expr::Null { .. } => Ok("null".to_string()),
            Expr::String { value, .. } => Ok(self.encode_php_string_literal(value)),
            Expr::Unary { op, expr, .. } => {
                let value = self.emit_expr(*expr)?;
                let js_op = match op {
                    UnaryOp::Plus => "+",
                    UnaryOp::Minus => "-",
                    UnaryOp::Not => "!",
                    UnaryOp::BitNot => "~",
                    UnaryOp::PreInc => "++",
                    UnaryOp::PreDec => "--",
                    _ => {
                        return Err(format!(
                            "unsupported unary operator in subset emitter: {:?}",
                            op
                        ));
                    }
                };
                Ok(format!("({}{})", js_op, value))
            }
            Expr::Binary {
                left, op, right, ..
            } => {
                let lhs = self.emit_expr(*left)?;
                let rhs = self.emit_expr(*right)?;
                let js_op = match op {
                    BinaryOp::Plus => "+",
                    BinaryOp::Minus => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Pow => "**",
                    BinaryOp::Concat => "+",
                    BinaryOp::Eq | BinaryOp::EqEq => "===",
                    BinaryOp::EqEqEq => "===",
                    BinaryOp::NotEq => "!==",
                    BinaryOp::NotEqEq => "!==",
                    BinaryOp::Lt => "<",
                    BinaryOp::LtEq => "<=",
                    BinaryOp::Gt => ">",
                    BinaryOp::GtEq => ">=",
                    BinaryOp::And | BinaryOp::LogicalAnd => "&&",
                    BinaryOp::Or | BinaryOp::LogicalOr => "||",
                    BinaryOp::Coalesce => "??",
                    _ => {
                        return Err(format!(
                            "unsupported binary operator in subset emitter: {:?}",
                            op
                        ));
                    }
                };
                Ok(format!("({} {} {})", lhs, js_op, rhs))
            }
            Expr::ArrowFunction { params, expr, .. } => {
                let mut names = Vec::with_capacity(params.len());
                for param in *params {
                    names.push(self.token_name(param.name));
                }
                let body = self.emit_expr(*expr)?;
                Ok(format!("({}) => {}", names.join(", "), body))
            }
            Expr::Closure { params, body, .. } => {
                let mut names = Vec::with_capacity(params.len());
                for param in *params {
                    names.push(self.token_name(param.name));
                }
                let block = self.emit_stmt_block_inline(body)?;
                Ok(format!("function({}) {{\n{} }}", names.join(", "), block))
            }
            Expr::Call { func, args, .. } => {
                let callee = self.emit_expr(*func)?;
                let args_js = self.emit_call_args(args)?;
                Ok(format!("{}({})", callee, args_js))
            }
            Expr::Assign { var, expr, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    let js_name = self.span_name(*name);
                    let rhs = self.emit_expr(*expr)?;
                    Ok(format!("({} = {})", js_name, rhs))
                } else {
                    Err("subset emitter only supports assignment to simple variables".to_string())
                }
            }
            Expr::AssignRef { var, expr, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    let js_name = self.span_name(*name);
                    let rhs = self.emit_expr(*expr)?;
                    Ok(format!("({} = {})", js_name, rhs))
                } else {
                    Err("subset emitter only supports assignment to simple variables".to_string())
                }
            }
            Expr::AssignOp { var, op, expr, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    let js_name = self.span_name(*name);
                    let rhs = self.emit_expr(*expr)?;
                    let js_op = match op {
                        php_rs::parser::ast::AssignOp::Plus => "+=",
                        php_rs::parser::ast::AssignOp::Minus => "-=",
                        php_rs::parser::ast::AssignOp::Mul => "*=",
                        php_rs::parser::ast::AssignOp::Div => "/=",
                        php_rs::parser::ast::AssignOp::Mod => "%=",
                        php_rs::parser::ast::AssignOp::Concat => "+=",
                        php_rs::parser::ast::AssignOp::BitAnd => "&=",
                        php_rs::parser::ast::AssignOp::BitOr => "|=",
                        php_rs::parser::ast::AssignOp::BitXor => "^=",
                        php_rs::parser::ast::AssignOp::ShiftLeft => "<<=",
                        php_rs::parser::ast::AssignOp::ShiftRight => ">>=",
                        php_rs::parser::ast::AssignOp::Pow => "**=",
                        php_rs::parser::ast::AssignOp::Coalesce => "??=",
                    };
                    Ok(format!("({} {} {})", js_name, js_op, rhs))
                } else {
                    Err("subset emitter only supports assignment to simple variables".to_string())
                }
            }
            Expr::PropertyFetch {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                match *property {
                    Expr::Variable { name, .. } => {
                        let prop = self.span_name(*name);
                        Ok(format!("{}.{}", target_js, prop))
                    }
                    _ => {
                        Err("dynamic property access is not supported in subset emitter"
                            .to_string())
                    }
                }
            }
            Expr::MethodCall {
                target,
                method,
                args,
                ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let method_name = match *method {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic method calls are not supported in subset emitter".to_string()
                        );
                    }
                };
                let args_js = self.emit_call_args(args)?;
                Ok(format!("{}.{}({})", target_js, method_name, args_js))
            }
            Expr::StaticCall {
                class,
                method,
                args,
                ..
            } => {
                let class_js = self.emit_expr(*class)?;
                let method_name = match *method {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic static method calls are not supported in subset emitter"
                                .to_string(),
                        );
                    }
                };
                let args_js = self.emit_call_args(args)?;
                Ok(format!("{}.{}({})", class_js, method_name, args_js))
            }
            Expr::ClassConstFetch {
                class, constant, ..
            } => {
                let class_js = self.emit_expr(*class)?;
                let const_name = match *constant {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic class constant access is not supported in subset emitter"
                                .to_string(),
                        );
                    }
                };
                Ok(format!("{}.{}", class_js, const_name))
            }
            Expr::New { class, args, .. } => {
                let class_js = self.emit_expr(*class)?;
                let args_js = self.emit_call_args(args)?;
                Ok(format!("new {}({})", class_js, args_js))
            }
            Expr::NullsafePropertyFetch {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                match *property {
                    Expr::Variable { name, .. } => {
                        let prop = self.span_name(*name);
                        Ok(format!("({})?.{}", target_js, prop))
                    }
                    _ => Err(
                        "dynamic nullsafe property access is not supported in subset emitter"
                            .to_string(),
                    ),
                }
            }
            Expr::NullsafeMethodCall {
                target,
                method,
                args,
                ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let method_name = match *method {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic nullsafe method calls are not supported in subset emitter"
                                .to_string(),
                        );
                    }
                };
                let args_js = self.emit_call_args(args)?;
                Ok(format!("({})?.{}({})", target_js, method_name, args_js))
            }
            Expr::DotAccess {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let prop = self.token_text(property);
                Ok(format!("{}.{}", target_js, prop))
            }
            Expr::ArrayDimFetch { array, dim, .. } => {
                let array_js = self.emit_expr(*array)?;
                if let Some(dim) = dim {
                    let dim_js = self.emit_expr(*dim)?;
                    Ok(format!("{}[{}]", array_js, dim_js))
                } else {
                    Err("append array access is not supported in subset emitter".to_string())
                }
            }
            Expr::Array { items, .. } => {
                if items
                    .iter()
                    .all(|item| item.key.is_none() && !item.by_ref && !item.unpack)
                {
                    let mut values = Vec::new();
                    for item in *items {
                        values.push(self.emit_expr(item.value)?);
                    }
                    return Ok(format!("[{}]", values.join(", ")));
                }

                if items
                    .iter()
                    .all(|item| item.key.is_some() && !item.by_ref && !item.unpack)
                {
                    let mut entries = Vec::new();
                    for item in *items {
                        let key_expr = item
                            .key
                            .ok_or_else(|| "keyed array expected key".to_string())?;
                        let key = self.emit_static_array_key(key_expr)?;
                        let value = self.emit_expr(item.value)?;
                        entries.push(format!("{}: {}", json_string(&key), value));
                    }
                    return Ok(format!("{{{}}}", entries.join(", ")));
                }

                Err("mixed or complex array items are not supported in subset emitter".to_string())
            }
            Expr::ObjectLiteral { items, .. } => {
                let mut entries = Vec::new();
                for item in *items {
                    let key = match item.key {
                        ObjectKey::Ident(tok) | ObjectKey::String(tok) => self.token_text(tok),
                    };
                    let value = self.emit_expr(item.value)?;
                    entries.push(format!("{}: {}", json_string(&key), value));
                }
                Ok(format!("{{{}}}", entries.join(", ")))
            }
            Expr::StructLiteral { name, fields, .. } => {
                let mut entries = Vec::new();
                entries.push(format!(
                    "{}: {}",
                    json_string("__struct"),
                    json_string(&self.name_last_segment(*name))
                ));
                for field in *fields {
                    let key = self
                        .token_text(field.name)
                        .trim_start_matches('$')
                        .to_string();
                    let value = self.emit_expr(field.value)?;
                    entries.push(format!("{}: {}", json_string(&key), value));
                }
                Ok(format!("{{{}}}", entries.join(", ")))
            }
            Expr::JsxElement {
                name,
                attributes,
                children,
                ..
            } => self.emit_jsx(Some(*name), attributes, children),
            Expr::JsxFragment { children, .. } => self.emit_jsx(None, &[], children),
            Expr::Cast { kind, expr, .. } => {
                let value = self.emit_expr(*expr)?;
                let lowered = match kind {
                    php_rs::parser::ast::CastKind::Int => format!("Number.parseInt({}, 10)", value),
                    php_rs::parser::ast::CastKind::Float => format!("Number({})", value),
                    php_rs::parser::ast::CastKind::String => format!("String({})", value),
                    php_rs::parser::ast::CastKind::Bool => format!("Boolean({})", value),
                    php_rs::parser::ast::CastKind::Array => {
                        format!("Array.isArray({0}) ? {0} : [{0}]", value)
                    }
                    php_rs::parser::ast::CastKind::Object => format!("({})", value),
                    _ => {
                        return Err(format!(
                            "unsupported cast kind in subset emitter: {:?}",
                            kind
                        ));
                    }
                };
                Ok(lowered)
            }
            Expr::Isset { vars, .. } => {
                if vars.is_empty() {
                    return Ok("false".to_string());
                }
                let mut checks = Vec::with_capacity(vars.len());
                for var in *vars {
                    let value = self.emit_expr(*var)?;
                    checks.push(format!("({0} !== undefined && {0} !== null)", value));
                }
                Ok(format!("({})", checks.join(" && ")))
            }
            Expr::PostInc { var, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    Ok(format!("({}++)", self.span_name(*name)))
                } else {
                    Err("subset emitter only supports ++ on simple variables".to_string())
                }
            }
            Expr::PostDec { var, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    Ok(format!("({}--)", self.span_name(*name)))
                } else {
                    Err("subset emitter only supports -- on simple variables".to_string())
                }
            }
            Expr::Empty { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("(!({}))", value))
            }
            Expr::Print { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("(console.log({}), undefined)", value))
            }
            Expr::Await { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("(await {})", value))
            }
            Expr::Eval { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("eval({})", value))
            }
            Expr::Clone { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("structuredClone({})", value))
            }
            Expr::Die { expr, .. } | Expr::Exit { expr, .. } => {
                if let Some(value) = expr {
                    let rendered = self.emit_expr(*value)?;
                    Ok(format!(
                        "(() => {{ throw new Error(String({})); }})()",
                        rendered
                    ))
                } else {
                    Ok("(() => { throw new Error(\"exit\"); })()".to_string())
                }
            }
            Expr::ShellExec { .. } => {
                Err("shell execution is not supported in JS subset emitter".to_string())
            }
            Expr::Yield { .. } => {
                Err("yield expressions are not supported in JS subset emitter".to_string())
            }
            Expr::AnonymousClass { .. } => {
                Err("anonymous classes are not supported in JS subset emitter".to_string())
            }
            Expr::VariadicPlaceholder { .. } => {
                Err("variadic placeholder is not supported in JS subset emitter".to_string())
            }
            Expr::Error { .. } => {
                Err("parser error expression reached JS subset emitter".to_string())
            }
            Expr::Include { kind, expr, .. } => {
                self.uses_include_stub = true;
                let path = self.emit_expr(*expr)?;
                let kind_name = match kind {
                    php_rs::parser::ast::IncludeKind::Include => "include",
                    php_rs::parser::ast::IncludeKind::IncludeOnce => "include_once",
                    php_rs::parser::ast::IncludeKind::Require => "require",
                    php_rs::parser::ast::IncludeKind::RequireOnce => "require_once",
                };
                Ok(format!(
                    "__phpx_include({}, {})",
                    path,
                    json_string(kind_name)
                ))
            }
            Expr::MagicConst { kind, .. } => {
                let lowered = match kind {
                    php_rs::parser::ast::MagicConstKind::Line => "0".to_string(),
                    php_rs::parser::ast::MagicConstKind::Dir
                    | php_rs::parser::ast::MagicConstKind::File
                    | php_rs::parser::ast::MagicConstKind::Function
                    | php_rs::parser::ast::MagicConstKind::Class
                    | php_rs::parser::ast::MagicConstKind::Trait
                    | php_rs::parser::ast::MagicConstKind::Method
                    | php_rs::parser::ast::MagicConstKind::Namespace
                    | php_rs::parser::ast::MagicConstKind::Property => json_string(""),
                };
                Ok(lowered)
            }
            Expr::InterpolatedString { parts, .. } => {
                let mut pieces = Vec::new();
                for part in *parts {
                    pieces.push(self.emit_expr(*part)?);
                }
                Ok(format!("({})", pieces.join(" + ")))
            }
            Expr::Ternary {
                condition,
                if_true,
                if_false,
                ..
            } => {
                let cond = self.emit_expr(*condition)?;
                let when_true = if let Some(value) = if_true {
                    self.emit_expr(*value)?
                } else {
                    cond.clone()
                };
                let when_false = self.emit_expr(*if_false)?;
                Ok(format!("({} ? {} : {})", cond, when_true, when_false))
            }
            Expr::Match {
                condition, arms, ..
            } => self.emit_match_expr(*condition, arms),
            other => Err(format!(
                "unsupported expression in subset emitter: {:?}",
                other
            )),
        }
    }

    fn emit_jsx(
        &mut self,
        name: Option<php_rs::parser::ast::Name<'_>>,
        attributes: &[php_rs::parser::ast::JsxAttribute<'_>],
        children: &[JsxChild<'_>],
    ) -> Result<String, String> {
        self.uses_jsx_runtime = true;

        let mut props = Vec::new();
        for attr in attributes {
            let key = self.token_text(attr.name);
            let value = if let Some(expr) = attr.value {
                self.emit_expr(expr)?
            } else {
                "true".to_string()
            };
            props.push(format!("{}: {}", json_string(&key), value));
        }

        let mut child_values = Vec::new();
        for child in children {
            match child {
                JsxChild::Text(span) => {
                    if let Some(text) = self.normalize_jsx_text(*span) {
                        child_values.push(json_string(&text));
                    }
                }
                JsxChild::Expr(expr) => child_values.push(self.emit_expr(*expr)?),
            }
        }

        if !child_values.is_empty() {
            if child_values.len() == 1 {
                props.push(format!("\"children\": {}", child_values[0]));
            } else {
                props.push(format!("\"children\": [{}]", child_values.join(", ")));
            }
        }

        let tag_expr = match name {
            Some(n) => {
                let raw = self.span_bytes(n.span);
                let trimmed = raw.strip_prefix(b"\\").unwrap_or(raw);
                let raw_text = String::from_utf8_lossy(trimmed).to_string();
                let last = raw_text.rsplit('\\').next().unwrap_or(raw_text.as_str());
                let is_component = last
                    .chars()
                    .next()
                    .map(|c| c.is_ascii_uppercase())
                    .unwrap_or(false);
                if is_component {
                    last.to_string()
                } else {
                    json_string(last)
                }
            }
            None => json_string("__fragment__"),
        };

        let props_expr = format!("{{{}}}", props.join(", "));
        let fn_name = if child_values.len() > 1 {
            "jsxs"
        } else {
            "jsx"
        };

        Ok(format!("{}({}, {})", fn_name, tag_expr, props_expr))
    }

    fn emit_stmt_block_inline(&mut self, stmts: &[StmtId<'_>]) -> Result<String, String> {
        let saved = std::mem::take(&mut self.body);
        self.push_scope();
        for stmt in stmts {
            self.emit_stmt(*stmt)?;
        }
        self.pop_scope();
        let block = std::mem::take(&mut self.body);
        self.body = saved;
        Ok(block)
    }

    fn emit_expr_list(&mut self, exprs: &[ExprId<'_>]) -> Result<String, String> {
        if exprs.is_empty() {
            return Ok(String::new());
        }
        let mut out = Vec::with_capacity(exprs.len());
        for expr in exprs {
            out.push(self.emit_expr(*expr)?);
        }
        Ok(out.join(", "))
    }

    fn emit_for_init(&mut self, exprs: &[ExprId<'_>]) -> Result<String, String> {
        if exprs.is_empty() {
            return Ok(String::new());
        }

        let mut parts = Vec::with_capacity(exprs.len());
        let mut all_new_assignments = true;

        for expr in exprs {
            if let Some((name, rhs)) = self.assignment_to_named_var(*expr)? {
                if self.is_declared(&name) {
                    all_new_assignments = false;
                    parts.push(format!("{} = {}", name, rhs));
                } else {
                    self.declare_in_scope(&name);
                    parts.push(format!("{} = {}", name, rhs));
                }
            } else {
                all_new_assignments = false;
                parts.push(self.emit_expr(*expr)?);
            }
        }

        if all_new_assignments {
            Ok(format!("let {}", parts.join(", ")))
        } else {
            Ok(parts.join(", "))
        }
    }

    fn extract_var_name(&self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            _ => Err("foreach key/value target must be a variable in subset emitter".to_string()),
        }
    }

    fn extract_static_var_name(&self, expr: ExprId<'_>) -> Option<String> {
        match expr {
            Expr::Variable { name, .. } => Some(self.span_name(*name)),
            Expr::IndirectVariable { name, .. } => match *name {
                Expr::Variable { name, .. } => Some(self.span_name(*name)),
                _ => Some(self.span_name(name.span())),
            },
            _ => Some(self.span_name(expr.span())),
        }
    }

    fn emit_call_args(&mut self, args: &[php_rs::parser::ast::Arg<'_>]) -> Result<String, String> {
        if args.iter().all(|a| a.name.is_none() && !a.unpack) {
            let mut rendered = Vec::with_capacity(args.len());
            for arg in args {
                rendered.push(self.emit_expr(arg.value)?);
            }
            return Ok(rendered.join(", "));
        }

        if args.iter().all(|a| a.name.is_some() && !a.unpack) {
            let mut entries = Vec::with_capacity(args.len());
            for arg in args {
                let name = arg
                    .name
                    .map(|tok| self.sanitize_name(&self.token_text(tok)))
                    .ok_or_else(|| {
                        "mixed positional/named arguments are not supported in subset emitter"
                            .to_string()
                    })?;
                let value = self.emit_expr(arg.value)?;
                entries.push(format!("{}: {}", json_string(&name), value));
            }
            return Ok(format!("{{{}}}", entries.join(", ")));
        }

        Err(
            "mixed positional/named/unpack call arguments are not supported in subset emitter"
                .to_string(),
        )
    }

    fn emit_match_expr(
        &mut self,
        condition: ExprId<'_>,
        arms: &[php_rs::parser::ast::MatchArm<'_>],
    ) -> Result<String, String> {
        let condition_js = self.emit_expr(condition)?;
        let mut rendered = String::new();

        for arm in arms.iter().rev() {
            let arm_expr = self.emit_expr(arm.body)?;
            if arm.conditions.is_none() {
                rendered = arm_expr;
                continue;
            }
            let guard = self.emit_match_guard(&condition_js, arm.conditions)?;
            if rendered.is_empty() {
                rendered = format!("({} ? {} : undefined)", guard, arm_expr);
            } else {
                rendered = format!("({} ? {} : {})", guard, arm_expr, rendered);
            }
        }

        if rendered.is_empty() {
            return Err("match requires at least one arm".to_string());
        }
        Ok(rendered)
    }

    fn emit_match_guard(
        &mut self,
        condition_js: &str,
        conditions: Option<&[ExprId<'_>]>,
    ) -> Result<String, String> {
        let Some(conditions) = conditions else {
            return Ok("true".to_string());
        };
        if conditions.is_empty() {
            return Ok("false".to_string());
        }

        let mut checks = Vec::with_capacity(conditions.len());
        for cond in conditions {
            let rhs = self.emit_expr(*cond)?;
            checks.push(format!("({} === {})", condition_js, rhs));
        }
        Ok(format!("({})", checks.join(" || ")))
    }

    fn emit_static_array_key(&self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::String { value, .. } => {
                let mut bytes: &[u8] = value;
                if bytes.len() >= 2
                    && ((bytes[0] == b'\'' && bytes[bytes.len() - 1] == b'\'')
                        || (bytes[0] == b'"' && bytes[bytes.len() - 1] == b'"'))
                {
                    bytes = &bytes[1..bytes.len() - 1];
                }
                Ok(String::from_utf8_lossy(bytes).to_string())
            }
            Expr::Integer { value, .. } => Ok(String::from_utf8_lossy(value).to_string()),
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            _ => {
                Err("array key must be static string/int/identifier in subset emitter".to_string())
            }
        }
    }

    fn assignment_to_named_var(
        &mut self,
        expr: ExprId<'_>,
    ) -> Result<Option<(String, String)>, String> {
        match expr {
            Expr::Assign { var, expr, .. } | Expr::AssignRef { var, expr, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    let js_name = self.span_name(*name);
                    let rhs = self.emit_expr(*expr)?;
                    Ok(Some((js_name, rhs)))
                } else {
                    Err("subset emitter only supports assignment to simple variables".to_string())
                }
            }
            _ => Ok(None),
        }
    }

    fn name_last_segment(&self, name: php_rs::parser::ast::Name<'_>) -> String {
        if let Some(last) = name.parts.last() {
            self.token_text(last).trim_start_matches('\\').to_string()
        } else {
            let raw = String::from_utf8_lossy(self.span_bytes(name.span)).to_string();
            raw.rsplit('\\').next().unwrap_or(raw.as_str()).to_string()
        }
    }

    fn token_name(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        self.sanitize_name(self.token_text(tok).as_str())
    }

    fn span_name(&self, span: php_rs::parser::span::Span) -> String {
        let text = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        self.sanitize_name(&text)
    }

    fn sanitize_name(&self, raw: &str) -> String {
        let mut name = raw.trim().trim_start_matches('$').replace('\\', "_");
        if name.is_empty() {
            name = "_".to_string();
        }
        name
    }

    fn token_text(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        String::from_utf8_lossy(tok.text(self.source)).to_string()
    }

    fn span_bytes(&self, span: php_rs::parser::span::Span) -> &'a [u8] {
        &self.source[span.start..span.end]
    }

    fn encode_php_string_literal(&self, value: &[u8]) -> String {
        let mut bytes: &[u8] = value;
        if bytes.len() >= 2
            && ((bytes[0] == b'\'' && bytes[bytes.len() - 1] == b'\'')
                || (bytes[0] == b'"' && bytes[bytes.len() - 1] == b'"'))
        {
            bytes = &bytes[1..bytes.len() - 1];
        }
        json_string(&String::from_utf8_lossy(bytes))
    }

    fn normalize_jsx_text(&self, span: php_rs::parser::span::Span) -> Option<String> {
        let raw = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        if raw.chars().all(|c| c.is_whitespace()) {
            if raw.contains('\n') || raw.contains('\r') {
                None
            } else {
                Some(" ".to_string())
            }
        } else {
            Some(raw)
        }
    }

    fn push_scope(&mut self) {
        self.scopes.push(HashSet::new());
    }

    fn pop_scope(&mut self) {
        let _ = self.scopes.pop();
    }

    fn declare_in_scope(&mut self, name: &str) {
        if let Some(scope) = self.scopes.last_mut() {
            scope.insert(name.to_string());
        }
    }

    fn is_declared(&self, name: &str) -> bool {
        for scope in self.scopes.iter().rev() {
            if scope.contains(name) {
                return true;
            }
        }
        false
    }

    fn emit_struct_schema(&self, members: &[ClassMember<'_>]) -> String {
        let mut fields = Vec::new();
        for member in members {
            if let ClassMember::Property { ty, entries, .. } = member {
                for entry in *entries {
                    let (schema, optional) = match ty {
                        Some(ty) => self.emit_type_schema(ty),
                        None => ("{ kind: 'unknown' }".to_string(), false),
                    };
                    let name = self.token_name(entry.name);
                    fields.push(format!(
                        "{}: {{ schema: {}, optional: {} }}",
                        json_string(&name),
                        schema,
                        if optional { "true" } else { "false" }
                    ));
                }
            }
        }
        format!("{{ kind: 'object', fields: {{ {} }} }}", fields.join(", "))
    }

    fn emit_type_schema(&self, ty: &AstType<'_>) -> (String, bool) {
        match ty {
            AstType::Simple(tok) => match self.token_name(tok).as_str() {
                "string" => ("{ kind: 'string' }".to_string(), false),
                "int" | "float" | "number" => ("{ kind: 'number' }".to_string(), false),
                "bool" | "boolean" => ("{ kind: 'boolean' }".to_string(), false),
                _ => ("{ kind: 'unknown' }".to_string(), false),
            },
            AstType::Name(_) => ("{ kind: 'object' }".to_string(), false),
            AstType::Nullable(inner) => {
                let (inner_schema, _) = self.emit_type_schema(inner);
                (
                    format!("{{ kind: 'optional', inner: {} }}", inner_schema),
                    true,
                )
            }
            AstType::Union(parts) => {
                let schemas = parts
                    .iter()
                    .map(|part| self.emit_type_schema(part).0)
                    .collect::<Vec<_>>();
                (
                    format!("{{ kind: 'union', anyOf: [{}] }}", schemas.join(", ")),
                    false,
                )
            }
            AstType::Intersection(_parts) => ("{ kind: 'object' }".to_string(), false),
            AstType::ObjectShape(shape_fields) => {
                let fields = shape_fields
                    .iter()
                    .map(|field| {
                        let (inner, opt) = self.emit_type_schema(field.ty);
                        format!(
                            "{}: {{ schema: {}, optional: {} }}",
                            json_string(&self.token_name(field.name)),
                            inner,
                            if field.optional || opt {
                                "true"
                            } else {
                                "false"
                            }
                        )
                    })
                    .collect::<Vec<_>>();
                (
                    format!("{{ kind: 'object', fields: {{ {} }} }}", fields.join(", ")),
                    false,
                )
            }
            AstType::Applied { base, args } => {
                if let AstType::Simple(tok) = *base {
                    let base_name = self.token_name(tok);
                    if base_name == "Option" {
                        let inner = args
                            .first()
                            .map(|t| self.emit_type_schema(t).0)
                            .unwrap_or_else(|| "{ kind: 'unknown' }".to_string());
                        return (format!("{{ kind: 'optional', inner: {} }}", inner), true);
                    }
                    if base_name == "array" || base_name == "Vec" {
                        let inner = args
                            .first()
                            .map(|t| self.emit_type_schema(t).0)
                            .unwrap_or_else(|| "{ kind: 'unknown' }".to_string());
                        return (format!("{{ kind: 'array', item: {} }}", inner), false);
                    }
                }
                ("{ kind: 'unknown' }".to_string(), false)
            }
        }
    }
}

fn add_or_merge_import(imports: &mut Vec<ImportDecl>, from: &str, specs: Vec<ImportSpec>) {
    if let Some(existing) = imports.iter_mut().find(|decl| decl.from == from) {
        for spec in specs {
            if !existing
                .specs
                .iter()
                .any(|item| item.imported == spec.imported && item.local == spec.local)
            {
                existing.specs.push(spec);
            }
        }
        return;
    }
    imports.push(ImportDecl {
        from: from.to_string(),
        specs,
    });
}

fn extract_deka_i_imports(imports: &mut Vec<ImportDecl>) -> Vec<String> {
    let mut locals = Vec::new();
    let mut kept = Vec::new();
    for decl in imports.drain(..) {
        if decl.from == "deka/i" {
            for spec in decl.specs {
                if !locals.contains(&spec.local) {
                    locals.push(spec.local);
                }
            }
        } else {
            kept.push(decl);
        }
    }
    *imports = kept;
    locals
}

fn emit_deka_i_runtime() -> String {
    include_str!("deka_i_runtime.js").to_string()
}

fn json_string(input: &str) -> String {
    serde_json::to_string(input).unwrap_or_else(|_| "\"\"".to_string())
}
