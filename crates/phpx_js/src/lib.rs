use bumpalo::Bump;
use modules_php::compiler_api::{compile_phpx, compile_phpx_internal};
use modules_php::validation::format_multiple_errors;
use php_rs::parser::ast::{
    BinaryOp, ClassKind, ClassMember, Expr, ExprId, JsxChild, ObjectKey, Program, Stmt, StmtId,
    Type as AstType, UnaryOp,
};
use std::collections::{BTreeSet, HashMap, HashSet};
use std::fs;
use std::path::Path;

pub fn compile_phpx_source_to_js(
    source: &str,
    input: &str,
    meta: SourceModuleMeta,
) -> Result<String, String> {
    let arena = Bump::new();
    let path = Path::new(input);
    let result = if is_internal_phpx_path(path) {
        compile_phpx_internal(source, input, &arena)
    } else {
        compile_phpx(source, input, &arena)
    };
    if !result.errors.is_empty() {
        let formatted = format_multiple_errors(source, input, &result.errors, &result.warnings);
        return Err(formatted);
    }

    let js = if let Some(program) = result.ast {
        match emit_js_from_ast(&program, source.as_bytes(), meta) {
            Ok(emitted) => emitted,
            Err(reason) => emit_js_scaffold_with_reason(source, input, &reason),
        }
    } else {
        emit_js_scaffold_with_reason(source, input, "no AST available after validation")
    };

    Ok(js)
}

fn is_internal_phpx_path(path: &Path) -> bool {
    let normalized = path.to_string_lossy().replace('\\', "/");
    normalized.starts_with("php_modules/")
        || normalized.contains("/php_modules/")
}

pub fn emit_js_from_ast(
    program: &Program<'_>,
    source: &[u8],
    meta: SourceModuleMeta,
) -> Result<String, String> {
    let mut emitter = JsSubsetEmitter::new(source, meta);
    emitter.emit_program(program)?;
    Ok(emitter.finish())
}

pub fn emit_js_scaffold_with_reason(source: &str, file_path: &str, reason: &str) -> String {
    let escaped = serde_json::to_string(source).unwrap_or_else(|_| "\"\"".to_string());
    let escaped_path =
        serde_json::to_string(file_path).unwrap_or_else(|_| "\"unknown.phpx\"".to_string());
    let escaped_reason =
        serde_json::to_string(reason).unwrap_or_else(|_| "\"unknown\"".to_string());

    format!(
        "// Generated by deka build. Do not edit manually.\n\
// Source: {file_path}\n\
// Target semantics: JavaScript runtime semantics.\n\
// Fallback scaffold used because subset emitter could not lower this file.\n\
export const phpxBuildMode = \"scaffold\";\n\
export const phpxTargetSemantics = \"js\";\n\
export const phpxBuildReason = {escaped_reason};\n\
export const phpxSource = {escaped};\n\
export const phpxFile = {escaped_path};\n\
\n\
export async function runPhpx(runtime, props = {{}}) {{\n\
  if (!runtime || typeof runtime.executePhpx !== 'function') {{\n\
    throw new Error('runtime.executePhpx(source, file, props) is required');\n\
  }}\n\
  return await runtime.executePhpx(phpxSource, phpxFile, props);\n\
}}\n",
    )
}

#[derive(Debug, Clone)]
pub struct ImportSpec {
    pub imported: String,
    pub local: String,
}

#[derive(Debug, Clone)]
pub struct ImportDecl {
    pub from: String,
    pub specs: Vec<ImportSpec>,
}

#[derive(Debug, Clone)]
pub struct SourceModuleMeta {
    pub imports: Vec<ImportDecl>,
    pub exported_functions: HashSet<String>,
    pub export_specs: Vec<ImportSpec>,
}

impl SourceModuleMeta {
    pub fn empty() -> Self {
        Self {
            imports: Vec::new(),
            exported_functions: HashSet::new(),
            export_specs: Vec::new(),
        }
    }
}

pub fn parse_source_module_meta(source: &str) -> SourceModuleMeta {
    let mut meta = SourceModuleMeta::empty();
    let lines: Vec<&str> = source.lines().collect();
    let (start, end) = frontmatter_range(&lines).unwrap_or((0, lines.len()));

    for line in &lines[start..end] {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("//") {
            continue;
        }

        if let Some(decl) = parse_import_line(trimmed) {
            meta.imports.push(decl);
            continue;
        }

        if let Some(name) = parse_export_function_line(trimmed) {
            meta.exported_functions.insert(name);
            continue;
        }

        if let Some(specs) = parse_export_specs_line(trimmed) {
            meta.export_specs.extend(specs);
        }
    }

    meta
}

pub fn build_stdlib_prelude(project_root: &Path) -> Result<String, String> {
    let stdlib_path = project_root.join("php_modules").join("stdlib.json");
    let raw = fs::read_to_string(&stdlib_path)
        .map_err(|err| format!("failed to read {}: {}", stdlib_path.display(), err))?;
    let entries: Vec<String> = serde_json::from_str(&raw)
        .map_err(|err| format!("failed to parse {}: {}", stdlib_path.display(), err))?;

    let modules_dir = project_root.join("php_modules");
    let mut modules = BTreeSet::new();
    for entry in entries {
        if let Some(prefix) = entry.strip_suffix("/*") {
            let dir = modules_dir.join(prefix);
            let read_dir = fs::read_dir(&dir)
                .map_err(|err| format!("failed to read {}: {}", dir.display(), err))?;
            for item in read_dir {
                let item =
                    item.map_err(|err| format!("failed to read {}: {}", dir.display(), err))?;
                let path = item.path();
                let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
                if ext != "phpx" && ext != "php" {
                    continue;
                }
                if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                    modules.insert(format!("{}/{}", prefix, stem));
                }
            }
        } else {
            modules.insert(entry);
        }
    }

    let mut imports = Vec::new();
    let mut binds = Vec::new();
    for (idx, spec) in modules.iter().enumerate() {
        let var = format!("__deka_mod_{}", idx);
        imports.push(format!("import * as {} from '{}';", var, spec));
        binds.push(var);
    }

    let mut prelude = String::new();
    prelude.push_str("// Generated by deka JS prelude. Do not edit manually.\n");
    prelude.push_str(&imports.join("\n"));
    prelude.push('\n');
    prelude.push_str("const __dekaExportToGlobal = (mod) => {\n");
    prelude.push_str("  if (!mod) return;\n");
    prelude.push_str("  for (const [key, value] of Object.entries(mod)) {\n");
    prelude.push_str("    if (key === 'default' || key === '__esModule') continue;\n");
    prelude.push_str("    globalThis[key] = value;\n");
    prelude.push_str("  }\n");
    prelude.push_str("};\n");
    prelude.push_str("if (!globalThis.panic) {\n");
    prelude.push_str("  globalThis.panic = (msg) => { throw new Error(String(msg)); };\n");
    prelude.push_str("}\n");
    prelude.push_str("if (!globalThis.function_exists) {\n");
    prelude.push_str("  globalThis.function_exists = (name) => typeof globalThis[name] === 'function';\n");
    prelude.push_str("}\n");
    prelude.push_str("if (!globalThis.class_exists) {\n");
    prelude.push_str("  globalThis.class_exists = (name) => typeof globalThis[name] === 'function' || typeof globalThis[name] === 'object';\n");
    prelude.push_str("}\n");
    prelude.push_str("if (!globalThis.class_alias) {\n");
    prelude.push_str("  globalThis.class_alias = () => false;\n");
    prelude.push_str("}\n");
    prelude.push_str("if (!globalThis.__dekaGlobalsInstalled) {\n");
    prelude.push_str("  globalThis.__dekaGlobalsInstalled = true;\n");
    for var in &binds {
        prelude.push_str(&format!("  __dekaExportToGlobal({});\n", var));
    }
    prelude.push_str("}\n");

    Ok(prelude)
}


fn frontmatter_range(lines: &[&str]) -> Option<(usize, usize)> {
    let mut first = None;
    let mut second = None;
    for (idx, line) in lines.iter().enumerate() {
        if line.trim() == "---" {
            if first.is_none() {
                first = Some(idx);
            } else {
                second = Some(idx);
                break;
            }
        }
    }
    match (first, second) {
        (Some(a), Some(b)) if b > a => Some((a + 1, b)),
        _ => None,
    }
}

fn parse_import_line(line: &str) -> Option<ImportDecl> {
    let trimmed = line.trim_end_matches(';').trim();
    if !trimmed.starts_with("import ") {
        return None;
    }
    let open = trimmed.find('{')?;
    let close = trimmed[open..].find('}')? + open;
    let from_pos = trimmed[close + 1..].find("from")? + close + 1;

    let inside = trimmed[open + 1..close].trim();
    let from_part = trimmed[from_pos + 4..].trim();
    let module = unquote(from_part)?;

    let mut specs = Vec::new();
    for chunk in inside.split(',') {
        let part = chunk.trim();
        if part.is_empty() {
            continue;
        }
        if let Some(as_pos) = part.find(" as ") {
            let imported = part[..as_pos].trim();
            let local = part[as_pos + 4..].trim();
            if !imported.is_empty() && !local.is_empty() {
                specs.push(ImportSpec {
                    imported: imported.to_string(),
                    local: local.to_string(),
                });
            }
        } else {
            specs.push(ImportSpec {
                imported: part.to_string(),
                local: part.to_string(),
            });
        }
    }

    if specs.is_empty() {
        return None;
    }

    Some(ImportDecl {
        from: module.to_string(),
        specs,
    })
}

fn parse_export_function_line(line: &str) -> Option<String> {
    let trimmed = line.trim_start();
    let rest = if let Some(rest) = trimmed.strip_prefix("export function ") {
        rest
    } else if let Some(rest) = trimmed.strip_prefix("export async function ") {
        rest
    } else {
        return None;
    };
    let name = rest.split('(').next()?.trim();
    if name.is_empty() {
        return None;
    }
    Some(name.to_string())
}

fn parse_export_specs_line(line: &str) -> Option<Vec<ImportSpec>> {
    let trimmed = line.trim_end_matches(';').trim();
    if !trimmed.starts_with("export {") || !trimmed.ends_with('}') {
        return None;
    }
    let inner = &trimmed[8..trimmed.len() - 1];
    let mut specs = Vec::new();
    for chunk in inner.split(',') {
        let part = chunk.trim();
        if part.is_empty() {
            continue;
        }
        if let Some(as_pos) = part.find(" as ") {
            let local = part[..as_pos].trim();
            let exported = part[as_pos + 4..].trim();
            if !local.is_empty() && !exported.is_empty() {
                specs.push(ImportSpec {
                    imported: exported.to_string(),
                    local: local.to_string(),
                });
            }
        } else {
            specs.push(ImportSpec {
                imported: part.to_string(),
                local: part.to_string(),
            });
        }
    }
    Some(specs)
}

fn unquote(input: &str) -> Option<&str> {
    let s = input.trim();
    if s.len() < 2 {
        return None;
    }
    let first = s.as_bytes()[0] as char;
    let last = s.as_bytes()[s.len() - 1] as char;
    if (first == '\'' && last == '\'') || (first == '"' && last == '"') {
        Some(&s[1..s.len() - 1])
    } else {
        None
    }
}

#[derive(Clone, Debug)]
struct EnumCaseDef {
    name: String,
    params: Vec<String>,
}

enum AssignmentTarget {
    Direct(String),
    Append(String),
}

struct JsSubsetEmitter<'a> {
    source: &'a [u8],
    body: String,
    main_body: String,
    uses_jsx_runtime: bool,
    uses_include_stub: bool,
    scopes: Vec<HashSet<String>>,
    meta: SourceModuleMeta,
    struct_schemas: Vec<(String, String)>,
    struct_names: HashSet<String>,
    struct_methods: HashMap<String, Vec<(String, String)>>,
    enum_cases: HashMap<String, Vec<EnumCaseDef>>,
}

impl<'a> JsSubsetEmitter<'a> {
    fn new(source: &'a [u8], meta: SourceModuleMeta) -> Self {
        Self {
            source,
            body: String::new(),
            main_body: String::new(),
            uses_jsx_runtime: false,
            uses_include_stub: false,
            scopes: vec![HashSet::new()],
            meta,
            struct_schemas: Vec::new(),
            struct_names: HashSet::new(),
            struct_methods: HashMap::new(),
            enum_cases: HashMap::new(),
        }
    }

    fn finish(self) -> String {
        let mut out = String::new();
        out.push_str("// Generated by deka build. Do not edit manually.\n");
        out.push_str("// Target semantics: JavaScript runtime semantics.\n");
        out.push_str("export const phpxBuildMode = \"subset-ast\";\n");
        out.push_str("export const phpxTargetSemantics = \"js\";\n\n");
        out.push_str("if (!globalThis.panic) { globalThis.panic = (msg) => { throw new Error(String(msg)); }; }\n");
        out.push_str("if (!globalThis.function_exists) { globalThis.function_exists = (name) => typeof globalThis[name] === 'function'; }\n");
        out.push_str("if (!globalThis.class_exists) { globalThis.class_exists = (name) => typeof globalThis[name] === 'function' || typeof globalThis[name] === 'object'; }\n");
        out.push_str("if (!globalThis.class_alias) { globalThis.class_alias = () => false; }\n\n");
        out.push_str("if (!globalThis.defined) { globalThis.defined = (name) => Object.prototype.hasOwnProperty.call(globalThis, String(name)); }\n\n");
        out.push_str("if (!globalThis.__phpx_is_struct) { globalThis.__phpx_is_struct = (value, name) => Boolean(value && typeof value === 'object' && value.__struct === name); }\n\n");
        out.push_str("if (!globalThis.__phpx_func_num_args) { globalThis.__phpx_func_num_args = (args) => args.length; }\n");
        out.push_str("if (!globalThis.__phpx_func_get_args) { globalThis.__phpx_func_get_args = (args) => Array.prototype.slice.call(args); }\n");
        out.push_str("if (!globalThis.__phpx_func_get_arg) { globalThis.__phpx_func_get_arg = (args, idx) => (idx >= 0 && idx < args.length ? args[idx] : null); }\n\n");
        out.push_str("if (!globalThis.__deka_chr) { globalThis.__deka_chr = (code) => String.fromCharCode((Number(code) || 0) & 0xff); }\n");
        out.push_str("if (!globalThis.__deka_ord) { globalThis.__deka_ord = (value) => { const str = String(value ?? ''); return str.length ? str.charCodeAt(0) : 0; }; }\n");
        out.push_str("if (!globalThis.chr) { globalThis.chr = globalThis.__deka_chr; }\n");
        out.push_str("if (!globalThis.ord) { globalThis.ord = globalThis.__deka_ord; }\n");
        out.push_str("if (!globalThis.strlen) { globalThis.strlen = (value) => String(value ?? '').length; }\n");
        out.push_str("if (!globalThis.substr) { globalThis.substr = (value, start, length = null) => { const src = String(value ?? ''); let s = Number(start) || 0; if (s < 0) s = Math.max(src.length + s, 0); if (length === null || length === undefined) return src.slice(s); let l = Number(length) || 0; if (l < 0) return src.slice(s, Math.max(src.length + l, s)); return src.slice(s, s + l); }; }\n");
        out.push_str("if (!globalThis.ltrim) { globalThis.ltrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/^\\s+/, ''); const set = new Set(String(chars)); let i = 0; while (i < src.length && set.has(src[i])) i += 1; return src.slice(i); }; }\n");
        out.push_str("if (!globalThis.rtrim) { globalThis.rtrim = (value, chars = null) => { const src = String(value ?? ''); if (chars === null || chars === undefined || chars === '') return src.replace(/\\s+$/, ''); const set = new Set(String(chars)); let i = src.length - 1; while (i >= 0 && set.has(src[i])) i -= 1; return src.slice(0, i + 1); }; }\n");
        out.push_str("if (!globalThis.trim) { globalThis.trim = (value, chars = null) => globalThis.ltrim(globalThis.rtrim(value, chars), chars); }\n");
        out.push_str("if (!globalThis.strpos) { globalThis.strpos = (haystack, needle, offset = 0) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = h.indexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }\n");
        out.push_str("if (!globalThis.strrpos) { globalThis.strrpos = (haystack, needle, offset = null) => { const h = String(haystack ?? ''); const n = String(needle ?? ''); const i = offset === null || offset === undefined ? h.lastIndexOf(n) : h.lastIndexOf(n, Number(offset) || 0); return i >= 0 ? i : false; }; }\n");
        out.push_str("if (!globalThis.str_starts_with) { globalThis.str_starts_with = (haystack, needle) => String(haystack ?? '').startsWith(String(needle ?? '')); }\n");
        out.push_str("if (!globalThis.str_ends_with) { globalThis.str_ends_with = (haystack, needle) => String(haystack ?? '').endsWith(String(needle ?? '')); }\n");
        out.push_str("if (!globalThis.str_contains) { globalThis.str_contains = (haystack, needle) => String(haystack ?? '').includes(String(needle ?? '')); }\n");
        out.push_str("if (!globalThis.strtolower) { globalThis.strtolower = (value) => String(value ?? '').toLowerCase(); }\n");
        out.push_str("if (!globalThis.strtoupper) { globalThis.strtoupper = (value) => String(value ?? '').toUpperCase(); }\n");
        out.push_str("if (!globalThis.array_key_exists) { globalThis.array_key_exists = (key, value) => { if (value === null || value === undefined) return false; if (Array.isArray(value)) { const idx = Number(key); return Number.isInteger(idx) && idx >= 0 && idx < value.length; } if (typeof value === 'object') return Object.prototype.hasOwnProperty.call(value, key); return false; }; }\n");
        out.push_str("if (!globalThis.in_array) { globalThis.in_array = (needle, haystack, strict = false) => { if (!Array.isArray(haystack)) return false; for (const item of haystack) { if (strict ? item === needle : item == needle) return true; } return false; }; }\n");
        out.push_str("if (!globalThis.explode) { globalThis.explode = (sep, value, limit = null) => { const s = String(value ?? ''); const parts = s.split(String(sep ?? '')); if (limit === null || limit === undefined || Number(limit) === 0) return parts; const n = Number(limit); if (!Number.isInteger(n)) return parts; if (n > 0) { if (parts.length <= n) return parts; const head = parts.slice(0, n - 1); head.push(parts.slice(n - 1).join(String(sep ?? ''))); return head; } return parts; }; }\n");
        out.push_str("if (!globalThis.implode) { globalThis.implode = (glue, pieces = null) => { if (pieces === null || pieces === undefined) { pieces = glue; glue = ''; } if (!Array.isArray(pieces)) return ''; return pieces.map((v) => String(v ?? '')).join(String(glue ?? '')); }; }\n");
        out.push_str("if (!globalThis.count) { globalThis.count = (value) => { if (Array.isArray(value) || typeof value === 'string') return value.length; if (value && typeof value === 'object') return Object.keys(value).length; return 0; }; }\n");
        out.push_str("if (!globalThis.time) { globalThis.time = () => Math.floor(Date.now() / 1000); }\n");
        out.push_str("if (!globalThis.getenv) { globalThis.getenv = (name) => { const key = String(name ?? ''); const env = globalThis.process && globalThis.process.env ? globalThis.process.env : null; if (!env || !Object.prototype.hasOwnProperty.call(env, key)) return false; const value = env[key]; return value === undefined || value === null ? false : String(value); }; }\n");
        out.push_str("if (!globalThis.is_promise) { globalThis.is_promise = (value) => Boolean(value && typeof value === 'object' && typeof value.then === 'function'); }\n");
        out.push_str("if (!globalThis.GLOBALS || typeof globalThis.GLOBALS !== 'object') { globalThis.GLOBALS = {}; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_NONE !== 'number') { globalThis.JSON_ERROR_NONE = 0; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_DEPTH !== 'number') { globalThis.JSON_ERROR_DEPTH = 1; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_STATE_MISMATCH !== 'number') { globalThis.JSON_ERROR_STATE_MISMATCH = 2; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_CTRL_CHAR !== 'number') { globalThis.JSON_ERROR_CTRL_CHAR = 3; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_SYNTAX !== 'number') { globalThis.JSON_ERROR_SYNTAX = 4; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_UTF8 !== 'number') { globalThis.JSON_ERROR_UTF8 = 5; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_RECURSION !== 'number') { globalThis.JSON_ERROR_RECURSION = 6; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_INF_OR_NAN !== 'number') { globalThis.JSON_ERROR_INF_OR_NAN = 7; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_UNSUPPORTED_TYPE !== 'number') { globalThis.JSON_ERROR_UNSUPPORTED_TYPE = 8; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_INVALID_PROPERTY_NAME !== 'number') { globalThis.JSON_ERROR_INVALID_PROPERTY_NAME = 9; }\n");
        out.push_str("if (typeof globalThis.JSON_ERROR_UTF16 !== 'number') { globalThis.JSON_ERROR_UTF16 = 10; }\n");
        out.push_str("if (!globalThis.__deka_object_set) { globalThis.__deka_object_set = (obj, key, value) => { if (obj && typeof obj === 'object') { obj[key] = value; } return obj; }; }\n");
        out.push_str("if (!globalThis.__phpx_base64_table) { globalThis.__phpx_base64_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; }\n");
        out.push_str("if (!globalThis.base64_encode) { globalThis.base64_encode = (input) => { const str = String(input ?? ''); const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < str.length; i += 3) { const b0 = str.charCodeAt(i) & 0xff; const b1 = i + 1 < str.length ? str.charCodeAt(i + 1) & 0xff : NaN; const b2 = i + 2 < str.length ? str.charCodeAt(i + 2) & 0xff : NaN; const n = (b0 << 16) | ((Number.isNaN(b1) ? 0 : b1) << 8) | (Number.isNaN(b2) ? 0 : b2); out += tbl[(n >> 18) & 63]; out += tbl[(n >> 12) & 63]; out += Number.isNaN(b1) ? '=' : tbl[(n >> 6) & 63]; out += Number.isNaN(b2) ? '=' : tbl[n & 63]; } return out; }; }\n");
        out.push_str("if (!globalThis.base64_decode) { globalThis.base64_decode = (input, strict = false) => { const src = String(input ?? '').replace(/\\s+/g, ''); if (src.length % 4 !== 0) return strict ? false : ''; const tbl = globalThis.__phpx_base64_table; let out = ''; for (let i = 0; i < src.length; i += 4) { const c0 = src[i], c1 = src[i + 1], c2 = src[i + 2], c3 = src[i + 3]; const n0 = tbl.indexOf(c0), n1 = tbl.indexOf(c1); const n2 = c2 === '=' ? -1 : tbl.indexOf(c2); const n3 = c3 === '=' ? -1 : tbl.indexOf(c3); if (n0 < 0 || n1 < 0 || n2 < -1 || n3 < -1) return strict ? false : ''; const n = (n0 << 18) | (n1 << 12) | ((n2 < 0 ? 0 : n2) << 6) | (n3 < 0 ? 0 : n3); out += String.fromCharCode((n >> 16) & 0xff); if (c2 !== '=') out += String.fromCharCode((n >> 8) & 0xff); if (c3 !== '=') out += String.fromCharCode(n & 0xff); } return out; }; }\n");
        out.push_str("if (!globalThis.__phpx_sha256_hex) { globalThis.__phpx_sha256_hex = (input) => { const K = [1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]; const bytes = []; const src = String(input ?? ''); for (let i = 0; i < src.length; i += 1) bytes.push(src.charCodeAt(i) & 0xff); const bitLen = bytes.length * 8; bytes.push(0x80); while ((bytes.length % 64) !== 56) bytes.push(0); for (let i = 7; i >= 0; i -= 1) bytes.push((bitLen >>> (i * 8)) & 0xff); let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a, h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19; const rotr = (x, n) => ((x >>> n) | (x << (32 - n))) >>> 0; for (let i = 0; i < bytes.length; i += 64) { const w = new Array(64); for (let j = 0; j < 16; j += 1) { const k = i + (j * 4); w[j] = (((bytes[k] << 24) | (bytes[k + 1] << 16) | (bytes[k + 2] << 8) | bytes[k + 3]) >>> 0); } for (let j = 16; j < 64; j += 1) { const s0 = (rotr(w[j - 15], 7) ^ rotr(w[j - 15], 18) ^ (w[j - 15] >>> 3)) >>> 0; const s1 = (rotr(w[j - 2], 17) ^ rotr(w[j - 2], 19) ^ (w[j - 2] >>> 10)) >>> 0; w[j] = (((w[j - 16] + s0) >>> 0) + ((w[j - 7] + s1) >>> 0)) >>> 0; } let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7; for (let j = 0; j < 64; j += 1) { const S1 = (rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)) >>> 0; const ch = ((e & f) ^ ((~e) & g)) >>> 0; const t1 = (((((h + S1) >>> 0) + ch) >>> 0) + ((K[j] + w[j]) >>> 0)) >>> 0; const S0 = (rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)) >>> 0; const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0; const t2 = (S0 + maj) >>> 0; h = g; g = f; f = e; e = (d + t1) >>> 0; d = c; c = b; b = a; a = (t1 + t2) >>> 0; } h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0; h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0; } const words = [h0, h1, h2, h3, h4, h5, h6, h7]; let out = ''; for (const w of words) { out += (w >>> 0).toString(16).padStart(8, '0'); } return out; }; }\n");
        out.push_str("if (!globalThis.__phpx_hex_to_binary) { globalThis.__phpx_hex_to_binary = (hex) => { const src = String(hex ?? ''); let out = ''; for (let i = 0; i < src.length; i += 2) out += String.fromCharCode(parseInt(src.slice(i, i + 2), 16) & 0xff); return out; }; }\n");
        out.push_str("if (!globalThis.__phpx_hmac_sha256_hex) { globalThis.__phpx_hmac_sha256_hex = (data, key) => { const toBytes = (s) => { const out = []; const src = String(s ?? ''); for (let i = 0; i < src.length; i += 1) out.push(src.charCodeAt(i) & 0xff); return out; }; const fromBytes = (arr) => arr.map((v) => String.fromCharCode(v & 0xff)).join(''); let k = toBytes(key); if (k.length > 64) { const kh = globalThis.__phpx_sha256_hex(fromBytes(k)); k = toBytes(globalThis.__phpx_hex_to_binary(kh)); } while (k.length < 64) k.push(0); const o = [], i = []; for (let n = 0; n < 64; n += 1) { o.push(k[n] ^ 0x5c); i.push(k[n] ^ 0x36); } const innerHex = globalThis.__phpx_sha256_hex(fromBytes(i) + String(data ?? '')); const outerHex = globalThis.__phpx_sha256_hex(fromBytes(o) + globalThis.__phpx_hex_to_binary(innerHex)); return outerHex; }; }\n");
        out.push_str("if (!globalThis.__phpx_node_crypto) { globalThis.__phpx_node_crypto = (() => { try { if (typeof require === 'function') { return require('node:crypto'); } } catch (_err) {} try { if (typeof require === 'function') { return require('crypto'); } } catch (_err) {} return null; })(); }\n");
        out.push_str("if (!globalThis.hash) { globalThis.hash = (algo, data, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_sha256_hex(String(data ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHash !== 'function') throw new Error('hash() requires crypto support'); const digest = mod.createHash(name).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }\n");
        out.push_str("if (!globalThis.hash_hmac) { globalThis.hash_hmac = (algo, data, key, raw = false) => { const name = String(algo || '').toLowerCase(); if (name === 'sha256') { const hex = globalThis.__phpx_hmac_sha256_hex(String(data ?? ''), String(key ?? '')); return raw ? globalThis.__phpx_hex_to_binary(hex) : hex; } const mod = globalThis.__phpx_node_crypto; if (!mod || typeof mod.createHmac !== 'function') throw new Error('hash_hmac() requires crypto support'); const digest = mod.createHmac(name, String(key ?? '')).update(String(data ?? ''), 'binary').digest(raw ? 'latin1' : 'hex'); return digest; }; }\n");
        out.push_str("if (!globalThis.hash_equals) { globalThis.hash_equals = (a, b) => { const left = String(a ?? ''); const right = String(b ?? ''); if (left.length !== right.length) return false; let out = 0; for (let i = 0; i < left.length; i += 1) out |= left.charCodeAt(i) ^ right.charCodeAt(i); return out === 0; }; }\n");
        out.push_str("if (!globalThis.__phpx_symbol_table) { globalThis.__phpx_symbol_table = Object.create(null); }\n");
        out.push_str("if (!globalThis.__deka_symbol_set) { globalThis.__deka_symbol_set = (name, value) => { const key = String(name); globalThis.__phpx_symbol_table[key] = value; return true; }; }\n");
        out.push_str("if (!globalThis.__deka_symbol_get) { globalThis.__deka_symbol_get = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key) ? globalThis.__phpx_symbol_table[key] : null; }; }\n");
        out.push_str("if (!globalThis.__deka_symbol_exists) { globalThis.__deka_symbol_exists = (name) => { const key = String(name); return Object.prototype.hasOwnProperty.call(globalThis.__phpx_symbol_table, key); }; }\n");
        out.push_str("if (!globalThis.__phpx_array_cursor) { globalThis.__phpx_array_cursor = new WeakMap(); }\n");
        out.push_str("if (!globalThis.__deka_array_cursor) { globalThis.__deka_array_cursor = (arr, action) => { if (!arr || (typeof arr !== 'object' && !Array.isArray(arr))) return null; const map = globalThis.__phpx_array_cursor; let state = map.get(arr); if (!state) { state = { idx: 0 }; map.set(arr, state); } const keys = Object.keys(arr); if (keys.length === 0) return null; const clamp = () => { if (state.idx < 0) state.idx = 0; if (state.idx >= keys.length) state.idx = keys.length - 1; }; switch (String(action)) { case 'reset': state.idx = 0; break; case 'end': state.idx = keys.length - 1; break; case 'next': state.idx += 1; if (state.idx >= keys.length) return null; break; case 'prev': state.idx -= 1; if (state.idx < 0) return null; break; case 'pos': case 'current': break; case 'key': break; default: return null; } clamp(); const key = keys[state.idx]; if (String(action) === 'key') return key; return arr[key]; }; }\n\n");
        out.push_str("if (!globalThis.is_array || !globalThis.is_array.__deka_polyfill) { const __isArray = (value) => { if (Array.isArray(value)) return true; if (!(value !== null && typeof value === 'object' && Object.getPrototypeOf(value) === Object.prototype)) return false; if (Object.prototype.hasOwnProperty.call(value, '__struct')) return false; return true; }; __isArray.__deka_polyfill = true; globalThis.is_array = __isArray; }\n\n");

        let mut imports = self.meta.imports.clone();
        if self.uses_jsx_runtime {
            add_or_merge_import(
                &mut imports,
                "component/core",
                vec![
                    ImportSpec {
                        imported: "jsx".to_string(),
                        local: "jsx".to_string(),
                    },
                    ImportSpec {
                        imported: "jsxs".to_string(),
                        local: "jsxs".to_string(),
                    },
                ],
            );
        }
        let deka_i_locals = extract_deka_i_imports(&mut imports);

        for decl in &imports {
            out.push_str("import { ");
            for (idx, spec) in decl.specs.iter().enumerate() {
                if idx > 0 {
                    out.push_str(", ");
                }
                if spec.imported == spec.local {
                    out.push_str(&spec.local);
                } else {
                    out.push_str(&format!("{} as {}", spec.imported, spec.local));
                }
            }
            out.push_str(&format!(" }} from '{}';\n", decl.from));
        }

        if !imports.is_empty() {
            out.push('\n');
        }

        if !deka_i_locals.is_empty() {
            out.push_str("const __phpxTypeRegistry = {};\n\n");
            for (name, schema) in &self.struct_schemas {
                out.push_str(&format!(
                    "__phpxTypeRegistry[{}] = {};\n",
                    json_string(name),
                    schema
                ));
            }
            out.push('\n');
            out.push_str(&emit_deka_i_runtime());
            for local in &deka_i_locals {
                out.push_str(&format!("const {} = __deka_i;\n", local));
            }
            out.push('\n');
        }

        if self.uses_include_stub {
            out.push_str("function __phpx_include(path, kind) {\n");
            out.push_str("  throw new Error(`include/require not supported in JS subset emitter: ${kind} ${path}`);\n");
            out.push_str("}\n\n");
        }

        out.push_str("if (!globalThis.__phpxStructMethods) { globalThis.__phpxStructMethods = Object.create(null); }\n");
        if !self.struct_methods.is_empty() {
            for (name, methods) in &self.struct_methods {
                out.push_str(&format!(
                    "globalThis.__phpxStructMethods[{}] = {{ {} }};\n",
                    json_string(name),
                    methods
                        .iter()
                        .map(|(method_name, body)| format!("{}: {}", method_name, body))
                        .collect::<Vec<_>>()
                        .join(", ")
                ));
            }
            out.push('\n');
        }

        out.push_str(&self.body);

        if !self.main_body.is_empty() {
            out.push('\n');
            out.push_str("const __phpx_main = async () => {\n");
            out.push_str(&self.main_body);
            out.push_str("};\n");
            out.push_str("await __phpx_main();\n");
        }

        if !self.meta.export_specs.is_empty() {
            out.push('\n');
            out.push_str("export { ");
            for (idx, spec) in self.meta.export_specs.iter().enumerate() {
                if idx > 0 {
                    out.push_str(", ");
                }
                if spec.imported == spec.local {
                    out.push_str(&spec.local);
                } else {
                    out.push_str(&format!("{} as {}", spec.local, spec.imported));
                }
            }
            out.push_str(" };\n");
        }

        out
    }

    fn emit_program(&mut self, program: &Program<'_>) -> Result<(), String> {
        let import_locals: Vec<String> = self
            .meta
            .imports
            .iter()
            .flat_map(|decl| decl.specs.iter().map(|spec| spec.local.clone()))
            .collect();
        for local in import_locals {
            self.declare_in_scope(&local);
        }
        for stmt in program.statements {
            match stmt {
                Stmt::Function { name, .. } => {
                    let fn_name = self.token_name(name);
                    if !self.is_declared(&fn_name) {
                        self.declare_in_scope(&fn_name);
                    }
                }
                Stmt::Enum { name, .. } => {
                    let enum_name = self.token_name(name);
                    if !self.is_declared(&enum_name) {
                        self.declare_in_scope(&enum_name);
                    }
                }
                Stmt::Class {
                    kind: ClassKind::Struct,
                    name,
                    ..
                } => {
                    let struct_name = self.token_name(name);
                    self.struct_names.insert(struct_name);
                }
                _ => {}
            }
        }
        for stmt in program.statements {
            let is_decl = matches!(
                stmt,
                Stmt::Function { .. }
                    | Stmt::Enum { .. }
                    | Stmt::Class { .. }
                    | Stmt::Const { .. }
                    | Stmt::TypeAlias { .. }
            );
            if is_decl {
                self.emit_stmt(*stmt)?;
            } else {
                self.emit_stmt_to_main(*stmt)?;
            }
        }
        Ok(())
    }

    fn emit_stmt_to_main(&mut self, stmt: StmtId<'_>) -> Result<(), String> {
        std::mem::swap(&mut self.body, &mut self.main_body);
        let res = self.emit_stmt(stmt);
        std::mem::swap(&mut self.body, &mut self.main_body);
        res
    }

    fn emit_stmt(&mut self, stmt: StmtId<'_>) -> Result<(), String> {
        match stmt {
            Stmt::Namespace { .. } => {
                Err("namespace declarations are not supported in JS subset emitter".to_string())
            }
            Stmt::Use { .. } => {
                Err("use declarations are not supported in JS subset emitter".to_string())
            }
            Stmt::Class {
                kind: ClassKind::Struct,
                name,
                members,
                ..
            } => {
                let schema = self.emit_struct_schema(*members);
                let struct_name = self.token_name(name);
                self.struct_schemas.push((struct_name.clone(), schema));
                let methods = self.emit_struct_methods(*members)?;
                if !methods.is_empty() {
                    self.struct_methods.insert(struct_name, methods);
                }
                Ok(())
            }
            Stmt::Enum { name, members, .. } => {
                self.emit_enum(name, members)?;
                Ok(())
            }
            Stmt::Class { .. }
            | Stmt::Trait { .. }
            | Stmt::Interface { .. } => {
                Err("class-like declarations are not supported in JS subset emitter".to_string())
            }
            Stmt::TypeAlias { .. } => {
                Err("type aliases are not supported in JS subset emitter".to_string())
            }
            Stmt::Error { .. } => {
                Err("parser error statement reached JS subset emitter".to_string())
            }
            Stmt::Function {
                name, params, body, is_async, ..
            } => {
                let fn_name = self.token_name(name);
                if !self.is_declared(&fn_name) {
                    self.declare_in_scope(&fn_name);
                }
                let js_params = params
                    .iter()
                    .map(|p| self.token_name(p.name))
                    .collect::<Vec<_>>()
                    .join(", ");

                let exported =
                    self.scopes.len() == 1 && self.meta.exported_functions.contains(&fn_name);
                let async_kw = if *is_async { "async " } else { "" };
                if exported {
                    self.body
                        .push_str(&format!("export {}function {}({}) {{\n", async_kw, fn_name, js_params));
                } else {
                    self.body
                        .push_str(&format!("{}function {}({}) {{\n", async_kw, fn_name, js_params));
                }

                self.push_scope();
                for p in *params {
                    self.declare_in_scope(&self.token_name(p.name));
                }
                self.emit_param_default_guards(params)?;
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();

                self.body.push_str("}\n\n");
                Ok(())
            }
            Stmt::If {
                condition,
                then_block,
                else_block,
                ..
            } => {
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("if ({}) {{\n", cond));
                self.push_scope();
                for inner in *then_block {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push('}');

                if let Some(else_stmts) = else_block {
                    self.body.push_str(" else {\n");
                    self.push_scope();
                    for inner in *else_stmts {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                    self.body.push('}');
                }
                self.body.push('\n');
                Ok(())
            }
            Stmt::Block { statements, .. } => {
                self.body.push_str("{\n");
                self.push_scope();
                for inner in *statements {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::While {
                condition, body, ..
            } => {
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("while ({}) {{\n", cond));
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::For {
                init,
                condition,
                loop_expr,
                body,
                ..
            } => {
                self.push_scope();
                let init_js = self.emit_for_init(init)?;
                let cond_js = self.emit_expr_list(condition)?;
                let loop_js = self.emit_expr_list(loop_expr)?;
                self.body
                    .push_str(&format!("for ({}; {}; {}) {{\n", init_js, cond_js, loop_js));
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.body.push_str("}\n");
                self.pop_scope();
                Ok(())
            }
            Stmt::Foreach {
                expr,
                key_var,
                value_var,
                body,
                ..
            } => {
                let iterable = self.emit_expr(*expr)?;
                let value_name = self.extract_var_name(*value_var)?;
                if let Some(key_var) = key_var {
                    let key_name = self.extract_var_name(*key_var)?;
                    self.body.push_str(&format!(
                        "for (const [{} , {}] of Object.entries({})) {{\n",
                        key_name, value_name, iterable
                    ));
                    self.push_scope();
                    self.declare_in_scope(&key_name);
                    self.declare_in_scope(&value_name);
                } else {
                    self.body.push_str(&format!(
                        "for (const {} of (Array.isArray({}) ? {} : Object.values(({} ?? {{}})))) {{\n",
                        value_name, iterable, iterable, iterable
                    ));
                    self.push_scope();
                    self.declare_in_scope(&value_name);
                }
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::DoWhile {
                body, condition, ..
            } => {
                self.body.push_str("do {\n");
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("}} while ({});\n", cond));
                Ok(())
            }
            Stmt::Switch {
                condition, cases, ..
            } => {
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("switch ({}) {{\n", cond));
                for case in *cases {
                    if let Some(case_cond) = case.condition {
                        let case_expr = self.emit_expr(case_cond)?;
                        self.body.push_str(&format!("case {}:\n", case_expr));
                    } else {
                        self.body.push_str("default:\n");
                    }
                    self.push_scope();
                    for inner in case.body {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                }
                self.body.push_str("}\n");
                Ok(())
            }
            Stmt::Const { consts, .. } => {
                for item in *consts {
                    let name = self.token_name(item.name);
                    let value = self.emit_expr(item.value)?;
                    self.body
                        .push_str(&format!("const {} = {};\n", name, value));
                    self.declare_in_scope(&name);
                }
                Ok(())
            }
            Stmt::Global { vars, .. } => {
                for var in *vars {
                    if let Expr::Variable { name, .. } = *var {
                        let local = self.span_name(*name);
                        if local.is_empty() {
                            continue;
                        }
                        if !self.is_declared(&local) {
                            self.declare_in_scope(&local);
                            self.body
                                .push_str(&format!("let {} = globalThis.{};\n", local, local));
                        } else {
                            self.body
                                .push_str(&format!("{} = globalThis.{};\n", local, local));
                        }
                    }
                }
                Ok(())
            }
            Stmt::Static { vars, .. } => {
                for item in *vars {
                    let mut init_expr = item.default;
                    let target_expr = match *item.var {
                        Expr::Assign { var, expr, .. } => {
                            if init_expr.is_none() {
                                init_expr = Some(expr);
                            }
                            var
                        }
                        _ => item.var,
                    };

                    if let Some(raw_name) = self.extract_static_var_name(target_expr) {
                        let var_name = self
                            .sanitize_name(raw_name.split('=').next().unwrap_or(raw_name.as_str()));
                        let init = if let Some(default) = init_expr {
                            self.emit_expr(default)?
                        } else {
                            "undefined".to_string()
                        };
                        if !self.is_declared(&var_name) {
                            self.body
                                .push_str(&format!("let {} = {};\n", var_name, init));
                            self.declare_in_scope(&var_name);
                        } else {
                            self.body.push_str(&format!("{} = {};\n", var_name, init));
                        }
                    } else {
                        self.body.push_str(
                            "// unsupported static declaration target in JS subset mode\n",
                        );
                    }
                }
                Ok(())
            }
            Stmt::Unset { vars, .. } => {
                for var in *vars {
                    let target = self.emit_expr(*var)?;
                    self.body
                        .push_str(&format!("{} = {};\n", target, "undefined"));
                }
                Ok(())
            }
            Stmt::Label { name, .. } => {
                self.body.push_str(&format!(
                    "// label {} ignored in JS subset mode\n",
                    self.token_name(name)
                ));
                Ok(())
            }
            Stmt::Goto { label, .. } => {
                self.body.push_str(&format!(
                    "// goto {} is not supported in JS subset mode\n",
                    self.token_name(label)
                ));
                Ok(())
            }
            Stmt::Declare { body, .. } => {
                // PHP declare directives have no JS equivalent; emit body directly.
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                Ok(())
            }
            Stmt::HaltCompiler { .. } => {
                self.body
                    .push_str("// __halt_compiler ignored in JS subset mode\n");
                Ok(())
            }
            Stmt::Break { .. } => {
                self.body.push_str("break;\n");
                Ok(())
            }
            Stmt::Continue { .. } => {
                self.body.push_str("continue;\n");
                Ok(())
            }
            Stmt::Return { expr, .. } => {
                if let Some(expr) = expr {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("return {};\n", value));
                } else {
                    self.body.push_str("return;\n");
                }
                Ok(())
            }
            Stmt::Throw { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                self.body.push_str(&format!("throw {};\n", value));
                Ok(())
            }
            Stmt::Try {
                body,
                catches,
                finally,
                ..
            } => {
                self.body.push_str("try {\n");
                self.push_scope();
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push_str("}");

                if let Some(first_catch) = catches.first() {
                    let err_name = if let Some(var) = first_catch.var {
                        let name = self.token_name(var);
                        if name.is_empty() {
                            "err".to_string()
                        } else {
                            name
                        }
                    } else {
                        "err".to_string()
                    };
                    self.body.push_str(&format!(" catch ({}) {{\n", err_name));
                    self.push_scope();
                    self.declare_in_scope(&err_name);
                    for inner in first_catch.body {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                    self.body.push_str("}");
                }

                if let Some(finally_block) = finally {
                    self.body.push_str(" finally {\n");
                    self.push_scope();
                    for inner in *finally_block {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                    self.body.push_str("}");
                }

                self.body.push('\n');
                Ok(())
            }
            Stmt::Echo { exprs, .. } => {
                for expr in *exprs {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!(
                        "(globalThis.__dekaPrint ? globalThis.__dekaPrint({}) : console.log({}));\n",
                        value, value
                    ));
                }
                Ok(())
            }
            Stmt::Expression { expr, .. } => {
                if let Some((name, rhs)) = self.assignment_to_named_var(*expr)? {
                    let top_level = self.scopes.len() == 1;
                    if !self.is_declared(&name) {
                        self.declare_in_scope(&name);
                        self.body.push_str(&format!("let {} = {};\n", name, rhs));
                        if top_level {
                            self.body
                                .push_str(&format!("globalThis.{} = {};\n", name, name));
                        }
                    } else {
                        self.body.push_str(&format!("{} = {};\n", name, rhs));
                        if top_level {
                            self.body
                                .push_str(&format!("globalThis.{} = {};\n", name, name));
                        }
                    }
                } else {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("{};\n", value));
                }
                Ok(())
            }
            Stmt::InlineHtml { value, .. } => {
                let text = String::from_utf8_lossy(value);
                self.body
                    .push_str(&format!("// inline html: {}\n", text.replace('\n', "\\n")));
                Ok(())
            }
            Stmt::Nop { .. } => Ok(()),
        }
    }

    fn emit_enum(
        &mut self,
        name: &php_rs::parser::lexer::token::Token,
        members: &[ClassMember<'_>],
    ) -> Result<(), String> {
        let enum_name = self.token_name(name);
        if !self.is_declared(&enum_name) {
            self.declare_in_scope(&enum_name);
        }
        let mut cases: Vec<EnumCaseDef> = Vec::new();
        let mut methods: Vec<&ClassMember<'_>> = Vec::new();

        for member in members {
            match member {
                ClassMember::Case { name, payload, .. } => {
                    let case_name = self.token_name(name);
                    let params = payload
                        .map(|items| {
                            items
                                .iter()
                                .map(|p| self.token_name(p.name))
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    cases.push(EnumCaseDef {
                        name: case_name,
                        params,
                    });
                }
                ClassMember::Method { .. } => methods.push(member),
                _ => {
                    return Err("enum members other than cases/methods are not supported in JS subset emitter".to_string());
                }
            }
        }

        self.enum_cases.insert(enum_name.clone(), cases.clone());

        self.body.push_str(&format!("class {} {{\n", enum_name));
        self.body.push_str("  constructor(__case, __payload) {\n");
        self.body.push_str(&format!("    this.__enum = {};\n", json_string(&enum_name)));
        self.body.push_str("    this.__case = __case;\n");
        self.body.push_str("    if (__payload) {\n");
        self.body.push_str("      Object.assign(this, __payload);\n");
        self.body.push_str("    }\n");
        self.body.push_str("  }\n");

        for member in methods {
            if let ClassMember::Method { name, params, body, .. } = member {
                let method_name = self.token_name(name);
                let js_params = params
                    .iter()
                    .map(|p| self.token_name(p.name))
                    .collect::<Vec<_>>()
                    .join(", ");
                let block = self.emit_method_block(params, body)?;
                self.body
                    .push_str(&format!("  {}({}) {{\n{}  }}\n", method_name, js_params, block));
            }
        }

        for case in &cases {
            if case.params.is_empty() {
                self.body.push_str(&format!(
                    "  static get {}() {{ return new {}({}, null); }}\n",
                    case.name,
                    enum_name,
                    json_string(&case.name)
                ));
            } else {
                let param_list = case.params.join(", ");
                let payload_entries = case
                    .params
                    .iter()
                    .map(|p| format!("{}: {}", json_string(p), p))
                    .collect::<Vec<_>>()
                    .join(", ");
                self.body.push_str(&format!(
                    "  static {}({}) {{ return new {}({}, {{{}}}); }}\n",
                    case.name,
                    param_list,
                    enum_name,
                    json_string(&case.name),
                    payload_entries
                ));
            }
        }

        self.body.push_str("}\n");
        Ok(())
    }

    fn emit_expr(&mut self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::Variable { name, .. } => {
                let ident = self.span_name(*name);
                if ident == "this" {
                    return Ok("this".to_string());
                }
                if self.is_declared(&ident) {
                    Ok(ident)
                } else {
                    Ok(format!("globalThis.{}", ident))
                }
            }
            Expr::Integer { value, .. } | Expr::Float { value, .. } => {
                Ok(String::from_utf8_lossy(value).to_string())
            }
            Expr::Boolean { value, .. } => Ok(if *value { "true" } else { "false" }.to_string()),
            Expr::Null { .. } => Ok("null".to_string()),
            Expr::String { value, .. } => Ok(self.encode_php_string_literal(value)),
            Expr::Unary { op, expr, .. } => {
                let value = self.emit_expr(*expr)?;
                let js_op = match op {
                    UnaryOp::Plus => "+",
                    UnaryOp::Minus => "-",
                    UnaryOp::Not => "!",
                    UnaryOp::BitNot => "~",
                    UnaryOp::PreInc => "++",
                    UnaryOp::PreDec => "--",
                    _ => {
                        return Err(format!(
                            "unsupported unary operator in subset emitter: {:?}",
                            op
                        ));
                    }
                };
                Ok(format!("({}{})", js_op, value))
            }
            Expr::Binary {
                left, op, right, ..
            } => {
                let lhs = self.emit_expr(*left)?;
                if matches!(op, BinaryOp::Instanceof) {
                    if let Expr::Variable { name, .. } = right {
                        let ident = self.span_name(*name);
                        if self.struct_names.contains(&ident) {
                            return Ok(format!(
                                "(globalThis.__phpx_is_struct({}, {}))",
                                lhs,
                                json_string(&ident)
                            ));
                        }
                    }
                }
                let rhs = self.emit_expr(*right)?;
                let js_op = match op {
                    BinaryOp::Plus => "+",
                    BinaryOp::Minus => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Pow => "**",
                    BinaryOp::ShiftLeft => "<<",
                    BinaryOp::ShiftRight => ">>",
                    BinaryOp::BitAnd => "&",
                    BinaryOp::BitOr => "|",
                    BinaryOp::BitXor => "^",
                    BinaryOp::Concat => "+",
                    BinaryOp::Instanceof => "instanceof",
                    BinaryOp::Eq | BinaryOp::EqEq => "===",
                    BinaryOp::EqEqEq => "===",
                    BinaryOp::NotEq => "!==",
                    BinaryOp::NotEqEq => "!==",
                    BinaryOp::Lt => "<",
                    BinaryOp::LtEq => "<=",
                    BinaryOp::Gt => ">",
                    BinaryOp::GtEq => ">=",
                    BinaryOp::And | BinaryOp::LogicalAnd => "&&",
                    BinaryOp::Or | BinaryOp::LogicalOr => "||",
                    BinaryOp::Coalesce => "??",
                    _ => {
                        return Err(format!(
                            "unsupported binary operator in subset emitter: {:?}",
                            op
                        ));
                    }
                };
                Ok(format!("({} {} {})", lhs, js_op, rhs))
            }
            Expr::ArrowFunction { params, expr, .. } => {
                let mut names = Vec::with_capacity(params.len());
                for param in *params {
                    names.push(self.token_name(param.name));
                }
                self.push_scope();
                for param in *params {
                    self.declare_in_scope(&self.token_name(param.name));
                }
                let body = self.emit_expr(*expr)?;
                self.pop_scope();
                Ok(format!("({}) => {}", names.join(", "), body))
            }
            Expr::Closure {
                params,
                body,
                is_async,
                uses,
                ..
            } => {
                let mut names = Vec::with_capacity(params.len());
                for param in *params {
                    names.push(self.token_name(param.name));
                }
                let block = self.emit_method_block(params, body)?;
                let async_kw = if *is_async { "async " } else { "" };
                let fn_expr = format!("{}function({}) {{\n{} }}", async_kw, names.join(", "), block);
                if uses.is_empty() {
                    return Ok(fn_expr);
                }

                let mut cap_params = Vec::new();
                let mut cap_bindings = Vec::new();
                let mut cap_args = Vec::new();
                for item in *uses {
                    let local = self.token_name(item.var);
                    if local.is_empty() {
                        continue;
                    }
                    let cap_name = format!("__phpx_cap_{}", local);
                    cap_params.push(cap_name.clone());
                    cap_bindings.push(format!("const {} = {};", local, cap_name));
                    if self.is_declared(&local) {
                        cap_args.push(local);
                    } else {
                        cap_args.push(format!("globalThis.{}", local));
                    }
                }

                Ok(format!(
                    "(({}) => {{\n{}\nreturn {};\n}})({})",
                    cap_params.join(", "),
                    cap_bindings.join("\n"),
                    fn_expr,
                    cap_args.join(", ")
                ))
            }
            Expr::Call { func, args, .. } => {
                if let Expr::Variable { name, .. } = func {
                    let ident = self.span_name(*name);
                    if ident == "func_num_args" {
                        return Ok("globalThis.__phpx_func_num_args(arguments)".to_string());
                    }
                    if ident == "func_get_args" {
                        return Ok("globalThis.__phpx_func_get_args(arguments)".to_string());
                    }
                    if ident == "func_get_arg" {
                        let args_js = self.emit_call_args(args)?;
                        if args_js.is_empty() {
                            return Ok("globalThis.__phpx_func_get_arg(arguments, 0)".to_string());
                        }
                        return Ok(format!("globalThis.__phpx_func_get_arg(arguments, {})", args_js));
                    }
                }
                let callee = self.emit_expr(*func)?;
                let args_js = self.emit_call_args(args)?;
                Ok(format!("{}({})", callee, args_js))
            }
            Expr::Assign { var, expr, .. } => {
                let rhs = self.emit_expr(*expr)?;
                match self.emit_assignment_target(*var)? {
                    AssignmentTarget::Direct(target) => Ok(format!("({} = {})", target, rhs)),
                    AssignmentTarget::Append(array) => Ok(format!(
                        "(() => {{ const __arr = {}; const __val = {}; __arr.push(__val); return __val; }})()",
                        array, rhs
                    )),
                }
            }
            Expr::AssignRef { var, expr, .. } => {
                let rhs = self.emit_expr(*expr)?;
                match self.emit_assignment_target(*var)? {
                    AssignmentTarget::Direct(target) => Ok(format!("({} = {})", target, rhs)),
                    AssignmentTarget::Append(array) => Ok(format!(
                        "(() => {{ const __arr = {}; const __val = {}; __arr.push(__val); return __val; }})()",
                        array, rhs
                    )),
                }
            }
            Expr::AssignOp { var, op, expr, .. } => {
                let rhs = self.emit_expr(*expr)?;
                let js_op = match op {
                    php_rs::parser::ast::AssignOp::Plus => "+=",
                    php_rs::parser::ast::AssignOp::Minus => "-=",
                    php_rs::parser::ast::AssignOp::Mul => "*=",
                    php_rs::parser::ast::AssignOp::Div => "/=",
                    php_rs::parser::ast::AssignOp::Mod => "%=",
                    php_rs::parser::ast::AssignOp::Concat => "+=",
                    php_rs::parser::ast::AssignOp::BitAnd => "&=",
                    php_rs::parser::ast::AssignOp::BitOr => "|=",
                    php_rs::parser::ast::AssignOp::BitXor => "^=",
                    php_rs::parser::ast::AssignOp::ShiftLeft => "<<=",
                    php_rs::parser::ast::AssignOp::ShiftRight => ">>=",
                    php_rs::parser::ast::AssignOp::Pow => "**=",
                    php_rs::parser::ast::AssignOp::Coalesce => "??=",
                };
                match self.emit_assignment_target(*var)? {
                    AssignmentTarget::Direct(target) => Ok(format!("({} {} {})", target, js_op, rhs)),
                    AssignmentTarget::Append(_) => Err(
                        "assign-op on append array access is not supported in subset emitter"
                            .to_string(),
                    ),
                }
            }
            Expr::PropertyFetch {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                match *property {
                    Expr::Variable { name, .. } => {
                        let prop = self.span_name(*name);
                        Ok(format!("{}.{}", target_js, prop))
                    }
                    _ => {
                        let prop = self.emit_expr(*property)?;
                        Ok(format!("{}[{}]", target_js, prop))
                    }
                }
            }
            Expr::MethodCall {
                target,
                method,
                args,
                ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let method_name = match *method {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic method calls are not supported in subset emitter".to_string()
                        );
                    }
                };
                let args_js = self.emit_call_args(args)?;
                Ok(format!("{}.{}({})", target_js, method_name, args_js))
            }
            Expr::StaticCall {
                class,
                method,
                args,
                ..
            } => {
                let class_js = self.emit_expr(*class)?;
                let method_name = match *method {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic static method calls are not supported in subset emitter"
                                .to_string(),
                        );
                    }
                };
                let args_js = self.emit_call_args(args)?;
                Ok(format!("{}.{}({})", class_js, method_name, args_js))
            }
            Expr::ClassConstFetch {
                class, constant, ..
            } => {
                let class_js = self.emit_expr(*class)?;
                let const_name = match *constant {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic class constant access is not supported in subset emitter"
                                .to_string(),
                        );
                    }
                };
                Ok(format!("{}.{}", class_js, const_name))
            }
            Expr::New { class, args, .. } => {
                let class_js = self.emit_expr(*class)?;
                let args_js = self.emit_call_args(args)?;
                Ok(format!("new {}({})", class_js, args_js))
            }
            Expr::NullsafePropertyFetch {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                match *property {
                    Expr::Variable { name, .. } => {
                        let prop = self.span_name(*name);
                        Ok(format!("({})?.{}", target_js, prop))
                    }
                    _ => {
                        let prop = self.emit_expr(*property)?;
                        Ok(format!("({})?.[{}]", target_js, prop))
                    }
                }
            }
            Expr::NullsafeMethodCall {
                target,
                method,
                args,
                ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let method_name = match *method {
                    Expr::Variable { name, .. } => self.span_name(*name),
                    _ => {
                        return Err(
                            "dynamic nullsafe method calls are not supported in subset emitter"
                                .to_string(),
                        );
                    }
                };
                let args_js = self.emit_call_args(args)?;
                Ok(format!("({})?.{}({})", target_js, method_name, args_js))
            }
            Expr::DotAccess {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let prop = self.token_text(property);
                if let Some(raw) = prop.strip_prefix('$') {
                    let name = self.sanitize_name(raw);
                    let value = if self.is_declared(&name) {
                        name
                    } else {
                        format!("globalThis.{}", name)
                    };
                    Ok(format!("{}[{}]", target_js, value))
                } else {
                    Ok(format!("{}.{}", target_js, prop))
                }
            }
            Expr::ArrayDimFetch { array, dim, .. } => {
                let array_js = self.emit_expr(*array)?;
                if let Some(dim) = dim {
                    let dim_js = self.emit_expr(*dim)?;
                    Ok(format!("{}[{}]", array_js, dim_js))
                } else {
                    Err("append array access is not supported in subset emitter".to_string())
                }
            }
            Expr::Array { items, .. } => {
                if !items.iter().all(|item| !item.by_ref && !item.unpack) {
                    return Err("mixed or complex array items are not supported in subset emitter"
                        .to_string());
                }

                let mut has_keys = false;
                let mut has_no_keys = false;
                for item in *items {
                    if item.key.is_some() {
                        has_keys = true;
                    } else {
                        has_no_keys = true;
                    }
                }

                if !has_keys {
                    let mut values = Vec::new();
                    for item in *items {
                        values.push(self.emit_expr(item.value)?);
                    }
                    return Ok(format!("[{}]", values.join(", ")));
                }

                if !has_no_keys {
                    let mut entries = Vec::new();
                    let mut all_static = true;
                    for item in *items {
                        let key_expr = item
                            .key
                            .ok_or_else(|| "keyed array expected key".to_string())?;
                        let key = match self.emit_static_array_key(key_expr) {
                            Ok(value) => value,
                            Err(_) => {
                                all_static = false;
                                break;
                            }
                        };
                        let value = self.emit_expr(item.value)?;
                        entries.push(format!("{}: {}", json_string(&key), value));
                    }
                    if all_static {
                        return Ok(format!("{{{}}}", entries.join(", ")));
                    }
                }

                let mut out = String::new();
                out.push_str("(() => { const __out = []; let __idx = 0;\n");
                let mut key_idx = 0;
                for item in *items {
                    if let Some(key_expr) = item.key {
                        let key_js = self.emit_expr(key_expr)?;
                        let value_js = self.emit_expr(item.value)?;
                        out.push_str(&format!(
                            "const __key{key_idx} = {key_js}; __out[__key{key_idx}] = {value_js}; if (typeof __key{key_idx} === 'number' && Number.isInteger(__key{key_idx})) {{ __idx = Math.max(__idx, __key{key_idx} + 1); }}\n",
                        ));
                        key_idx += 1;
                    } else {
                        let value_js = self.emit_expr(item.value)?;
                        out.push_str(&format!("__out[__idx++] = {};\n", value_js));
                    }
                }
                out.push_str("return __out; })()");
                Ok(out)
            }
            Expr::ObjectLiteral { items, .. } => {
                let mut entries = Vec::new();
                for item in *items {
                    let key = match item.key {
                        ObjectKey::Ident(tok) | ObjectKey::String(tok) => self.token_text(tok),
                    };
                    let value = self.emit_expr(item.value)?;
                    entries.push(format!("{}: {}", json_string(&key), value));
                }
                Ok(format!("{{{}}}", entries.join(", ")))
            }
            Expr::StructLiteral { name, fields, .. } => {
                let struct_name = self.name_last_segment(*name);
                let mut entries = Vec::new();
                entries.push(format!(
                    "{}: {}",
                    json_string("__struct"),
                    json_string(&struct_name)
                ));
                for field in *fields {
                    let key = self
                        .token_text(field.name)
                        .trim_start_matches('$')
                        .to_string();
                    let value = self.emit_expr(field.value)?;
                    entries.push(format!("{}: {}", json_string(&key), value));
                }
                Ok(format!(
                    "(() => {{ const __obj = {{{}}}; const __m = globalThis.__phpxStructMethods ? globalThis.__phpxStructMethods[{}] : null; if (__m) Object.assign(__obj, __m); return __obj; }})()",
                    entries.join(", "),
                    json_string(&struct_name)
                ))
            }
            Expr::JsxElement {
                name,
                attributes,
                children,
                ..
            } => self.emit_jsx(Some(*name), attributes, children),
            Expr::JsxFragment { children, .. } => self.emit_jsx(None, &[], children),
            Expr::Cast { kind, expr, .. } => {
                let value = self.emit_expr(*expr)?;
                let lowered = match kind {
                    php_rs::parser::ast::CastKind::Int => format!("Number.parseInt({}, 10)", value),
                    php_rs::parser::ast::CastKind::Float => format!("Number({})", value),
                    php_rs::parser::ast::CastKind::String => format!("String({})", value),
                    php_rs::parser::ast::CastKind::Bool => format!("Boolean({})", value),
                    php_rs::parser::ast::CastKind::Array => {
                        format!(
                            "Array.isArray({0}) ? {0} : ({0} && typeof {0} === 'object' ? Object.fromEntries(Object.entries({0})) : [{0}])",
                            value
                        )
                    }
                    php_rs::parser::ast::CastKind::Object => format!("({})", value),
                    _ => {
                        return Err(format!(
                            "unsupported cast kind in subset emitter: {:?}",
                            kind
                        ));
                    }
                };
                Ok(lowered)
            }
            Expr::Isset { vars, .. } => {
                if vars.is_empty() {
                    return Ok("false".to_string());
                }
                let mut checks = Vec::with_capacity(vars.len());
                for var in *vars {
                    let value = self.emit_expr(*var)?;
                    checks.push(format!("({0} !== undefined && {0} !== null)", value));
                }
                Ok(format!("({})", checks.join(" && ")))
            }
            Expr::PostInc { var, .. } => {
                let target = self.emit_assignable_expr(*var)?;
                Ok(format!("({}++)", target))
            }
            Expr::PostDec { var, .. } => {
                let target = self.emit_assignable_expr(*var)?;
                Ok(format!("({}--)", target))
            }
            Expr::Empty { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("(!({}))", value))
            }
            Expr::Print { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!(
                    "(globalThis.__dekaPrint ? globalThis.__dekaPrint({}) : console.log({}), undefined)",
                    value, value
                ))
            }
            Expr::Await { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("(await {})", value))
            }
            Expr::Eval { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("eval({})", value))
            }
            Expr::Clone { expr, .. } => {
                let value = self.emit_expr(*expr)?;
                Ok(format!("structuredClone({})", value))
            }
            Expr::Die { expr, .. } | Expr::Exit { expr, .. } => {
                if let Some(value) = expr {
                    let rendered = self.emit_expr(*value)?;
                    Ok(format!(
                        "(() => {{ throw new Error(String({})); }})()",
                        rendered
                    ))
                } else {
                    Ok("(() => { throw new Error(\"exit\"); })()".to_string())
                }
            }
            Expr::ShellExec { .. } => {
                Err("shell execution is not supported in JS subset emitter".to_string())
            }
            Expr::Yield { .. } => {
                Err("yield expressions are not supported in JS subset emitter".to_string())
            }
            Expr::AnonymousClass { .. } => {
                Err("anonymous classes are not supported in JS subset emitter".to_string())
            }
            Expr::VariadicPlaceholder { .. } => {
                Err("variadic placeholder is not supported in JS subset emitter".to_string())
            }
            Expr::Error { .. } => {
                Err("parser error expression reached JS subset emitter".to_string())
            }
            Expr::Include { kind, expr, .. } => {
                self.uses_include_stub = true;
                let path = self.emit_expr(*expr)?;
                let kind_name = match kind {
                    php_rs::parser::ast::IncludeKind::Include => "include",
                    php_rs::parser::ast::IncludeKind::IncludeOnce => "include_once",
                    php_rs::parser::ast::IncludeKind::Require => "require",
                    php_rs::parser::ast::IncludeKind::RequireOnce => "require_once",
                };
                Ok(format!(
                    "__phpx_include({}, {})",
                    path,
                    json_string(kind_name)
                ))
            }
            Expr::MagicConst { kind, .. } => {
                let lowered = match kind {
                    php_rs::parser::ast::MagicConstKind::Line => "0".to_string(),
                    php_rs::parser::ast::MagicConstKind::Dir
                    | php_rs::parser::ast::MagicConstKind::File
                    | php_rs::parser::ast::MagicConstKind::Function
                    | php_rs::parser::ast::MagicConstKind::Class
                    | php_rs::parser::ast::MagicConstKind::Trait
                    | php_rs::parser::ast::MagicConstKind::Method
                    | php_rs::parser::ast::MagicConstKind::Namespace
                    | php_rs::parser::ast::MagicConstKind::Property => json_string(""),
                };
                Ok(lowered)
            }
            Expr::InterpolatedString { parts, .. } => {
                let mut pieces = Vec::new();
                for part in *parts {
                    pieces.push(self.emit_expr(*part)?);
                }
                Ok(format!("({})", pieces.join(" + ")))
            }
            Expr::Ternary {
                condition,
                if_true,
                if_false,
                ..
            } => {
                let cond = self.emit_expr(*condition)?;
                let when_true = if let Some(value) = if_true {
                    self.emit_expr(*value)?
                } else {
                    cond.clone()
                };
                let when_false = self.emit_expr(*if_false)?;
                Ok(format!("({} ? {} : {})", cond, when_true, when_false))
            }
            Expr::Match {
                condition, arms, ..
            } => self.emit_match_expr(*condition, arms),
            other => Err(format!(
                "unsupported expression in subset emitter: {:?}",
                other
            )),
        }
    }

    fn emit_jsx(
        &mut self,
        name: Option<php_rs::parser::ast::Name<'_>>,
        attributes: &[php_rs::parser::ast::JsxAttribute<'_>],
        children: &[JsxChild<'_>],
    ) -> Result<String, String> {
        self.uses_jsx_runtime = true;

        let mut props = Vec::new();
        for attr in attributes {
            let key = self.token_text(attr.name);
            let value = if let Some(expr) = attr.value {
                self.emit_expr(expr)?
            } else {
                "true".to_string()
            };
            props.push(format!("{}: {}", json_string(&key), value));
        }

        let mut child_values = Vec::new();
        for child in children {
            match child {
                JsxChild::Text(span) => {
                    if let Some(text) = self.normalize_jsx_text(*span) {
                        child_values.push(json_string(&text));
                    }
                }
                JsxChild::Expr(expr) => child_values.push(self.emit_expr(*expr)?),
            }
        }

        if !child_values.is_empty() {
            if child_values.len() == 1 {
                props.push(format!("\"children\": {}", child_values[0]));
            } else {
                props.push(format!("\"children\": [{}]", child_values.join(", ")));
            }
        }

        let tag_expr = match name {
            Some(n) => {
                let raw = self.span_bytes(n.span);
                let trimmed = raw.strip_prefix(b"\\").unwrap_or(raw);
                let raw_text = String::from_utf8_lossy(trimmed).to_string();
                let last = raw_text.rsplit('\\').next().unwrap_or(raw_text.as_str());
                let is_component = last
                    .chars()
                    .next()
                    .map(|c| c.is_ascii_uppercase())
                    .unwrap_or(false);
                if is_component {
                    last.to_string()
                } else {
                    json_string(last)
                }
            }
            None => json_string("__fragment__"),
        };

        let props_expr = format!("{{{}}}", props.join(", "));
        let fn_name = if child_values.len() > 1 {
            "jsxs"
        } else {
            "jsx"
        };

        Ok(format!("{}({}, {})", fn_name, tag_expr, props_expr))
    }

    fn emit_stmt_block_inline(&mut self, stmts: &[StmtId<'_>]) -> Result<String, String> {
        let saved = std::mem::take(&mut self.body);
        self.push_scope();
        for stmt in stmts {
            self.emit_stmt(*stmt)?;
        }
        self.pop_scope();
        let block = std::mem::take(&mut self.body);
        self.body = saved;
        Ok(block)
    }

    fn emit_method_block(
        &mut self,
        params: &[php_rs::parser::ast::Param<'_>],
        stmts: &[StmtId<'_>],
    ) -> Result<String, String> {
        let saved = std::mem::take(&mut self.body);
        self.push_scope();
        for param in params {
            self.declare_in_scope(&self.token_name(param.name));
        }
        let defaults = self.emit_param_default_guards_inline(params)?;
        if !defaults.is_empty() {
            self.body.push_str(&defaults);
        }
        for stmt in stmts {
            self.emit_stmt(*stmt)?;
        }
        self.pop_scope();
        let block = std::mem::take(&mut self.body);
        self.body = saved;
        Ok(block)
    }

    fn emit_expr_list(&mut self, exprs: &[ExprId<'_>]) -> Result<String, String> {
        if exprs.is_empty() {
            return Ok(String::new());
        }
        let mut out = Vec::with_capacity(exprs.len());
        for expr in exprs {
            out.push(self.emit_expr(*expr)?);
        }
        Ok(out.join(", "))
    }

    fn emit_for_init(&mut self, exprs: &[ExprId<'_>]) -> Result<String, String> {
        if exprs.is_empty() {
            return Ok(String::new());
        }

        let mut parts = Vec::with_capacity(exprs.len());
        let mut all_new_assignments = true;

        for expr in exprs {
            if let Some((name, rhs)) = self.assignment_to_named_var(*expr)? {
                if self.is_declared(&name) {
                    all_new_assignments = false;
                    parts.push(format!("{} = {}", name, rhs));
                } else {
                    self.declare_in_scope(&name);
                    parts.push(format!("{} = {}", name, rhs));
                }
            } else {
                all_new_assignments = false;
                parts.push(self.emit_expr(*expr)?);
            }
        }

        if all_new_assignments {
            Ok(format!("let {}", parts.join(", ")))
        } else {
            Ok(parts.join(", "))
        }
    }

    fn extract_var_name(&self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            _ => Err("foreach key/value target must be a variable in subset emitter".to_string()),
        }
    }

    fn extract_static_var_name(&self, expr: ExprId<'_>) -> Option<String> {
        match expr {
            Expr::Variable { name, .. } => Some(self.span_name(*name)),
            Expr::IndirectVariable { name, .. } => match *name {
                Expr::Variable { name, .. } => Some(self.span_name(*name)),
                _ => Some(self.span_name(name.span())),
            },
            _ => Some(self.span_name(expr.span())),
        }
    }

    fn emit_call_args(&mut self, args: &[php_rs::parser::ast::Arg<'_>]) -> Result<String, String> {
        if args.iter().all(|a| a.name.is_none() && !a.unpack) {
            let mut rendered = Vec::with_capacity(args.len());
            for arg in args {
                rendered.push(self.emit_expr(arg.value)?);
            }
            return Ok(rendered.join(", "));
        }

        if args.iter().all(|a| a.name.is_some() && !a.unpack) {
            let mut entries = Vec::with_capacity(args.len());
            for arg in args {
                let name = arg
                    .name
                    .map(|tok| self.sanitize_name(&self.token_text(tok)))
                    .ok_or_else(|| {
                        "mixed positional/named arguments are not supported in subset emitter"
                            .to_string()
                    })?;
                let value = self.emit_expr(arg.value)?;
                entries.push(format!("{}: {}", json_string(&name), value));
            }
            return Ok(format!("{{{}}}", entries.join(", ")));
        }

        Err(
            "mixed positional/named/unpack call arguments are not supported in subset emitter"
                .to_string(),
        )
    }

    fn emit_match_expr(
        &mut self,
        condition: ExprId<'_>,
        arms: &[php_rs::parser::ast::MatchArm<'_>],
    ) -> Result<String, String> {
        let condition_js = self.emit_expr(condition)?;
        let mut rendered = String::new();

        for arm in arms.iter().rev() {
            let arm_expr = self.emit_expr(arm.body)?;
            if arm.conditions.is_none() {
                rendered = arm_expr;
                continue;
            }
            let guard = self.emit_match_guard(&condition_js, arm.conditions)?;
            if rendered.is_empty() {
                rendered = format!("({} ? {} : undefined)", guard, arm_expr);
            } else {
                rendered = format!("({} ? {} : {})", guard, arm_expr, rendered);
            }
        }

        if rendered.is_empty() {
            return Err("match requires at least one arm".to_string());
        }
        Ok(rendered)
    }

    fn emit_match_guard(
        &mut self,
        condition_js: &str,
        conditions: Option<&[ExprId<'_>]>,
    ) -> Result<String, String> {
        let Some(conditions) = conditions else {
            return Ok("true".to_string());
        };
        if conditions.is_empty() {
            return Ok("false".to_string());
        }

        let mut checks = Vec::with_capacity(conditions.len());
        for cond in conditions {
            if let Some((enum_name, case_name)) = self.enum_case_from_expr(*cond) {
                checks.push(format!(
                    "({} instanceof {} && {}.__case === {})",
                    condition_js,
                    enum_name,
                    condition_js,
                    json_string(&case_name)
                ));
                continue;
            }
            let rhs = self.emit_expr(*cond)?;
            checks.push(format!("({} === {})", condition_js, rhs));
        }
        Ok(format!("({})", checks.join(" || ")))
    }

    fn enum_case_from_expr(&self, expr: ExprId<'_>) -> Option<(String, String)> {
        match expr {
            Expr::ClassConstFetch {
                class, constant, ..
            } => {
                let enum_name = self.extract_static_name(*class)?;
                let case_name = self.extract_static_name(*constant)?;
                let cases = self.enum_cases.get(&enum_name)?;
                if cases.iter().any(|c| c.name == case_name) {
                    Some((enum_name, case_name))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    fn extract_static_name(&self, expr: ExprId<'_>) -> Option<String> {
        match expr {
            Expr::Variable { name, .. } => Some(self.span_name(*name)),
            Expr::String { value, .. } => {
                let mut bytes: &[u8] = value;
                if bytes.len() >= 2
                    && ((bytes[0] == b'\'' && bytes[bytes.len() - 1] == b'\'')
                        || (bytes[0] == b'"' && bytes[bytes.len() - 1] == b'"'))
                {
                    bytes = &bytes[1..bytes.len() - 1];
                }
                Some(String::from_utf8_lossy(bytes).to_string())
            }
            _ => None,
        }
    }

    fn emit_static_array_key(&self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::String { value, .. } => {
                let mut bytes: &[u8] = value;
                if bytes.len() >= 2
                    && ((bytes[0] == b'\'' && bytes[bytes.len() - 1] == b'\'')
                        || (bytes[0] == b'"' && bytes[bytes.len() - 1] == b'"'))
                {
                    bytes = &bytes[1..bytes.len() - 1];
                }
                Ok(String::from_utf8_lossy(bytes).to_string())
            }
            Expr::Integer { value, .. } => Ok(String::from_utf8_lossy(value).to_string()),
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            _ => {
                Err("array key must be static string/int/identifier in subset emitter".to_string())
            }
        }
    }

    fn emit_assignable_expr(&mut self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            Expr::DotAccess { target, property, .. } => {
                let target_js = self.emit_expr(*target)?;
                let prop = self.token_text(property);
                Ok(format!("{}.{}", target_js, prop))
            }
            Expr::PropertyFetch { target, property, .. } => {
                let target_js = self.emit_expr(*target)?;
                match *property {
                    Expr::Variable { name, .. } => Ok(format!("{}.{}", target_js, self.span_name(*name))),
                    _ => {
                        let prop = self.emit_expr(*property)?;
                        Ok(format!("{}[{}]", target_js, prop))
                    }
                }
            }
            Expr::ArrayDimFetch { array, dim, .. } => {
                let array_js = self.emit_expr(*array)?;
                if let Some(dim) = dim {
                    let dim_js = self.emit_expr(*dim)?;
                    Ok(format!("{}[{}]", array_js, dim_js))
                } else {
                    Err("append array access is not supported in assignable expressions".to_string())
                }
            }
            _ => Err("assignment target is not supported in subset emitter".to_string()),
        }
    }

    fn emit_assignment_target(
        &mut self,
        expr: ExprId<'_>,
    ) -> Result<AssignmentTarget, String> {
        match expr {
            Expr::ArrayDimFetch { array, dim, .. } => {
                let array_js = self.emit_expr(*array)?;
                if let Some(dim) = dim {
                    let dim_js = self.emit_expr(*dim)?;
                    Ok(AssignmentTarget::Direct(format!("{}[{}]", array_js, dim_js)))
                } else {
                    Ok(AssignmentTarget::Append(array_js))
                }
            }
            _ => Ok(AssignmentTarget::Direct(self.emit_assignable_expr(expr)?)),
        }
    }

    fn assignment_to_named_var(
        &mut self,
        expr: ExprId<'_>,
    ) -> Result<Option<(String, String)>, String> {
        match expr {
            Expr::Assign { var, expr, .. } | Expr::AssignRef { var, expr, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    let js_name = self.span_name(*name);
                    let rhs = self.emit_expr(*expr)?;
                    Ok(Some((js_name, rhs)))
                } else {
                    Ok(None)
                }
            }
            _ => Ok(None),
        }
    }

    fn name_last_segment(&self, name: php_rs::parser::ast::Name<'_>) -> String {
        if let Some(last) = name.parts.last() {
            self.token_text(last).trim_start_matches('\\').to_string()
        } else {
            let raw = String::from_utf8_lossy(self.span_bytes(name.span)).to_string();
            raw.rsplit('\\').next().unwrap_or(raw.as_str()).to_string()
        }
    }

    fn token_name(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        self.sanitize_name(self.token_text(tok).as_str())
    }

    fn span_name(&self, span: php_rs::parser::span::Span) -> String {
        let text = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        self.sanitize_name(&text)
    }

    fn sanitize_name(&self, raw: &str) -> String {
        let mut name = raw
            .trim()
            .trim_start_matches('$')
            .trim_start_matches('\\')
            .replace('\\', "_");
        if name == "this" {
            return "this".to_string();
        }
        if name.is_empty() {
            name = "_".to_string();
        }
        if is_js_reserved_word(&name) {
            name.push('_');
        }
        name
    }

    fn token_text(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        String::from_utf8_lossy(tok.text(self.source)).to_string()
    }

    fn span_bytes(&self, span: php_rs::parser::span::Span) -> &'a [u8] {
        &self.source[span.start..span.end]
    }

    fn encode_php_string_literal(&self, value: &[u8]) -> String {
        let mut bytes: &[u8] = value;
        let mut quote = None;
        if bytes.len() >= 2 {
            let first = bytes[0];
            let last = bytes[bytes.len() - 1];
            if (first == b'\'' && last == b'\'') || (first == b'"' && last == b'"') {
                quote = Some(first);
                bytes = &bytes[1..bytes.len() - 1];
            }
        }
        let raw = String::from_utf8_lossy(bytes).to_string();
        let decoded = match quote {
            Some(b'\'') => unescape_php_single(&raw),
            Some(b'"') => unescape_php_double(&raw),
            _ => raw,
        };
        json_string(&decoded)
    }

    fn normalize_jsx_text(&self, span: php_rs::parser::span::Span) -> Option<String> {
        let raw = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        if raw.chars().all(|c| c.is_whitespace()) {
            if raw.contains('\n') || raw.contains('\r') {
                None
            } else {
                Some(" ".to_string())
            }
        } else {
            Some(raw)
        }
    }

    fn push_scope(&mut self) {
        self.scopes.push(HashSet::new());
    }

    fn pop_scope(&mut self) {
        let _ = self.scopes.pop();
    }

    fn declare_in_scope(&mut self, name: &str) {
        if let Some(scope) = self.scopes.last_mut() {
            scope.insert(name.to_string());
        }
    }

    fn emit_param_default_guards(
        &mut self,
        params: &[php_rs::parser::ast::Param<'_>],
    ) -> Result<(), String> {
        for param in params {
            if let Some(default) = param.default {
                let name = self.token_name(param.name);
                let default_js = self.emit_expr(default)?;
                self.body.push_str(&format!(
                    "if ({} === undefined) {{ {} = {}; }}\n",
                    name, name, default_js
                ));
            }
        }
        Ok(())
    }

    fn emit_param_default_guards_inline(
        &mut self,
        params: &[php_rs::parser::ast::Param<'_>],
    ) -> Result<String, String> {
        let mut out = String::new();
        for param in params {
            if let Some(default) = param.default {
                let name = self.token_name(param.name);
                let default_js = self.emit_expr(default)?;
                out.push_str(&format!(
                    "if ({} === undefined) {{ {} = {}; }}\n",
                    name, name, default_js
                ));
            }
        }
        Ok(out)
    }

    fn is_declared(&self, name: &str) -> bool {
        for scope in self.scopes.iter().rev() {
            if scope.contains(name) {
                return true;
            }
        }
        false
    }

    fn emit_struct_schema(&self, members: &[ClassMember<'_>]) -> String {
        let mut fields = Vec::new();
        for member in members {
            if let ClassMember::Property { ty, entries, .. } = member {
                for entry in *entries {
                    let (schema, optional) = match ty {
                        Some(ty) => self.emit_type_schema(ty),
                        None => ("{ kind: 'unknown' }".to_string(), false),
                    };
                    let name = self.token_name(entry.name);
                    fields.push(format!(
                        "{}: {{ schema: {}, optional: {} }}",
                        json_string(&name),
                        schema,
                        if optional { "true" } else { "false" }
                    ));
                }
            }
        }
        format!("{{ kind: 'object', fields: {{ {} }} }}", fields.join(", "))
    }

    fn emit_struct_methods(
        &mut self,
        members: &[ClassMember<'_>],
    ) -> Result<Vec<(String, String)>, String> {
        let mut methods = Vec::new();
        for member in members {
            if let ClassMember::Method {
                name, params, body, ..
            } = member
            {
                let method_name = self.token_name(name);
                let js_params = params
                    .iter()
                    .map(|p| self.token_name(p.name))
                    .collect::<Vec<_>>()
                    .join(", ");
                let block = self.emit_method_block(params, body)?;
                methods.push((
                    method_name,
                    format!("function({}) {{\n{} }}", js_params, block),
                ));
            }
        }
        Ok(methods)
    }

    fn emit_type_schema(&self, ty: &AstType<'_>) -> (String, bool) {
        match ty {
            AstType::Simple(tok) => match self.token_name(tok).as_str() {
                "string" => ("{ kind: 'string' }".to_string(), false),
                "int" | "float" | "number" => ("{ kind: 'number' }".to_string(), false),
                "bool" | "boolean" => ("{ kind: 'boolean' }".to_string(), false),
                _ => ("{ kind: 'unknown' }".to_string(), false),
            },
            AstType::Name(_) => ("{ kind: 'object' }".to_string(), false),
            AstType::Nullable(inner) => {
                let (inner_schema, _) = self.emit_type_schema(inner);
                (
                    format!("{{ kind: 'optional', inner: {} }}", inner_schema),
                    true,
                )
            }
            AstType::Union(parts) => {
                let schemas = parts
                    .iter()
                    .map(|part| self.emit_type_schema(part).0)
                    .collect::<Vec<_>>();
                (
                    format!("{{ kind: 'union', anyOf: [{}] }}", schemas.join(", ")),
                    false,
                )
            }
            AstType::Intersection(_parts) => ("{ kind: 'object' }".to_string(), false),
            AstType::ObjectShape(shape_fields) => {
                let fields = shape_fields
                    .iter()
                    .map(|field| {
                        let (inner, opt) = self.emit_type_schema(field.ty);
                        format!(
                            "{}: {{ schema: {}, optional: {} }}",
                            json_string(&self.token_name(field.name)),
                            inner,
                            if field.optional || opt {
                                "true"
                            } else {
                                "false"
                            }
                        )
                    })
                    .collect::<Vec<_>>();
                (
                    format!("{{ kind: 'object', fields: {{ {} }} }}", fields.join(", ")),
                    false,
                )
            }
            AstType::Applied { base, args } => {
                if let AstType::Simple(tok) = *base {
                    let base_name = self.token_name(tok);
                    if base_name == "Option" {
                        let inner = args
                            .first()
                            .map(|t| self.emit_type_schema(t).0)
                            .unwrap_or_else(|| "{ kind: 'unknown' }".to_string());
                        return (format!("{{ kind: 'optional', inner: {} }}", inner), true);
                    }
                    if base_name == "array" || base_name == "Vec" {
                        let inner = args
                            .first()
                            .map(|t| self.emit_type_schema(t).0)
                            .unwrap_or_else(|| "{ kind: 'unknown' }".to_string());
                        return (format!("{{ kind: 'array', item: {} }}", inner), false);
                    }
                }
                ("{ kind: 'unknown' }".to_string(), false)
            }
        }
    }
}

fn unescape_php_single(raw: &str) -> String {
    let mut out = String::with_capacity(raw.len());
    let mut chars = raw.chars();
    while let Some(ch) = chars.next() {
        if ch == '\\' {
            match chars.next() {
                Some('\'') => out.push('\''),
                Some('\\') => out.push('\\'),
                Some(other) => {
                    out.push('\\');
                    out.push(other);
                }
                None => out.push('\\'),
            }
        } else {
            out.push(ch);
        }
    }
    out
}

fn unescape_php_double(raw: &str) -> String {
    let mut out = String::with_capacity(raw.len());
    let mut chars = raw.chars().peekable();
    while let Some(ch) = chars.next() {
        if ch != '\\' {
            out.push(ch);
            continue;
        }
        let Some(next) = chars.next() else {
            out.push('\\');
            break;
        };
        match next {
            'n' => out.push('\n'),
            'r' => out.push('\r'),
            't' => out.push('\t'),
            'v' => out.push('\x0b'),
            'e' => out.push('\x1b'),
            'f' => out.push('\x0c'),
            '"' => out.push('"'),
            '\\' => out.push('\\'),
            '$' => out.push('$'),
            'x' => {
                let mut hex = String::new();
                for _ in 0..2 {
                    if let Some(h) = chars.peek().copied() {
                        if h.is_ascii_hexdigit() {
                            hex.push(h);
                            chars.next();
                        }
                    }
                }
                if hex.is_empty() {
                    out.push('x');
                } else if let Ok(code) = u8::from_str_radix(&hex, 16) {
                    out.push(code as char);
                }
            }
            '0'..='7' => {
                let mut oct = String::new();
                oct.push(next);
                for _ in 0..2 {
                    if let Some(o) = chars.peek().copied() {
                        if o >= '0' && o <= '7' {
                            oct.push(o);
                            chars.next();
                        } else {
                            break;
                        }
                    }
                }
                if let Ok(code) = u32::from_str_radix(&oct, 8) {
                    if let Some(c) = std::char::from_u32(code) {
                        out.push(c);
                    }
                }
            }
            other => {
                out.push(other);
            }
        }
    }
    out
}

fn add_or_merge_import(imports: &mut Vec<ImportDecl>, from: &str, specs: Vec<ImportSpec>) {
    if let Some(existing) = imports.iter_mut().find(|decl| decl.from == from) {
        for spec in specs {
            if !existing
                .specs
                .iter()
                .any(|item| item.imported == spec.imported && item.local == spec.local)
            {
                existing.specs.push(spec);
            }
        }
        return;
    }
    imports.push(ImportDecl {
        from: from.to_string(),
        specs,
    });
}

fn extract_deka_i_imports(imports: &mut Vec<ImportDecl>) -> Vec<String> {
    let mut locals = Vec::new();
    let mut kept = Vec::new();
    for decl in imports.drain(..) {
        if decl.from == "deka/i" {
            for spec in decl.specs {
                if !locals.contains(&spec.local) {
                    locals.push(spec.local);
                }
            }
        } else {
            kept.push(decl);
        }
    }
    *imports = kept;
    locals
}

fn emit_deka_i_runtime() -> String {
    include_str!("deka_i_runtime.js").to_string()
}

fn json_string(input: &str) -> String {
    serde_json::to_string(input).unwrap_or_else(|_| "\"\"".to_string())
}

fn is_js_reserved_word(name: &str) -> bool {
    matches!(
        name,
        "await"
            | "break"
            | "case"
            | "catch"
            | "class"
            | "const"
            | "continue"
            | "debugger"
            | "default"
            | "delete"
            | "do"
            | "else"
            | "enum"
            | "export"
            | "extends"
            | "false"
            | "finally"
            | "for"
            | "function"
            | "if"
            | "implements"
            | "import"
            | "in"
            | "instanceof"
            | "interface"
            | "let"
            | "new"
            | "null"
            | "package"
            | "private"
            | "protected"
            | "public"
            | "return"
            | "static"
            | "super"
            | "switch"
            | "this"
            | "throw"
            | "true"
            | "try"
            | "typeof"
            | "var"
            | "void"
            | "while"
            | "with"
            | "yield"
    )
}
