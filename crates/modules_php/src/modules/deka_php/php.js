// Generated by build.rs (PHP prelude). Do not edit.
const { op_php_get_wasm, op_php_parse_phpx_types, op_php_read_file_sync, op_php_read_env, op_php_cwd, op_php_file_exists, op_php_path_resolve, op_php_read_dir, op_php_parse_wit } = Deno.core.ops;
const console = {
    log: (...args)=>{
        const message = args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    },
    error: (...args)=>{
        const message = args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', true);
    },
    warn: (...args)=>{
        const message = '[WARN] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', true);
    },
    info: (...args)=>{
        const message = '[INFO] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    },
    debug: (...args)=>{
        const message = '[DEBUG] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    }
};
globalThis.console = console;
if (!globalThis.TextEncoder) {
    globalThis.TextEncoder = class TextEncoder {
        encode(input) {
            const str = String(input);
            const utf8 = [];
            for(let i = 0; i < str.length; i++){
                let charCode = str.charCodeAt(i);
                if (charCode < 0x80) {
                    utf8.push(charCode);
                } else if (charCode < 0x800) {
                    utf8.push(0xc0 | charCode >> 6, 0x80 | charCode & 0x3f);
                } else if (charCode < 0xd800 || charCode >= 0xe000) {
                    utf8.push(0xe0 | charCode >> 12, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);
                } else {
                    i++;
                    charCode = 0x10000 + ((charCode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
                    utf8.push(0xf0 | charCode >> 18, 0x80 | charCode >> 12 & 0x3f, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);
                }
            }
            return new Uint8Array(utf8);
        }
    };
}
if (!globalThis.TextDecoder) {
    globalThis.TextDecoder = class TextDecoder1 {
        decode(bytes) {
            if (!bytes) return '';
            const arr = new Uint8Array(bytes);
            let str = '';
            let i = 0;
            while(i < arr.length){
                let __byte = arr[i++];
                if (__byte < 0x80) {
                    str += String.fromCharCode(__byte);
                } else if (__byte < 0xe0) {
                    str += String.fromCharCode((__byte & 0x1f) << 6 | arr[i++] & 0x3f);
                } else if (__byte < 0xf0) {
                    str += String.fromCharCode((__byte & 0x0f) << 12 | (arr[i++] & 0x3f) << 6 | arr[i++] & 0x3f);
                } else {
                    const code = (__byte & 0x07) << 18 | (arr[i++] & 0x3f) << 12 | (arr[i++] & 0x3f) << 6 | arr[i++] & 0x3f;
                    const high = code - 0x10000 >> 10 | 0xd800;
                    const low = code - 0x10000 & 0x3ff | 0xdc00;
                    str += String.fromCharCode(high, low);
                }
            }
            return str;
        }
    };
}
globalThis.fs = {
    readFileSync: (path, encoding)=>{
        const bytes = op_php_read_file_sync(path);
        if (encoding === 'utf8' || encoding === 'utf-8') {
            return new TextDecoder().decode(bytes);
        }
        return bytes;
    },
    existsSync: (path)=>{
        return op_php_file_exists(path);
    },
    readdirSync: (path, options)=>{
        const entries = op_php_read_dir(path);
        if (options && options.withFileTypes) {
            return entries;
        }
        return entries.map((entry)=>entry.name);
    }
};
if (globalThis.Deno) {
    if (!globalThis.fs.mkdirSync) {
        globalThis.fs.mkdirSync = (path, options)=>globalThis.Deno.mkdirSync(path, options);
    }
    if (!globalThis.fs.readdirSync) {
        globalThis.fs.readdirSync = (path, options)=>{
            const entries = Array.from(globalThis.Deno.readDirSync(path));
            if (options && options.withFileTypes) {
                return entries;
            }
            return entries.map((entry)=>entry.name);
        };
    }
    if (!globalThis.fs.statSync) {
        globalThis.fs.statSync = (path)=>globalThis.Deno.statSync(path);
    }
    if (!globalThis.fs.writeFileSync) {
        globalThis.fs.writeFileSync = (path, data, encoding)=>{
            if (typeof data === 'string') {
                const enc = encoding || 'utf8';
                if ((enc === 'utf8' || enc === 'utf-8') && typeof globalThis.Deno.writeTextFileSync === 'function') {
                    globalThis.Deno.writeTextFileSync(path, data);
                    return;
                }
            }
            const bytes = data instanceof Uint8Array ? data : new TextEncoder().encode(String(data));
            globalThis.Deno.writeFileSync(path, bytes);
        };
    }
}
globalThis.process = {
    env: op_php_read_env(),
    cwd: ()=>op_php_cwd()
};
if (globalThis.__dekaPhpLogEnabled === undefined) {
    const debug = globalThis.process?.env?.DEKA_DEBUG;
    globalThis.__dekaPhpLogEnabled = debug === '1' || debug === 'true' || debug === 'yes' || debug === 'on';
}
globalThis.URLSearchParams = class URLSearchParams {
    params = [];
    constructor(init){
        if (typeof init === 'string') {
            const pairs = init.replace(/^\?/, '').split('&');
            for (const pair of pairs){
                if (!pair) continue;
                const idx = pair.indexOf('=');
                if (idx === -1) {
                    this.params.push([
                        decodeURIComponent(pair),
                        ''
                    ]);
                } else {
                    this.params.push([
                        decodeURIComponent(pair.slice(0, idx)),
                        decodeURIComponent(pair.slice(idx + 1))
                    ]);
                }
            }
        }
    }
    append(name, value) {
        this.params.push([
            String(name),
            String(value)
        ]);
    }
    get(name) {
        const entry = this.params.find(([k])=>k === name);
        return entry ? entry[1] : null;
    }
    *entries() {
        for (const param of this.params){
            yield param;
        }
    }
    toString() {
        return this.params.map(([k, v])=>`${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
    }
};
globalThis.path = {
    sep: '/',
    delimiter: ':',
    extname: (p)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        const lastDot = str.lastIndexOf('.');
        if (lastDot === -1 || lastDot < lastSlash) return '';
        return str.slice(lastDot);
    },
    dirname: (p)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        if (lastSlash === -1) return '.';
        if (lastSlash === 0) return '/';
        return str.slice(0, lastSlash);
    },
    basename: (p, ext)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        let base = lastSlash === -1 ? str : str.slice(lastSlash + 1);
        if (ext && base.endsWith(ext)) {
            base = base.slice(0, -ext.length);
        }
        return base;
    },
    normalize: (p)=>{
        const str = String(p);
        const parts = str.split('/');
        const result = [];
        for (const part of parts){
            if (part === '..') {
                if (result.length > 0 && result[result.length - 1] !== '..') {
                    result.pop();
                } else {
                    result.push('..');
                }
            } else if (part !== '.' && part !== '') {
                result.push(part);
            }
        }
        const normalized = result.join('/');
        return str.startsWith('/') ? '/' + normalized : normalized || '.';
    },
    resolve: (...args)=>{
        let resolved = '';
        for(let i = args.length - 1; i >= 0; i--){
            const p = String(args[i]);
            if (!p) continue;
            if (resolved === '') {
                resolved = p;
            } else if (p.startsWith('/')) {
                resolved = p + '/' + resolved;
                break;
            } else {
                resolved = p + '/' + resolved;
            }
            if (resolved.startsWith('/')) {
                break;
            }
        }
        if (!resolved.startsWith('/')) {
            const cwd = op_php_cwd();
            resolved = cwd + '/' + resolved;
        }
        return globalThis.path.normalize(resolved);
    },
    relative: (from, to)=>{
        const fromAbs = globalThis.path.resolve(from);
        const toAbs = globalThis.path.resolve(to);
        const fromParts = fromAbs.split('/').filter(Boolean);
        const toParts = toAbs.split('/').filter(Boolean);
        let shared = 0;
        while(shared < fromParts.length && shared < toParts.length && fromParts[shared] === toParts[shared]){
            shared++;
        }
        const up = fromParts.slice(shared).map(()=>"..");
        const down = toParts.slice(shared);
        const combined = up.concat(down);
        return combined.length ? combined.join('/') : '.';
    },
    join: (...args)=>{
        const parts = args.filter((p)=>p && String(p) !== '');
        if (parts.length === 0) return '.';
        const joined = parts.join('/');
        return globalThis.path.normalize(joined);
    }
};
let phpActiveRoots = [];
let phpModulesRoot = '';
function normalizeHostPath(value) {
    const raw = String(value || '').replace(/\\/g, '/');
    return globalThis.path.resolve(op_php_cwd(), raw);
}
function uniqueValues(values) {
    const seen = new Set();
    const out = [];
    for (const value of values){
        if (!value) continue;
        if (seen.has(value)) continue;
        seen.add(value);
        out.push(value);
    }
    return out;
}
function getPhpModulesRoots(entryPath) {
    const cwd = op_php_cwd();
    const roots = [];
    if (entryPath) {
        const entryAbs = normalizeHostPath(entryPath);
        const entryDir = globalThis.path.dirname(entryAbs);
        roots.push(globalThis.path.resolve(entryDir, 'php_modules'));
    }
    roots.push(globalThis.path.resolve(cwd, 'php_modules'));
    return uniqueValues(roots);
}
function resolvePhpModulesRoot(entryPath) {
    const roots = getPhpModulesRoots(entryPath);
    for (const root of roots){
        if (globalThis.fs.existsSync(root)) {
            return root;
        }
    }
    return '';
}
function getActiveModulesRoot(entryPath) {
    if (phpModulesRoot) return phpModulesRoot;
    return resolvePhpModulesRoot(entryPath);
}
function setPhpActiveRoots(entryPath) {
    const cwd = op_php_cwd();
    const entryAbs = normalizeHostPath(entryPath);
    const entryDir = globalThis.path.dirname(entryAbs);
    const modulesRoots = getPhpModulesRoots(entryPath);
    phpModulesRoot = resolvePhpModulesRoot(entryPath);
    phpActiveRoots = uniqueValues([
        entryDir,
        ...modulesRoots,
        normalizeHostPath(cwd)
    ]);
    if (globalThis.process?.env?.DEKA_PHP_FS_DEBUG) {
        console.log('[php-fs] roots', phpActiveRoots);
    }
}
function getDekaEntryPath(entryPath) {
    const roots = getPhpModulesRoots(entryPath);
    for (const root of roots){
        const candidate = globalThis.path.resolve(root, 'deka.php');
        if (globalThis.fs.existsSync(candidate)) {
            return candidate;
        }
    }
    return '';
}
function stripPhpTags(source) {
    return String(source).replace(/^\s*<\?(?:php)?/i, '').replace(/\?>\s*$/, '');
}
function stripInlineTypes(source) {
    const input = String(source);
    let out = '';
    let i = 0;
    let lastSignificant = '';
    while(i < input.length){
        const ch = input[i];
        if (ch === "'" || ch === '"') {
            const chunk = readQuoted(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceQuoted(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '/') {
            const chunk = readLineComment(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceLineComment(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '*') {
            const chunk = readBlockComment(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceBlockComment(input, i);
            continue;
        }
        if (ch === '#') {
            const chunk = readLineComment(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceLineComment(input, i);
            continue;
        }
        const stripped = tryStripPrefixType(input, i, lastSignificant);
        if (stripped) {
            out += stripped.text;
            lastSignificant = updateLastSignificant(lastSignificant, stripped.text);
            i = stripped.end;
            continue;
        }
        if (ch === '$') {
            const varInfo = readVariableName(input, i);
            if (varInfo) {
                out += varInfo.text;
                lastSignificant = updateLastSignificant(lastSignificant, varInfo.text);
                const wsAfterVar = readWhitespace(input, varInfo.end);
                let j = wsAfterVar.end;
                const allowInlineType = isTypeBoundary(lastSignificant) || lastSignificant === '(' || lastSignificant === ',';
                if (allowInlineType && input[j] === ':') {
                    const wsAfterColon = readWhitespace(input, j + 1);
                    const typeStart = wsAfterColon.end;
                    if (isTypeStartChar(input[typeStart])) {
                        const typeInfo = readTypeToken(input, typeStart);
                        const wsAfterType = readWhitespace(input, typeInfo.end);
                        const nextChar = input[wsAfterType.end];
                        if (nextChar && "=,;)]}".includes(nextChar)) {
                            out += wsAfterVar.text + wsAfterType.text;
                            lastSignificant = updateLastSignificant(lastSignificant, wsAfterType.text);
                            i = wsAfterType.end;
                            continue;
                        }
                    }
                }
                i = varInfo.end;
                continue;
            }
        }
        out += ch;
        lastSignificant = updateLastSignificant(lastSignificant, ch);
        i++;
    }
    return out;
}
function stripPhpxTypes(source) {
    const input = String(source);
    let out = '';
    let i = 0;
    while(i < input.length){
        const ch = input[i];
        if (ch === "'" || ch === '"') {
            out += readQuoted(input, i);
            i = advanceQuoted(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '/') {
            out += readLineComment(input, i);
            i = advanceLineComment(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '*') {
            out += readBlockComment(input, i);
            i = advanceBlockComment(input, i);
            continue;
        }
        if (ch === '#') {
            out += readLineComment(input, i);
            i = advanceLineComment(input, i);
            continue;
        }
        if (isKeywordAt(input, i, 'function')) {
            out += 'function';
            i += 8;
            while(i < input.length){
                const next = input[i];
                if (next === '(') {
                    out += '(';
                    i++;
                    break;
                }
                out += next;
                i++;
            }
            const params = readParenBlock(input, i);
            out += stripParamTypes(params.text);
            out += ')';
            i = params.endIndex + 1;
            const returnInfo = stripReturnType(input, i);
            out += returnInfo.text;
            i = returnInfo.index;
            continue;
        }
        out += ch;
        i++;
    }
    return out;
}
const PHPX_MARKER = '/*__DEKA_PHPX__*/';
const PHPX_INTERNAL_MARKER = '/*__DEKA_PHPX_INTERNAL__*/';
const PHP_SAPI_MARKER_PREFIX = '/*__DEKA_PHP_SAPI:';
function buildSapiMarker(value) {
    return `${PHP_SAPI_MARKER_PREFIX}${value}__*/\n`;
}
function updateLastSignificant(prev, chunk) {
    for(let i = chunk.length - 1; i >= 0; i--){
        const ch = chunk[i];
        if (!/\s/.test(ch)) {
            return ch;
        }
    }
    return prev;
}
function isTypeBoundary(lastSignificant) {
    if (!lastSignificant) return true;
    return lastSignificant === ';' || lastSignificant === '{' || lastSignificant === '}' || lastSignificant === "\n";
}
function isTypeStartChar(ch) {
    return !!ch && (/[A-Za-z_]/.test(ch) || ch === '?' || ch === '\\');
}
function isTypeChar(ch) {
    return !!ch && /[A-Za-z0-9_\\|?<>[\],]/.test(ch);
}
const RESERVED_PREFIX_KEYWORDS = new Set([
    'return',
    'throw',
    'echo',
    'print',
    'if',
    'for',
    'foreach',
    'while',
    'switch',
    'case',
    'break',
    'continue',
    'catch',
    'try',
    'finally',
    'do',
    'new',
    'clone',
    'yield',
    'function',
    'fn',
    'class',
    'interface',
    'trait',
    'enum',
    'extends',
    'implements',
    'namespace',
    'use',
    'as'
]);
function isReservedPrefixKeyword(word) {
    return RESERVED_PREFIX_KEYWORDS.has(word);
}
function readWhitespace(source, index) {
    let i = index;
    let out = '';
    while(i < source.length && /\s/.test(source[i])){
        out += source[i];
        i++;
    }
    return {
        text: out,
        end: i
    };
}
function readIdentifierAt(source, index) {
    if (!source[index] || !/[A-Za-z_]/.test(source[index])) {
        return null;
    }
    let i = index + 1;
    while(i < source.length && /[A-Za-z0-9_]/.test(source[i])){
        i++;
    }
    return {
        text: source.slice(index, i),
        end: i
    };
}
function readTypeToken(source, index) {
    let i = index;
    let depthAngle = 0;
    let depthBrace = 0;
    while(i < source.length){
        const ch = source[i];
        if (ch === "'" || ch === '"') {
            i = advanceQuoted(source, i);
            continue;
        }
        if (ch === '<') {
            depthAngle++;
            i++;
            continue;
        }
        if (ch === '>') {
            depthAngle = Math.max(0, depthAngle - 1);
            i++;
            continue;
        }
        if (depthAngle > 0 && ch === '{') {
            depthBrace++;
            i++;
            continue;
        }
        if (depthAngle > 0 && ch === '}') {
            depthBrace = Math.max(0, depthBrace - 1);
            i++;
            continue;
        }
        if (depthAngle > 0 || depthBrace > 0) {
            i++;
            continue;
        }
        if (!isTypeChar(ch)) {
            break;
        }
        i++;
    }
    return {
        text: source.slice(index, i),
        end: i
    };
}
function readVariableName(source, index) {
    if (source[index] !== '$') return null;
    if (!source[index + 1] || !/[A-Za-z_]/.test(source[index + 1])) return null;
    let i = index + 2;
    while(i < source.length && /[A-Za-z0-9_]/.test(source[i])){
        i++;
    }
    return {
        text: source.slice(index, i),
        end: i
    };
}
function tryStripPrefixType(source, index, lastSignificant) {
    if (!isTypeBoundary(lastSignificant)) {
        return null;
    }
    let i = index;
    const leading = readWhitespace(source, i);
    i = leading.end;
    const prefixStart = index;
    let cursor = i;
    const modifiers = new Set([
        'public',
        'protected',
        'private',
        'var',
        'static',
        'readonly'
    ]);
    while(true){
        const ident = readIdentifierAt(source, cursor);
        if (!ident || !modifiers.has(ident.text)) {
            break;
        }
        cursor = ident.end;
        const ws = readWhitespace(source, cursor);
        cursor = ws.end;
    }
    const typeStart = cursor;
    const typeInfo = readTypeToken(source, typeStart);
    if (!typeInfo.text) {
        return null;
    }
    const keyword = typeInfo.text.toLowerCase();
    if (isReservedPrefixKeyword(keyword)) {
        return null;
    }
    const wsAfterType = readWhitespace(source, typeInfo.end);
    const scan = scanForVarStart(source, wsAfterType.end);
    if (!scan) {
        return null;
    }
    const varInfo = readVariableName(source, scan.varStart);
    if (!varInfo) {
        return null;
    }
    const prefix = source.slice(prefixStart, typeStart);
    const replacement = prefix + wsAfterType.text + scan.symbolSegment + varInfo.text;
    return {
        text: replacement,
        end: varInfo.end
    };
}
function scanForVarStart(source, index) {
    let i = index;
    while(i < source.length){
        const ch = source[i];
        if (ch === '$') {
            return {
                varStart: i,
                symbolSegment: source.slice(index, i)
            };
        }
        if (/\s/.test(ch) || ch === '&' || ch === '.') {
            i++;
            continue;
        }
        return null;
    }
    return null;
}
function isKeywordAt(source, index, keyword) {
    if (source.slice(index, index + keyword.length) !== keyword) {
        return false;
    }
    const before = index === 0 ? '' : source[index - 1];
    const after = source[index + keyword.length] || '';
    if (before && /[A-Za-z0-9_]/.test(before)) {
        return false;
    }
    if (after && /[A-Za-z0-9_]/.test(after)) {
        return false;
    }
    return true;
}
function readQuoted(source, index) {
    const quote = source[index];
    let i = index;
    let out = '';
    while(i < source.length){
        const ch = source[i];
        out += ch;
        if (ch === '\\') {
            i++;
            if (i < source.length) {
                out += source[i];
            }
        } else if (ch === quote && i !== index) {
            i++;
            break;
        }
        i++;
    }
    return out;
}
function advanceQuoted(source, index) {
    const quote = source[index];
    let i = index + 1;
    while(i < source.length){
        const ch = source[i];
        if (ch === '\\') {
            i += 2;
            continue;
        }
        if (ch === quote) {
            return i + 1;
        }
        i++;
    }
    return source.length;
}
function readLineComment(source, index) {
    let i = index;
    let out = '';
    while(i < source.length){
        const ch = source[i];
        out += ch;
        i++;
        if (ch === '\n') {
            break;
        }
    }
    return out;
}
function advanceLineComment(source, index) {
    let i = index;
    while(i < source.length){
        const ch = source[i];
        i++;
        if (ch === '\n') {
            break;
        }
    }
    return i;
}
function readBlockComment(source, index) {
    let i = index;
    let out = '';
    while(i < source.length){
        const ch = source[i];
        out += ch;
        if (ch === '*' && source[i + 1] === '/') {
            out += '/';
            i += 2;
            break;
        }
        i++;
    }
    return out;
}
function advanceBlockComment(source, index) {
    let i = index;
    while(i < source.length){
        if (source[i] === '*' && source[i + 1] === '/') {
            return i + 2;
        }
        i++;
    }
    return source.length;
}
function readParenBlock(source, startIndex) {
    let i = startIndex;
    let out = '';
    let depth = 0;
    while(i < source.length){
        const ch = source[i];
        if (ch === "'" || ch === '"') {
            out += readQuoted(source, i);
            i = advanceQuoted(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '/') {
            out += readLineComment(source, i);
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '*') {
            out += readBlockComment(source, i);
            i = advanceBlockComment(source, i);
            continue;
        }
        if (ch === '#') {
            out += readLineComment(source, i);
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '(') {
            depth++;
            out += ch;
            i++;
            continue;
        }
        if (ch === ')') {
            if (depth === 0) {
                break;
            }
            depth--;
            out += ch;
            i++;
            continue;
        }
        out += ch;
        i++;
    }
    return {
        text: out,
        endIndex: i
    };
}
function stripParamTypes(params) {
    const parts = [];
    let buf = '';
    let depthParen = 0;
    let depthBracket = 0;
    let depthBrace = 0;
    let depthAngle = 0;
    let i = 0;
    while(i < params.length){
        const ch = params[i];
        if (ch === "'" || ch === '"') {
            buf += readQuoted(params, i);
            i = advanceQuoted(params, i);
            continue;
        }
        if (ch === '/' && params[i + 1] === '/') {
            buf += readLineComment(params, i);
            i = advanceLineComment(params, i);
            continue;
        }
        if (ch === '/' && params[i + 1] === '*') {
            buf += readBlockComment(params, i);
            i = advanceBlockComment(params, i);
            continue;
        }
        if (ch === '#') {
            buf += readLineComment(params, i);
            i = advanceLineComment(params, i);
            continue;
        }
        if (ch === '(') depthParen++;
        if (ch === ')') depthParen = Math.max(0, depthParen - 1);
        if (ch === '[') depthBracket++;
        if (ch === ']') depthBracket = Math.max(0, depthBracket - 1);
        if (ch === '{') depthBrace++;
        if (ch === '}') depthBrace = Math.max(0, depthBrace - 1);
        if (ch === '<') depthAngle++;
        if (ch === '>') depthAngle = Math.max(0, depthAngle - 1);
        if (ch === ',' && depthParen === 0 && depthBracket === 0 && depthBrace === 0 && depthAngle === 0) {
            parts.push(buf);
            buf = '';
            i++;
            continue;
        }
        buf += ch;
        i++;
    }
    parts.push(buf);
    return parts.map(stripParamType).join(',');
}
function stripParamType(segment) {
    const dollarIndex = findDollarIndex(segment);
    if (dollarIndex === -1) {
        return segment;
    }
    const before = segment.slice(0, dollarIndex);
    const after = segment.slice(dollarIndex);
    const leadingWsMatch = before.match(/^\s*/);
    const leadingWs = leadingWsMatch ? leadingWsMatch[0] : '';
    const tailMatch = before.match(/(\.\.\.\s*)?(&\s*)?$/);
    const tail = tailMatch ? `${tailMatch[1] || ''}${tailMatch[2] || ''}` : '';
    const typePart = before.slice(leadingWs.length, before.length - tail.length);
    if (!typePart.trim()) {
        return segment;
    }
    return leadingWs + tail + after;
}
function findDollarIndex(segment) {
    let i = 0;
    while(i < segment.length){
        const ch = segment[i];
        if (ch === "'" || ch === '"') {
            i = advanceQuoted(segment, i);
            continue;
        }
        if (ch === '/' && segment[i + 1] === '/') {
            i = advanceLineComment(segment, i);
            continue;
        }
        if (ch === '/' && segment[i + 1] === '*') {
            i = advanceBlockComment(segment, i);
            continue;
        }
        if (ch === '#') {
            i = advanceLineComment(segment, i);
            continue;
        }
        if (ch === '$') {
            return i;
        }
        i++;
    }
    return -1;
}
function stripReturnType(source, startIndex) {
    let i = startIndex;
    let wsBefore = '';
    while(i < source.length && /\s/.test(source[i])){
        wsBefore += source[i];
        i++;
    }
    if (source[i] !== ':') {
        return {
            text: wsBefore,
            index: i
        };
    }
    i++;
    while(i < source.length && /\s/.test(source[i])){
        i++;
    }
    let depthAngle = 0;
    while(i < source.length){
        const ch = source[i];
        if (ch === "'" || ch === '"') {
            i = advanceQuoted(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '/') {
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '*') {
            i = advanceBlockComment(source, i);
            continue;
        }
        if (ch === '#') {
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '<') depthAngle++;
        if (ch === '>') depthAngle = Math.max(0, depthAngle - 1);
        if (depthAngle === 0 && (ch === '{' || ch === ';')) {
            break;
        }
        i++;
    }
    let wsAfter = '';
    while(i < source.length && /\s/.test(source[i])){
        wsAfter += source[i];
        i++;
    }
    return {
        text: wsBefore + wsAfter,
        index: i
    };
}
function moduleIdFromRel(rel) {
    const normalized = String(rel).replace(/\\/g, '/');
    if (normalized.endsWith('/index.phpx')) {
        return normalized.replace(/\/index\.phpx$/, '');
    }
    return normalized.replace(/\.phpx$/, '');
}
function stripPhpTagsInline(line) {
    let out = String(line);
    out = out.replace(/<\?(?:php)?/gi, '');
    out = out.replace(/\?>/g, '');
    return out;
}
function sanitizePhpIdentifier(segment) {
    let clean = String(segment || '').replace(/[^A-Za-z0-9_]/g, '_');
    if (!clean) clean = '_';
    if (/^[0-9]/.test(clean)) clean = '_' + clean;
    return clean;
}
function buildModuleNamespace(moduleId) {
    const parts = String(moduleId || '').split('/').filter(Boolean);
    const safe = parts.length ? parts.map(sanitizePhpIdentifier) : [
        '_'
    ];
    return '__phpx_' + safe.join('_');
}
function escapeRegex(value) {
    return String(value).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function stripPhpCommentsAndStrings(source) {
    const input = String(source);
    let out = '';
    let i = 0;
    while(i < input.length){
        const ch = input[i];
        if (ch === "'" || ch === '"') {
            const quote = ch;
            out += ' ';
            i++;
            while(i < input.length){
                const c = input[i];
                if (c === '\\') {
                    out += c === '\n' ? '\n' : ' ';
                    i += 2;
                    continue;
                }
                if (c === quote) {
                    out += ' ';
                    i++;
                    break;
                }
                out += c === '\n' ? '\n' : ' ';
                i++;
            }
            continue;
        }
        if (ch === '/' && input[i + 1] === '/') {
            const start = i;
            const end = advanceLineComment(input, i);
            for(let j = start; j < end; j++){
                out += input[j] === '\n' ? '\n' : ' ';
            }
            i = end;
            continue;
        }
        if (ch === '/' && input[i + 1] === '*') {
            const start = i;
            const end = advanceBlockComment(input, i);
            for(let j = start; j < end; j++){
                out += input[j] === '\n' ? '\n' : ' ';
            }
            i = end;
            continue;
        }
        if (ch === '#') {
            const start = i;
            const end = advanceLineComment(input, i);
            for(let j = start; j < end; j++){
                out += input[j] === '\n' ? '\n' : ' ';
            }
            i = end;
            continue;
        }
        if (ch === '<' && input.slice(i, i + 3) === '<<<') {
            const start = i;
            let j = i + 3;
            while(j < input.length && /\s/.test(input[j])){
                j++;
            }
            let quote = null;
            if (input[j] === "'" || input[j] === '"') {
                quote = input[j];
                j++;
            }
            let ident = '';
            while(j < input.length && /[A-Za-z0-9_]/.test(input[j])){
                ident += input[j];
                j++;
            }
            if (quote && input[j] === quote) {
                j++;
            }
            while(j < input.length && input[j] !== '\n'){
                j++;
            }
            if (j < input.length) j++;
            if (ident) {
                let k = j;
                while(k < input.length){
                    const lineStart = k === 0 || input[k - 1] === '\n';
                    if (lineStart && input.slice(k, k + ident.length) === ident) {
                        k += ident.length;
                        if (input[k] === ';') k++;
                        while(k < input.length && input[k] !== '\n'){
                            k++;
                        }
                        if (k < input.length) k++;
                        for(let idx = start; idx < k; idx++){
                            out += input[idx] === '\n' ? '\n' : ' ';
                        }
                        i = k;
                        break;
                    }
                    k++;
                }
                if (i !== k) {
                    for(let idx = start; idx < j; idx++){
                        out += input[idx] === '\n' ? '\n' : ' ';
                    }
                    i = j;
                }
            } else {
                for(let idx = start; idx < j; idx++){
                    out += input[idx] === '\n' ? '\n' : ' ';
                }
                i = j;
            }
            continue;
        }
        out += ch;
        i++;
    }
    return out;
}
function isJsxNameStart(ch) {
    return ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z' || ch === '_';
}
function splitFrontmatter(source) {
    const raw = String(source);
    const lines = raw.split(/\r?\n/);
    if (lines.length === 0) return null;
    if (lines[0].charCodeAt(0) === 0xfeff) {
        lines[0] = lines[0].slice(1);
    }
    let i = 0;
    while(i < lines.length && lines[i].trim() === ''){
        i++;
    }
    if (i >= lines.length || lines[i].trim() !== '---') return null;
    const startLine = i;
    i++;
    const frontmatterLines = [];
    for(; i < lines.length; i++){
        if (lines[i].trim() === '---') {
            const endLine = i;
            const templateStartLine = i + 1;
            return {
                frontmatter: frontmatterLines.join('\n'),
                template: lines.slice(templateStartLine).join('\n'),
                startLine,
                endLine,
                templateStartLine
            };
        }
        frontmatterLines.push(lines[i]);
    }
    throw new Error('Unterminated PHPX frontmatter (missing closing ---).');
}
function skipTemplateWhitespace(input, i) {
    while(i < input.length && /\s/.test(input[i])){
        i++;
    }
    return i;
}
function readBalanced(input, i, openChar, closeChar) {
    if (input[i] !== openChar) {
        return null;
    }
    let depth = 1;
    let j = i + 1;
    let inSingle = false;
    let inDouble = false;
    let inBacktick = false;
    while(j < input.length){
        const ch = input[j];
        if (inSingle) {
            if (ch === '\\\\') {
                j += 2;
                continue;
            }
            if (ch === "'") inSingle = false;
            j++;
            continue;
        }
        if (inDouble) {
            if (ch === '\\\\') {
                j += 2;
                continue;
            }
            if (ch === '"') inDouble = false;
            j++;
            continue;
        }
        if (inBacktick) {
            if (ch === '\\\\') {
                j += 2;
                continue;
            }
            if (ch === '`') inBacktick = false;
            j++;
            continue;
        }
        if (ch === "'") {
            inSingle = true;
            j++;
            continue;
        }
        if (ch === '"') {
            inDouble = true;
            j++;
            continue;
        }
        if (ch === '`') {
            inBacktick = true;
            j++;
            continue;
        }
        if (ch === openChar) {
            depth++;
        } else if (ch === closeChar) {
            depth--;
            if (depth === 0) {
                return {
                    content: input.slice(i + 1, j),
                    end: j + 1
                };
            }
        }
        j++;
    }
    return null;
}
function parseForeachHeader(raw) {
    const trimmed = raw.trim();
    const match = trimmed.match(/^(.*?)\s+as\s+(&?\$[A-Za-z_][A-Za-z0-9_]*)(?:\s*=>\s*(&?\$[A-Za-z_][A-Za-z0-9_]*))?\s*$/s);
    if (!match) {
        throw new Error('Invalid foreach header in PHPX template.');
    }
    const collection = match[1].trim();
    const first = match[2].replace(/^&/, '');
    const second = match[3] ? match[3].replace(/^&/, '') : '';
    if (second) {
        return {
            collection,
            key: first,
            value: second
        };
    }
    return {
        collection,
        key: '',
        value: first
    };
}
function wrapTemplateBody(body) {
    const trimmed = body.trim();
    if (!trimmed) return 'false';
    return `<__fragment__>\n${body}\n</__fragment__>`;
}
function transformTemplate(input) {
    let out = '';
    let i = 0;
    let usesEach = false;
    let usesEachKv = false;
    while(i < input.length){
        const ch = input[i];
        if (ch !== '{') {
            out += ch;
            i++;
            continue;
        }
        let j = skipTemplateWhitespace(input, i + 1);
        if (input.startsWith('if', j) && !/[A-Za-z0-9_]/.test(input[j + 2] || '')) {
            j += 2;
            j = skipTemplateWhitespace(input, j);
            if (input[j] !== '(') {
                out += '{';
                i++;
                continue;
            }
            const condBlock = readBalanced(input, j, '(', ')');
            if (!condBlock) {
                out += '{';
                i++;
                continue;
            }
            j = skipTemplateWhitespace(input, condBlock.end);
            if (input[j] !== '{') {
                out += '{';
                i++;
                continue;
            }
            const bodyBlock = readBalanced(input, j, '{', '}');
            if (!bodyBlock) {
                out += '{';
                i++;
                continue;
            }
            const bodyTransformed = transformTemplate(bodyBlock.content);
            if (bodyTransformed.usesEach) usesEach = true;
            if (bodyTransformed.usesEachKv) usesEachKv = true;
            let expr = `(${condBlock.content.trim()} ? ${wrapTemplateBody(bodyTransformed.code)} : `;
            let depth = 1;
            let cursor = skipTemplateWhitespace(input, bodyBlock.end);
            let closed = false;
            while(cursor < input.length){
                if (input.startsWith('else', cursor) && !/[A-Za-z0-9_]/.test(input[cursor + 4] || '')) {
                    cursor += 4;
                    cursor = skipTemplateWhitespace(input, cursor);
                    if (input.startsWith('if', cursor) && !/[A-Za-z0-9_]/.test(input[cursor + 2] || '')) {
                        cursor += 2;
                        cursor = skipTemplateWhitespace(input, cursor);
                        if (input[cursor] !== '(') break;
                        const elseCond = readBalanced(input, cursor, '(', ')');
                        if (!elseCond) break;
                        cursor = skipTemplateWhitespace(input, elseCond.end);
                        if (input[cursor] !== '{') break;
                        const elseBody = readBalanced(input, cursor, '{', '}');
                        if (!elseBody) break;
                        const elseBodyTransformed = transformTemplate(elseBody.content);
                        if (elseBodyTransformed.usesEach) usesEach = true;
                        if (elseBodyTransformed.usesEachKv) usesEachKv = true;
                        expr += `(${elseCond.content.trim()} ? ${wrapTemplateBody(elseBodyTransformed.code)} : `;
                        depth++;
                        cursor = skipTemplateWhitespace(input, elseBody.end);
                        continue;
                    }
                    if (input[cursor] !== '{') break;
                    const elseBody = readBalanced(input, cursor, '{', '}');
                    if (!elseBody) break;
                    const elseBodyTransformed = transformTemplate(elseBody.content);
                    if (elseBodyTransformed.usesEach) usesEach = true;
                    if (elseBodyTransformed.usesEachKv) usesEachKv = true;
                    expr += `${wrapTemplateBody(elseBodyTransformed.code)}` + ')'.repeat(depth);
                    cursor = skipTemplateWhitespace(input, elseBody.end);
                    closed = true;
                    break;
                }
                break;
            }
            if (!closed) {
                expr += 'false' + ')'.repeat(depth);
            }
            let closeIdx = skipTemplateWhitespace(input, cursor);
            if (input[closeIdx] !== '}') {
                out += '{';
                i++;
                continue;
            }
            out += `{ ${expr} }`;
            i = closeIdx + 1;
            continue;
        }
        if (input.startsWith('foreach', j) && !/[A-Za-z0-9_]/.test(input[j + 7] || '')) {
            j += 7;
            j = skipTemplateWhitespace(input, j);
            if (input[j] !== '(') {
                out += '{';
                i++;
                continue;
            }
            const headerBlock = readBalanced(input, j, '(', ')');
            if (!headerBlock) {
                out += '{';
                i++;
                continue;
            }
            const header = parseForeachHeader(headerBlock.content);
            j = skipTemplateWhitespace(input, headerBlock.end);
            if (input[j] !== '{') {
                out += '{';
                i++;
                continue;
            }
            const bodyBlock = readBalanced(input, j, '{', '}');
            if (!bodyBlock) {
                out += '{';
                i++;
                continue;
            }
            const bodyTransformed = transformTemplate(bodyBlock.content);
            if (bodyTransformed.usesEach) usesEach = true;
            if (bodyTransformed.usesEachKv) usesEachKv = true;
            let helper = '__component_each';
            let args = `${header.collection}, fn(${header.value}) => ${wrapTemplateBody(bodyTransformed.code)}`;
            if (header.key) {
                helper = '__component_each_kv';
                args = `${header.collection}, fn(${header.value}, ${header.key}) => ${wrapTemplateBody(bodyTransformed.code)}`;
                usesEachKv = true;
            } else {
                usesEach = true;
            }
            let cursor = skipTemplateWhitespace(input, bodyBlock.end);
            if (input[cursor] !== '}') {
                out += '{';
                i++;
                continue;
            }
            out += `{ ${helper}(${args}) }`;
            i = cursor + 1;
            continue;
        }
        const exprBlock = readBalanced(input, i, '{', '}');
        if (!exprBlock) {
            out += ch;
            i++;
            continue;
        }
        out += `{${exprBlock.content}}`;
        i = exprBlock.end;
    }
    return {
        code: out,
        usesEach,
        usesEachKv
    };
}
function extractDoctype(template) {
    const match = template.match(/^\s*<!doctype\s+html\s*>\s*/i);
    if (!match) {
        return {
            doctype: '',
            template
        };
    }
    return {
        doctype: '<!doctype html>',
        template: template.slice(match[0].length)
    };
}
function compileFrontmatterTemplate(source, mode) {
    const frontmatter = splitFrontmatter(source);
    if (!frontmatter) {
        return {
            code: source,
            usesTemplate: false
        };
    }
    if (frontmatter.template.trim() === '') {
        return {
            code: frontmatter.frontmatter,
            usesTemplate: false
        };
    }
    if (mode === 'module') {
        if (/\bexport\s+/.test(frontmatter.frontmatter)) {
            throw new Error('PHPX frontmatter templates do not support export statements. Use a non-template module for exports.');
        }
        if (/\bfunction\s+Component\b/.test(frontmatter.frontmatter)) {
            throw new Error('PHPX frontmatter templates reserve the Component name. Rename your function or remove it.');
        }
    }
    const templateTransform = transformTemplate(frontmatter.template);
    const doctypeInfo = extractDoctype(templateTransform.code);
    let generated = '';
    if (doctypeInfo.doctype && mode === 'entry') {
        generated += `echo "${doctypeInfo.doctype}\\n";\n`;
    }
    if (doctypeInfo.template.trim() !== '') {
        if (mode === 'module') {
            generated += "export function Component($props) {\n";
            if (frontmatter.frontmatter.trim() !== '') {
                generated += `${frontmatter.frontmatter}\n`;
            }
            generated += `  return <__fragment__>\n${doctypeInfo.template}\n</__fragment__>;\n`;
            generated += "}\n";
            return {
                code: generated,
                usesTemplate: true
            };
        }
        generated += `$__phpx_template = <__fragment__>\n${doctypeInfo.template}\n</__fragment__>;\n`;
        generated += "echo renderToString($__phpx_template);\n";
    }
    let code = frontmatter.frontmatter;
    if (code && !code.endsWith('\n')) {
        code += '\n';
    }
    code += generated;
    return {
        code,
        usesTemplate: true
    };
}
function hasJsxSyntax(source) {
    const clean = stripPhpCommentsAndStrings(stripPhpTags(source));
    for(let i = 0; i < clean.length - 1; i++){
        if (clean[i] !== '<') continue;
        const next = clean[i + 1];
        if (next === '>') return true;
        if (next === '/') {
            const next2 = clean[i + 2] || '';
            if (next2 === '>' || isJsxNameStart(next2) || next2 === '\\') {
                return true;
            }
            continue;
        }
        if (isJsxNameStart(next) || next === '\\') {
            return true;
        }
    }
    return false;
}
function ensureJsxRuntimeImports(imports, source, filePath) {
    if (!String(filePath || '').endsWith('.phpx')) return false;
    if (!hasJsxSyntax(source)) return false;
    const needs = [
        'jsx',
        'jsxs'
    ];
    for (const name of needs){
        if (imports.some((spec)=>spec.local === name)) continue;
        imports.push({
            imported: name,
            local: name,
            from: 'component/core',
            kind: '',
            synthetic: true
        });
    }
    return true;
}
function detectCoreRuntimeDeps(source, filePath) {
    if (!String(filePath || '').endsWith('.phpx')) return [];
    const clean = stripPhpCommentsAndStrings(stripPhpTags(source));
    const deps = new Set();
    if (/\bOption\b/.test(clean)) deps.add('core/option');
    if (/\bResult\b/.test(clean)) deps.add('core/result');
    return Array.from(deps);
}
function ensureTemplateRuntimeImports(imports, source, filePath, mode) {
    if (!String(filePath || '').endsWith('.phpx')) return false;
    const frontmatter = splitFrontmatter(source);
    if (!frontmatter || frontmatter.template.trim() === '') return false;
    const templateTransform = transformTemplate(frontmatter.template);
    if (templateTransform.usesEach) {
        if (!imports.some((spec)=>spec.local === '__component_each')) {
            imports.push({
                imported: '__component_each',
                local: '__component_each',
                from: 'component/core',
                kind: '',
                synthetic: true
            });
        }
    }
    if (templateTransform.usesEachKv) {
        if (!imports.some((spec)=>spec.local === '__component_each_kv')) {
            imports.push({
                imported: '__component_each_kv',
                local: '__component_each_kv',
                from: 'component/core',
                kind: '',
                synthetic: true
            });
        }
    }
    if (mode !== 'module') {
        if (!imports.some((spec)=>spec.local === 'renderToString')) {
            imports.push({
                imported: 'renderToString',
                local: 'renderToString',
                from: 'component/dom',
                kind: '',
                synthetic: true
            });
        }
    }
    return true;
}
function parseTopLevelImports(source, filePath, modulesRoot, mode = 'entry') {
    const raw = String(source);
    const frontmatter = splitFrontmatter(raw);
    const rawLines = raw.split(/\r?\n/);
    const clean = stripPhpCommentsAndStrings(raw);
    if (String(filePath || '').endsWith('.phpx') && /\bnamespace\b/.test(clean)) {
        throw new Error(`phpx namespaces are not supported yet (${filePath}).`);
    }
    const cleanLines = clean.split(/\r?\n/);
    const importLines = new Set();
    const imports = [];
    let sawCode = false;
    const scanEnd = frontmatter ? frontmatter.endLine : rawLines.length;
    for (let i = 0; i < scanEnd; i++){
        if (frontmatter && (i === frontmatter.startLine || i === frontmatter.endLine)) {
            continue;
        }
        const rawLine = rawLines[i] || '';
        let cleanLine = cleanLines[i] || '';
        cleanLine = stripPhpTagsInline(cleanLine).trim();
        if (!cleanLine) continue;
        if (cleanLine.startsWith('import ')) {
            if (sawCode) {
                throw new Error(`phpx import must appear before other code in ${filePath}.`);
            }
            if (!modulesRoot) {
                throw new Error(`phpx import requires php_modules/ (missing for ${filePath}).`);
            }
            const normalizedLine = stripPhpTagsInline(rawLine);
            const parsed = parseImportLine(normalizedLine, filePath, modulesRoot);
            if (!parsed) {
                throw new Error(`Invalid import in ${filePath}: ${rawLine}`);
            }
            imports.push(...parsed);
            importLines.add(i);
            continue;
        }
        sawCode = true;
    }
    const hasJsx = ensureJsxRuntimeImports(imports, raw, filePath);
    ensureTemplateRuntimeImports(imports, raw, filePath, mode);
    if (imports.length === 0) {
        return {
            imports: [],
            strippedSource: raw
        };
    }
    const strippedLines = rawLines.map((line, idx)=>importLines.has(idx) ? '' : line);
    let strippedSource = strippedLines.join('\n');
    const compiledTemplate = compileFrontmatterTemplate(strippedSource, mode);
    strippedSource = compiledTemplate.code;
    const searchable = stripPhpCommentsAndStrings(strippedSource);
    for (const spec of imports){
        if (spec.synthetic) continue;
        if (hasJsx && spec.from === 'component/core' && (spec.local === 'jsx' || spec.local === 'jsxs')) {
            continue;
        }
        if (!isImportedFunctionUsed(searchable, spec.local)) {
            throw new Error(`Unused import '${spec.local}' in ${filePath}.`);
        }
    }
    return {
        imports,
        strippedSource
    };
}
function collectFunctionDeclarations(source) {
    const decls = new Set();
    const pattern = /\bfunction\s+&?\s*([A-Za-z_][A-Za-z0-9_]*)\s*\(/g;
    let match;
    while((match = pattern.exec(source)) !== null){
        decls.add(match[1]);
    }
    return decls;
}
function isImportedFunctionUsed(source, name) {
    if (isImportedAsJsxTag(source, name)) return true;
    const pattern = new RegExp(`\\b${escapeRegex(name)}\\s*\\(`, 'g');
    let match;
    while((match = pattern.exec(source)) !== null){
        const idx = match.index;
        let j = idx - 1;
        while(j >= 0 && /\s/.test(source[j])){
            j--;
        }
        if (j >= 1 && source[j - 1] === '-' && source[j] === '>') continue;
        if (j >= 1 && source[j - 1] === ':' && source[j] === ':') continue;
        if (source[j] === '\\') continue;
        let k = j;
        while(k >= 0 && /[A-Za-z0-9_]/.test(source[k])){
            k--;
        }
        const prevWord = source.slice(k + 1, j + 1);
        if (prevWord === 'function' || prevWord === 'fn' || prevWord === 'use' || prevWord === 'new') {
            continue;
        }
        return true;
    }
    return false;
}
function isImportedAsJsxTag(source, name) {
    const pattern = new RegExp(`<\\/?\\s*${escapeRegex(name)}\\b`, 'g');
    return pattern.test(source);
}
function buildExportAliasFunction(exported, targetNamespace, targetName) {
    const params = [
        '$a',
        '$b',
        '$c',
        '$d',
        '$e',
        '$f'
    ];
    let out = `function ${exported}(${params.join(', ')}) {`;
    out += " $argc = func_num_args();";
    out += ` if ($argc === 0) return \\${targetNamespace}\\${targetName}();`;
    out += ` if ($argc === 1) return \\${targetNamespace}\\${targetName}($a);`;
    out += ` if ($argc === 2) return \\${targetNamespace}\\${targetName}($a, $b);`;
    out += ` if ($argc === 3) return \\${targetNamespace}\\${targetName}($a, $b, $c);`;
    out += ` if ($argc === 4) return \\${targetNamespace}\\${targetName}($a, $b, $c, $d);`;
    out += ` if ($argc === 5) return \\${targetNamespace}\\${targetName}($a, $b, $c, $d, $e);`;
    out += ` if ($argc === 6) return \\${targetNamespace}\\${targetName}($a, $b, $c, $d, $e, $f);`;
    out += ` return \\${targetNamespace}\\${targetName}($a, $b, $c, $d, $e, $f);`;
    out += " }\n";
    return out;
}
function buildPhpImportWrappers(imports, options = {}) {
    const useRegistry = options.useRegistry === true;
    let out = '';
    const seen = new Set();
    for (const spec of imports){
        if (spec.kind === 'wasm') continue;
        if (seen.has(spec.local)) continue;
        seen.add(spec.local);
        if (useRegistry) {
            out += buildRegistryImportWrapper(spec.local, spec.from, spec.imported);
        } else {
            const targetNs = buildModuleNamespace(spec.from);
            out += buildLazyExportWrapper(spec.local, targetNs, spec.imported, spec.from);
        }
    }
    return out;
}

function buildRegistryImportWrapper(local, moduleId, exportName) {
    const params = [
        '$a',
        '$b',
        '$c',
        '$d',
        '$e',
        '$f'
    ];
    let out = `function ${local}(${params.join(', ')}) {`;
    out += ` $fn = phpx_import('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}');`;
    out += " $argc = func_num_args();";
    out += " $args = array();";
    out += " if ($argc >= 1) { $args[] = $a; }";
    out += " if ($argc >= 2) { $args[] = $b; }";
    out += " if ($argc >= 3) { $args[] = $c; }";
    out += " if ($argc >= 4) { $args[] = $d; }";
    out += " if ($argc >= 5) { $args[] = $e; }";
    out += " if ($argc >= 6) { $args[] = $f; }";
    out += " return call_user_func_array($fn, $args);";
    out += " }\n";
    return out;
}
function buildLazyExportWrapper(local, targetNamespace, targetName, moduleId) {
    const params = [
        '$a',
        '$b',
        '$c',
        '$d',
        '$e',
        '$f'
    ];
    let out = `function ${local}(${params.join(', ')}) {`;
    out += ` __phpx_load('${escapePhpString(moduleId)}');`;
    out += " $argc = func_num_args();";
    out += ` if ($argc === 0) return \\${targetNamespace}\\${targetName}();`;
    out += ` if ($argc === 1) return \\${targetNamespace}\\${targetName}($a);`;
    out += ` if ($argc === 2) return \\${targetNamespace}\\${targetName}($a, $b);`;
    out += ` if ($argc === 3) return \\${targetNamespace}\\${targetName}($a, $b, $c);`;
    out += ` if ($argc === 4) return \\${targetNamespace}\\${targetName}($a, $b, $c, $d);`;
    out += ` if ($argc === 5) return \\${targetNamespace}\\${targetName}($a, $b, $c, $d, $e);`;
    out += ` if ($argc === 6) return \\${targetNamespace}\\${targetName}($a, $b, $c, $d, $e, $f);`;
    out += ` return \\${targetNamespace}\\${targetName}($a, $b, $c, $d, $e, $f);`;
    out += " }\n";
    return out;
}
function buildWasmImportWrapper(local, moduleId, exportName) {
    const params = [
        '$a',
        '$b',
        '$c',
        '$d',
        '$e',
        '$f'
    ];
    let out = `function ${local}(${params.join(', ')}) {`;
    out += " $argc = func_num_args();";
    out += ` if ($argc === 0) return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}');`;
    out += ` if ($argc === 1) return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}', $a);`;
    out += ` if ($argc === 2) return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}', $a, $b);`;
    out += ` if ($argc === 3) return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}', $a, $b, $c);`;
    out += ` if ($argc === 4) return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}', $a, $b, $c, $d);`;
    out += ` if ($argc === 5) return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}', $a, $b, $c, $d, $e);`;
    out += ` if ($argc === 6) return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}', $a, $b, $c, $d, $e, $f);`;
    out += ` return __deka_wasm_call('${escapePhpString(moduleId)}', '${escapePhpString(exportName)}', $a, $b, $c, $d, $e, $f);`;
    out += " }\n";
    return out;
}
function buildWasmImportWrappers(imports) {
    let out = '';
    const seen = new Set();
    for (const spec of imports){
        if (spec.kind !== 'wasm') continue;
        if (seen.has(spec.local)) continue;
        seen.add(spec.local);
        out += buildWasmImportWrapper(spec.local, spec.from, spec.imported);
    }
    return out;
}
function compilePhpxSource(source, moduleId, options = {}) {
    let working = stripPhpTags(source);
    const compiledTemplate = compileFrontmatterTemplate(working, 'module');
    working = compiledTemplate.code;
    if (/\bnamespace\b/.test(working)) {
        throw new Error(`phpx namespaces are not supported yet (${moduleId}).`);
    }
    const exports = [];
    const exportRegex = /export\s+function\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(/g;
    working = working.replace(exportRegex, (_match, name)=>{
        exports.push(name);
        return `function ${name}(`;
    });
    const stripTypes = options.stripTypes !== false;
    if (stripTypes) {
        working = stripPhpxTypes(working);
        working = stripInlineTypes(working);
    }
    if (/export\s/.test(working)) {
        throw new Error(`Unsupported export syntax in ${moduleId}.`);
    }
    const trimmed = working.trim();
    const prefix = trimmed ? `${PHPX_INTERNAL_MARKER}\n` : `${PHPX_INTERNAL_MARKER}`;
    return {
        code: prefix + trimmed + '\n',
        exports
    };
}

function compilePhpxSourceForTypes(source, moduleId) {
    return compilePhpxSource(source, moduleId, {
        stripTypes: false
    });
}

function toPhpLiteral(value) {
    if (value === null || value === undefined) {
        return 'null';
    }
    const type = typeof value;
    if (type === 'string') {
        return `'${escapePhpString(value)}'`;
    }
    if (type === 'number') {
        if (!Number.isFinite(value)) {
            return '0';
        }
        return String(value);
    }
    if (type === 'boolean') {
        return value ? 'true' : 'false';
    }
    if (Array.isArray(value)) {
        return `array(${value.map((item)=>toPhpLiteral(item)).join(', ')})`;
    }
    if (type === 'object') {
        const entries = Object.entries(value);
        if (entries.length === 0) {
            return 'array()';
        }
        const parts = entries.map(([key, val])=>`'${escapePhpString(key)}' => ${toPhpLiteral(val)}`);
        return `array(${parts.join(', ')})`;
    }
    return 'null';
}

function buildModuleTypeInfo(source, filePath, moduleId) {
    if (typeof op_php_parse_phpx_types !== 'function') {
        return null;
    }
    const compiled = compilePhpxSourceForTypes(source, moduleId);
    try {
        const typeInfo = op_php_parse_phpx_types(compiled.code, filePath);
        return qualifyTypeInfoForModule(typeInfo, moduleId);
    } catch (err) {
        throw new Error(`Failed to parse PHPX types for ${filePath}: ${err?.message || err}`);
    }
}

function qualifyTypeInfoForModule(typeInfo, moduleId) {
    if (!typeInfo || !typeInfo.structs) return typeInfo;
    const moduleNamespace = buildModuleNamespace(moduleId);
    const prefix = `${moduleNamespace}\\\\`;
    const structNames = new Set(Object.keys(typeInfo.structs || {}));
    const normalizeStructFieldName = (name)=>{
        if (typeof name !== 'string') return name;
        return name.startsWith('$') ? name.slice(1) : name;
    };

    const qualifyType = (ty)=>{
        if (!ty || typeof ty !== 'object') return ty;
        switch(ty.kind){
            case 'struct': {
                let name = ty.name;
                if (structNames.has(name) && !String(name).includes('\\')) {
                    name = prefix + name;
                }
                const fields = Array.isArray(ty.fields) ? ty.fields.map((field)=>({
                    ...field,
                    name: normalizeStructFieldName(field.name),
                    type: qualifyType(field.type)
                })) : ty.fields;
                return {
                    ...ty,
                    name,
                    fields
                };
            }
            case 'object_shape':
                return {
                    ...ty,
                    fields: Array.isArray(ty.fields) ? ty.fields.map((field)=>({
                        ...field,
                        type: qualifyType(field.type)
                    })) : ty.fields
                };
            case 'array':
                return {
                    ...ty,
                    element: ty.element ? qualifyType(ty.element) : ty.element
                };
            case 'option':
                return {
                    ...ty,
                    inner: ty.inner ? qualifyType(ty.inner) : ty.inner
                };
            case 'result':
                return {
                    ...ty,
                    ok: ty.ok ? qualifyType(ty.ok) : ty.ok,
                    err: ty.err ? qualifyType(ty.err) : ty.err
                };
            case 'union':
                return {
                    ...ty,
                    types: Array.isArray(ty.types) ? ty.types.map(qualifyType) : ty.types
                };
            case 'applied':
                return {
                    ...ty,
                    args: Array.isArray(ty.args) ? ty.args.map(qualifyType) : ty.args
                };
            default:
                return ty;
        }
    };

    const qualifiedStructs = {};
    for (const [name, struct] of Object.entries(typeInfo.structs || {})){
        const qualifiedName = String(name).includes('\\') ? name : prefix + name;
        qualifiedStructs[qualifiedName] = {
            ...struct,
            fields: Array.isArray(struct.fields) ? struct.fields.map((field)=>({
                ...field,
                name: normalizeStructFieldName(field.name),
                type: qualifyType(field.type)
            })) : struct.fields
        };
    }

    const qualifiedFunctions = {};
    for (const [name, fn] of Object.entries(typeInfo.functions || {})){
        qualifiedFunctions[name] = {
            ...fn,
            params: Array.isArray(fn.params) ? fn.params.map((param)=>({
                ...param,
                type: param.type ? qualifyType(param.type) : param.type
            })) : fn.params,
            return: fn.return ? qualifyType(fn.return) : fn.return
        };
    }

    return {
        ...typeInfo,
        structs: qualifiedStructs,
        functions: qualifiedFunctions
    };
}

function buildStructFromHelpers(typeInfo, moduleNamespace) {
    if (!typeInfo || !typeInfo.structs) return '';
    const entries = Object.entries(typeInfo.structs || {});
    if (entries.length === 0) return '';
    let code = '';
    code += "if (!isset($GLOBALS['__PHPX_STRUCT_FROM'])) { $GLOBALS['__PHPX_STRUCT_FROM'] = array(); }\n";
    for (const [name, struct] of entries){
        const fnName = `__phpx_struct_from_${sanitizePhpIdentifier(name)}`;
        const classLiteral = escapePhpString(name);
        code += `if (!function_exists('${fnName}')) { function ${fnName}($value) {\n`;
        code += "  if (!is_array($value) && !is_object($value)) { return $value; }\n";
        code += `  if (is_object($value) && function_exists('get_class') && get_class($value) === '${classLiteral}') { return $value; }\n`;
        code += "  if (!function_exists('__phpx_struct_new')) { return $value; }\n";
        code += "  $data = is_array($value) ? $value : get_object_vars($value);\n";
        code += `  $obj = __phpx_struct_new('${classLiteral}');\n`;
        const fields = Array.isArray(struct.fields) ? struct.fields : [];
        for (const field of fields){
            if (!field || typeof field.name !== 'string') continue;
            const fieldName = field.name;
            const fieldLiteral = escapePhpString(fieldName);
            const fieldType = toPhpLiteral(field.type);
            code += `  if (__phpx_array_has_key($data, '${fieldLiteral}')) { $val = __phpx_coerce_value(${fieldType}, $data['${fieldLiteral}']); $obj->${fieldName} = $val; }\n`;
        }
        code += "  return $obj;\n";
        code += "} }\n";
        const qualifiedFn = moduleNamespace ? `${moduleNamespace}\\\\${fnName}` : fnName;
        code += `$GLOBALS['__PHPX_STRUCT_FROM']['${classLiteral}'] = '${escapePhpString(qualifiedFn)}';\n`;
    }
    return code;
}

function buildExportWrappers(moduleId, moduleNamespace, exports, typeInfo) {
    if (!exports.length) return {
        code: '',
        exportTargets: new Map()
    };
    const exportTargets = new Map();
    const safeModule = sanitizePhpIdentifier(moduleId);
    const typeVar = `$__phpx_types_${safeModule}`;
    const types = {};
    if (typeInfo && typeInfo.functions) {
        for (const name of exports){
            if (typeInfo.functions[name]) {
                types[name] = typeInfo.functions[name];
            }
        }
    }
    let code = '';
    code += `${typeVar} = ${toPhpLiteral(types)};\n`;
    code += `if (!empty(${typeVar})) { __phpx_register_types('${escapePhpString(moduleId)}', ${typeVar}); }\n`;
    code += buildStructFromHelpers(typeInfo, moduleNamespace);
    for (const name of exports){
        const wrapperName = `__phpx_wrap_${name}`;
        exportTargets.set(name, wrapperName);
        const escapedModuleId = escapePhpString(moduleId);
        const escapedName = escapePhpString(name);
        const typesAccess = `(isset($GLOBALS['__PHPX_TYPES']) && __phpx_array_has_key($GLOBALS['__PHPX_TYPES'], '${escapedModuleId}') ? $GLOBALS['__PHPX_TYPES']['${escapedModuleId}'] : null)`;
        const sigAccess = `((${typesAccess} && __phpx_array_has_key(${typesAccess}, '${escapedName}')) ? ${typesAccess}['${escapedName}'] : null)`;
        const params = [
            '$a',
            '$b',
            '$c',
            '$d',
            '$e',
            '$f'
        ];
        const target = `${moduleNamespace}\\${name}`;
        code += `function ${wrapperName}(${params.join(', ')}) {`;
        code += " $argc = func_num_args();";
        code += " $args = array();";
        code += " if ($argc >= 1) { $args[] = $a; }";
        code += " if ($argc >= 2) { $args[] = $b; }";
        code += " if ($argc >= 3) { $args[] = $c; }";
        code += " if ($argc >= 4) { $args[] = $d; }";
        code += " if ($argc >= 5) { $args[] = $e; }";
        code += " if ($argc >= 6) { $args[] = $f; }";
        code += ` $sig = ${sigAccess};`;
        code += " if ($sig) { $args = \\__phpx_coerce_args($sig, $args); }";
        code += ` $result = call_user_func_array('${escapePhpString(target)}', $args);`;
        code += " if ($sig && \\__phpx_array_has_key($sig, 'return')) { $result = \\__phpx_coerce_return($sig['return'], $result); }";
        code += " $result = \\__phpx_to_php($result);";
        code += " return $result;";
        code += " }\n";
    }
    return {
        code,
        exportTargets
    };
}
function resolveImportTarget(specifier, currentFilePath, modulesRoot) {
    const raw = String(specifier);
    const isRelative = raw.startsWith('.');
    const baseDir = isRelative ? globalThis.path.dirname(currentFilePath) : modulesRoot;
    const basePath = globalThis.path.resolve(baseDir, raw);
    const candidates = [];
    if (raw.endsWith('.phpx')) {
        candidates.push(basePath);
    } else {
        candidates.push(basePath + '.phpx');
        candidates.push(globalThis.path.join(basePath, 'index.phpx'));
    }
    if (!isRelative) {
        candidates.push(globalThis.path.resolve(modulesRoot, raw + '.phpx'));
        candidates.push(globalThis.path.resolve(modulesRoot, raw, 'index.phpx'));
    }
    for (const candidate of candidates){
        if (globalThis.fs.existsSync(candidate)) {
            const rel = globalThis.path.relative(modulesRoot, candidate).replace(/\\/g, '/');
            const moduleId = moduleIdFromRel(rel);
            return {
                filePath: candidate,
                moduleId
            };
        }
    }
    throw new Error(`Missing phpx module '${raw}' (imported from ${currentFilePath}).`);
}
function resolveWasmImportTarget(specifier, currentFilePath, modulesRoot) {
    const raw = String(specifier);
    if (!modulesRoot) {
        throw new Error(`wasm import requires php_modules/ (missing for ${currentFilePath}).`);
    }
    const isRelative = raw.startsWith('.');
    const baseDir = isRelative ? globalThis.path.dirname(currentFilePath) : modulesRoot;
    const rootPath = globalThis.path.resolve(baseDir, raw);
    const rel = globalThis.path.relative(modulesRoot, rootPath).replace(/\\/g, '/');
    if (!rel || rel.startsWith('..')) {
        throw new Error(`wasm import must resolve inside php_modules/ (${currentFilePath}: ${raw}).`);
    }
    const manifestPath = globalThis.path.resolve(rootPath, 'deka.json');
    if (!globalThis.fs.existsSync(manifestPath)) {
        throw new Error(`Missing wasm module manifest for '${raw}' (expected ${manifestPath}).`);
    }
    return {
        moduleId: rel,
        rootPath,
        manifestPath
    };
}
function parseNamedSpecifiers(rawSpecifiers, currentFilePath) {
    const specifiers = rawSpecifiers.split(',').map((spec)=>spec.trim()).filter(Boolean);
    const parsed = [];
    for (const spec of specifiers){
        const specMatch = spec.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\s+as\s+([A-Za-z_][A-Za-z0-9_]*))?$/);
        if (!specMatch) {
            throw new Error(`Invalid import specifier '${spec}' in ${currentFilePath}.`);
        }
        const imported = specMatch[1];
        const local = specMatch[2] || imported;
        parsed.push({
            imported,
            local
        });
    }
    return parsed;
}
function parseImportLine(line, currentFilePath, modulesRoot) {
    const match = line.match(/^\s*import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]\s*(?:as\s+([A-Za-z_][A-Za-z0-9_]*))?\s*;?\s*$/);
    if (!match) return null;
    const from = match[2].trim();
    if (!from) {
        throw new Error(`Invalid import in ${currentFilePath}: ${line}`);
    }
    const importKind = match[3] ? match[3].trim() : '';
    if (importKind && importKind !== 'wasm') {
        throw new Error(`Unknown import kind '${importKind}' in ${currentFilePath}: ${line}`);
    }
    const isWasm = importKind === 'wasm';
    const target = isWasm
        ? resolveWasmImportTarget(from, currentFilePath, modulesRoot)
        : resolveImportTarget(from, currentFilePath, modulesRoot);
    const specifiers = parseNamedSpecifiers(match[1], currentFilePath);
    const imports = [];
    for (const spec of specifiers){
        const imported = spec.imported;
        const local = spec.local;
        imports.push({
            imported,
            local,
            from: target.moduleId,
            kind: isWasm ? 'wasm' : 'phpx'
        });
    }
    return imports;
}
function parseExportListLine(line, currentFilePath) {
    const match = line.match(/^\s*export\s+\{([^}]+)\}\s*;?\s*$/);
    if (!match) return null;
    const specifiers = parseNamedSpecifiers(match[1], currentFilePath);
    const locals = [];
    const exports = [];
    for (const spec of specifiers){
        if (spec.local !== spec.imported) {
            throw new Error(`Unsupported export alias '${spec.imported} as ${spec.local}' in ${currentFilePath}.`);
        }
        locals.push(spec.imported);
        exports.push(spec.imported);
    }
    return {
        locals,
        exports
    };
}
function parseExportFromLine(line, currentFilePath, modulesRoot) {
    const match = line.match(/^\s*export\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]\s*;?\s*$/);
    if (!match) return null;
    const from = match[2].trim();
    if (!from) {
        throw new Error(`Invalid export in ${currentFilePath}: ${line}`);
    }
    const target = resolveImportTarget(from, currentFilePath, modulesRoot);
    const specifiers = parseNamedSpecifiers(match[1], currentFilePath);
    const imports = [];
    const exports = [];
    for (const spec of specifiers){
        imports.push({
            imported: spec.imported,
            local: spec.local,
            from: target.moduleId,
            kind: 'phpx'
        });
        exports.push(spec.local);
    }
    return {
        imports,
        exports
    };
}
function parsePhpxModule(filePath, modulesRoot) {
    const rel = globalThis.path.relative(modulesRoot, filePath).replace(/\\/g, '/');
    const moduleId = moduleIdFromRel(rel);
    const raw = globalThis.fs.readFileSync(filePath, 'utf8');
    const runtimeDeps = detectCoreRuntimeDeps(raw, filePath).filter((dep)=>dep !== moduleId);
    const lines = raw.split(/\r?\n/);
    const frontmatter = splitFrontmatter(raw);
    const frontmatterStart = frontmatter ? frontmatter.startLine : -1;
    const frontmatterEnd = frontmatter ? frontmatter.endLine : -1;
    const imports = [];
    const extraExports = [];
    const exportLocals = new Set();
    const reexportedLocals = new Set();
    const exportAliasSpecs = [];
    const body = [];
    for (let i = 0; i < lines.length; i++){
        const line = lines[i];
        const inFrontmatter = frontmatter
            ? i > frontmatterStart && i < frontmatterEnd
            : true;
        if (!inFrontmatter) {
            body.push(line);
            continue;
        }
        const exported = parseExportFromLine(line, filePath, modulesRoot);
        if (exported) {
            imports.push(...exported.imports);
            extraExports.push(...exported.exports);
            for (const spec of exported.imports){
                reexportedLocals.add(spec.local);
                exportAliasSpecs.push({
                    exported: spec.local,
                    from: spec.from,
                    imported: spec.imported
                });
            }
            body.push('');
            continue;
        }
        const exportList = parseExportListLine(line, filePath);
        if (exportList) {
            for (const name of exportList.locals){
                exportLocals.add(name);
            }
            extraExports.push(...exportList.exports);
            body.push('');
            continue;
        }
        const parsed = parseImportLine(line, filePath, modulesRoot);
        if (parsed) {
            imports.push(...parsed);
            body.push('');
            continue;
        }
        body.push(line);
    }
    const hasJsx = ensureJsxRuntimeImports(imports, raw, filePath);
    ensureTemplateRuntimeImports(imports, raw, filePath, 'module');
    const joinedBody = body.join('\n');
    const compiled = compilePhpxSource(joinedBody, moduleId);
    let compiledCode = compiled.code;
    let markerPrefix = '';
    if (compiledCode.startsWith(PHPX_INTERNAL_MARKER)) {
        markerPrefix = `${PHPX_INTERNAL_MARKER}\n`;
        compiledCode = compiledCode.slice(PHPX_INTERNAL_MARKER.length);
        if (compiledCode.startsWith('\n')) {
            compiledCode = compiledCode.slice(1);
        }
    }
    const typeInfo = buildModuleTypeInfo(joinedBody, filePath, moduleId);
    const searchable = stripPhpCommentsAndStrings(compiledCode);
    const declaredFunctions = collectFunctionDeclarations(searchable);
    const importedLocals = new Set();
    const importByLocal = new Map();
    for (const spec of imports){
        if (importByLocal.has(spec.local)) {
            const prev = importByLocal.get(spec.local);
            if (prev.from !== spec.from || prev.imported !== spec.imported) {
                throw new Error(`Duplicate import for '${spec.local}' in ${filePath}.`);
            }
            continue;
        }
        importByLocal.set(spec.local, spec);
        importedLocals.add(spec.local);
    }
    for (const name of exportLocals){
        if (declaredFunctions.has(name) || importedLocals.has(name)) {
            continue;
        }
        throw new Error(`Missing export '${name}' in ${filePath}.`);
    }
    for (const name of exportLocals){
        if (!declaredFunctions.has(name) && importedLocals.has(name)) {
            const spec = importByLocal.get(name);
            exportAliasSpecs.push({
                exported: name,
                from: spec.from,
                imported: spec.imported
            });
            reexportedLocals.add(name);
        }
    }
    for (const spec of imports){
        if (declaredFunctions.has(spec.local)) {
            throw new Error(`Import '${spec.local}' conflicts with local function in ${filePath}.`);
        }
    }
    for (const spec of imports){
        if (spec.synthetic) continue;
        const usedByJsx = hasJsx && spec.from === 'component/core' && (spec.local === 'jsx' || spec.local === 'jsxs');
        const used = reexportedLocals.has(spec.local) || usedByJsx || isImportedFunctionUsed(searchable, spec.local);
        if (!used) {
            throw new Error(`Unused import '${spec.local}' in ${filePath}.`);
        }
    }
    const mergedExports = [];
    const seenExports = new Set();
    for (const name of [
        ...compiled.exports,
        ...extraExports
    ]){
        if (seenExports.has(name)) continue;
        seenExports.add(name);
        mergedExports.push(name);
    }
    const aliasCode = buildPhpImportWrappers(
        imports.filter((spec)=>!reexportedLocals.has(spec.local)),
        {
            useRegistry: false
        }
    );
    const wasmBindingCode = buildWasmImportWrappers(imports);
    const moduleNamespace = buildModuleNamespace(moduleId);
    let exportAliasCode = '';
    const exportAliasByName = new Map();
    for (const alias of exportAliasSpecs){
        if (exportAliasByName.has(alias.exported)) {
            const prev = exportAliasByName.get(alias.exported);
            if (prev.from !== alias.from || prev.imported !== alias.imported) {
                throw new Error(`Duplicate export alias '${alias.exported}' in ${filePath}.`);
            }
            continue;
        }
        exportAliasByName.set(alias.exported, alias);
    }
    for (const alias of exportAliasByName.values()){
        if (declaredFunctions.has(alias.exported)) {
            throw new Error(`Export '${alias.exported}' conflicts with local function in ${filePath}.`);
        }
        const targetNs = buildModuleNamespace(alias.from);
        exportAliasCode += buildExportAliasFunction(alias.exported, targetNs, alias.imported);
    }
    const wrappers = buildExportWrappers(moduleId, moduleNamespace, mergedExports, typeInfo);
    const registryCode = buildExportRegistry(moduleId, mergedExports, moduleNamespace, wrappers.exportTargets);
    return {
        moduleId,
        filePath,
        deps: runtimeDeps,
        imports,
        exports: mergedExports,
        code: `${markerPrefix}namespace ${moduleNamespace};\n${aliasCode}${wasmBindingCode}${exportAliasCode}${compiledCode}\n${wrappers.code}${registryCode}`
    };
}
function buildExportRegistry(moduleId, exports, moduleNamespace, exportTargets = null) {
    if (!exports.length) return '';
    const escapedId = escapePhpString(moduleId);
    let out = "if (!isset($GLOBALS['__PHPX_MODULES'])) { $GLOBALS['__PHPX_MODULES'] = array(); }\n";
    out += ` $GLOBALS['__PHPX_MODULES']['${escapedId}'] = array(\n`;
    for (const name of exports){
        const escapedName = escapePhpString(name);
        const target = exportTargets && exportTargets.has(name)
            ? exportTargets.get(name)
            : name;
        out += `  '${escapedName}' => '${moduleNamespace}\\\\${target}',\n`;
    }
    out += " );\n";
    return out;
}
function buildLazyModuleRegistry(modules) {
    let out = '';
    out += "if (!isset($GLOBALS['__PHPX_LAZY'])) { $GLOBALS['__PHPX_LAZY'] = array(); }\n";
    out += "if (!function_exists('__phpx_register_lazy')) { function __phpx_register_lazy($moduleId, $code, $deps) { $GLOBALS['__PHPX_LAZY'][$moduleId] = array('code' => $code, 'deps' => $deps); } }\n";
    const escapeNowdocContent = (value)=>String(value);
    for (const module of modules.values()){
        const deps = [];
        if (Array.isArray(module.deps)) {
            for (const dep of module.deps){
                if (!deps.includes(dep)) deps.push(dep);
            }
        }
        for (const spec of module.imports){
            if (spec.kind === 'wasm') continue;
            if (!deps.includes(spec.from)) deps.push(spec.from);
        }
        let token = `PHPX_${sanitizePhpIdentifier(module.moduleId)}`;
        let counter = 0;
        while(module.code.includes(token)){
            counter += 1;
            token = `PHPX_${sanitizePhpIdentifier(module.moduleId)}_${counter}`;
        }
        let varName = `$__phpx_code_${sanitizePhpIdentifier(module.moduleId)}`;
        let varCounter = 0;
        while(module.code.includes(varName)){
            varCounter += 1;
            varName = `$__phpx_code_${sanitizePhpIdentifier(module.moduleId)}_${varCounter}`;
        }
        out += `${varName} = <<<'${token}'\n`;
        out += `${escapeNowdocContent(module.code)}\n`;
        out += `${token}\n`;
        out += ";\n";
        if (deps.length === 0) {
            out += `__phpx_register_lazy('${escapePhpString(module.moduleId)}', ${varName}, array());\n`;
        } else {
            const depsList = deps.map((dep)=>`'${escapePhpString(dep)}'`).join(', ');
            out += `__phpx_register_lazy('${escapePhpString(module.moduleId)}', ${varName}, array(${depsList}));\n`;
        }
    }
    return out;
}
function topoSortModules(modules) {
    const order = [];
    const visiting = new Set();
    const visited = new Set();
    function visit(moduleId) {
        if (visited.has(moduleId)) return;
        if (visiting.has(moduleId)) {
            throw new Error(`Cyclic phpx import detected: ${moduleId}`);
        }
        const module = modules.get(moduleId);
        if (!module) {
            throw new Error(`Missing phpx module '${moduleId}'.`);
        }
        visiting.add(moduleId);
        for (const spec of module.imports){
            if (spec.kind === 'wasm') continue;
            visit(spec.from);
        }
        if (Array.isArray(module.deps)) {
            for (const dep of module.deps){
                visit(dep);
            }
        }
        visiting.delete(moduleId);
        visited.add(moduleId);
        order.push(moduleId);
    }
    for (const moduleId of modules.keys()){
        visit(moduleId);
    }
    return order;
}
function validateImports(modules) {
    for (const module of modules.values()){
        if (Array.isArray(module.deps)) {
            for (const dep of module.deps){
                if (!modules.has(dep)) {
                    throw new Error(`Unknown phpx module '${dep}' referenced by '${module.moduleId}'.`);
                }
            }
        }
        for (const spec of module.imports){
            if (spec.kind === 'wasm') continue;
            const target = modules.get(spec.from);
            if (!target) {
                throw new Error(`Unknown phpx module '${spec.from}' imported by '${module.moduleId}'.`);
            }
            if (!target.exports.includes(spec.imported)) {
                throw new Error(`Missing export '${spec.imported}' in '${spec.from}' (imported by '${module.moduleId}').`);
            }
        }
    }
}
function collectPhpxFiles(root) {
    const out = [];
    if (!root || !globalThis.fs.existsSync(root)) {
        return out;
    }
    const entries = globalThis.fs.readdirSync(root, {
        withFileTypes: true
    });
    for (const entry of entries){
        const entryPath = globalThis.path.join(root, entry.name);
        const isDirectory = typeof entry.isDirectory === 'function' ? entry.isDirectory() : entry.is_dir;
        const isFile = typeof entry.isFile === 'function' ? entry.isFile() : entry.is_file;
        if (isDirectory) {
            out.push(...collectPhpxFiles(entryPath));
            continue;
        }
        if (isFile && entry.name.endsWith('.phpx')) {
            out.push(entryPath);
        }
    }
    return out;
}
function collectModulePathMap(modulesRoot) {
    const files = collectPhpxFiles(modulesRoot);
    const map = new Map();
    for (const filePath of files){
        const rel = globalThis.path.relative(modulesRoot, filePath).replace(/\\/g, '/');
        const moduleId = moduleIdFromRel(rel);
        if (map.has(moduleId)) {
            throw new Error(`Duplicate phpx module id '${moduleId}'.`);
        }
        map.set(moduleId, filePath);
    }
    return map;
}
function resolveStdlibListPath(modulesRoot) {
    if (!modulesRoot) return '';
    return globalThis.path.resolve(modulesRoot, 'stdlib.json');
}
function readStdlibModuleList(entryPath) {
    const modulesRoot = resolvePhpModulesRoot(entryPath);
    const stdlibPath = resolveStdlibListPath(modulesRoot);
    if (!stdlibPath || !globalThis.fs.existsSync(stdlibPath)) {
        return [];
    }
    const raw = globalThis.fs.readFileSync(stdlibPath, 'utf8');
    let parsed = [];
    try {
        parsed = JSON.parse(raw);
    } catch (err) {
        throw new Error(`Invalid stdlib.json: ${err.message || err}`);
    }
    if (!Array.isArray(parsed)) {
        throw new Error('stdlib.json must be a JSON array of module patterns.');
    }
    return parsed.map((entry)=>String(entry).trim()).filter(Boolean);
}
function moduleIdMatchesPattern(moduleId, pattern) {
    if (!pattern) return false;
    if (pattern.endsWith('/*')) {
        const prefix = pattern.slice(0, -1);
        return moduleId.startsWith(prefix);
    }
    return moduleId === pattern;
}
function selectStdlibModuleIds(modulePathMap, patterns) {
    const selected = new Set();
    for (const pattern of patterns){
        let matched = false;
        for (const moduleId of modulePathMap.keys()){
            if (moduleIdMatchesPattern(moduleId, pattern)) {
                matched = true;
                selected.add(moduleId);
            }
        }
        if (!matched) {
            throw new Error(`stdlib.json pattern '${pattern}' did not match any module.`);
        }
    }
    return Array.from(selected);
}
function resolveStdlibModuleIds(entryPath) {
    const modulesRoot = resolvePhpModulesRoot(entryPath);
    if (!modulesRoot) return [];
    const override = globalThis.process?.env?.DEKA_PHPX_STDLIB;
    if (override && typeof override === 'string') {
        const trimmed = override.trim();
        if (trimmed.toLowerCase() === 'none') {
            return [];
        }
        const patterns = trimmed
            .split(',')
            .map((entry)=>String(entry).trim())
            .filter(Boolean);
        if (patterns.length > 0) {
            const modulePathMap = collectModulePathMap(modulesRoot);
            return selectStdlibModuleIds(modulePathMap, patterns);
        }
    }
    const patterns = readStdlibModuleList(entryPath);
    if (patterns.length === 0) return [];
    const modulePathMap = collectModulePathMap(modulesRoot);
    return selectStdlibModuleIds(modulePathMap, patterns);
}
function compilePhpxModules(entryPath, rootModuleIds = null) {
    const modulesRoot = resolvePhpModulesRoot(entryPath);
    if (!modulesRoot) {
        return {
            source: '',
            modules: new Map()
        };
    }
    if (rootModuleIds && rootModuleIds.length > 0) {
        const modulePathMap = collectModulePathMap(modulesRoot);
        const modules = new Map();
        const queue = [
            ...rootModuleIds
        ];
        while(queue.length > 0){
            const moduleId = queue.pop();
            if (modules.has(moduleId)) continue;
            const filePath = modulePathMap.get(moduleId);
            if (!filePath) {
                throw new Error(`Missing phpx module '${moduleId}'.`);
            }
            const parsed = parsePhpxModule(filePath, modulesRoot);
            modules.set(moduleId, parsed);
            for (const spec of parsed.imports){
                if (spec.kind === 'wasm') continue;
                queue.push(spec.from);
            }
            if (Array.isArray(parsed.deps)) {
                for (const dep of parsed.deps){
                    queue.push(dep);
                }
            }
        }
        validateImports(modules);
        const order = topoSortModules(modules);
        return {
            source: order.map((moduleId)=>modules.get(moduleId).code).join('\n'),
            modules
        };
    }
    const files = collectPhpxFiles(modulesRoot);
    const modules = new Map();
    for (const filePath of files){
        const parsed = parsePhpxModule(filePath, modulesRoot);
        if (modules.has(parsed.moduleId)) {
            throw new Error(`Duplicate phpx module id '${parsed.moduleId}'.`);
        }
        modules.set(parsed.moduleId, parsed);
    }
    validateImports(modules);
    const order = topoSortModules(modules);
    const moduleBlocks = order.map((moduleId)=>modules.get(moduleId).code);
    return {
        source: moduleBlocks.join('\n'),
        modules
    };
}
function buildPhpxBridgePrelude() {
    let out = '';
    out += "if (!isset($GLOBALS['__PHPX_MODULES'])) { $GLOBALS['__PHPX_MODULES'] = array(); }\n";
    out += "if (!isset($GLOBALS['__PHPX_TYPES'])) { $GLOBALS['__PHPX_TYPES'] = array(); }\n";
    out += "if (!isset($GLOBALS['__PHPX_STRUCT_FROM'])) { $GLOBALS['__PHPX_STRUCT_FROM'] = array(); }\n";
    out += "if (!function_exists('__phpx_fail')) { function __phpx_fail($msg) { if (function_exists('panic')) { panic($msg); return null; } if (function_exists('trigger_error')) { trigger_error($msg); return null; } echo $msg; return null; } }\n";
    out += "if (!function_exists('__phpx_register')) { function __phpx_register($moduleId, $exports) { $GLOBALS['__PHPX_MODULES'][$moduleId] = $exports; } }\n";
    out += "if (!function_exists('__phpx_register_types')) { function __phpx_register_types($moduleId, $types) { $GLOBALS['__PHPX_TYPES'][$moduleId] = $types; } }\n";
    out += "if (!function_exists('__phpx_array_has_key')) { function __phpx_array_has_key($arr, $key) { if (!is_array($arr)) { return false; } if (function_exists('array_key_exists')) { return array_key_exists($key, $arr); } foreach ($arr as $k => $val) { if ($k === $key) { return true; } } return false; } }\n";
    out += "if (!function_exists('__phpx_array_get')) { function __phpx_array_get($arr, $key, $default = null) { if (!is_array($arr)) { return $default; } if (__phpx_array_has_key($arr, $key)) { return $arr[$key]; } return $default; } }\n";
    out += "if (!function_exists('__phpx_object_from')) { function __phpx_object_from($value, $fields = null) {\n";
    out += "  if (!is_array($value) && !is_object($value)) { return $value; }\n";
    out += "  $data = is_array($value) ? $value : get_object_vars($value);\n";
    out += "  if (!function_exists('__phpx_object_new')) { return $value; }\n";
    out += "  $obj = __phpx_object_new();\n";
    out += "  if (is_array($fields)) {\n";
    out += "    foreach ($fields as $field) {\n";
    out += "      if (!is_array($field) || !isset($field['name'])) { continue; }\n";
    out += "      $name = $field['name'];\n";
    out += "      if (__phpx_array_has_key($data, $name)) {\n";
    out += "        $val = __phpx_coerce_value(__phpx_array_get($field, 'type'), $data[$name]);\n";
    out += "        __deka_object_set($obj, $name, $val);\n";
    out += "      }\n";
    out += "    }\n";
    out += "  } else {\n";
    out += "    foreach ($data as $name => $val) {\n";
    out += "      __deka_object_set($obj, $name, $val);\n";
    out += "    }\n";
    out += "  }\n";
    out += "  return $obj;\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_struct_from')) { function __phpx_struct_from($type, $value) {\n";
    out += "  if (!is_array($type) || !isset($type['name'])) { return $value; }\n";
    out += "  $class = $type['name'];\n";
    out += "  if (is_object($value) && function_exists('get_class') && get_class($value) === $class) { return $value; }\n";
    out += "  if (!is_array($value) && !is_object($value)) { return $value; }\n";
    out += "  if (isset($GLOBALS['__PHPX_STRUCT_FROM']) && __phpx_array_has_key($GLOBALS['__PHPX_STRUCT_FROM'], $class)) {\n";
    out += "    $fn = $GLOBALS['__PHPX_STRUCT_FROM'][$class];\n";
    out += "    if (is_string($fn) && function_exists($fn)) { return call_user_func($fn, $value); }\n";
    out += "  }\n";
    out += "  if (!function_exists('__phpx_struct_new')) { return $value; }\n";
    out += "  $data = is_array($value) ? $value : get_object_vars($value);\n";
    out += "  $obj = __phpx_struct_new($class);\n";
    out += "  $fields = __phpx_array_get($type, 'fields', array());\n";
    out += "  if (is_object($fields)) { $fields = get_object_vars($fields); }\n";
    out += "  if (!is_array($fields)) { $fields = array(); }\n";
    out += "  $field_count = is_array($fields) ? count($fields) : 0;\n";
    out += "  for ($i = 0; $i < $field_count; $i++) {\n";
    out += "    $field = $fields[$i];\n";
    out += "    if (!is_array($field) || !isset($field['name'])) { continue; }\n";
    out += "    $name = $field['name'];\n";
    out += "    if (__phpx_array_has_key($data, $name)) {\n";
    out += "      $val = __phpx_coerce_value(__phpx_array_get($field, 'type'), $data[$name]);\n";
    out += "      if (function_exists('__phpx_struct_set')) { __phpx_struct_set($obj, $name, $val); }\n";
    out += "      else { $obj->$name = $val; }\n";
    out += "    }\n";
    out += "  }\n";
    out += "  return $obj;\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_to_php')) { function __phpx_to_php($value) {\n";
    out += "  if (function_exists('__phpx_object_to_stdclass')) { return __phpx_object_to_stdclass($value); }\n";
    out += "  return $value;\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_coerce_option')) { function __phpx_coerce_option($type, $value) {\n";
    out += "  if ($value instanceof Option) { return $value; }\n";
    out += "  if ($value === null) { return Option::None; }\n";
    out += "  $inner = __phpx_array_get($type, 'inner');\n";
    out += "  $val = $inner ? __phpx_coerce_value($inner, $value) : $value;\n";
    out += "  return Option::Some($val);\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_coerce_result')) { function __phpx_coerce_result($type, $value) {\n";
    out += "  if ($value instanceof Result) { return $value; }\n";
    out += "  $ok_ty = __phpx_array_get($type, 'ok');\n";
    out += "  $err_ty = __phpx_array_get($type, 'err');\n";
    out += "  if (is_object($value)) { $value = get_object_vars($value); }\n";
    out += "  if (is_array($value)) {\n";
    out += "    if (__phpx_array_has_key($value, 'ok')) {\n";
    out += "      $ok = $value['ok'];\n";
    out += "      if ($ok === true) {\n";
    out += "        $val = __phpx_array_has_key($value, 'value') ? $value['value'] : $ok;\n";
    out += "        $val = $ok_ty ? __phpx_coerce_value($ok_ty, $val) : $val;\n";
    out += "        return Result::Ok($val);\n";
    out += "      }\n";
    out += "      if ($ok === false) {\n";
    out += "        $err = __phpx_array_has_key($value, 'error') ? $value['error'] : (__phpx_array_has_key($value, 'err') ? $value['err'] : null);\n";
    out += "        $err = $err_ty ? __phpx_coerce_value($err_ty, $err) : $err;\n";
    out += "        return Result::Err($err);\n";
    out += "      }\n";
    out += "      if (__phpx_array_has_key($value, 'value')) {\n";
    out += "        $val = $value['value'];\n";
    out += "        $val = $ok_ty ? __phpx_coerce_value($ok_ty, $val) : $val;\n";
    out += "        return Result::Ok($val);\n";
    out += "      }\n";
    out += "      if (__phpx_array_has_key($value, 'error') || __phpx_array_has_key($value, 'err')) {\n";
    out += "        $err = __phpx_array_has_key($value, 'error') ? $value['error'] : (__phpx_array_has_key($value, 'err') ? $value['err'] : null);\n";
    out += "        $err = $err_ty ? __phpx_coerce_value($err_ty, $err) : $err;\n";
    out += "        return Result::Err($err);\n";
    out += "      }\n";
    out += "      $val = $ok;\n";
    out += "      $val = $ok_ty ? __phpx_coerce_value($ok_ty, $val) : $val;\n";
    out += "      return Result::Ok($val);\n";
    out += "    }\n";
    out += "    if (__phpx_array_has_key($value, 'error') || __phpx_array_has_key($value, 'err')) {\n";
    out += "      $err = __phpx_array_has_key($value, 'error') ? $value['error'] : (__phpx_array_has_key($value, 'err') ? $value['err'] : null);\n";
    out += "      $err = $err_ty ? __phpx_coerce_value($err_ty, $err) : $err;\n";
    out += "      return Result::Err($err);\n";
    out += "    }\n";
    out += "    if (__phpx_array_has_key($value, 'value')) {\n";
    out += "      $val = $value['value'];\n";
    out += "      $val = $ok_ty ? __phpx_coerce_value($ok_ty, $val) : $val;\n";
    out += "      return Result::Ok($val);\n";
    out += "    }\n";
    out += "  }\n";
    out += "  if ($value === null) { return Result::Err(null); }\n";
    out += "  $val = $ok_ty ? __phpx_coerce_value($ok_ty, $value) : $value;\n";
    out += "  return Result::Ok($val);\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_coerce_value')) { function __phpx_coerce_value($type, $value) {\n";
    out += "  if (!is_array($type) || !isset($type['kind'])) { return $value; }\n";
    out += "  switch ($type['kind']) {\n";
    out += "    case 'option':\n";
    out += "      return __phpx_coerce_option($type, $value);\n";
    out += "    case 'result':\n";
    out += "      return __phpx_coerce_result($type, $value);\n";
    out += "    case 'array':\n";
    out += "      if (is_array($value) && isset($type['element'])) {\n";
    out += "        $out = array();\n";
    out += "        foreach ($value as $k => $v) { $out[$k] = __phpx_coerce_value($type['element'], $v); }\n";
    out += "        return $out;\n";
    out += "      }\n";
    out += "      return $value;\n";
    out += "    case 'object_shape':\n";
    out += "      return __phpx_object_from($value, __phpx_array_get($type, 'fields'));\n";
    out += "    case 'object':\n";
    out += "      return __phpx_object_from($value, null);\n";
    out += "    case 'struct':\n";
    out += "      return __phpx_struct_from($type, $value);\n";
    out += "    default:\n";
    out += "      return $value;\n";
    out += "  }\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_coerce_args')) { function __phpx_coerce_args($sig, $args) {\n";
    out += "  if (!is_array($sig)) { return $args; }\n";
    out += "  $params = __phpx_array_get($sig, 'params', array());\n";
    out += "  $param_count = count($params);\n";
    out += "  $arg_count = count($args);\n";
    out += "  $last_variadic = -1;\n";
    out += "  if ($param_count > 0 && !empty($params[$param_count - 1]['variadic'])) { $last_variadic = $param_count - 1; }\n";
    out += "  $out = array();\n";
    out += "  for ($i = 0; $i < $arg_count; $i++) {\n";
    out += "    $param_index = ($last_variadic >= 0 && $i >= $last_variadic) ? $last_variadic : $i;\n";
    out += "    if ($param_index < $param_count) {\n";
    out += "      $param = $params[$param_index];\n";
    out += "      $ty = __phpx_array_get($param, 'type');\n";
    out += "      $out[] = __phpx_coerce_value($ty, $args[$i]);\n";
    out += "    } else {\n";
    out += "      $out[] = $args[$i];\n";
    out += "    }\n";
    out += "  }\n";
    out += "  return $out;\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_coerce_return')) { function __phpx_coerce_return($type, $value) {\n";
    out += "  if (!is_array($type) || !isset($type['kind'])) { return $value; }\n";
    out += "  switch ($type['kind']) {\n";
    out += "    case 'option':\n";
    out += "      if ($value instanceof Option) { return $value->is_none() ? null : $value->unwrap(); }\n";
    out += "      return $value;\n";
    out += "    case 'result':\n";
    out += "      if ($value instanceof Result) {\n";
    out += "        if ($value->is_ok()) { return $value->unwrap(); }\n";
    out += "        return array('ok' => false, 'error' => (property_exists($value, 'error') ? $value->error : null));\n";
    out += "      }\n";
    out += "      return $value;\n";
    out += "    default:\n";
    out += "      return $value;\n";
    out += "  }\n";
    out += "} }\n";
    out += "if (!function_exists('__phpx_load')) { function __phpx_load($moduleId) {\n";
    out += "  if (isset($GLOBALS['__PHPX_MODULES'][$moduleId])) { return; }\n";
    out += "  if (!isset($GLOBALS['__PHPX_LAZY'][$moduleId])) { return __phpx_fail('Unknown phpx module: ' . $moduleId); }\n";
    out += "  $entry = $GLOBALS['__PHPX_LAZY'][$moduleId];\n";
    out += "  $deps = __phpx_array_get($entry, 'deps', array());\n";
    out += "  $dep_count = is_array($deps) ? count($deps) : 0;\n";
    out += "  for ($i = 0; $i < $dep_count; $i++) { $dep = $deps[$i]; __phpx_load($dep); }\n";
    out += "  eval($entry['code']);\n";
    out += "  if (!isset($GLOBALS['__PHPX_MODULES'][$moduleId])) { return __phpx_fail('Failed to load phpx module: ' . $moduleId); }\n";
    out += "} }\n";
    out += "if (!function_exists('phpx_import')) { function phpx_import($moduleId, $name = null) {\n";
    out += "  __phpx_load($moduleId);\n";
    out += "  $exports = $GLOBALS['__PHPX_MODULES'][$moduleId];\n";
    out += "  if ($name === null) { return __phpx_to_php($exports); }\n";
    out += "  if (!__phpx_array_has_key($exports, $name)) { return __phpx_fail('Unknown phpx export: ' . $moduleId . ':' . $name); }\n";
    out += "  return __phpx_to_php($exports[$name]);\n";
    out += "} }\n";
    return out;
}
function buildModulePrelude(entryPath) {
    const modulesRoot = resolvePhpModulesRoot(entryPath);
    const isPhpxEntry = String(entryPath || '').endsWith('.phpx');
    const entrySource = globalThis.fs.readFileSync(entryPath, 'utf8');
    const importsInfo = parseTopLevelImports(entrySource, entryPath, modulesRoot);
    const enableModules = isPhpxEntry || importsInfo.imports.length > 0;
    if (!enableModules) {
        const dekaPath = getDekaEntryPath(entryPath);
        if (!dekaPath) {
            throw new Error("Missing php_modules/deka.php. Run `deka init` to create a project.");
        }
        const stdlibModules = isPhpxEntry ? [] : resolveStdlibModuleIds(entryPath);
        const moduleBuild = stdlibModules.length
            ? compilePhpxModules(entryPath, stdlibModules)
            : {
                source: '',
                modules: new Map()
            };
        let prelude = '';
        prelude += buildPhpxBridgePrelude();
        if (moduleBuild.modules.size > 0) {
            prelude += buildLazyModuleRegistry(moduleBuild.modules);
        }
        const skipDeka = globalThis.process?.env?.DEKA_PHPX_SKIP_DEKA;
        if (!skipDeka) {
            prelude += `require_once '${escapePhpString(dekaPath)}';\n`;
        }
        return {
            prelude,
            entryPrelude: '',
            source: importsInfo.strippedSource
        };
    }
    const dekaPath = getDekaEntryPath(entryPath);
    if (!dekaPath) {
        throw new Error("Missing php_modules/deka.php. Run `deka init` to create a project.");
    }
    const stdlibModules = isPhpxEntry ? [] : resolveStdlibModuleIds(entryPath);
    const phpxImports = importsInfo.imports.filter((spec)=>spec.kind !== 'wasm');
    const wasmImports = importsInfo.imports.filter((spec)=>spec.kind === 'wasm');
    let moduleBuild = null;
    if (importsInfo.imports.length > 0) {
        const roots = Array.from(new Set([
            ...stdlibModules,
            ...phpxImports.map((spec)=>spec.from)
        ]));
        moduleBuild = roots.length > 0
            ? compilePhpxModules(entryPath, roots)
            : {
                source: '',
                modules: new Map()
            };
    } else {
        moduleBuild = stdlibModules.length > 0
            ? compilePhpxModules(entryPath, stdlibModules)
            : {
                source: '',
                modules: new Map()
            };
    }
    for (const spec of phpxImports){
        const target = moduleBuild.modules.get(spec.from);
        if (!target) {
            throw new Error(`Unknown phpx module '${spec.from}' imported by ${entryPath}.`);
        }
        if (!target.exports.includes(spec.imported)) {
            throw new Error(`Missing export '${spec.imported}' in '${spec.from}' (imported by ${entryPath}).`);
        }
    }
    let prelude = '';
    let entryPrelude = '';
    prelude += buildPhpxBridgePrelude();
    if (isPhpxEntry) {
        prelude += "define('__DEKA_PHPX_ENTRY', true);\n";
    }
    if (moduleBuild.modules.size > 0) {
        prelude += buildLazyModuleRegistry(moduleBuild.modules);
    }
    if (phpxImports.length > 0) {
        const wrappers = buildPhpImportWrappers(phpxImports, { useRegistry: !isPhpxEntry });
        if (isPhpxEntry) {
            entryPrelude += wrappers;
        } else {
            prelude += wrappers;
        }
    }
    if (wasmImports.length > 0) {
        const wrappers = buildWasmImportWrappers(wasmImports);
        if (isPhpxEntry) {
            entryPrelude += wrappers;
        } else {
            prelude += wrappers;
        }
    }
    const skipDeka = globalThis.process?.env?.DEKA_PHPX_SKIP_DEKA;
    if (!skipDeka) {
        prelude += `require_once '${escapePhpString(dekaPath)}';\n`;
    }
    return {
        prelude,
        entryPrelude,
        source: importsInfo.strippedSource
    };
}
function isPathAllowed(targetPath) {
    const normalized = normalizeHostPath(targetPath);
    return phpActiveRoots.some((root)=>{
        if (!root) return false;
        const normalizedRoot = normalizeHostPath(root);
        if (normalized === normalizedRoot) return true;
        const prefix = normalizedRoot.endsWith('/') ? normalizedRoot : normalizedRoot + '/';
        return normalized.startsWith(prefix);
    });
}
function writeResult(outPtr, dataPtr, dataLen) {
    const view = new DataView(phpMemory.buffer, outPtr, 8);
    view.setUint32(0, dataPtr, true);
    view.setUint32(4, dataLen, true);
}
const wasmModuleCache = new Map();
const wasmWitCache = new Map();
const wasmWitExportCache = new Map();

function toSnakeCase(name) {
    return String(name || '').replace(/[\s\-.]+/g, '_').replace(/([a-z0-9])([A-Z])/g, '$1_$2').toLowerCase();
}

function loadWitSchema(entry) {
    if (wasmWitCache.has(entry.moduleId)) {
        return wasmWitCache.get(entry.moduleId);
    }
    const witPath = globalThis.path.resolve(entry.moduleRoot, entry.manifest.wit || 'module.wit');
    if (!globalThis.fs.existsSync(witPath)) {
        throw new Error(`Missing WIT file at ${witPath}`);
    }
    const schema = op_php_parse_wit(witPath, entry.manifest.world || '');
    wasmWitCache.set(entry.moduleId, schema);
    return schema;
}

function buildWitExportMap(schema, interfacePrefix) {
    const exports = new Map();
    const register = (name, sig)=>{
        if (exports.has(name)) {
            throw new Error(`Duplicate WIT export name '${name}'`);
        }
        exports.set(name, sig);
    };
    for (const func of schema.functions || []){
        register(toSnakeCase(func.name), {
            func,
            interfaceName: null
        });
    }
    for (const iface of schema.interfaces || []){
        const ifaceName = toSnakeCase(iface.name);
        for (const func of iface.functions || []){
            const localName = toSnakeCase(func.name);
            const exportName = interfacePrefix ? `${ifaceName}__${localName}` : localName;
            register(exportName, {
                func,
                interfaceName: iface.name
            });
        }
    }
    return exports;
}

function getWitExport(entry, exportName) {
    if (!wasmWitExportCache.has(entry.moduleId)) {
        const schema = loadWitSchema(entry);
        const map = buildWitExportMap(schema, entry.manifest.interfacePrefix !== false);
        wasmWitExportCache.set(entry.moduleId, map);
    }
    const map = wasmWitExportCache.get(entry.moduleId);
    return map.get(exportName) || null;
}

function resolveWitExportName(exports, interfaceName, funcName) {
    const candidates = [];
    const witFunc = String(funcName || '');
    const snakeFunc = toSnakeCase(witFunc);
    const ifaceNames = [];
    if (interfaceName) {
        const witIface = String(interfaceName || '');
        ifaceNames.push(witIface);
        ifaceNames.push(toSnakeCase(witIface));
    }
    for (const iface of ifaceNames){
        for (const fname of [
            witFunc,
            snakeFunc
        ]){
            candidates.push(`${iface}#${fname}`);
            candidates.push(`${iface}_${fname}`);
            candidates.push(`${iface}__${fname}`);
            candidates.push(`${iface}.${fname}`);
            candidates.push(`${iface}:${fname}`);
        }
    }
    candidates.push(witFunc);
    candidates.push(snakeFunc);
    for (const name of candidates){
        if (typeof exports[name] === 'function') {
            return name;
        }
    }
    return null;
}
function ensureSafeModuleId(moduleId) {
    const raw = String(moduleId || '');
    if (!raw || raw.startsWith('/') || raw.startsWith('..') || raw.includes('\\') || raw.includes('..')) {
        throw new Error(`Invalid wasm module id '${raw}'`);
    }
    return raw;
}
function readWasmManifest(moduleRoot) {
    const manifestPath = globalThis.path.resolve(moduleRoot, 'deka.json');
    if (!globalThis.fs.existsSync(manifestPath)) {
        throw new Error(`Missing wasm manifest at ${manifestPath}`);
    }
    const raw = globalThis.fs.readFileSync(manifestPath, 'utf8');
    let manifest = null;
    try {
        manifest = JSON.parse(raw);
    } catch (err) {
        throw new Error(`Invalid wasm manifest (${manifestPath}): ${err.message || err}`);
    }
    if (!manifest || typeof manifest !== 'object') {
        throw new Error(`Invalid wasm manifest (${manifestPath}): expected JSON object`);
    }
    const modulePath = manifest.module || 'module.wasm';
    if (typeof modulePath !== 'string' || !modulePath) {
        throw new Error(`Invalid wasm manifest (${manifestPath}): missing module path`);
    }
    if (manifest.instance && manifest.instance !== 'per_request') {
        throw new Error(`Unsupported wasm instance mode '${manifest.instance}' in ${manifestPath}`);
    }
    const abi = manifest.abi || 'deka-json';
    if (abi !== 'deka-json' && abi !== 'wit') {
        throw new Error(`Unsupported wasm abi '${abi}' in ${manifestPath}`);
    }
    const wit = manifest.wit || 'module.wit';
    const world = manifest.world || '';
    const interfacePrefix = manifest.interfacePrefix !== false;
    return {
        manifestPath,
        modulePath,
        abi,
        wit,
        world,
        interfacePrefix
    };
}
function loadWasmModule(moduleId) {
    const safeId = ensureSafeModuleId(moduleId);
    if (wasmModuleCache.has(safeId)) {
        return wasmModuleCache.get(safeId);
    }
    const modulesRoot = getActiveModulesRoot();
    if (!modulesRoot) {
        throw new Error('php_modules root missing for wasm import');
    }
    const moduleRoot = globalThis.path.resolve(modulesRoot, safeId);
    if (!isPathAllowed(moduleRoot)) {
        throw new Error(`Wasm module path not allowed: ${moduleRoot}`);
    }
    const manifest = readWasmManifest(moduleRoot);
    const wasmPath = globalThis.path.resolve(moduleRoot, manifest.modulePath);
    if (!isPathAllowed(wasmPath)) {
        throw new Error(`Wasm module path not allowed: ${wasmPath}`);
    }
    if (!globalThis.fs.existsSync(wasmPath)) {
        throw new Error(`Missing wasm module at ${wasmPath}`);
    }
    const bytes = globalThis.fs.readFileSync(wasmPath);
    const wasmModule = new WebAssembly.Module(bytes);
    const entry = {
        moduleId: safeId,
        moduleRoot,
        manifest,
        wasmPath,
        module: wasmModule
    };
    wasmModuleCache.set(safeId, entry);
    return entry;
}
function callWasmJsonExport(moduleId, exportName, argsJson) {
    const entry = loadWasmModule(moduleId);
    const instance = new WebAssembly.Instance(entry.module, {});
    const exports = instance.exports || {};
    const memory = exports.memory;
    const alloc = exports.deka_alloc;
    const free = exports.deka_free;
    const call = exports.deka_call;
    if (!memory || typeof alloc !== 'function' || typeof free !== 'function' || typeof call !== 'function') {
        throw new Error(`Wasm module '${moduleId}' must export memory, deka_alloc, deka_free, and deka_call`);
    }
    const encoder = new TextEncoder();
    const nameBytes = encoder.encode(String(exportName || ''));
    const argsBytes = encoder.encode(String(argsJson || '[]'));
    const namePtr = nameBytes.length ? alloc(nameBytes.length) : 0;
    if (nameBytes.length) {
        new Uint8Array(memory.buffer, namePtr, nameBytes.length).set(nameBytes);
    }
    const argsPtr = argsBytes.length ? alloc(argsBytes.length) : 0;
    if (argsBytes.length) {
        new Uint8Array(memory.buffer, argsPtr, argsBytes.length).set(argsBytes);
    }
    const resultPtr = call(namePtr, nameBytes.length, argsPtr, argsBytes.length);
    if (!resultPtr) {
        throw new Error(`Wasm module '${moduleId}' returned empty result`);
    }
    const resultView = new DataView(memory.buffer, resultPtr, 8);
    const dataPtr = resultView.getUint32(0, true);
    const dataLen = resultView.getUint32(4, true);
    let resultJson = '';
    if (dataPtr && dataLen) {
        const resultBytes = new Uint8Array(memory.buffer, dataPtr, dataLen);
        resultJson = new TextDecoder().decode(resultBytes);
    }
    if (argsPtr && argsBytes.length) free(argsPtr, argsBytes.length);
    if (namePtr && nameBytes.length) free(namePtr, nameBytes.length);
    if (dataPtr && dataLen) free(dataPtr, dataLen);
    free(resultPtr, 8);
    return resultJson;
}

function ensureSupportedWitType(ty) {
    if (!ty || typeof ty !== 'object') {
        throw new Error('Invalid WIT type');
    }
    const kind = ty.kind;
    switch(kind){
        case 'enum': {
            const cases = ty.cases || [];
            if (!Array.isArray(cases)) {
                throw new Error('Invalid WIT enum cases');
            }
            return;
        }
        case 'flags': {
            const flags = ty.flags || [];
            if (!Array.isArray(flags)) {
                throw new Error('Invalid WIT flags');
            }
            if (flags.length > 32) {
                throw new Error('WIT flags with more than 32 entries are not supported in abi=wit v1');
            }
            return;
        }
        case 'bool':
        case 'u8':
        case 'u16':
        case 'u32':
        case 'u64':
        case 's8':
        case 's16':
        case 's32':
        case 's64':
        case 'f32':
        case 'f64':
        case 'char':
        case 'string':
            return;
        case 'list':
            if (ty.element?.kind !== 'u8') {
                throw new Error('Only list<u8> is supported in abi=wit v1');
            }
            return;
        case 'option':
            if (ty.some) {
                ensureSupportedWitType(ty.some);
            }
            return;
        case 'result':
            if (ty.ok) {
                ensureSupportedWitType(ty.ok);
            }
            if (ty.err) {
                ensureSupportedWitType(ty.err);
            }
            return;
        case 'record':
        case 'tuple':
            for (const field of ty.fields || ty.items || []){
                const nested = field.type || field;
                ensureSupportedWitType(nested);
            }
            return;
        default:
            throw new Error(`Unsupported WIT type '${kind}' in abi=wit v1`);
    }
}

function normalizeWitCaseName(name) {
    return toSnakeCase(String(name || ''));
}

function enumCaseIndex(value, ty) {
    const cases = ty.cases || [];
    if (typeof value === 'number' && Number.isFinite(value)) {
        if (!Number.isInteger(value)) {
            throw new Error(`Invalid enum discriminant ${value} (expected integer)`);
        }
        const index = value;
        if (index < 0 || index >= cases.length) {
            throw new Error(`Invalid enum discriminant ${index} (expected 0..${Math.max(0, cases.length - 1)})`);
        }
        return index;
    }
    if (typeof value === 'string') {
        const normalized = normalizeWitCaseName(value);
        for (let i = 0; i < cases.length; i++){
            if (normalizeWitCaseName(cases[i]) === normalized) {
                return i;
            }
        }
        throw new Error(`Unknown enum case '${value}'. Expected one of: ${cases.join(', ')}`);
    }
    throw new Error('enum expects a case name string or numeric discriminant');
}

function enumCaseName(index, ty) {
    const cases = ty.cases || [];
    if (index < 0 || index >= cases.length) {
        throw new Error(`Invalid enum discriminant ${index} (expected 0..${Math.max(0, cases.length - 1)})`);
    }
    return toSnakeCase(cases[index]);
}

function witEnumLayout(ty) {
    const count = (ty.cases || []).length;
    if (count <= 0xff) {
        return {
            size: 1,
            align: 1
        };
    }
    if (count <= 0xffff) {
        return {
            size: 2,
            align: 2
        };
    }
    return {
        size: 4,
        align: 4
    };
}

function witFlagsLayout(ty) {
    const count = (ty.flags || []).length;
    if (count <= 8) {
        return {
            size: 1,
            align: 1
        };
    }
    if (count <= 16) {
        return {
            size: 2,
            align: 2
        };
    }
    if (count <= 32) {
        return {
            size: 4,
            align: 4
        };
    }
    throw new Error('WIT flags with more than 32 entries are not supported in abi=wit v1');
}

function flagsMaskFromValue(value, ty) {
    if (value === null || value === undefined) {
        return 0;
    }
    if (typeof value === 'number' && Number.isFinite(value)) {
        if (!Number.isInteger(value)) {
            throw new Error(`Invalid flags bitmask ${value} (expected integer)`);
        }
        return value >>> 0;
    }
    if (typeof value === 'string') {
        value = [
            value
        ];
    }
    const flags = ty.flags || [];
    const indexByName = new Map();
    for (let i = 0; i < flags.length; i++){
        indexByName.set(normalizeWitCaseName(flags[i]), i);
    }
    let mask = 0;
    if (Array.isArray(value)) {
        for (const entry of value){
            if (typeof entry === 'number' && Number.isFinite(entry)) {
                if (!Number.isInteger(entry)) {
                    throw new Error(`Invalid flag index ${entry} (expected integer)`);
                }
                const idx = entry;
                if (idx < 0 || idx >= flags.length) {
                    throw new Error(`Invalid flag index ${idx} (expected 0..${Math.max(0, flags.length - 1)})`);
                }
                mask = (mask | 1 << idx) >>> 0;
                continue;
            }
            const key = normalizeWitCaseName(entry);
            const idx = indexByName.get(key);
            if (idx === undefined) {
                throw new Error(`Unknown flag '${entry}'. Expected one of: ${flags.join(', ')}`);
            }
            mask = (mask | 1 << idx) >>> 0;
        }
        return mask >>> 0;
    }
    if (value && typeof value === 'object') {
        for (const [key, enabled] of Object.entries(value)){
            if (!enabled) continue;
            const normalized = normalizeWitCaseName(key);
            const idx = indexByName.get(normalized);
            if (idx === undefined) {
                throw new Error(`Unknown flag '${key}'. Expected one of: ${flags.join(', ')}`);
            }
            mask = (mask | 1 << idx) >>> 0;
        }
        return mask >>> 0;
    }
    throw new Error('flags expects an integer bitmask, array of flag names, or object map');
}

function flagsMaskToArray(mask, ty) {
    const flags = ty.flags || [];
    const out = [];
    const value = mask >>> 0;
    for (let i = 0; i < flags.length; i++){
        if (value >>> i & 1) {
            out.push(toSnakeCase(flags[i]));
        }
    }
    return out;
}

function witTypeFlatCount(ty) {
    switch(ty.kind){
        case 'enum':
        case 'flags':
        case 'bool':
        case 'u8':
        case 'u16':
        case 'u32':
        case 'u64':
        case 's8':
        case 's16':
        case 's32':
        case 's64':
        case 'f32':
        case 'f64':
        case 'char':
            return 1;
        case 'string':
        case 'list':
            return 2;
        case 'record':
            return (ty.fields || []).reduce((sum, field)=>sum + witTypeFlatCount(field.type), 0);
        case 'tuple':
            return (ty.items || []).reduce((sum, item)=>sum + witTypeFlatCount(item), 0);
        case 'option': {
            const payload = ty.some ? witTypeFlatCount(ty.some) : 0;
            return 1 + payload;
        }
        case 'result': {
            const okCount = ty.ok ? witTypeFlatCount(ty.ok) : 0;
            const errCount = ty.err ? witTypeFlatCount(ty.err) : 0;
            return 1 + Math.max(okCount, errCount);
        }
        default:
            return 0;
    }
}

function witTypeLayout(ty) {
    switch(ty.kind){
        case 'enum':
            return witEnumLayout(ty);
        case 'flags':
            return witFlagsLayout(ty);
        case 'bool':
        case 'u8':
        case 's8':
            return {
                size: 1,
                align: 1
            };
        case 'u16':
        case 's16':
            return {
                size: 2,
                align: 2
            };
        case 'u32':
        case 's32':
        case 'f32':
        case 'char':
            return {
                size: 4,
                align: 4
            };
        case 'u64':
        case 's64':
        case 'f64':
            return {
                size: 8,
                align: 8
            };
        case 'string':
        case 'list':
            return {
                size: 8,
                align: 4
            };
        case 'record': {
            let size = 0;
            let align = 1;
            for (const field of ty.fields || []){
                const layout = witTypeLayout(field.type);
                size = alignTo(size, layout.align);
                size += layout.size;
                align = Math.max(align, layout.align);
            }
            size = alignTo(size, align);
            return {
                size,
                align
            };
        }
        case 'tuple': {
            let size = 0;
            let align = 1;
            for (const item of ty.items || []){
                const layout = witTypeLayout(item);
                size = alignTo(size, layout.align);
                size += layout.size;
                align = Math.max(align, layout.align);
            }
            size = alignTo(size, align);
            return {
                size,
                align
            };
        }
        case 'option': {
            const payload = ty.some ? witTypeLayout(ty.some) : {
                size: 0,
                align: 1
            };
            const offset = alignTo(1, payload.align);
            const size = alignTo(offset + payload.size, Math.max(1, payload.align));
            return {
                size,
                align: Math.max(1, payload.align)
            };
        }
        case 'result': {
            const okLayout = ty.ok ? witTypeLayout(ty.ok) : {
                size: 0,
                align: 1
            };
            const errLayout = ty.err ? witTypeLayout(ty.err) : {
                size: 0,
                align: 1
            };
            const payloadAlign = Math.max(okLayout.align, errLayout.align, 1);
            const payloadSize = Math.max(okLayout.size, errLayout.size);
            const offset = alignTo(1, payloadAlign);
            const size = alignTo(offset + payloadSize, payloadAlign);
            return {
                size,
                align: payloadAlign
            };
        }
        default:
            return {
                size: 0,
                align: 1
            };
    }
}

function alignTo(offset, alignment) {
    const align = Math.max(1, alignment);
    return Math.ceil(offset / align) * align;
}

function allocBytes(realloc, size, align) {
    return realloc(0, 0, align, size);
}

function lowerString(value, memory, realloc) {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(String(value ?? ''));
    const ptr = bytes.length ? allocBytes(realloc, bytes.length, 1) : 0;
    if (bytes.length) {
        new Uint8Array(memory.buffer, ptr, bytes.length).set(bytes);
    }
    return [
        ptr,
        bytes.length
    ];
}

function parseResultValue(value) {
    if (value && typeof value === 'object' && !Array.isArray(value)) {
        if (Object.prototype.hasOwnProperty.call(value, 'ok')) {
            if (typeof value.ok === 'boolean') {
                if (value.ok) {
                    return {
                        kind: 'ok',
                        value: Object.prototype.hasOwnProperty.call(value, 'value') ? value.value : null
                    };
                }
                const errValue = Object.prototype.hasOwnProperty.call(value, 'error') ? value.error : Object.prototype.hasOwnProperty.call(value, 'err') ? value.err : null;
                return {
                    kind: 'err',
                    value: errValue
                };
            }
            return {
                kind: 'ok',
                value: value.ok
            };
        }
        if (Object.prototype.hasOwnProperty.call(value, 'err')) {
            return {
                kind: 'err',
                value: value.err
            };
        }
    }
    return null;
}

function lowerBytes(value, memory, realloc) {
    let bytes = null;
    if (value instanceof Uint8Array) {
        bytes = value;
    } else if (Array.isArray(value)) {
        bytes = Uint8Array.from(value.map((v)=>v & 0xff));
    } else if (typeof value === 'string') {
        bytes = new TextEncoder().encode(value);
    } else {
        throw new Error('list<u8> expects array, Uint8Array, or string');
    }
    const ptr = bytes.length ? allocBytes(realloc, bytes.length, 1) : 0;
    if (bytes.length) {
        new Uint8Array(memory.buffer, ptr, bytes.length).set(bytes);
    }
    return [
        ptr,
        bytes.length
    ];
}

function lowerValue(value, ty, memory, realloc) {
    ensureSupportedWitType(ty);
    switch(ty.kind){
        case 'enum':
            return [
                enumCaseIndex(value, ty)
            ];
        case 'flags':
            return [
                flagsMaskFromValue(value, ty)
            ];
        case 'bool':
            return [
                value ? 1 : 0
            ];
        case 'u8':
        case 'u16':
        case 'u32':
        case 's8':
        case 's16':
        case 's32':
        case 'char':
            return [
                Number(value || 0)
            ];
        case 'u64':
        case 's64':
            return [
                Number(value || 0)
            ];
        case 'f32':
        case 'f64':
            return [
                Number(value || 0)
            ];
        case 'string':
            return lowerString(value, memory, realloc);
        case 'list':
            return lowerBytes(value, memory, realloc);
        case 'record': {
            const out = [];
            const obj = value || {};
            for (const field of ty.fields || []){
                const key = field.name;
                const alt = toSnakeCase(key);
                const fieldValue = Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : obj[alt];
                out.push(...lowerValue(fieldValue, field.type, memory, realloc));
            }
            return out;
        }
        case 'tuple': {
            const out = [];
            const arr = Array.isArray(value) ? value : [];
            const items = ty.items || [];
            for (let i = 0; i < items.length; i++){
                out.push(...lowerValue(arr[i], items[i], memory, realloc));
            }
            return out;
        }
        case 'option': {
            const payloadCount = ty.some ? witTypeFlatCount(ty.some) : 0;
            if (value === null || value === undefined) {
                return [
                    0,
                    ...Array(payloadCount).fill(0)
                ];
            }
            const payload = ty.some ? lowerValue(value, ty.some, memory, realloc) : [];
            return [
                1,
                ...payload,
                ...Array(Math.max(0, payloadCount - payload.length)).fill(0)
            ];
        }
        case 'result': {
            const okCount = ty.ok ? witTypeFlatCount(ty.ok) : 0;
            const errCount = ty.err ? witTypeFlatCount(ty.err) : 0;
            const payloadCount = Math.max(okCount, errCount);
            const parsed = parseResultValue(value);
            if (!parsed) {
                throw new Error('result<T,E> expects {ok: ...} or {err: ...}');
            }
            if (parsed.kind === 'ok') {
                const payload = ty.ok ? lowerValue(parsed.value, ty.ok, memory, realloc) : [];
                return [
                    0,
                    ...payload,
                    ...Array(Math.max(0, payloadCount - payload.length)).fill(0)
                ];
            }
            const payload = ty.err ? lowerValue(parsed.value, ty.err, memory, realloc) : [];
            return [
                1,
                ...payload,
                ...Array(Math.max(0, payloadCount - payload.length)).fill(0)
            ];
        }
        default:
            throw new Error(`Unsupported WIT type '${ty.kind}' in abi=wit v1`);
    }
}

function liftFromFlat(ty, flat, index, memory) {
    ensureSupportedWitType(ty);
    switch(ty.kind){
        case 'enum': {
            const value = flat[index] ?? 0;
            return {
                value: enumCaseName(value, ty),
                next: index + 1
            };
        }
        case 'flags': {
            const value = flat[index] ?? 0;
            return {
                value: flagsMaskToArray(value, ty),
                next: index + 1
            };
        }
        case 'bool':
            return {
                value: flat[index] !== 0,
                next: index + 1
            };
        case 'u8':
        case 'u16':
        case 'u32':
        case 's8':
        case 's16':
        case 's32':
        case 'char':
            return {
                value: flat[index] ?? 0,
                next: index + 1
            };
        case 'u64':
        case 's64':
        case 'f32':
        case 'f64':
            return {
                value: flat[index] ?? 0,
                next: index + 1
            };
        case 'string': {
            const ptr = flat[index] || 0;
            const len = flat[index + 1] || 0;
            const bytes = ptr && len ? new Uint8Array(memory.buffer, ptr, len) : new Uint8Array();
            const value = new TextDecoder().decode(bytes);
            return {
                value,
                next: index + 2
            };
        }
        case 'list': {
            const ptr = flat[index] || 0;
            const len = flat[index + 1] || 0;
            const bytes = ptr && len ? new Uint8Array(memory.buffer, ptr, len) : new Uint8Array();
            return {
                value: Array.from(bytes),
                next: index + 2
            };
        }
        case 'record': {
            const obj = {};
            let next = index;
            for (const field of ty.fields || []){
                const res = liftFromFlat(field.type, flat, next, memory);
                obj[toSnakeCase(field.name)] = res.value;
                next = res.next;
            }
            return {
                value: obj,
                next
            };
        }
        case 'tuple': {
            const items = [];
            let next = index;
            for (const item of ty.items || []){
                const res = liftFromFlat(item, flat, next, memory);
                items.push(res.value);
                next = res.next;
            }
            return {
                value: items,
                next
            };
        }
        case 'option': {
            const tag = flat[index] || 0;
            let next = index + 1;
            if (tag === 0 || !ty.some) {
                return {
                    value: null,
                    next: next + (ty.some ? witTypeFlatCount(ty.some) : 0)
                };
            }
            const res = liftFromFlat(ty.some, flat, next, memory);
            const payloadCount = witTypeFlatCount(ty.some);
            return {
                value: res.value,
                next: index + 1 + payloadCount
            };
        }
        case 'result': {
            const tag = flat[index] || 0;
            const okCount = ty.ok ? witTypeFlatCount(ty.ok) : 0;
            const errCount = ty.err ? witTypeFlatCount(ty.err) : 0;
            const payloadCount = Math.max(okCount, errCount);
            const payloadIndex = index + 1;
            if (tag === 0) {
                const value = ty.ok ? liftFromFlat(ty.ok, flat, payloadIndex, memory).value : null;
                return {
                    value: {
                        ok: value
                    },
                    next: payloadIndex + payloadCount
                };
            }
            const value = ty.err ? liftFromFlat(ty.err, flat, payloadIndex, memory).value : null;
            return {
                value: {
                    err: value
                },
                next: payloadIndex + payloadCount
            };
        }
        default:
            throw new Error(`Unsupported WIT type '${ty.kind}' in abi=wit v1`);
    }
}

function loadValueFromMemory(ty, memory, ptr) {
    ensureSupportedWitType(ty);
    const view = new DataView(memory.buffer);
    switch(ty.kind){
        case 'enum': {
            const layout = witEnumLayout(ty);
            let raw = 0;
            if (layout.size === 1) {
                raw = view.getUint8(ptr);
            } else if (layout.size === 2) {
                raw = view.getUint16(ptr, true);
            } else {
                raw = view.getUint32(ptr, true);
            }
            return enumCaseName(raw, ty);
        }
        case 'flags': {
            const layout = witFlagsLayout(ty);
            let raw = 0;
            if (layout.size === 1) {
                raw = view.getUint8(ptr);
            } else if (layout.size === 2) {
                raw = view.getUint16(ptr, true);
            } else {
                raw = view.getUint32(ptr, true);
            }
            return flagsMaskToArray(raw, ty);
        }
        case 'bool':
        case 'u8':
        case 's8':
            return view.getUint8(ptr) !== 0;
        case 'u16':
            return view.getUint16(ptr, true);
        case 's16':
            return view.getInt16(ptr, true);
        case 'u32':
        case 'char':
            return view.getUint32(ptr, true);
        case 's32':
            return view.getInt32(ptr, true);
        case 'u64':
        case 's64': {
            const low = view.getUint32(ptr, true);
            const high = view.getUint32(ptr + 4, true);
            return high * 2 ** 32 + low;
        }
        case 'f32':
            return view.getFloat32(ptr, true);
        case 'f64':
            return view.getFloat64(ptr, true);
        case 'string': {
            const dataPtr = view.getUint32(ptr, true);
            const len = view.getUint32(ptr + 4, true);
            const bytes = dataPtr && len ? new Uint8Array(memory.buffer, dataPtr, len) : new Uint8Array();
            return new TextDecoder().decode(bytes);
        }
        case 'list': {
            const dataPtr = view.getUint32(ptr, true);
            const len = view.getUint32(ptr + 4, true);
            const bytes = dataPtr && len ? new Uint8Array(memory.buffer, dataPtr, len) : new Uint8Array();
            return Array.from(bytes);
        }
        case 'record': {
            const obj = {};
            let offset = 0;
            for (const field of ty.fields || []){
                const layout = witTypeLayout(field.type);
                offset = alignTo(offset, layout.align);
                obj[toSnakeCase(field.name)] = loadValueFromMemory(field.type, memory, ptr + offset);
                offset += layout.size;
            }
            return obj;
        }
        case 'tuple': {
            const items = [];
            let offset = 0;
            for (const item of ty.items || []){
                const layout = witTypeLayout(item);
                offset = alignTo(offset, layout.align);
                items.push(loadValueFromMemory(item, memory, ptr + offset));
                offset += layout.size;
            }
            return items;
        }
        case 'option': {
            const tag = view.getUint8(ptr);
            if (!ty.some) {
                return null;
            }
            const payloadLayout = witTypeLayout(ty.some);
            const offset = alignTo(1, payloadLayout.align);
            if (tag === 0) {
                return null;
            }
            return loadValueFromMemory(ty.some, memory, ptr + offset);
        }
        case 'result': {
            const tag = view.getUint8(ptr);
            const okLayout = ty.ok ? witTypeLayout(ty.ok) : {
                size: 0,
                align: 1
            };
            const errLayout = ty.err ? witTypeLayout(ty.err) : {
                size: 0,
                align: 1
            };
            const payloadAlign = Math.max(okLayout.align, errLayout.align, 1);
            const offset = alignTo(1, payloadAlign);
            if (tag === 0) {
                const value = ty.ok ? loadValueFromMemory(ty.ok, memory, ptr + offset) : null;
                return {
                    ok: value
                };
            }
            const value = ty.err ? loadValueFromMemory(ty.err, memory, ptr + offset) : null;
            return {
                err: value
            };
        }
        default:
            throw new Error(`Unsupported WIT type '${ty.kind}' in abi=wit v1`);
    }
}

function callWasmWitExport(moduleId, exportName, argsJson) {
    const entry = loadWasmModule(moduleId);
    const exportInfo = getWitExport(entry, exportName);
    if (!exportInfo) {
        throw new Error(`Unknown wasm export '${exportName}' (abi=wit)`);
    }
    const funcSig = exportInfo.func;
    const args = argsJson ? JSON.parse(argsJson) : [];
    if (!Array.isArray(args)) {
        throw new Error('abi=wit expects array args');
    }
    if (args.length !== funcSig.params.length) {
        throw new Error(`abi=wit expected ${funcSig.params.length} args, got ${args.length}`);
    }

    const instance = new WebAssembly.Instance(entry.module, {});
    const exports = instance.exports || {};
    const memory = exports.memory;
    const realloc = exports.cabi_realloc || exports.canonical_abi_realloc;
    if (!memory || typeof realloc !== 'function') {
        throw new Error(`Wasm module '${moduleId}' must export memory and cabi_realloc`);
    }

    const wasmName = resolveWitExportName(exports, exportInfo.interfaceName, funcSig.name);
    if (!wasmName || typeof exports[wasmName] !== 'function') {
        const available = Object.keys(exports).filter((name)=>typeof exports[name] === 'function');
        throw new Error(`Missing wasm export for '${exportName}'. Available: ${available.join(', ')}`);
    }
    const func = exports[wasmName];

    const flatArgs = [];
    for (let i = 0; i < funcSig.params.length; i++){
        flatArgs.push(...lowerValue(args[i], funcSig.params[i].type, memory, realloc));
    }

    const resultType = funcSig.result || null;
    if (!resultType) {
        func(...flatArgs);
        return 'null';
    }

    const flatResultCount = witTypeFlatCount(resultType);
    let useRetptr = false;
    if (typeof func.length === 'number' && func.length === flatArgs.length + 1) {
        useRetptr = true;
    }

    if (useRetptr) {
        const layout = witTypeLayout(resultType);
        const retPtr = allocBytes(realloc, layout.size, layout.align);
        func(retPtr, ...flatArgs);
        const resultValue = loadValueFromMemory(resultType, memory, retPtr);
        return JSON.stringify(resultValue);
    }

    const raw = func(...flatArgs);
    const flatResults = flatResultCount <= 1 ? [
        raw
    ] : Array.isArray(raw) ? raw : [
        raw
    ];
    const lifted = liftFromFlat(resultType, flatResults, 0, memory);
    return JSON.stringify(lifted.value);
}
function writeWasmResultBytes(bytes) {
    if (!phpAlloc || !phpMemory) {
        throw new Error('php wasm allocator unavailable');
    }
    const dataPtr = bytes.length ? phpAlloc(bytes.length) : 0;
    if (bytes.length) {
        new Uint8Array(phpMemory.buffer, dataPtr, bytes.length).set(bytes);
    }
    const resultPtr = phpAlloc(8);
    writeResult(resultPtr, dataPtr, bytes.length);
    return resultPtr;
}
function phpWasmCall(modulePtr, moduleLen, exportPtr, exportLen, argsPtr, argsLen) {
    try {
        if (!phpMemory) {
            throw new Error('php wasm memory unavailable');
        }
        const moduleId = readString(modulePtr, moduleLen);
        const exportName = readString(exportPtr, exportLen);
        const argsJson = readString(argsPtr, argsLen);
        const entry = loadWasmModule(moduleId);
        const abi = entry.manifest?.abi || 'deka-json';
        const resultJson = abi === 'wit'
            ? callWasmWitExport(moduleId, exportName, argsJson)
            : callWasmJsonExport(moduleId, exportName, argsJson);
        const bytes = new TextEncoder().encode(resultJson);
        return writeWasmResultBytes(bytes);
    } catch (err) {
        const message = err && err.message ? err.message : String(err);
        const errorJson = JSON.stringify({
            __deka_error: message
        });
        const bytes = new TextEncoder().encode(errorJson);
        return writeWasmResultBytes(bytes);
    }
}
if (!globalThis.Response) {
    globalThis.Response = class Response1 {
        body;
        status;
        headers;
        constructor(body, init){
            this.body = body || '';
            this.status = init?.status || 200;
            this.headers = init?.headers || {};
        }
    };
}
let phpInstance = null;
let phpModule = null;
let phpMemory = null;
let phpAlloc = null;
let phpFree = null;
let phpRun = null;
const __wbindgen_heap = [
    undefined,
    null,
    true,
    false
];
let __wbindgen_heap_next = __wbindgen_heap.length;
function __wbindgen_get_object(idx) {
    return __wbindgen_heap[idx];
}
function __wbindgen_add_heap_object(obj) {
    if (__wbindgen_heap_next === __wbindgen_heap.length) {
        __wbindgen_heap.push(__wbindgen_heap.length + 1);
    }
    const idx = __wbindgen_heap_next;
    __wbindgen_heap_next = __wbindgen_heap[idx];
    __wbindgen_heap[idx] = obj;
    return idx;
}
function __wbindgen_drop_object(idx) {
    if (idx < 4) return;
    __wbindgen_heap[idx] = __wbindgen_heap_next;
    __wbindgen_heap_next = idx;
}
async function initPhpWasm() {
    if (phpInstance) return phpInstance;
    const wasmBytes = op_php_get_wasm();
    if (!wasmBytes || wasmBytes.length === 0) {
        console.error('[php] wasm bytes missing or empty');
    }
    const wasmModule = new WebAssembly.Module(wasmBytes);
    const imports = {
        env: {
            php_log: (ptr, len)=>{
                if (!phpMemory) return;
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                let message = new TextDecoder().decode(bytes);
                if (globalThis.__dekaPhpLogEnabled) {
                    console.log('[php]', message);
                }
            },
            php_fs_read: phpFsRead,
            php_fs_exists: phpFsExists,
            php_wasm_call: phpWasmCall
        },
        __wbindgen_placeholder__: {
            __wbindgen_describe: ()=>{},
            __wbindgen_describe_cast: ()=>{},
            __wbindgen_object_drop_ref: (idx)=>__wbindgen_drop_object(idx),
            __wbg_getTimezoneOffset_45389e26d6f46823: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTimezoneOffset === "function"
                    ? obj.getTimezoneOffset()
                    : 0;
            },
            __wbg_getTimezoneOffset_81776d10a4ec18a8: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTimezoneOffset === "function"
                    ? obj.getTimezoneOffset()
                    : 0;
            },
            __wbg_new_b2db8aa2650f793a: (...args)=>{
                if (args.length > 0 && typeof args[0] === "number") {
                    return __wbindgen_add_heap_object(new Date(args[0]));
                }
                return __wbindgen_add_heap_object(new Date());
            },
            __wbg_new_245cd5c49157e602: (...args)=>{
                if (args.length > 0 && typeof args[0] === "number") {
                    return __wbindgen_add_heap_object(new Date(args[0]));
                }
                return __wbindgen_add_heap_object(new Date());
            },
            __wbg_new_0_23cedd11d9b40c9d: ()=>__wbindgen_add_heap_object(new Date()),
            __wbg_new_0_73afc35eb544e539: ()=>__wbindgen_add_heap_object(new Date()),
            __wbg_getTime_ad1e9878a735af08: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTime === "function" ? obj.getTime() : 0;
            },
            __wbg_getTime_1e3cd1391c5c3995: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTime === "function" ? obj.getTime() : 0;
            },
            __wbg___wbindgen_throw_dd24417ed36fc46e: (ptr, len)=>{
                if (!phpMemory) {
                    throw new Error("php wasm trap");
                }
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                const message = new TextDecoder().decode(bytes);
                throw new Error(message);
            },
            __wbg___wbindgen_throw_be289d5034ed271b: (ptr, len)=>{
                if (!phpMemory) {
                    throw new Error("php wasm trap");
                }
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                const message = new TextDecoder().decode(bytes);
                throw new Error(message);
            },
            __wbg___wbindgen_is_object_ce774f3490692386: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return typeof obj === "object" && obj !== null;
            },
            __wbg___wbindgen_is_string_704ef9c8fc131030: (idx)=>{
                return typeof __wbindgen_get_object(idx) === "string";
            },
            __wbg___wbindgen_is_function_8d400b8b1af978cd: (idx)=>{
                return typeof __wbindgen_get_object(idx) === "function";
            },
            __wbg___wbindgen_is_undefined_f6b95eab589e0269: (idx)=>{
                return __wbindgen_get_object(idx) === undefined;
            }
        },
        __wbindgen_externref_xform__: {
            __wbindgen_externref_table_set_null: (_idx)=>{},
            __wbindgen_externref_table_grow: (_delta)=>0
        }
    };
    phpModule = wasmModule;
    phpInstance = await WebAssembly.instantiate(wasmModule, imports);
    phpMemory = phpInstance.exports.memory;
    phpAlloc = phpInstance.exports.php_alloc;
    phpFree = phpInstance.exports.php_free;
    phpRun = phpInstance.exports.php_run;
    if (!phpMemory || !phpAlloc || !phpFree || !phpRun) {
        throw new Error('php wasm exports missing php_* api');
    }
    return phpInstance;
}
function readString(ptr, len) {
    const view = new Uint8Array(phpMemory.buffer, ptr, len);
    return new TextDecoder().decode(view);
}
function writeBytes(bytes) {
    const ptr = phpAlloc(bytes.length);
    new Uint8Array(phpMemory.buffer, ptr, bytes.length).set(bytes);
    return ptr;
}
function phpFsRead(pathPtr, pathLen, outPtr) {
    if (!phpMemory || !phpAlloc) return 0;
    const rawPath = readString(pathPtr, pathLen);
    const pathValue = rawPath.replace(/\0+$/, '');
    const resolved = normalizeHostPath(pathValue);
    const allowed = isPathAllowed(resolved);
    if (globalThis.process?.env?.DEKA_PHP_FS_DEBUG) {
        console.log('[php-fs] read', pathValue, '->', resolved, 'allowed=', allowed);
    }
    if (!allowed) return 0;
    if (!globalThis.fs.existsSync(resolved)) return 0;
    const bytes = globalThis.fs.readFileSync(resolved);
    const dataPtr = bytes.length ? phpAlloc(bytes.length) : 0;
    if (bytes.length) {
        new Uint8Array(phpMemory.buffer, dataPtr, bytes.length).set(bytes);
    }
    writeResult(outPtr, dataPtr, bytes.length);
    return 1;
}
function phpFsExists(pathPtr, pathLen) {
    if (!phpMemory) return 0;
    const rawPath = readString(pathPtr, pathLen);
    const pathValue = rawPath.replace(/\0+$/, '');
    const resolved = normalizeHostPath(pathValue);
    const allowed = isPathAllowed(resolved);
    const exists = allowed && globalThis.fs.existsSync(resolved);
    if (globalThis.process?.env?.DEKA_PHP_FS_DEBUG) {
        console.log('[php-fs] exists', pathValue, '->', resolved, 'allowed=', allowed, 'exists=', exists);
    }
    return exists ? 1 : 0;
}
function escapePhpString(value) {
    return String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\r/g, '\\r').replace(/\n/g, '\\n');
}
function buildArrayAssignments(target, entries) {
    let out = `${target} = array();\n`;
    for (const [key, value] of entries){
        const escapedKey = escapePhpString(key);
        if (value === null || value === undefined) {
            out += `${target}['${escapedKey}'] = null;\n`;
        } else {
            out += `${target}['${escapedKey}'] = '${escapePhpString(value)}';\n`;
        }
    }
    return out;
}
function parseQuery(queryString) {
    const params = new URLSearchParams(queryString || '');
    const out = [];
    for (const [key, value] of params.entries()){
        out.push([
            key,
            value
        ]);
    }
    return out;
}
function parseMultipart(body, boundary) {
    const text = String(body || '');
    const outFiles = [];
    const outFields = [];
    const delimiter = `--${boundary}`;
    const parts = text.split(delimiter);
    for (const part of parts){
        if (!part || part === '--' || part === '--\r\n') {
            continue;
        }
        const trimmed = part.replace(/^\r?\n/, '').replace(/\r?\n--$/, '');
        const headerEnd = trimmed.indexOf('\r\n\r\n');
        if (headerEnd === -1) {
            continue;
        }
        const headerText = trimmed.slice(0, headerEnd);
        const bodyText = trimmed.slice(headerEnd + 4);
        const headers = headerText.split('\r\n');
        const dispo = headers.find((line)=>line.toLowerCase().startsWith('content-disposition'));
        if (!dispo) {
            continue;
        }
        const nameMatch = dispo.match(/name=\"([^\"]+)\"/i);
        if (!nameMatch) {
            continue;
        }
        const name = nameMatch[1];
        const filenameMatch = dispo.match(/filename=\"([^\"]*)\"/i);
        if (filenameMatch && filenameMatch[1] !== undefined && filenameMatch[1] !== '') {
            const filename = filenameMatch[1];
            const contentTypeHeader = headers.find((line)=>line.toLowerCase().startsWith('content-type'));
            const contentType = contentTypeHeader ? contentTypeHeader.split(':').slice(1).join(':').trim() : 'application/octet-stream';
            outFiles.push({
                field: name,
                name: filename,
                type: contentType,
                size: bodyText.length,
                content: bodyText
            });
        } else {
            outFields.push([
                name,
                bodyText.replace(/\r?\n$/, '')
            ]);
        }
    }
    return {
        fields: outFields,
        files: outFiles
    };
}
function parseCookies(cookieHeader) {
    if (!cookieHeader) return [];
    const out = [];
    const parts = String(cookieHeader).split(';');
    for (const part of parts){
        const trimmed = part.trim();
        if (!trimmed) continue;
        const idx = trimmed.indexOf('=');
        if (idx < 0) {
            out.push([
                trimmed,
                ''
            ]);
        } else {
            out.push([
                trimmed.slice(0, idx),
                trimmed.slice(idx + 1)
            ]);
        }
    }
    return out;
}
function normalizeHeaders(headers) {
    if (!headers) return {};
    if (typeof headers.entries === 'function') {
        const out = {};
        for (const [key, value] of headers.entries()){
            out[key] = value;
        }
        return out;
    }
    return headers;
}
function bodyToString(body) {
    if (!body) return '';
    if (typeof body === 'string') return body;
    if (body instanceof Uint8Array) {
        return new TextDecoder().decode(body);
    }
    return String(body);
}
function normalizeRequestUrl(request) {
    const raw = request && request.url ? request.url : 'http://localhost/';
    if (raw instanceof URL) return raw;
    const rawStr = typeof raw === 'string' ? raw : String(raw);
    try {
        return new URL(rawStr, 'http://localhost/');
    } catch (_err) {
        return new URL('http://localhost/');
    }
}
function buildPrelude(request, filePath) {
    const url = normalizeRequestUrl(request);
    const headers = normalizeHeaders(request.headers || {});
    const contentType = headers['content-type'] || headers['Content-Type'] || '';
    const contentLength = headers['content-length'] || headers['Content-Length'] || '';
    const hostHeader = headers.host || headers.Host || url.host || 'localhost';
    const hostParts = String(hostHeader).split(':');
    const hostname = hostParts[0] || 'localhost';
    const port = hostParts[1] ? Number(hostParts[1]) : url.protocol === 'https:' ? 443 : 80;
    const queryString = url.search ? url.search.slice(1) : '';
    const now = Date.now();
    const requestTime = Math.floor(now / 1000);
    const requestTimeFloat = (now / 1000).toFixed(6);
    const requestScheme = url.protocol === 'https:' ? 'https' : 'http';
    const serverEntries = [
        [
            'REQUEST_METHOD',
            request.method || 'GET'
        ],
        [
            'REQUEST_URI',
            url.pathname + (url.search || '')
        ],
        [
            'QUERY_STRING',
            queryString
        ],
        [
            'GATEWAY_INTERFACE',
            'CGI/1.1'
        ],
        [
            'HTTP_HOST',
            hostHeader
        ],
        [
            'SERVER_NAME',
            hostname
        ],
        [
            'SERVER_PORT',
            String(port)
        ],
        [
            'SERVER_PROTOCOL',
            'HTTP/1.1'
        ],
        [
            'SERVER_SOFTWARE',
            'deka'
        ],
        [
            'SCRIPT_NAME',
            url.pathname || '/'
        ],
        [
            'SCRIPT_FILENAME',
            filePath
        ],
        [
            'DOCUMENT_ROOT',
            globalThis.path && typeof globalThis.path.dirname === 'function' ? globalThis.path.dirname(filePath) : '.'
        ],
        [
            'REQUEST_SCHEME',
            requestScheme
        ],
        [
            'HTTPS',
            url.protocol === 'https:' ? 'on' : 'off'
        ],
        [
            'REMOTE_ADDR',
            '127.0.0.1'
        ],
        [
            'REMOTE_PORT',
            '0'
        ],
        [
            'PATH_INFO',
            ''
        ],
        [
            'REQUEST_TIME',
            String(requestTime)
        ],
        [
            'REQUEST_TIME_FLOAT',
            String(requestTimeFloat)
        ],
        [
            'PHP_SAPI',
            'cli-server'
        ]
    ];
    if (contentType) {
        serverEntries.push([
            'CONTENT_TYPE',
            contentType
        ]);
    }
    if (contentLength) {
        serverEntries.push([
            'CONTENT_LENGTH',
            contentLength
        ]);
    }
    for (const [key, value] of Object.entries(headers)){
        const headerKey = `HTTP_${String(key).toUpperCase().replace(/-/g, '_')}`;
        serverEntries.push([
            headerKey,
            value
        ]);
    }
    let prelude = buildSapiMarker('cli-server');
    if (String(filePath || '').endsWith('.phpx')) {
        // PHPX entry code runs in its own namespace block (in injectPrelude).
    }
    for (const [key, value] of serverEntries){
        const escapedKey = escapePhpString(key);
        prelude += `$_SERVER['${escapedKey}'] = '${escapePhpString(value)}';\n`;
    }
    const getEntries = parseQuery(queryString);
    const cookieEntries = parseCookies(headers.cookie || headers.Cookie);
    const postEntries = [];
    const fileEntries = [];
    const rawBody = bodyToString(request.body);
    if (rawBody && String(contentType).includes('application/x-www-form-urlencoded')) {
        postEntries.push(...parseQuery(rawBody));
    } else if (rawBody && String(contentType).includes('multipart/form-data')) {
        const boundaryMatch = String(contentType).match(/boundary=([^;]+)/i);
        if (boundaryMatch) {
            const parsed = parseMultipart(rawBody, boundaryMatch[1]);
            postEntries.push(...parsed.fields);
            fileEntries.push(...parsed.files);
        }
    }
    prelude += buildArrayAssignments('$_GET', getEntries);
    prelude += buildArrayAssignments('$_POST', postEntries);
    prelude += buildArrayAssignments('$_COOKIE', cookieEntries);
    prelude += '$_REQUEST = array();\n';
    for (const [key, value] of [
        ...getEntries,
        ...postEntries,
        ...cookieEntries
    ]){
        prelude += `$_REQUEST['${escapePhpString(key)}'] = '${escapePhpString(value)}';\n`;
    }
    prelude += '$_FILES = array();\n';
    for (const file of fileEntries){
        const field = escapePhpString(file.field);
        prelude += `$_FILES['${field}'] = array(\n`;
        prelude += `  'name' => '${escapePhpString(file.name)}',\n`;
        prelude += `  'type' => '${escapePhpString(file.type)}',\n`;
        prelude += `  'size' => ${file.size},\n`;
        prelude += "  'tmp_name' => '',\n";
        prelude += "  'error' => 0,\n";
        prelude += `  'content' => '${escapePhpString(file.content)}'\n`;
        prelude += ");\n";
    }
    const rawInput = escapePhpString(rawBody);
    prelude += `$_SERVER['PHP_INPUT'] = '${rawInput}';\n`;
    prelude += `$_SERVER['REQUEST_BODY'] = '${rawInput}';\n`;
    prelude += `$HTTP_RAW_POST_DATA = '${rawInput}';\n`;
    const moduleInfo = buildModulePrelude(filePath);
    prelude += moduleInfo.prelude;
    return {
        prelude,
        entryPrelude: moduleInfo.entryPrelude,
        source: moduleInfo.source
    };
}
function buildCliPrelude(filePath) {
    let argv = [];
    const argsRaw = globalThis.process?.env?.DEKA_ARGS;
    if (argsRaw) {
        try {
            const parsed = JSON.parse(argsRaw);
            if (Array.isArray(parsed)) {
                argv = parsed.map((arg)=>String(arg));
            }
        } catch (_err) {}
    }
    const cwd = globalThis.process?.cwd ? globalThis.process.cwd() : '';
    const resolved = op_php_path_resolve(cwd, filePath);
    const docRoot = resolved.includes('/') ? resolved.slice(0, resolved.lastIndexOf('/')) : '';
    const now = Date.now();
    const requestTime = Math.floor(now / 1000);
    const requestTimeFloat = (now / 1000).toFixed(6);
    let prelude = buildSapiMarker('cli');
    if (String(filePath || '').endsWith('.phpx')) {
        // PHPX entry code runs in its own namespace block (in injectPrelude).
    }
    prelude += "$_SERVER = array();\n";
    prelude += `$_SERVER['SCRIPT_FILENAME'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['SCRIPT_NAME'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['PHP_SELF'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['DOCUMENT_ROOT'] = '${escapePhpString(docRoot)}';\n`;
    prelude += `$_SERVER['PWD'] = '${escapePhpString(cwd)}';\n`;
    prelude += "$_SERVER['PHP_SAPI'] = 'cli';\n";
    prelude += `$_SERVER['REQUEST_TIME'] = '${requestTime}';\n`;
    prelude += `$_SERVER['REQUEST_TIME_FLOAT'] = '${requestTimeFloat}';\n`;
    prelude += "$argv = array();\n";
    prelude += `$argv[] = '${escapePhpString(resolved)}';\n`;
    for (const arg of argv){
        prelude += `$argv[] = '${escapePhpString(arg)}';\n`;
    }
    prelude += `$argc = ${argv.length + 1};\n`;
    prelude += "$_SERVER['argv'] = $argv;\n";
    prelude += "$_SERVER['argc'] = $argc;\n";
    const moduleInfo = buildModulePrelude(filePath);
    prelude += moduleInfo.prelude;
    return {
        prelude,
        entryPrelude: moduleInfo.entryPrelude,
        source: moduleInfo.source
    };
}
function injectPrelude(source, prelude, filePath = '', entryPrelude = '') {
    const trimmed = source.trimStart();
    if (trimmed.startsWith('<?php')) {
        const idx = source.indexOf('<?php');
        const afterOpen = source.slice(idx + 5);
        const afterTrimmed = afterOpen.trimStart();
        if (afterTrimmed.startsWith('declare')) {
            const declareStart = afterOpen.indexOf(afterTrimmed);
            const semicolonIdx = afterTrimmed.indexOf(';');
            if (semicolonIdx !== -1) {
                const insertPos = idx + 5 + declareStart + semicolonIdx + 1;
                return source.slice(0, insertPos) + '\n' + prelude + '\n' + source.slice(insertPos);
            }
        }
        return source.slice(0, idx + 5) + '\n' + prelude + '\n' + source.slice(idx + 5);
    }
    if (String(filePath || '').endsWith('.phpx')) {
        // Wrap PHPX prelude in the global namespace and the entry code in a dedicated namespace.
        return `${PHPX_INTERNAL_MARKER}\nnamespace {\n${prelude}\n}\nnamespace __phpx_entry {\n${entryPrelude}${source}\n}\n`;
    }
    return `<?php\n${prelude}\n?>\n` + source;
}
function runSource(source) {
    const bytes = new TextEncoder().encode(source);
    const srcPtr = writeBytes(bytes);
    const resultPtr = phpRun(srcPtr, bytes.length);
    phpFree(srcPtr, bytes.length);
    const view = new DataView(phpMemory.buffer, resultPtr, 8);
    const outPtr = view.getUint32(0, true);
    const outLen = view.getUint32(4, true);
    const outText = readString(outPtr, outLen);
    phpFree(outPtr, outLen);
    phpFree(resultPtr, 8);
    return JSON.parse(outText);
}
async function runFile(filePath) {
    await initPhpWasm();
    setPhpActiveRoots(filePath);
    const moduleInfo = buildCliPrelude(filePath);
    const stitched = injectPrelude(moduleInfo.source, moduleInfo.prelude, filePath, moduleInfo.entryPrelude);
    const dumpPath = globalThis.process?.env?.DEKA_DUMP_PHPX;
    if (dumpPath) {
        if (dumpPath === 'stdout') {
            Deno.core.print(stitched, false);
        } else if (dumpPath === 'stderr') {
            Deno.core.print(stitched, true);
        } else {
            try {
                globalThis.fs.writeFileSync(dumpPath, stitched, 'utf8');
            } catch (err) {
                console.error('[phpx] failed to write DEKA_DUMP_PHPX:', err);
            }
        }
    }
    return runSource(stitched);
}
function runRequest(request, filePath) {
    setPhpActiveRoots(filePath);
    const moduleInfo = buildPrelude(request || {}, filePath);
    const stitched = injectPrelude(moduleInfo.source, moduleInfo.prelude, filePath, moduleInfo.entryPrelude);
    const dumpPath = globalThis.process?.env?.DEKA_DUMP_PHPX;
    if (dumpPath) {
        if (dumpPath === 'stdout') {
            Deno.core.print(stitched, false);
        } else if (dumpPath === 'stderr') {
            Deno.core.print(stitched, true);
        } else {
            try {
                globalThis.fs.writeFileSync(dumpPath, stitched, 'utf8');
            } catch (err) {
                console.error('[phpx] failed to write DEKA_DUMP_PHPX:', err);
            }
        }
    }
    return runSource(stitched);
}
function reset() {
    if (!phpModule) return;
    const imports = {
        env: {
            php_log: (ptr, len)=>{
                if (!phpMemory) return;
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                let message = new TextDecoder().decode(bytes);
                if (globalThis.__dekaPhpLogEnabled) {
                    console.log('[php]', message);
                }
            },
            php_fs_read: phpFsRead,
            php_fs_exists: phpFsExists,
            php_wasm_call: phpWasmCall
        }
    };
    phpInstance = new WebAssembly.Instance(phpModule, imports);
    phpMemory = phpInstance.exports.memory;
    phpAlloc = phpInstance.exports.php_alloc;
    phpFree = phpInstance.exports.php_free;
    phpRun = phpInstance.exports.php_run;
}
function servePhp(phpFile) {
    return {
        async fetch (request) {
            try {
                await initPhpWasm();
                const url = normalizeRequestUrl(request);
                const headers = normalizeHeaders(request.headers || {});
                const accept = headers.accept || headers.Accept || '';
                const searchParams = url.searchParams || new URLSearchParams(url.search || '');
                const wantsPartial = searchParams.get('partial') === '1' || String(accept).includes('text/x-phpx-fragment');
                const contentType = wantsPartial ? 'application/json; charset=utf-8' : 'text/html; charset=utf-8';
                const result = runRequest(request, phpFile);
                if (result && result.ok) {
                    return new Response(result.stdout || '', {
                        status: 200,
                        headers: {
                            'Content-Type': contentType
                        }
                    });
                }
                const errorMessage = result ? [
                    result.error || 'php_error',
                    result.stderr || ''
                ].filter(Boolean).join('\n') : 'php_error';
                return new Response(errorMessage, {
                    status: 500,
                    headers: {
                        'Content-Type': 'text/plain; charset=utf-8'
                    }
                });
            } catch (error) {
                console.error('PHP execution error:', error);
                return new Response(`PHP Error: ${error.message}`, {
                    status: 500,
                    headers: {
                        'Content-Type': 'text/plain'
                    }
                });
            }
        }
    };
}
globalThis.__dekaPhp = {
    runSource,
    runFile,
    runRequest,
    reset,
    servePhp
};
export { servePhp as servePhp };
