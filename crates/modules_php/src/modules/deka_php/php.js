// Generated by build.rs (PHP prelude). Do not edit.
const { op_php_get_wasm, op_php_read_file_sync, op_php_read_env, op_php_cwd, op_php_file_exists, op_php_path_resolve, op_php_read_dir } = Deno.core.ops;
const console = {
    log: (...args)=>{
        const message = args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    },
    error: (...args)=>{
        const message = args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', true);
    },
    warn: (...args)=>{
        const message = '[WARN] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', true);
    },
    info: (...args)=>{
        const message = '[INFO] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    },
    debug: (...args)=>{
        const message = '[DEBUG] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    }
};
globalThis.console = console;
if (!globalThis.TextEncoder) {
    globalThis.TextEncoder = class TextEncoder {
        encode(input) {
            const str = String(input);
            const utf8 = [];
            for(let i = 0; i < str.length; i++){
                let charCode = str.charCodeAt(i);
                if (charCode < 0x80) {
                    utf8.push(charCode);
                } else if (charCode < 0x800) {
                    utf8.push(0xc0 | charCode >> 6, 0x80 | charCode & 0x3f);
                } else if (charCode < 0xd800 || charCode >= 0xe000) {
                    utf8.push(0xe0 | charCode >> 12, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);
                } else {
                    i++;
                    charCode = 0x10000 + ((charCode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
                    utf8.push(0xf0 | charCode >> 18, 0x80 | charCode >> 12 & 0x3f, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);
                }
            }
            return new Uint8Array(utf8);
        }
    };
}
if (!globalThis.TextDecoder) {
    globalThis.TextDecoder = class TextDecoder1 {
        decode(bytes) {
            if (!bytes) return '';
            const arr = new Uint8Array(bytes);
            let str = '';
            let i = 0;
            while(i < arr.length){
                let __byte = arr[i++];
                if (__byte < 0x80) {
                    str += String.fromCharCode(__byte);
                } else if (__byte < 0xe0) {
                    str += String.fromCharCode((__byte & 0x1f) << 6 | arr[i++] & 0x3f);
                } else if (__byte < 0xf0) {
                    str += String.fromCharCode((__byte & 0x0f) << 12 | (arr[i++] & 0x3f) << 6 | arr[i++] & 0x3f);
                } else {
                    const code = (__byte & 0x07) << 18 | (arr[i++] & 0x3f) << 12 | (arr[i++] & 0x3f) << 6 | arr[i++] & 0x3f;
                    const high = code - 0x10000 >> 10 | 0xd800;
                    const low = code - 0x10000 & 0x3ff | 0xdc00;
                    str += String.fromCharCode(high, low);
                }
            }
            return str;
        }
    };
}
globalThis.fs = {
    readFileSync: (path, encoding)=>{
        const bytes = op_php_read_file_sync(path);
        if (encoding === 'utf8' || encoding === 'utf-8') {
            return new TextDecoder().decode(bytes);
        }
        return bytes;
    },
    existsSync: (path)=>{
        return op_php_file_exists(path);
    },
    readdirSync: (path, options)=>{
        const entries = op_php_read_dir(path);
        if (options && options.withFileTypes) {
            return entries;
        }
        return entries.map((entry)=>entry.name);
    }
};
if (globalThis.Deno) {
    if (!globalThis.fs.mkdirSync) {
        globalThis.fs.mkdirSync = (path, options)=>globalThis.Deno.mkdirSync(path, options);
    }
    if (!globalThis.fs.readdirSync) {
        globalThis.fs.readdirSync = (path, options)=>{
            const entries = Array.from(globalThis.Deno.readDirSync(path));
            if (options && options.withFileTypes) {
                return entries;
            }
            return entries.map((entry)=>entry.name);
        };
    }
    if (!globalThis.fs.statSync) {
        globalThis.fs.statSync = (path)=>globalThis.Deno.statSync(path);
    }
    if (!globalThis.fs.writeFileSync) {
        globalThis.fs.writeFileSync = (path, data, encoding)=>{
            if (typeof data === 'string') {
                const enc = encoding || 'utf8';
                if (enc === 'utf8' || enc === 'utf-8') {
                    globalThis.Deno.writeTextFileSync(path, data);
                    return;
                }
            }
            const bytes = data instanceof Uint8Array ? data : new TextEncoder().encode(String(data));
            globalThis.Deno.writeFileSync(path, bytes);
        };
    }
}
globalThis.process = {
    env: op_php_read_env(),
    cwd: ()=>op_php_cwd()
};
if (globalThis.__dekaPhpLogEnabled === undefined) {
    const debug = globalThis.process?.env?.DEKA_DEBUG;
    globalThis.__dekaPhpLogEnabled = debug === '1' || debug === 'true' || debug === 'yes' || debug === 'on';
}
globalThis.URLSearchParams = class URLSearchParams {
    params = [];
    constructor(init){
        if (typeof init === 'string') {
            const pairs = init.replace(/^\?/, '').split('&');
            for (const pair of pairs){
                if (!pair) continue;
                const idx = pair.indexOf('=');
                if (idx === -1) {
                    this.params.push([
                        decodeURIComponent(pair),
                        ''
                    ]);
                } else {
                    this.params.push([
                        decodeURIComponent(pair.slice(0, idx)),
                        decodeURIComponent(pair.slice(idx + 1))
                    ]);
                }
            }
        }
    }
    append(name, value) {
        this.params.push([
            String(name),
            String(value)
        ]);
    }
    get(name) {
        const entry = this.params.find(([k])=>k === name);
        return entry ? entry[1] : null;
    }
    *entries() {
        for (const param of this.params){
            yield param;
        }
    }
    toString() {
        return this.params.map(([k, v])=>`${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
    }
};
globalThis.path = {
    sep: '/',
    delimiter: ':',
    extname: (p)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        const lastDot = str.lastIndexOf('.');
        if (lastDot === -1 || lastDot < lastSlash) return '';
        return str.slice(lastDot);
    },
    dirname: (p)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        if (lastSlash === -1) return '.';
        if (lastSlash === 0) return '/';
        return str.slice(0, lastSlash);
    },
    basename: (p, ext)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        let base = lastSlash === -1 ? str : str.slice(lastSlash + 1);
        if (ext && base.endsWith(ext)) {
            base = base.slice(0, -ext.length);
        }
        return base;
    },
    normalize: (p)=>{
        const str = String(p);
        const parts = str.split('/');
        const result = [];
        for (const part of parts){
            if (part === '..') {
                if (result.length > 0 && result[result.length - 1] !== '..') {
                    result.pop();
                } else {
                    result.push('..');
                }
            } else if (part !== '.' && part !== '') {
                result.push(part);
            }
        }
        const normalized = result.join('/');
        return str.startsWith('/') ? '/' + normalized : normalized || '.';
    },
    resolve: (...args)=>{
        let resolved = '';
        for(let i = args.length - 1; i >= 0; i--){
            const p = String(args[i]);
            if (!p) continue;
            if (resolved === '') {
                resolved = p;
            } else if (p.startsWith('/')) {
                resolved = p + '/' + resolved;
                break;
            } else {
                resolved = p + '/' + resolved;
            }
            if (resolved.startsWith('/')) {
                break;
            }
        }
        if (!resolved.startsWith('/')) {
            const cwd = op_php_cwd();
            resolved = cwd + '/' + resolved;
        }
        return globalThis.path.normalize(resolved);
    },
    relative: (from, to)=>{
        const fromAbs = globalThis.path.resolve(from);
        const toAbs = globalThis.path.resolve(to);
        const fromParts = fromAbs.split('/').filter(Boolean);
        const toParts = toAbs.split('/').filter(Boolean);
        let shared = 0;
        while(shared < fromParts.length && shared < toParts.length && fromParts[shared] === toParts[shared]){
            shared++;
        }
        const up = fromParts.slice(shared).map(()=>"..");
        const down = toParts.slice(shared);
        const combined = up.concat(down);
        return combined.length ? combined.join('/') : '.';
    },
    join: (...args)=>{
        const parts = args.filter((p)=>p && String(p) !== '');
        if (parts.length === 0) return '.';
        const joined = parts.join('/');
        return globalThis.path.normalize(joined);
    }
};
let phpActiveRoots = [];
function normalizeHostPath(value) {
    const raw = String(value || '').replace(/\\/g, '/');
    return globalThis.path.resolve(op_php_cwd(), raw);
}
function uniqueValues(values) {
    const seen = new Set();
    const out = [];
    for (const value of values){
        if (!value) continue;
        if (seen.has(value)) continue;
        seen.add(value);
        out.push(value);
    }
    return out;
}
function getPhpModulesRoots(entryPath) {
    const cwd = op_php_cwd();
    const roots = [];
    if (entryPath) {
        const entryAbs = normalizeHostPath(entryPath);
        const entryDir = globalThis.path.dirname(entryAbs);
        roots.push(globalThis.path.resolve(entryDir, 'php_modules'));
    }
    roots.push(globalThis.path.resolve(cwd, 'php_modules'));
    return uniqueValues(roots);
}
function resolvePhpModulesRoot(entryPath) {
    const roots = getPhpModulesRoots(entryPath);
    for (const root of roots){
        if (globalThis.fs.existsSync(root)) {
            return root;
        }
    }
    return '';
}
function setPhpActiveRoots(entryPath) {
    const cwd = op_php_cwd();
    const entryAbs = normalizeHostPath(entryPath);
    const entryDir = globalThis.path.dirname(entryAbs);
    const modulesRoots = getPhpModulesRoots(entryPath);
    phpActiveRoots = uniqueValues([
        entryDir,
        ...modulesRoots,
        normalizeHostPath(cwd)
    ]);
}
function getDekaEntryPath(entryPath) {
    const roots = getPhpModulesRoots(entryPath);
    for (const root of roots){
        const candidate = globalThis.path.resolve(root, 'deka.php');
        if (globalThis.fs.existsSync(candidate)) {
            return candidate;
        }
    }
    return '';
}
function stripPhpTags(source) {
    return String(source).replace(/^\s*<\?(?:php)?/i, '').replace(/\?>\s*$/, '');
}
function stripInlineTypes(source) {
    const input = String(source);
    let out = '';
    let i = 0;
    let lastSignificant = '';
    while(i < input.length){
        const ch = input[i];
        if (ch === "'" || ch === '"') {
            const chunk = readQuoted(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceQuoted(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '/') {
            const chunk = readLineComment(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceLineComment(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '*') {
            const chunk = readBlockComment(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceBlockComment(input, i);
            continue;
        }
        if (ch === '#') {
            const chunk = readLineComment(input, i);
            out += chunk;
            lastSignificant = updateLastSignificant(lastSignificant, chunk);
            i = advanceLineComment(input, i);
            continue;
        }
        const stripped = tryStripPrefixType(input, i, lastSignificant);
        if (stripped) {
            out += stripped.text;
            lastSignificant = updateLastSignificant(lastSignificant, stripped.text);
            i = stripped.end;
            continue;
        }
        if (ch === '$') {
            const varInfo = readVariableName(input, i);
            if (varInfo) {
                out += varInfo.text;
                lastSignificant = updateLastSignificant(lastSignificant, varInfo.text);
                const wsAfterVar = readWhitespace(input, varInfo.end);
                let j = wsAfterVar.end;
                if (input[j] === ':') {
                    const wsAfterColon = readWhitespace(input, j + 1);
                    const typeStart = wsAfterColon.end;
                    if (isTypeStartChar(input[typeStart])) {
                        const typeInfo = readTypeToken(input, typeStart);
                        const wsAfterType = readWhitespace(input, typeInfo.end);
                        const nextChar = input[wsAfterType.end];
                        if (nextChar && "=,;)]}".includes(nextChar)) {
                            out += wsAfterVar.text + wsAfterType.text;
                            lastSignificant = updateLastSignificant(lastSignificant, wsAfterType.text);
                            i = wsAfterType.end;
                            continue;
                        }
                    }
                }
                i = varInfo.end;
                continue;
            }
        }
        out += ch;
        lastSignificant = updateLastSignificant(lastSignificant, ch);
        i++;
    }
    return out;
}
function stripPhpxTypes(source) {
    const input = String(source);
    let out = '';
    let i = 0;
    while(i < input.length){
        const ch = input[i];
        if (ch === "'" || ch === '"') {
            out += readQuoted(input, i);
            i = advanceQuoted(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '/') {
            out += readLineComment(input, i);
            i = advanceLineComment(input, i);
            continue;
        }
        if (ch === '/' && input[i + 1] === '*') {
            out += readBlockComment(input, i);
            i = advanceBlockComment(input, i);
            continue;
        }
        if (ch === '#') {
            out += readLineComment(input, i);
            i = advanceLineComment(input, i);
            continue;
        }
        if (isKeywordAt(input, i, 'function')) {
            out += 'function';
            i += 8;
            while(i < input.length){
                const next = input[i];
                if (next === '(') {
                    out += '(';
                    i++;
                    break;
                }
                out += next;
                i++;
            }
            const params = readParenBlock(input, i);
            out += stripParamTypes(params.text);
            out += ')';
            i = params.endIndex + 1;
            const returnInfo = stripReturnType(input, i);
            out += returnInfo.text;
            i = returnInfo.index;
            continue;
        }
        out += ch;
        i++;
    }
    return out;
}
function updateLastSignificant(prev, chunk) {
    for(let i = chunk.length - 1; i >= 0; i--){
        const ch = chunk[i];
        if (!/\s/.test(ch)) {
            return ch;
        }
    }
    return prev;
}
function isTypeBoundary(lastSignificant) {
    if (!lastSignificant) return true;
    return lastSignificant === ';' || lastSignificant === '{' || lastSignificant === '}' || lastSignificant === "\n";
}
function isTypeStartChar(ch) {
    return !!ch && (/[A-Za-z_]/.test(ch) || ch === '?' || ch === '\\');
}
function isTypeChar(ch) {
    return !!ch && /[A-Za-z0-9_\\|?<>[\],]/.test(ch);
}
const RESERVED_PREFIX_KEYWORDS = new Set([
    'return',
    'throw',
    'echo',
    'print',
    'if',
    'for',
    'foreach',
    'while',
    'switch',
    'case',
    'break',
    'continue',
    'catch',
    'try',
    'finally',
    'do',
    'new',
    'clone',
    'yield',
    'function',
    'fn',
    'class',
    'interface',
    'trait',
    'enum',
    'extends',
    'implements',
    'namespace',
    'use',
    'as'
]);
function isReservedPrefixKeyword(word) {
    return RESERVED_PREFIX_KEYWORDS.has(word);
}
function readWhitespace(source, index) {
    let i = index;
    let out = '';
    while(i < source.length && /\s/.test(source[i])){
        out += source[i];
        i++;
    }
    return {
        text: out,
        end: i
    };
}
function readIdentifierAt(source, index) {
    if (!source[index] || !/[A-Za-z_]/.test(source[index])) {
        return null;
    }
    let i = index + 1;
    while(i < source.length && /[A-Za-z0-9_]/.test(source[i])){
        i++;
    }
    return {
        text: source.slice(index, i),
        end: i
    };
}
function readTypeToken(source, index) {
    let i = index;
    while(i < source.length && isTypeChar(source[i])){
        i++;
    }
    return {
        text: source.slice(index, i),
        end: i
    };
}
function readVariableName(source, index) {
    if (source[index] !== '$') return null;
    if (!source[index + 1] || !/[A-Za-z_]/.test(source[index + 1])) return null;
    let i = index + 2;
    while(i < source.length && /[A-Za-z0-9_]/.test(source[i])){
        i++;
    }
    return {
        text: source.slice(index, i),
        end: i
    };
}
function tryStripPrefixType(source, index, lastSignificant) {
    if (!isTypeBoundary(lastSignificant)) {
        return null;
    }
    let i = index;
    const leading = readWhitespace(source, i);
    i = leading.end;
    const prefixStart = index;
    let cursor = i;
    const modifiers = new Set([
        'public',
        'protected',
        'private',
        'var',
        'static',
        'readonly'
    ]);
    while(true){
        const ident = readIdentifierAt(source, cursor);
        if (!ident || !modifiers.has(ident.text)) {
            break;
        }
        cursor = ident.end;
        const ws = readWhitespace(source, cursor);
        cursor = ws.end;
    }
    const typeStart = cursor;
    const typeInfo = readTypeToken(source, typeStart);
    if (!typeInfo.text) {
        return null;
    }
    const keyword = typeInfo.text.toLowerCase();
    if (isReservedPrefixKeyword(keyword)) {
        return null;
    }
    const wsAfterType = readWhitespace(source, typeInfo.end);
    const scan = scanForVarStart(source, wsAfterType.end);
    if (!scan) {
        return null;
    }
    const varInfo = readVariableName(source, scan.varStart);
    if (!varInfo) {
        return null;
    }
    const prefix = source.slice(prefixStart, typeStart);
    const replacement = prefix + wsAfterType.text + scan.symbolSegment + varInfo.text;
    return {
        text: replacement,
        end: varInfo.end
    };
}
function scanForVarStart(source, index) {
    let i = index;
    while(i < source.length){
        const ch = source[i];
        if (ch === '$') {
            return {
                varStart: i,
                symbolSegment: source.slice(index, i)
            };
        }
        if (/\s/.test(ch) || ch === '&' || ch === '.') {
            i++;
            continue;
        }
        return null;
    }
    return null;
}
function isKeywordAt(source, index, keyword) {
    if (source.slice(index, index + keyword.length) !== keyword) {
        return false;
    }
    const before = index === 0 ? '' : source[index - 1];
    const after = source[index + keyword.length] || '';
    if (before && /[A-Za-z0-9_]/.test(before)) {
        return false;
    }
    if (after && /[A-Za-z0-9_]/.test(after)) {
        return false;
    }
    return true;
}
function readQuoted(source, index) {
    const quote = source[index];
    let i = index;
    let out = '';
    while(i < source.length){
        const ch = source[i];
        out += ch;
        if (ch === '\\') {
            i++;
            if (i < source.length) {
                out += source[i];
            }
        } else if (ch === quote && i !== index) {
            i++;
            break;
        }
        i++;
    }
    return out;
}
function advanceQuoted(source, index) {
    const quote = source[index];
    let i = index + 1;
    while(i < source.length){
        const ch = source[i];
        if (ch === '\\') {
            i += 2;
            continue;
        }
        if (ch === quote) {
            return i + 1;
        }
        i++;
    }
    return source.length;
}
function readLineComment(source, index) {
    let i = index;
    let out = '';
    while(i < source.length){
        const ch = source[i];
        out += ch;
        i++;
        if (ch === '\n') {
            break;
        }
    }
    return out;
}
function advanceLineComment(source, index) {
    let i = index;
    while(i < source.length){
        const ch = source[i];
        i++;
        if (ch === '\n') {
            break;
        }
    }
    return i;
}
function readBlockComment(source, index) {
    let i = index;
    let out = '';
    while(i < source.length){
        const ch = source[i];
        out += ch;
        if (ch === '*' && source[i + 1] === '/') {
            out += '/';
            i += 2;
            break;
        }
        i++;
    }
    return out;
}
function advanceBlockComment(source, index) {
    let i = index;
    while(i < source.length){
        if (source[i] === '*' && source[i + 1] === '/') {
            return i + 2;
        }
        i++;
    }
    return source.length;
}
function readParenBlock(source, startIndex) {
    let i = startIndex;
    let out = '';
    let depth = 0;
    while(i < source.length){
        const ch = source[i];
        if (ch === "'" || ch === '"') {
            out += readQuoted(source, i);
            i = advanceQuoted(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '/') {
            out += readLineComment(source, i);
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '*') {
            out += readBlockComment(source, i);
            i = advanceBlockComment(source, i);
            continue;
        }
        if (ch === '#') {
            out += readLineComment(source, i);
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '(') {
            depth++;
            out += ch;
            i++;
            continue;
        }
        if (ch === ')') {
            if (depth === 0) {
                break;
            }
            depth--;
            out += ch;
            i++;
            continue;
        }
        out += ch;
        i++;
    }
    return {
        text: out,
        endIndex: i
    };
}
function stripParamTypes(params) {
    const parts = [];
    let buf = '';
    let depthParen = 0;
    let depthBracket = 0;
    let depthBrace = 0;
    let i = 0;
    while(i < params.length){
        const ch = params[i];
        if (ch === "'" || ch === '"') {
            buf += readQuoted(params, i);
            i = advanceQuoted(params, i);
            continue;
        }
        if (ch === '/' && params[i + 1] === '/') {
            buf += readLineComment(params, i);
            i = advanceLineComment(params, i);
            continue;
        }
        if (ch === '/' && params[i + 1] === '*') {
            buf += readBlockComment(params, i);
            i = advanceBlockComment(params, i);
            continue;
        }
        if (ch === '#') {
            buf += readLineComment(params, i);
            i = advanceLineComment(params, i);
            continue;
        }
        if (ch === '(') depthParen++;
        if (ch === ')') depthParen = Math.max(0, depthParen - 1);
        if (ch === '[') depthBracket++;
        if (ch === ']') depthBracket = Math.max(0, depthBracket - 1);
        if (ch === '{') depthBrace++;
        if (ch === '}') depthBrace = Math.max(0, depthBrace - 1);
        if (ch === ',' && depthParen === 0 && depthBracket === 0 && depthBrace === 0) {
            parts.push(buf);
            buf = '';
            i++;
            continue;
        }
        buf += ch;
        i++;
    }
    parts.push(buf);
    return parts.map(stripParamType).join(',');
}
function stripParamType(segment) {
    const dollarIndex = findDollarIndex(segment);
    if (dollarIndex === -1) {
        return segment;
    }
    const before = segment.slice(0, dollarIndex);
    const after = segment.slice(dollarIndex);
    const leadingWsMatch = before.match(/^\s*/);
    const leadingWs = leadingWsMatch ? leadingWsMatch[0] : '';
    const tailMatch = before.match(/(\.\.\.\s*)?(&\s*)?$/);
    const tail = tailMatch ? `${tailMatch[1] || ''}${tailMatch[2] || ''}` : '';
    const typePart = before.slice(leadingWs.length, before.length - tail.length);
    if (!typePart.trim()) {
        return segment;
    }
    return leadingWs + tail + after;
}
function findDollarIndex(segment) {
    let i = 0;
    while(i < segment.length){
        const ch = segment[i];
        if (ch === "'" || ch === '"') {
            i = advanceQuoted(segment, i);
            continue;
        }
        if (ch === '/' && segment[i + 1] === '/') {
            i = advanceLineComment(segment, i);
            continue;
        }
        if (ch === '/' && segment[i + 1] === '*') {
            i = advanceBlockComment(segment, i);
            continue;
        }
        if (ch === '#') {
            i = advanceLineComment(segment, i);
            continue;
        }
        if (ch === '$') {
            return i;
        }
        i++;
    }
    return -1;
}
function stripReturnType(source, startIndex) {
    let i = startIndex;
    let wsBefore = '';
    while(i < source.length && /\s/.test(source[i])){
        wsBefore += source[i];
        i++;
    }
    if (source[i] !== ':') {
        return {
            text: wsBefore,
            index: i
        };
    }
    i++;
    while(i < source.length && /\s/.test(source[i])){
        i++;
    }
    let depthAngle = 0;
    while(i < source.length){
        const ch = source[i];
        if (ch === "'" || ch === '"') {
            i = advanceQuoted(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '/') {
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '/' && source[i + 1] === '*') {
            i = advanceBlockComment(source, i);
            continue;
        }
        if (ch === '#') {
            i = advanceLineComment(source, i);
            continue;
        }
        if (ch === '<') depthAngle++;
        if (ch === '>') depthAngle = Math.max(0, depthAngle - 1);
        if (depthAngle === 0 && (ch === '{' || ch === ';')) {
            break;
        }
        i++;
    }
    let wsAfter = '';
    while(i < source.length && /\s/.test(source[i])){
        wsAfter += source[i];
        i++;
    }
    return {
        text: wsBefore + wsAfter,
        index: i
    };
}
function moduleIdFromRel(rel) {
    const normalized = String(rel).replace(/\\/g, '/');
    if (normalized.endsWith('/index.phpx')) {
        return normalized.replace(/\/index\.phpx$/, '');
    }
    return normalized.replace(/\.phpx$/, '');
}
function compilePhpxSource(source, moduleId) {
    let working = stripPhpTags(source);
    if (/\bnamespace\b/.test(working)) {
        throw new Error(`phpx namespaces are not supported yet (${moduleId}).`);
    }
    if (/^\s*import\s/m.test(working)) {
        throw new Error(`phpx imports are not supported yet (${moduleId}).`);
    }
    const exports = [];
    const exportRegex = /export\s+function\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(/g;
    working = working.replace(exportRegex, (_match, name)=>{
        exports.push(name);
        return `function ${name}(`;
    });
    working = stripPhpxTypes(working);
    working = stripInlineTypes(working);
    if (/export\s/.test(working)) {
        throw new Error(`Unsupported export syntax in ${moduleId}.`);
    }
    return {
        code: working.trim() + '\n',
        exports
    };
}
function resolveImportTarget(specifier, currentFilePath, modulesRoot) {
    const raw = String(specifier);
    const isRelative = raw.startsWith('.');
    const baseDir = isRelative ? globalThis.path.dirname(currentFilePath) : modulesRoot;
    const basePath = globalThis.path.resolve(baseDir, raw);
    const candidates = [];
    if (raw.endsWith('.phpx')) {
        candidates.push(basePath);
    } else {
        candidates.push(basePath + '.phpx');
        candidates.push(globalThis.path.join(basePath, 'index.phpx'));
    }
    if (!isRelative) {
        candidates.push(globalThis.path.resolve(modulesRoot, raw + '.phpx'));
        candidates.push(globalThis.path.resolve(modulesRoot, raw, 'index.phpx'));
    }
    for (const candidate of candidates){
        if (globalThis.fs.existsSync(candidate)) {
            const rel = globalThis.path.relative(modulesRoot, candidate).replace(/\\/g, '/');
            const moduleId = moduleIdFromRel(rel);
            return {
                filePath: candidate,
                moduleId
            };
        }
    }
    throw new Error(`Missing phpx module '${raw}' (imported from ${currentFilePath}).`);
}
function parseNamedSpecifiers(rawSpecifiers, currentFilePath) {
    const specifiers = rawSpecifiers.split(',').map((spec)=>spec.trim()).filter(Boolean);
    const parsed = [];
    for (const spec of specifiers){
        const specMatch = spec.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\s+as\s+([A-Za-z_][A-Za-z0-9_]*))?$/);
        if (!specMatch) {
            throw new Error(`Invalid import specifier '${spec}' in ${currentFilePath}.`);
        }
        const imported = specMatch[1];
        const local = specMatch[2] || imported;
        parsed.push({
            imported,
            local
        });
    }
    return parsed;
}
function parseImportLine(line, currentFilePath, modulesRoot) {
    const match = line.match(/^\s*import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]\s*;?\s*$/);
    if (!match) return null;
    const from = match[2].trim();
    if (!from) {
        throw new Error(`Invalid import in ${currentFilePath}: ${line}`);
    }
    const target = resolveImportTarget(from, currentFilePath, modulesRoot);
    const specifiers = parseNamedSpecifiers(match[1], currentFilePath);
    const imports = [];
    for (const spec of specifiers){
        const imported = spec.imported;
        const local = spec.local;
        imports.push({
            imported,
            local,
            from: target.moduleId
        });
    }
    return imports;
}
function parseExportFromLine(line, currentFilePath, modulesRoot) {
    const match = line.match(/^\s*export\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]\s*;?\s*$/);
    if (!match) return null;
    const from = match[2].trim();
    if (!from) {
        throw new Error(`Invalid export in ${currentFilePath}: ${line}`);
    }
    const target = resolveImportTarget(from, currentFilePath, modulesRoot);
    const specifiers = parseNamedSpecifiers(match[1], currentFilePath);
    const imports = [];
    const exports = [];
    for (const spec of specifiers){
        imports.push({
            imported: spec.imported,
            local: spec.local,
            from: target.moduleId
        });
        exports.push(spec.local);
    }
    return {
        imports,
        exports
    };
}
function buildAliasFunction(local, imported) {
    const params = [
        '$a',
        '$b',
        '$c',
        '$d',
        '$e',
        '$f'
    ];
    let out = `if (!function_exists('${local}')) { function ${local}(${params.join(', ')}) {`;
    out += " $argc = func_num_args();";
    out += ` if ($argc === 0) return ${imported}();`;
    out += ` if ($argc === 1) return ${imported}($a);`;
    out += ` if ($argc === 2) return ${imported}($a, $b);`;
    out += ` if ($argc === 3) return ${imported}($a, $b, $c);`;
    out += ` if ($argc === 4) return ${imported}($a, $b, $c, $d);`;
    out += ` if ($argc === 5) return ${imported}($a, $b, $c, $d, $e);`;
    out += ` if ($argc === 6) return ${imported}($a, $b, $c, $d, $e, $f);`;
    out += ` return ${imported}($a, $b, $c, $d, $e, $f);`;
    out += " } }\n";
    return out;
}
function buildImportAliases(imports) {
    let out = '';
    for (const spec of imports){
        if (spec.local === spec.imported) {
            continue;
        }
        out += buildAliasFunction(spec.local, spec.imported);
    }
    return out;
}
function parsePhpxModule(filePath, modulesRoot) {
    const rel = globalThis.path.relative(modulesRoot, filePath).replace(/\\/g, '/');
    const moduleId = moduleIdFromRel(rel);
    const raw = globalThis.fs.readFileSync(filePath, 'utf8');
    const lines = raw.split(/\r?\n/);
    const imports = [];
    const extraExports = [];
    const body = [];
    for (const line of lines){
        const exported = parseExportFromLine(line, filePath, modulesRoot);
        if (exported) {
            imports.push(...exported.imports);
            extraExports.push(...exported.exports);
            continue;
        }
        const parsed = parseImportLine(line, filePath, modulesRoot);
        if (parsed) {
            imports.push(...parsed);
            continue;
        }
        body.push(line);
    }
    const compiled = compilePhpxSource(body.join('\n'), moduleId);
    const mergedExports = [];
    const seenExports = new Set();
    for (const name of [
        ...compiled.exports,
        ...extraExports
    ]){
        if (seenExports.has(name)) continue;
        seenExports.add(name);
        mergedExports.push(name);
    }
    const aliasCode = buildImportAliases(imports);
    return {
        moduleId,
        filePath,
        imports,
        exports: mergedExports,
        code: aliasCode + compiled.code
    };
}
function topoSortModules(modules) {
    const order = [];
    const visiting = new Set();
    const visited = new Set();
    function visit(moduleId) {
        if (visited.has(moduleId)) return;
        if (visiting.has(moduleId)) {
            throw new Error(`Cyclic phpx import detected: ${moduleId}`);
        }
        const module = modules.get(moduleId);
        if (!module) {
            throw new Error(`Missing phpx module '${moduleId}'.`);
        }
        visiting.add(moduleId);
        for (const spec of module.imports){
            visit(spec.from);
        }
        visiting.delete(moduleId);
        visited.add(moduleId);
        order.push(moduleId);
    }
    for (const moduleId of modules.keys()){
        visit(moduleId);
    }
    return order;
}
function validateImports(modules) {
    for (const module of modules.values()){
        for (const spec of module.imports){
            const target = modules.get(spec.from);
            if (!target) {
                throw new Error(`Unknown phpx module '${spec.from}' imported by '${module.moduleId}'.`);
            }
            if (!target.exports.includes(spec.imported)) {
                throw new Error(`Missing export '${spec.imported}' in '${spec.from}' (imported by '${module.moduleId}').`);
            }
        }
    }
}
function collectPhpxFiles(root) {
    const out = [];
    if (!root || !globalThis.fs.existsSync(root)) {
        return out;
    }
    const entries = globalThis.fs.readdirSync(root, {
        withFileTypes: true
    });
    for (const entry of entries){
        const entryPath = globalThis.path.join(root, entry.name);
        const isDirectory = typeof entry.isDirectory === 'function' ? entry.isDirectory() : entry.is_dir;
        const isFile = typeof entry.isFile === 'function' ? entry.isFile() : entry.is_file;
        if (isDirectory) {
            out.push(...collectPhpxFiles(entryPath));
            continue;
        }
        if (isFile && entry.name.endsWith('.phpx')) {
            out.push(entryPath);
        }
    }
    return out;
}
function compilePhpxModules(entryPath) {
    const modulesRoot = resolvePhpModulesRoot(entryPath);
    if (!modulesRoot) return '';
    const files = collectPhpxFiles(modulesRoot);
    const modules = new Map();
    for (const filePath of files){
        const parsed = parsePhpxModule(filePath, modulesRoot);
        if (modules.has(parsed.moduleId)) {
            throw new Error(`Duplicate phpx module id '${parsed.moduleId}'.`);
        }
        modules.set(parsed.moduleId, parsed);
    }
    validateImports(modules);
    const order = topoSortModules(modules);
    const moduleBlocks = order.map((moduleId)=>modules.get(moduleId).code);
    return moduleBlocks.join('\n');
}
function buildModulePrelude(entryPath) {
    const dekaPath = getDekaEntryPath(entryPath);
    if (!dekaPath) {
        throw new Error("Missing php_modules/deka.php. Run `deka init` to create a project.");
    }
    const moduleSource = compilePhpxModules(entryPath);
    let prelude = '';
    if (moduleSource) {
        prelude += moduleSource + '\n';
    }
    prelude += `require_once '${escapePhpString(dekaPath)}';\n`;
    return prelude;
}
function isPathAllowed(targetPath) {
    const normalized = globalThis.path.normalize(targetPath);
    return phpActiveRoots.some((root)=>{
        if (!root) return false;
        const normalizedRoot = globalThis.path.normalize(root);
        if (normalized === normalizedRoot) return true;
        const prefix = normalizedRoot.endsWith('/') ? normalizedRoot : normalizedRoot + '/';
        return normalized.startsWith(prefix);
    });
}
function writeResult(outPtr, dataPtr, dataLen) {
    const view = new DataView(phpMemory.buffer, outPtr, 8);
    view.setUint32(0, dataPtr, true);
    view.setUint32(4, dataLen, true);
}
if (!globalThis.Response) {
    globalThis.Response = class Response1 {
        body;
        status;
        headers;
        constructor(body, init){
            this.body = body || '';
            this.status = init?.status || 200;
            this.headers = init?.headers || {};
        }
    };
}
let phpInstance = null;
let phpModule = null;
let phpMemory = null;
let phpAlloc = null;
let phpFree = null;
let phpRun = null;
const __wbindgen_heap = [
    undefined,
    null,
    true,
    false
];
let __wbindgen_heap_next = __wbindgen_heap.length;
function __wbindgen_get_object(idx) {
    return __wbindgen_heap[idx];
}
function __wbindgen_add_heap_object(obj) {
    if (__wbindgen_heap_next === __wbindgen_heap.length) {
        __wbindgen_heap.push(__wbindgen_heap.length + 1);
    }
    const idx = __wbindgen_heap_next;
    __wbindgen_heap_next = __wbindgen_heap[idx];
    __wbindgen_heap[idx] = obj;
    return idx;
}
function __wbindgen_drop_object(idx) {
    if (idx < 4) return;
    __wbindgen_heap[idx] = __wbindgen_heap_next;
    __wbindgen_heap_next = idx;
}
async function initPhpWasm() {
    if (phpInstance) return phpInstance;
    const wasmBytes = op_php_get_wasm();
    if (!wasmBytes || wasmBytes.length === 0) {
        console.error('[php] wasm bytes missing or empty');
    }
    const wasmModule = new WebAssembly.Module(wasmBytes);
    const imports = {
        env: {
            php_log: (ptr, len)=>{
                if (!phpMemory) return;
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                let message = new TextDecoder().decode(bytes);
                if (globalThis.__dekaPhpLogEnabled) {
                    console.log('[php]', message);
                }
            },
            php_fs_read: phpFsRead,
            php_fs_exists: phpFsExists
        },
        __wbindgen_placeholder__: {
            __wbindgen_describe: ()=>{},
            __wbindgen_describe_cast: ()=>{},
            __wbindgen_object_drop_ref: (idx)=>__wbindgen_drop_object(idx),
            __wbg_getTimezoneOffset_45389e26d6f46823: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTimezoneOffset === "function"
                    ? obj.getTimezoneOffset()
                    : 0;
            },
            __wbg_getTimezoneOffset_81776d10a4ec18a8: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTimezoneOffset === "function"
                    ? obj.getTimezoneOffset()
                    : 0;
            },
            __wbg_new_b2db8aa2650f793a: (...args)=>{
                if (args.length > 0 && typeof args[0] === "number") {
                    return __wbindgen_add_heap_object(new Date(args[0]));
                }
                return __wbindgen_add_heap_object(new Date());
            },
            __wbg_new_245cd5c49157e602: (...args)=>{
                if (args.length > 0 && typeof args[0] === "number") {
                    return __wbindgen_add_heap_object(new Date(args[0]));
                }
                return __wbindgen_add_heap_object(new Date());
            },
            __wbg_new_0_23cedd11d9b40c9d: ()=>__wbindgen_add_heap_object(new Date()),
            __wbg_new_0_73afc35eb544e539: ()=>__wbindgen_add_heap_object(new Date()),
            __wbg_getTime_ad1e9878a735af08: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTime === "function" ? obj.getTime() : 0;
            },
            __wbg_getTime_1e3cd1391c5c3995: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTime === "function" ? obj.getTime() : 0;
            },
            __wbg___wbindgen_throw_dd24417ed36fc46e: (ptr, len)=>{
                if (!phpMemory) {
                    throw new Error("php wasm trap");
                }
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                const message = new TextDecoder().decode(bytes);
                throw new Error(message);
            },
            __wbg___wbindgen_throw_be289d5034ed271b: (ptr, len)=>{
                if (!phpMemory) {
                    throw new Error("php wasm trap");
                }
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                const message = new TextDecoder().decode(bytes);
                throw new Error(message);
            },
            __wbg___wbindgen_is_object_ce774f3490692386: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return typeof obj === "object" && obj !== null;
            },
            __wbg___wbindgen_is_string_704ef9c8fc131030: (idx)=>{
                return typeof __wbindgen_get_object(idx) === "string";
            },
            __wbg___wbindgen_is_function_8d400b8b1af978cd: (idx)=>{
                return typeof __wbindgen_get_object(idx) === "function";
            },
            __wbg___wbindgen_is_undefined_f6b95eab589e0269: (idx)=>{
                return __wbindgen_get_object(idx) === undefined;
            }
        },
        __wbindgen_externref_xform__: {
            __wbindgen_externref_table_set_null: (_idx)=>{},
            __wbindgen_externref_table_grow: (_delta)=>0
        }
    };
    phpModule = wasmModule;
    phpInstance = await WebAssembly.instantiate(wasmModule, imports);
    phpMemory = phpInstance.exports.memory;
    phpAlloc = phpInstance.exports.php_alloc;
    phpFree = phpInstance.exports.php_free;
    phpRun = phpInstance.exports.php_run;
    if (!phpMemory || !phpAlloc || !phpFree || !phpRun) {
        throw new Error('php wasm exports missing php_* api');
    }
    return phpInstance;
}
function readString(ptr, len) {
    const view = new Uint8Array(phpMemory.buffer, ptr, len);
    return new TextDecoder().decode(view);
}
function writeBytes(bytes) {
    const ptr = phpAlloc(bytes.length);
    new Uint8Array(phpMemory.buffer, ptr, bytes.length).set(bytes);
    return ptr;
}
function phpFsRead(pathPtr, pathLen, outPtr) {
    if (!phpMemory || !phpAlloc) return 0;
    const pathValue = readString(pathPtr, pathLen);
    const resolved = normalizeHostPath(pathValue);
    if (!isPathAllowed(resolved)) return 0;
    if (!globalThis.fs.existsSync(resolved)) return 0;
    const bytes = globalThis.fs.readFileSync(resolved);
    const dataPtr = bytes.length ? phpAlloc(bytes.length) : 0;
    if (bytes.length) {
        new Uint8Array(phpMemory.buffer, dataPtr, bytes.length).set(bytes);
    }
    writeResult(outPtr, dataPtr, bytes.length);
    return 1;
}
function phpFsExists(pathPtr, pathLen) {
    if (!phpMemory) return 0;
    const pathValue = readString(pathPtr, pathLen);
    const resolved = normalizeHostPath(pathValue);
    if (!isPathAllowed(resolved)) return 0;
    return globalThis.fs.existsSync(resolved) ? 1 : 0;
}
function escapePhpString(value) {
    return String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\r/g, '\\r').replace(/\n/g, '\\n');
}
function buildArrayAssignments(target, entries) {
    let out = `${target} = array();\n`;
    for (const [key, value] of entries){
        const escapedKey = escapePhpString(key);
        if (value === null || value === undefined) {
            out += `${target}['${escapedKey}'] = null;\n`;
        } else {
            out += `${target}['${escapedKey}'] = '${escapePhpString(value)}';\n`;
        }
    }
    return out;
}
function parseQuery(queryString) {
    const params = new URLSearchParams(queryString || '');
    const out = [];
    for (const [key, value] of params.entries()){
        out.push([
            key,
            value
        ]);
    }
    return out;
}
function parseMultipart(body, boundary) {
    const text = String(body || '');
    const outFiles = [];
    const outFields = [];
    const delimiter = `--${boundary}`;
    const parts = text.split(delimiter);
    for (const part of parts){
        if (!part || part === '--' || part === '--\r\n') {
            continue;
        }
        const trimmed = part.replace(/^\r?\n/, '').replace(/\r?\n--$/, '');
        const headerEnd = trimmed.indexOf('\r\n\r\n');
        if (headerEnd === -1) {
            continue;
        }
        const headerText = trimmed.slice(0, headerEnd);
        const bodyText = trimmed.slice(headerEnd + 4);
        const headers = headerText.split('\r\n');
        const dispo = headers.find((line)=>line.toLowerCase().startsWith('content-disposition'));
        if (!dispo) {
            continue;
        }
        const nameMatch = dispo.match(/name=\"([^\"]+)\"/i);
        if (!nameMatch) {
            continue;
        }
        const name = nameMatch[1];
        const filenameMatch = dispo.match(/filename=\"([^\"]*)\"/i);
        if (filenameMatch && filenameMatch[1] !== undefined && filenameMatch[1] !== '') {
            const filename = filenameMatch[1];
            const contentTypeHeader = headers.find((line)=>line.toLowerCase().startsWith('content-type'));
            const contentType = contentTypeHeader ? contentTypeHeader.split(':').slice(1).join(':').trim() : 'application/octet-stream';
            outFiles.push({
                field: name,
                name: filename,
                type: contentType,
                size: bodyText.length,
                content: bodyText
            });
        } else {
            outFields.push([
                name,
                bodyText.replace(/\r?\n$/, '')
            ]);
        }
    }
    return {
        fields: outFields,
        files: outFiles
    };
}
function parseCookies(cookieHeader) {
    if (!cookieHeader) return [];
    const out = [];
    const parts = String(cookieHeader).split(';');
    for (const part of parts){
        const trimmed = part.trim();
        if (!trimmed) continue;
        const idx = trimmed.indexOf('=');
        if (idx < 0) {
            out.push([
                trimmed,
                ''
            ]);
        } else {
            out.push([
                trimmed.slice(0, idx),
                trimmed.slice(idx + 1)
            ]);
        }
    }
    return out;
}
function normalizeHeaders(headers) {
    if (!headers) return {};
    if (typeof headers.entries === 'function') {
        const out = {};
        for (const [key, value] of headers.entries()){
            out[key] = value;
        }
        return out;
    }
    return headers;
}
function bodyToString(body) {
    if (!body) return '';
    if (typeof body === 'string') return body;
    if (body instanceof Uint8Array) {
        return new TextDecoder().decode(body);
    }
    return String(body);
}
function buildPrelude(request, scriptPath) {
    const url = new URL(request.url || 'http://localhost/');
    const headers = normalizeHeaders(request.headers || {});
    const hostHeader = headers.host || headers.Host || url.host || 'localhost';
    const hostParts = String(hostHeader).split(':');
    const hostname = hostParts[0] || 'localhost';
    const port = hostParts[1] ? Number(hostParts[1]) : url.protocol === 'https:' ? 443 : 80;
    const queryString = url.search ? url.search.slice(1) : '';
    const serverEntries = [
        [
            'REQUEST_METHOD',
            request.method || 'GET'
        ],
        [
            'REQUEST_URI',
            url.pathname + (url.search || '')
        ],
        [
            'QUERY_STRING',
            queryString
        ],
        [
            'HTTP_HOST',
            hostHeader
        ],
        [
            'SERVER_NAME',
            hostname
        ],
        [
            'SERVER_PORT',
            String(port)
        ],
        [
            'SCRIPT_NAME',
            url.pathname || '/'
        ],
        [
            'SCRIPT_FILENAME',
            scriptPath
        ],
        [
            'DOCUMENT_ROOT',
            globalThis.path && typeof globalThis.path.dirname === 'function' ? globalThis.path.dirname(scriptPath) : '.'
        ],
        [
            'HTTPS',
            url.protocol === 'https:' ? 'on' : 'off'
        ],
        [
            'REMOTE_ADDR',
            '127.0.0.1'
        ],
        [
            'REMOTE_PORT',
            '0'
        ]
    ];
    for (const [key, value] of Object.entries(headers)){
        const headerKey = `HTTP_${String(key).toUpperCase().replace(/-/g, '_')}`;
        serverEntries.push([
            headerKey,
            value
        ]);
    }
    let prelude = '';
    for (const [key, value] of serverEntries){
        const escapedKey = escapePhpString(key);
        prelude += `$_SERVER['${escapedKey}'] = '${escapePhpString(value)}';\n`;
    }
    const getEntries = parseQuery(queryString);
    const cookieEntries = parseCookies(headers.cookie || headers.Cookie);
    const postEntries = [];
    const fileEntries = [];
    const contentType = headers['content-type'] || headers['Content-Type'] || '';
    const rawBody = bodyToString(request.body);
    if (rawBody && String(contentType).includes('application/x-www-form-urlencoded')) {
        postEntries.push(...parseQuery(rawBody));
    } else if (rawBody && String(contentType).includes('multipart/form-data')) {
        const boundaryMatch = String(contentType).match(/boundary=([^;]+)/i);
        if (boundaryMatch) {
            const parsed = parseMultipart(rawBody, boundaryMatch[1]);
            postEntries.push(...parsed.fields);
            fileEntries.push(...parsed.files);
        }
    }
    prelude += buildArrayAssignments('$_GET', getEntries);
    prelude += buildArrayAssignments('$_POST', postEntries);
    prelude += buildArrayAssignments('$_COOKIE', cookieEntries);
    prelude += '$_REQUEST = array();\n';
    for (const [key, value] of [
        ...getEntries,
        ...postEntries,
        ...cookieEntries
    ]){
        prelude += `$_REQUEST['${escapePhpString(key)}'] = '${escapePhpString(value)}';\n`;
    }
    prelude += '$_FILES = array();\n';
    for (const file of fileEntries){
        const field = escapePhpString(file.field);
        prelude += `$_FILES['${field}'] = array(\n`;
        prelude += `  'name' => '${escapePhpString(file.name)}',\n`;
        prelude += `  'type' => '${escapePhpString(file.type)}',\n`;
        prelude += `  'size' => ${file.size},\n`;
        prelude += "  'tmp_name' => '',\n";
        prelude += "  'error' => 0,\n";
        prelude += `  'content' => '${escapePhpString(file.content)}'\n`;
        prelude += ");\n";
    }
    const rawInput = escapePhpString(rawBody);
    prelude += `$_SERVER['PHP_INPUT'] = '${rawInput}';\n`;
    prelude += `$_SERVER['REQUEST_BODY'] = '${rawInput}';\n`;
    prelude += `$HTTP_RAW_POST_DATA = '${rawInput}';\n`;
    prelude += buildModulePrelude(filePath);
    return prelude;
}
function buildCliPrelude(filePath) {
    let argv = [];
    const argsRaw = globalThis.process?.env?.DEKA_ARGS;
    if (argsRaw) {
        try {
            const parsed = JSON.parse(argsRaw);
            if (Array.isArray(parsed)) {
                argv = parsed.map((arg)=>String(arg));
            }
        } catch (_err) {}
    }
    const cwd = globalThis.process?.cwd ? globalThis.process.cwd() : '';
    const resolved = op_php_path_resolve(cwd, filePath);
    const docRoot = resolved.includes('/') ? resolved.slice(0, resolved.lastIndexOf('/')) : '';
    let prelude = '';
    prelude += "$_SERVER = array();\n";
    prelude += `$_SERVER['SCRIPT_FILENAME'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['SCRIPT_NAME'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['PHP_SELF'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['DOCUMENT_ROOT'] = '${escapePhpString(docRoot)}';\n`;
    prelude += `$_SERVER['PWD'] = '${escapePhpString(cwd)}';\n`;
    prelude += "$_SERVER['PHP_SAPI'] = 'cli';\n";
    prelude += "$argv = array();\n";
    prelude += `$argv[] = '${escapePhpString(resolved)}';\n`;
    for (const arg of argv){
        prelude += `$argv[] = '${escapePhpString(arg)}';\n`;
    }
    prelude += `$argc = ${argv.length + 1};\n`;
    prelude += "$_SERVER['argv'] = $argv;\n";
    prelude += "$_SERVER['argc'] = $argc;\n";
    prelude += buildModulePrelude(filePath);
    return prelude;
}
function injectPrelude(source, prelude) {
    const trimmed = source.trimStart();
    if (trimmed.startsWith('<?php')) {
        const idx = source.indexOf('<?php');
        const afterOpen = source.slice(idx + 5);
        const afterTrimmed = afterOpen.trimStart();
        if (afterTrimmed.startsWith('declare')) {
            const declareStart = afterOpen.indexOf(afterTrimmed);
            const semicolonIdx = afterTrimmed.indexOf(';');
            if (semicolonIdx !== -1) {
                const insertPos = idx + 5 + declareStart + semicolonIdx + 1;
                return source.slice(0, insertPos) + '\n' + prelude + '\n' + source.slice(insertPos);
            }
        }
        return source.slice(0, idx + 5) + '\n' + prelude + '\n' + source.slice(idx + 5);
    }
    return `<?php\n${prelude}\n?>\n` + source;
}
function runSource(source) {
    const bytes = new TextEncoder().encode(source);
    const srcPtr = writeBytes(bytes);
    const resultPtr = phpRun(srcPtr, bytes.length);
    phpFree(srcPtr, bytes.length);
    const view = new DataView(phpMemory.buffer, resultPtr, 8);
    const outPtr = view.getUint32(0, true);
    const outLen = view.getUint32(4, true);
    const outText = readString(outPtr, outLen);
    phpFree(outPtr, outLen);
    phpFree(resultPtr, 8);
    return JSON.parse(outText);
}
async function runFile(filePath) {
    await initPhpWasm();
    setPhpActiveRoots(filePath);
    const source = globalThis.fs.readFileSync(filePath, 'utf8');
    const prelude = buildCliPrelude(filePath);
    const stitched = injectPrelude(source, prelude);
    return runSource(stitched);
}
function runRequest(request, filePath) {
    setPhpActiveRoots(filePath);
    const source = globalThis.fs.readFileSync(filePath, 'utf8');
    const prelude = buildPrelude(request || {}, filePath);
    const stitched = injectPrelude(source, prelude);
    return runSource(stitched);
}
function reset() {
    if (!phpModule) return;
    const imports = {
        env: {
            php_log: (ptr, len)=>{
                if (!phpMemory) return;
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                let message = new TextDecoder().decode(bytes);
                if (globalThis.__dekaPhpLogEnabled) {
                    console.log('[php]', message);
                }
            },
            php_fs_read: phpFsRead,
            php_fs_exists: phpFsExists
        }
    };
    phpInstance = new WebAssembly.Instance(phpModule, imports);
    phpMemory = phpInstance.exports.memory;
    phpAlloc = phpInstance.exports.php_alloc;
    phpFree = phpInstance.exports.php_free;
    phpRun = phpInstance.exports.php_run;
}
function servePhp(phpFile) {
    return {
        async fetch (request) {
            try {
                await initPhpWasm();
                const result = runRequest(request, phpFile);
                if (result && result.ok) {
                    return new Response(result.stdout || '', {
                        status: 200,
                        headers: {
                            'Content-Type': 'text/html; charset=utf-8'
                        }
                    });
                }
                const errorMessage = result ? [
                    result.error || 'php_error',
                    result.stderr || ''
                ].filter(Boolean).join('\n') : 'php_error';
                return new Response(errorMessage, {
                    status: 500,
                    headers: {
                        'Content-Type': 'text/plain; charset=utf-8'
                    }
                });
            } catch (error) {
                console.error('PHP execution error:', error);
                return new Response(`PHP Error: ${error.message}`, {
                    status: 500,
                    headers: {
                        'Content-Type': 'text/plain'
                    }
                });
            }
        }
    };
}
globalThis.__dekaPhp = {
    runSource,
    runFile,
    runRequest,
    reset,
    servePhp
};
export { servePhp as servePhp };
