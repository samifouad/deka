// Generated by build.rs (PHP prelude). Do not edit.
const { op_php_get_wasm, op_php_read_file_sync, op_php_read_env, op_php_cwd, op_php_file_exists, op_php_path_resolve } = Deno.core.ops;
const console = {
    log: (...args)=>{
        const message = args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    },
    error: (...args)=>{
        const message = args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', true);
    },
    warn: (...args)=>{
        const message = '[WARN] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', true);
    },
    info: (...args)=>{
        const message = '[INFO] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    },
    debug: (...args)=>{
        const message = '[DEBUG] ' + args.map((a)=>String(a)).join(' ');
        Deno.core.print(message + '\n', false);
    }
};
globalThis.console = console;
if (!globalThis.TextEncoder) {
    globalThis.TextEncoder = class TextEncoder {
        encode(input) {
            const str = String(input);
            const utf8 = [];
            for(let i = 0; i < str.length; i++){
                let charCode = str.charCodeAt(i);
                if (charCode < 0x80) {
                    utf8.push(charCode);
                } else if (charCode < 0x800) {
                    utf8.push(0xc0 | charCode >> 6, 0x80 | charCode & 0x3f);
                } else if (charCode < 0xd800 || charCode >= 0xe000) {
                    utf8.push(0xe0 | charCode >> 12, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);
                } else {
                    i++;
                    charCode = 0x10000 + ((charCode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
                    utf8.push(0xf0 | charCode >> 18, 0x80 | charCode >> 12 & 0x3f, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);
                }
            }
            return new Uint8Array(utf8);
        }
    };
}
if (!globalThis.TextDecoder) {
    globalThis.TextDecoder = class TextDecoder1 {
        decode(bytes) {
            if (!bytes) return '';
            const arr = new Uint8Array(bytes);
            let str = '';
            let i = 0;
            while(i < arr.length){
                let __byte = arr[i++];
                if (__byte < 0x80) {
                    str += String.fromCharCode(__byte);
                } else if (__byte < 0xe0) {
                    str += String.fromCharCode((__byte & 0x1f) << 6 | arr[i++] & 0x3f);
                } else if (__byte < 0xf0) {
                    str += String.fromCharCode((__byte & 0x0f) << 12 | (arr[i++] & 0x3f) << 6 | arr[i++] & 0x3f);
                } else {
                    const code = (__byte & 0x07) << 18 | (arr[i++] & 0x3f) << 12 | (arr[i++] & 0x3f) << 6 | arr[i++] & 0x3f;
                    const high = code - 0x10000 >> 10 | 0xd800;
                    const low = code - 0x10000 & 0x3ff | 0xdc00;
                    str += String.fromCharCode(high, low);
                }
            }
            return str;
        }
    };
}
globalThis.fs = {
    readFileSync: (path, encoding)=>{
        const bytes = op_php_read_file_sync(path);
        if (encoding === 'utf8' || encoding === 'utf-8') {
            return new TextDecoder().decode(bytes);
        }
        return bytes;
    },
    existsSync: (path)=>{
        return op_php_file_exists(path);
    }
};
globalThis.process = {
    env: op_php_read_env(),
    cwd: ()=>op_php_cwd()
};
if (globalThis.__dekaPhpLogEnabled === undefined) {
    const debug = globalThis.process?.env?.DEKA_DEBUG;
    globalThis.__dekaPhpLogEnabled = debug === '1' || debug === 'true' || debug === 'yes' || debug === 'on';
}
globalThis.URLSearchParams = class URLSearchParams {
    params = [];
    constructor(init){
        if (typeof init === 'string') {
            const pairs = init.replace(/^\?/, '').split('&');
            for (const pair of pairs){
                if (!pair) continue;
                const idx = pair.indexOf('=');
                if (idx === -1) {
                    this.params.push([
                        decodeURIComponent(pair),
                        ''
                    ]);
                } else {
                    this.params.push([
                        decodeURIComponent(pair.slice(0, idx)),
                        decodeURIComponent(pair.slice(idx + 1))
                    ]);
                }
            }
        }
    }
    append(name, value) {
        this.params.push([
            String(name),
            String(value)
        ]);
    }
    get(name) {
        const entry = this.params.find(([k])=>k === name);
        return entry ? entry[1] : null;
    }
    *entries() {
        for (const param of this.params){
            yield param;
        }
    }
    toString() {
        return this.params.map(([k, v])=>`${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
    }
};
globalThis.path = {
    sep: '/',
    delimiter: ':',
    extname: (p)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        const lastDot = str.lastIndexOf('.');
        if (lastDot === -1 || lastDot < lastSlash) return '';
        return str.slice(lastDot);
    },
    dirname: (p)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        if (lastSlash === -1) return '.';
        if (lastSlash === 0) return '/';
        return str.slice(0, lastSlash);
    },
    basename: (p, ext)=>{
        const str = String(p);
        const lastSlash = str.lastIndexOf('/');
        let base = lastSlash === -1 ? str : str.slice(lastSlash + 1);
        if (ext && base.endsWith(ext)) {
            base = base.slice(0, -ext.length);
        }
        return base;
    },
    normalize: (p)=>{
        const str = String(p);
        const parts = str.split('/');
        const result = [];
        for (const part of parts){
            if (part === '..') {
                if (result.length > 0 && result[result.length - 1] !== '..') {
                    result.pop();
                } else {
                    result.push('..');
                }
            } else if (part !== '.' && part !== '') {
                result.push(part);
            }
        }
        const normalized = result.join('/');
        return str.startsWith('/') ? '/' + normalized : normalized || '.';
    },
    resolve: (...args)=>{
        let resolved = '';
        for(let i = args.length - 1; i >= 0; i--){
            const p = String(args[i]);
            if (!p) continue;
            if (resolved === '') {
                resolved = p;
            } else if (p.startsWith('/')) {
                resolved = p + '/' + resolved;
                break;
            } else {
                resolved = p + '/' + resolved;
            }
            if (resolved.startsWith('/')) {
                break;
            }
        }
        if (!resolved.startsWith('/')) {
            const cwd = op_php_cwd();
            resolved = cwd + '/' + resolved;
        }
        return globalThis.path.normalize(resolved);
    },
    join: (...args)=>{
        const parts = args.filter((p)=>p && String(p) !== '');
        if (parts.length === 0) return '.';
        const joined = parts.join('/');
        return globalThis.path.normalize(joined);
    }
};
if (!globalThis.Response) {
    globalThis.Response = class Response1 {
        body;
        status;
        headers;
        constructor(body, init){
            this.body = body || '';
            this.status = init?.status || 200;
            this.headers = init?.headers || {};
        }
    };
}
let phpInstance = null;
let phpModule = null;
let phpMemory = null;
let phpAlloc = null;
let phpFree = null;
let phpRun = null;
const __wbindgen_heap = [
    undefined,
    null,
    true,
    false
];
let __wbindgen_heap_next = __wbindgen_heap.length;
function __wbindgen_get_object(idx) {
    return __wbindgen_heap[idx];
}
function __wbindgen_add_heap_object(obj) {
    if (__wbindgen_heap_next === __wbindgen_heap.length) {
        __wbindgen_heap.push(__wbindgen_heap.length + 1);
    }
    const idx = __wbindgen_heap_next;
    __wbindgen_heap_next = __wbindgen_heap[idx];
    __wbindgen_heap[idx] = obj;
    return idx;
}
function __wbindgen_drop_object(idx) {
    if (idx < 4) return;
    __wbindgen_heap[idx] = __wbindgen_heap_next;
    __wbindgen_heap_next = idx;
}
async function initPhpWasm() {
    if (phpInstance) return phpInstance;
    const wasmBytes = op_php_get_wasm();
    if (!wasmBytes || wasmBytes.length === 0) {
        console.error('[php] wasm bytes missing or empty');
    }
    const wasmModule = new WebAssembly.Module(wasmBytes);
    const imports = {
        env: {
            gild_log: (ptr, len)=>{
                if (!phpMemory) return;
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                let message = new TextDecoder().decode(bytes);
                if (message.startsWith('gild_')) {
                    message = message.replace('gild_', 'php_');
                }
                if (globalThis.__dekaPhpLogEnabled) {
                    console.log('[php]', message);
                }
            }
        },
        __wbindgen_placeholder__: {
            __wbindgen_describe: ()=>{},
            __wbindgen_describe_cast: ()=>{},
            __wbindgen_object_drop_ref: (idx)=>__wbindgen_drop_object(idx),
            __wbg_getTimezoneOffset_45389e26d6f46823: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTimezoneOffset === "function"
                    ? obj.getTimezoneOffset()
                    : 0;
            },
            __wbg_new_b2db8aa2650f793a: (...args)=>{
                if (args.length > 0 && typeof args[0] === "number") {
                    return __wbindgen_add_heap_object(new Date(args[0]));
                }
                return __wbindgen_add_heap_object(new Date());
            },
            __wbg_new_0_23cedd11d9b40c9d: ()=>__wbindgen_add_heap_object(new Date()),
            __wbg_getTime_ad1e9878a735af08: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return obj && typeof obj.getTime === "function" ? obj.getTime() : 0;
            },
            __wbg___wbindgen_throw_dd24417ed36fc46e: (ptr, len)=>{
                if (!phpMemory) {
                    throw new Error("php wasm trap");
                }
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                const message = new TextDecoder().decode(bytes);
                throw new Error(message);
            },
            __wbg___wbindgen_is_object_ce774f3490692386: (idx)=>{
                const obj = __wbindgen_get_object(idx);
                return typeof obj === "object" && obj !== null;
            },
            __wbg___wbindgen_is_string_704ef9c8fc131030: (idx)=>{
                return typeof __wbindgen_get_object(idx) === "string";
            },
            __wbg___wbindgen_is_function_8d400b8b1af978cd: (idx)=>{
                return typeof __wbindgen_get_object(idx) === "function";
            },
            __wbg___wbindgen_is_undefined_f6b95eab589e0269: (idx)=>{
                return __wbindgen_get_object(idx) === undefined;
            }
        },
        __wbindgen_externref_xform__: {
            __wbindgen_externref_table_set_null: (_idx)=>{},
            __wbindgen_externref_table_grow: (_delta)=>0
        }
    };
    phpModule = wasmModule;
    phpInstance = await WebAssembly.instantiate(wasmModule, imports);
    phpMemory = phpInstance.exports.memory;
    phpAlloc = phpInstance.exports.gild_alloc;
    phpFree = phpInstance.exports.gild_free;
    phpRun = phpInstance.exports.gild_run;
    if (!phpMemory || !phpAlloc || !phpFree || !phpRun) {
        throw new Error('php wasm exports missing gild_* api');
    }
    return phpInstance;
}
function readString(ptr, len) {
    const view = new Uint8Array(phpMemory.buffer, ptr, len);
    return new TextDecoder().decode(view);
}
function writeBytes(bytes) {
    const ptr = phpAlloc(bytes.length);
    new Uint8Array(phpMemory.buffer, ptr, bytes.length).set(bytes);
    return ptr;
}
function escapePhpString(value) {
    return String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\r/g, '\\r').replace(/\n/g, '\\n');
}
function buildArrayAssignments(target, entries) {
    let out = `${target} = array();\n`;
    for (const [key, value] of entries){
        const escapedKey = escapePhpString(key);
        if (value === null || value === undefined) {
            out += `${target}['${escapedKey}'] = null;\n`;
        } else {
            out += `${target}['${escapedKey}'] = '${escapePhpString(value)}';\n`;
        }
    }
    return out;
}
function parseQuery(queryString) {
    const params = new URLSearchParams(queryString || '');
    const out = [];
    for (const [key, value] of params.entries()){
        out.push([
            key,
            value
        ]);
    }
    return out;
}
function parseMultipart(body, boundary) {
    const text = String(body || '');
    const outFiles = [];
    const outFields = [];
    const delimiter = `--${boundary}`;
    const parts = text.split(delimiter);
    for (const part of parts){
        if (!part || part === '--' || part === '--\r\n') {
            continue;
        }
        const trimmed = part.replace(/^\r?\n/, '').replace(/\r?\n--$/, '');
        const headerEnd = trimmed.indexOf('\r\n\r\n');
        if (headerEnd === -1) {
            continue;
        }
        const headerText = trimmed.slice(0, headerEnd);
        const bodyText = trimmed.slice(headerEnd + 4);
        const headers = headerText.split('\r\n');
        const dispo = headers.find((line)=>line.toLowerCase().startsWith('content-disposition'));
        if (!dispo) {
            continue;
        }
        const nameMatch = dispo.match(/name=\"([^\"]+)\"/i);
        if (!nameMatch) {
            continue;
        }
        const name = nameMatch[1];
        const filenameMatch = dispo.match(/filename=\"([^\"]*)\"/i);
        if (filenameMatch && filenameMatch[1] !== undefined && filenameMatch[1] !== '') {
            const filename = filenameMatch[1];
            const contentTypeHeader = headers.find((line)=>line.toLowerCase().startsWith('content-type'));
            const contentType = contentTypeHeader ? contentTypeHeader.split(':').slice(1).join(':').trim() : 'application/octet-stream';
            outFiles.push({
                field: name,
                name: filename,
                type: contentType,
                size: bodyText.length,
                content: bodyText
            });
        } else {
            outFields.push([
                name,
                bodyText.replace(/\r?\n$/, '')
            ]);
        }
    }
    return {
        fields: outFields,
        files: outFiles
    };
}
function parseCookies(cookieHeader) {
    if (!cookieHeader) return [];
    const out = [];
    const parts = String(cookieHeader).split(';');
    for (const part of parts){
        const trimmed = part.trim();
        if (!trimmed) continue;
        const idx = trimmed.indexOf('=');
        if (idx < 0) {
            out.push([
                trimmed,
                ''
            ]);
        } else {
            out.push([
                trimmed.slice(0, idx),
                trimmed.slice(idx + 1)
            ]);
        }
    }
    return out;
}
function normalizeHeaders(headers) {
    if (!headers) return {};
    if (typeof headers.entries === 'function') {
        const out = {};
        for (const [key, value] of headers.entries()){
            out[key] = value;
        }
        return out;
    }
    return headers;
}
function bodyToString(body) {
    if (!body) return '';
    if (typeof body === 'string') return body;
    if (body instanceof Uint8Array) {
        return new TextDecoder().decode(body);
    }
    return String(body);
}
function buildPrelude(request, scriptPath) {
    const url = new URL(request.url || 'http://localhost/');
    const headers = normalizeHeaders(request.headers || {});
    const hostHeader = headers.host || headers.Host || url.host || 'localhost';
    const hostParts = String(hostHeader).split(':');
    const hostname = hostParts[0] || 'localhost';
    const port = hostParts[1] ? Number(hostParts[1]) : url.protocol === 'https:' ? 443 : 80;
    const queryString = url.search ? url.search.slice(1) : '';
    const serverEntries = [
        [
            'REQUEST_METHOD',
            request.method || 'GET'
        ],
        [
            'REQUEST_URI',
            url.pathname + (url.search || '')
        ],
        [
            'QUERY_STRING',
            queryString
        ],
        [
            'HTTP_HOST',
            hostHeader
        ],
        [
            'SERVER_NAME',
            hostname
        ],
        [
            'SERVER_PORT',
            String(port)
        ],
        [
            'SCRIPT_NAME',
            url.pathname || '/'
        ],
        [
            'SCRIPT_FILENAME',
            scriptPath
        ],
        [
            'DOCUMENT_ROOT',
            globalThis.path && typeof globalThis.path.dirname === 'function' ? globalThis.path.dirname(scriptPath) : '.'
        ],
        [
            'HTTPS',
            url.protocol === 'https:' ? 'on' : 'off'
        ],
        [
            'REMOTE_ADDR',
            '127.0.0.1'
        ],
        [
            'REMOTE_PORT',
            '0'
        ]
    ];
    for (const [key, value] of Object.entries(headers)){
        const headerKey = `HTTP_${String(key).toUpperCase().replace(/-/g, '_')}`;
        serverEntries.push([
            headerKey,
            value
        ]);
    }
    let prelude = '';
    for (const [key, value] of serverEntries){
        const escapedKey = escapePhpString(key);
        prelude += `$_SERVER['${escapedKey}'] = '${escapePhpString(value)}';\n`;
    }
    const getEntries = parseQuery(queryString);
    const cookieEntries = parseCookies(headers.cookie || headers.Cookie);
    const postEntries = [];
    const fileEntries = [];
    const contentType = headers['content-type'] || headers['Content-Type'] || '';
    const rawBody = bodyToString(request.body);
    if (rawBody && String(contentType).includes('application/x-www-form-urlencoded')) {
        postEntries.push(...parseQuery(rawBody));
    } else if (rawBody && String(contentType).includes('multipart/form-data')) {
        const boundaryMatch = String(contentType).match(/boundary=([^;]+)/i);
        if (boundaryMatch) {
            const parsed = parseMultipart(rawBody, boundaryMatch[1]);
            postEntries.push(...parsed.fields);
            fileEntries.push(...parsed.files);
        }
    }
    prelude += buildArrayAssignments('$_GET', getEntries);
    prelude += buildArrayAssignments('$_POST', postEntries);
    prelude += buildArrayAssignments('$_COOKIE', cookieEntries);
    prelude += '$_REQUEST = array();\n';
    for (const [key, value] of [
        ...getEntries,
        ...postEntries,
        ...cookieEntries
    ]){
        prelude += `$_REQUEST['${escapePhpString(key)}'] = '${escapePhpString(value)}';\n`;
    }
    prelude += '$_FILES = array();\n';
    for (const file of fileEntries){
        const field = escapePhpString(file.field);
        prelude += `$_FILES['${field}'] = array(\n`;
        prelude += `  'name' => '${escapePhpString(file.name)}',\n`;
        prelude += `  'type' => '${escapePhpString(file.type)}',\n`;
        prelude += `  'size' => ${file.size},\n`;
        prelude += "  'tmp_name' => '',\n";
        prelude += "  'error' => 0,\n";
        prelude += `  'content' => '${escapePhpString(file.content)}'\n`;
        prelude += ");\n";
    }
    const rawInput = escapePhpString(rawBody);
    prelude += `$_SERVER['PHP_INPUT'] = '${rawInput}';\n`;
    prelude += `$_SERVER['REQUEST_BODY'] = '${rawInput}';\n`;
    prelude += `$HTTP_RAW_POST_DATA = '${rawInput}';\n`;
    return prelude;
}
function buildCliPrelude(filePath) {
    let argv = [];
    const argsRaw = globalThis.process?.env?.DEKA_ARGS;
    if (argsRaw) {
        try {
            const parsed = JSON.parse(argsRaw);
            if (Array.isArray(parsed)) {
                argv = parsed.map((arg)=>String(arg));
            }
        } catch (_err) {}
    }
    const cwd = globalThis.process?.cwd ? globalThis.process.cwd() : '';
    const resolved = op_php_path_resolve(cwd, filePath);
    const docRoot = resolved.includes('/') ? resolved.slice(0, resolved.lastIndexOf('/')) : '';
    let prelude = '';
    prelude += "$_SERVER = array();\n";
    prelude += `$_SERVER['SCRIPT_FILENAME'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['SCRIPT_NAME'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['PHP_SELF'] = '${escapePhpString(resolved)}';\n`;
    prelude += `$_SERVER['DOCUMENT_ROOT'] = '${escapePhpString(docRoot)}';\n`;
    prelude += `$_SERVER['PWD'] = '${escapePhpString(cwd)}';\n`;
    prelude += "$_SERVER['PHP_SAPI'] = 'cli';\n";
    prelude += "$argv = array();\n";
    prelude += `$argv[] = '${escapePhpString(resolved)}';\n`;
    for (const arg of argv){
        prelude += `$argv[] = '${escapePhpString(arg)}';\n`;
    }
    prelude += `$argc = ${argv.length + 1};\n`;
    prelude += "$_SERVER['argv'] = $argv;\n";
    prelude += "$_SERVER['argc'] = $argc;\n";
    return prelude;
}
function injectPrelude(source, prelude) {
    const trimmed = source.trimStart();
    if (trimmed.startsWith('<?php')) {
        const idx = source.indexOf('<?php');
        const afterOpen = source.slice(idx + 5);
        const afterTrimmed = afterOpen.trimStart();
        if (afterTrimmed.startsWith('declare')) {
            const declareStart = afterOpen.indexOf(afterTrimmed);
            const semicolonIdx = afterTrimmed.indexOf(';');
            if (semicolonIdx !== -1) {
                const insertPos = idx + 5 + declareStart + semicolonIdx + 1;
                return source.slice(0, insertPos) + '\n' + prelude + '\n' + source.slice(insertPos);
            }
        }
        return source.slice(0, idx + 5) + '\n' + prelude + '\n' + source.slice(idx + 5);
    }
    return `<?php\n${prelude}\n?>\n` + source;
}
function runSource(source) {
    const bytes = new TextEncoder().encode(source);
    const srcPtr = writeBytes(bytes);
    const resultPtr = phpRun(srcPtr, bytes.length);
    phpFree(srcPtr, bytes.length);
    const view = new DataView(phpMemory.buffer, resultPtr, 8);
    const outPtr = view.getUint32(0, true);
    const outLen = view.getUint32(4, true);
    const outText = readString(outPtr, outLen);
    phpFree(outPtr, outLen);
    phpFree(resultPtr, 8);
    return JSON.parse(outText);
}
async function runFile(filePath) {
    await initPhpWasm();
    const source = globalThis.fs.readFileSync(filePath, 'utf8');
    const prelude = buildCliPrelude(filePath);
    const stitched = injectPrelude(source, prelude);
    return runSource(stitched);
}
function runRequest(request, filePath) {
    const source = globalThis.fs.readFileSync(filePath, 'utf8');
    const prelude = buildPrelude(request || {}, filePath);
    const stitched = injectPrelude(source, prelude);
    return runSource(stitched);
}
function reset() {
    if (!phpModule) return;
    const imports = {
        env: {
            gild_log: (ptr, len)=>{
                if (!phpMemory) return;
                const bytes = new Uint8Array(phpMemory.buffer, ptr, len);
                let message = new TextDecoder().decode(bytes);
                if (message.startsWith('gild_')) {
                    message = message.replace('gild_', 'php_');
                }
                if (globalThis.__dekaPhpLogEnabled) {
                    console.log('[php]', message);
                }
            }
        }
    };
    phpInstance = new WebAssembly.Instance(phpModule, imports);
    phpMemory = phpInstance.exports.memory;
    phpAlloc = phpInstance.exports.gild_alloc;
    phpFree = phpInstance.exports.gild_free;
    phpRun = phpInstance.exports.gild_run;
}
function servePhp(phpFile) {
    return {
        async fetch (request) {
            try {
                await initPhpWasm();
                const result = runRequest(request, phpFile);
                if (result && result.ok) {
                    return new Response(result.stdout || '', {
                        status: 200,
                        headers: {
                            'Content-Type': 'text/html; charset=utf-8'
                        }
                    });
                }
                const errorMessage = result ? [
                    result.error || 'php_error',
                    result.stderr || ''
                ].filter(Boolean).join('\n') : 'php_error';
                return new Response(errorMessage, {
                    status: 500,
                    headers: {
                        'Content-Type': 'text/plain; charset=utf-8'
                    }
                });
            } catch (error) {
                console.error('PHP execution error:', error);
                return new Response(`PHP Error: ${error.message}`, {
                    status: 500,
                    headers: {
                        'Content-Type': 'text/plain'
                    }
                });
            }
        }
    };
}
globalThis.__dekaPhp = {
    runSource,
    runFile,
    runRequest,
    reset,
    servePhp
};
export { servePhp as servePhp };
