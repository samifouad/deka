use bumpalo::Bump;
use core::{CommandSpec, Context, ParamSpec, Registry};
use modules_php::compiler_api::compile_phpx;
use modules_php::validation::format_multiple_errors;
use php_rs::parser::ast::{
    BinaryOp, Expr, ExprId, JsxChild, ObjectKey, Program, Stmt, StmtId,
};
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};

const COMMAND: CommandSpec = CommandSpec {
    name: "build",
    category: "project",
    summary: "build a PHPX file into a JavaScript module scaffold",
    aliases: &[],
    subcommands: &[],
    handler: cmd,
};

pub fn register(registry: &mut Registry) {
    registry.add_command(COMMAND);
    registry.add_param(ParamSpec {
        name: "--out",
        description: "output JavaScript file path",
    });
}

pub fn cmd(context: &Context) {
    if let Err(err) = run(context) {
        stdio::error("build", &err);
    }
}

fn run(context: &Context) -> Result<(), String> {
    let input = context
        .args
        .positionals
        .first()
        .ok_or_else(|| "usage: deka build <input.phpx> [--out dist/file.js]".to_string())?;

    if !input.ends_with(".phpx") {
        return Err(format!(
            "build currently supports .phpx input only; got '{}'",
            input
        ));
    }

    let input_path = PathBuf::from(input);
    let source = fs::read_to_string(&input_path)
        .map_err(|err| format!("failed to read {}: {}", input_path.display(), err))?;

    // Reuse strict PHPX validation before writing any build artifact.
    let arena = Bump::new();
    let result = compile_phpx(&source, input, &arena);
    if !result.errors.is_empty() {
        let formatted = format_multiple_errors(&source, input, &result.errors, &result.warnings);
        return Err(formatted);
    }

    let output_path = resolve_output_path(output_arg(context), &input_path)?;
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)
            .map_err(|err| format!("failed to create {}: {}", parent.display(), err))?;
    }

    let js = if let Some(program) = result.ast {
        match emit_js_from_ast(&program, source.as_bytes()) {
            Ok(emitted) => emitted,
            Err(reason) => emit_js_scaffold_with_reason(&source, input, &reason),
        }
    } else {
        emit_js_scaffold_with_reason(&source, input, "no AST available after validation")
    };

    fs::write(&output_path, js)
        .map_err(|err| format!("failed to write {}: {}", output_path.display(), err))?;

    stdio::success(&format!(
        "built {} -> {}",
        input_path.display(),
        output_path.display()
    ));
    Ok(())
}

fn output_arg(context: &Context) -> Option<String> {
    context
        .args
        .params
        .get("--out")
        .or_else(|| context.args.params.get("-o"))
        .or_else(|| context.args.params.get("--outdir"))
        .cloned()
}

fn resolve_output_path(out: Option<String>, input_path: &Path) -> Result<PathBuf, String> {
    if let Some(out) = out {
        return Ok(PathBuf::from(out));
    }

    let stem = input_path
        .file_stem()
        .and_then(|v| v.to_str())
        .ok_or_else(|| format!("invalid input filename: {}", input_path.display()))?;

    Ok(PathBuf::from("dist").join(format!("{}.js", stem)))
}

fn emit_js_from_ast(program: &Program<'_>, source: &[u8]) -> Result<String, String> {
    let mut emitter = JsSubsetEmitter::new(source);
    emitter.emit_program(program)?;
    Ok(emitter.finish())
}

fn emit_js_scaffold_with_reason(source: &str, file_path: &str, reason: &str) -> String {
    let escaped = serde_json::to_string(source).unwrap_or_else(|_| "\"\"".to_string());
    let escaped_path =
        serde_json::to_string(file_path).unwrap_or_else(|_| "\"unknown.phpx\"".to_string());
    let escaped_reason = serde_json::to_string(reason).unwrap_or_else(|_| "\"unknown\"".to_string());

    format!(
        "// Generated by deka build. Do not edit manually.\n\
// Source: {file_path}\n\
// Fallback scaffold used because subset emitter could not lower this file.\n\
export const phpxBuildMode = \"scaffold\";\n\
export const phpxBuildReason = {escaped_reason};\n\
export const phpxSource = {escaped};\n\
export const phpxFile = {escaped_path};\n\
\n\
export async function runPhpx(runtime, props = {{}}) {{\n\
  if (!runtime || typeof runtime.executePhpx !== 'function') {{\n\
    throw new Error('runtime.executePhpx(source, file, props) is required');\n\
  }}\n\
  return await runtime.executePhpx(phpxSource, phpxFile, props);\n\
}}\n",
    )
}

struct JsSubsetEmitter<'a> {
    source: &'a [u8],
    body: String,
    uses_jsx_runtime: bool,
    scopes: Vec<HashSet<String>>,
}

impl<'a> JsSubsetEmitter<'a> {
    fn new(source: &'a [u8]) -> Self {
        Self {
            source,
            body: String::new(),
            uses_jsx_runtime: false,
            scopes: vec![HashSet::new()],
        }
    }

    fn finish(self) -> String {
        let mut out = String::new();
        out.push_str("// Generated by deka build. Do not edit manually.\n");
        out.push_str("export const phpxBuildMode = \"subset-ast\";\n\n");
        if self.uses_jsx_runtime {
            out.push_str("import { jsx, jsxs } from 'component/core'\n\n");
        }
        out.push_str(&self.body);
        out
    }

    fn emit_program(&mut self, program: &Program<'_>) -> Result<(), String> {
        for stmt in program.statements {
            self.emit_stmt(*stmt)?;
        }
        Ok(())
    }

    fn emit_stmt(&mut self, stmt: StmtId<'_>) -> Result<(), String> {
        match stmt {
            Stmt::Function {
                name, params, body, ..
            } => {
                let fn_name = self.token_name(name);
                let js_params = params
                    .iter()
                    .map(|p| self.token_name(p.name))
                    .collect::<Vec<_>>()
                    .join(", ");
                self.body
                    .push_str(&format!("function {}({}) {{\n", fn_name, js_params));

                self.push_scope();
                for p in *params {
                    self.declare_in_scope(&self.token_name(p.name));
                }
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();

                self.body.push_str("}\n\n");
                Ok(())
            }
            Stmt::Return { expr, .. } => {
                if let Some(expr) = expr {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("return {};\n", value));
                } else {
                    self.body.push_str("return;\n");
                }
                Ok(())
            }
            Stmt::Echo { exprs, .. } => {
                for expr in *exprs {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("console.log({});\n", value));
                }
                Ok(())
            }
            Stmt::Expression { expr, .. } => {
                if let Some((name, rhs)) = self.assignment_to_named_var(*expr)? {
                    if !self.is_declared(&name) {
                        self.declare_in_scope(&name);
                        self.body.push_str(&format!("let {} = {};\n", name, rhs));
                    } else {
                        self.body.push_str(&format!("{} = {};\n", name, rhs));
                    }
                } else {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("{};\n", value));
                }
                Ok(())
            }
            Stmt::Nop { .. } => Ok(()),
            other => Err(format!("unsupported statement in subset emitter: {:?}", other)),
        }
    }

    fn emit_expr(&mut self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            Expr::Integer { value, .. } | Expr::Float { value, .. } => {
                Ok(String::from_utf8_lossy(value).to_string())
            }
            Expr::Boolean { value, .. } => Ok(if *value { "true" } else { "false" }.to_string()),
            Expr::Null { .. } => Ok("null".to_string()),
            Expr::String { value, .. } => Ok(self.encode_php_string_literal(value)),
            Expr::Binary {
                left, op, right, ..
            } => {
                let lhs = self.emit_expr(*left)?;
                let rhs = self.emit_expr(*right)?;
                let js_op = match op {
                    BinaryOp::Plus => "+",
                    BinaryOp::Minus => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Pow => "**",
                    BinaryOp::Concat => "+",
                    BinaryOp::EqEq => "==",
                    BinaryOp::EqEqEq => "===",
                    BinaryOp::NotEq => "!=",
                    BinaryOp::NotEqEq => "!==",
                    BinaryOp::Lt => "<",
                    BinaryOp::LtEq => "<=",
                    BinaryOp::Gt => ">",
                    BinaryOp::GtEq => ">=",
                    BinaryOp::And => "&&",
                    BinaryOp::Or => "||",
                    _ => {
                        return Err(format!("unsupported binary operator in subset emitter: {:?}", op));
                    }
                };
                Ok(format!("({} {} {})", lhs, js_op, rhs))
            }
            Expr::Call { func, args, .. } => {
                let callee = self.emit_expr(*func)?;
                let mut rendered = Vec::with_capacity(args.len());
                for arg in *args {
                    if arg.name.is_some() || arg.unpack {
                        return Err("named/unpack call arguments are not supported in subset emitter"
                            .to_string());
                    }
                    rendered.push(self.emit_expr(arg.value)?);
                }
                Ok(format!("{}({})", callee, rendered.join(", ")))
            }
            Expr::Assign { var, expr, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    let js_name = self.span_name(*name);
                    let rhs = self.emit_expr(*expr)?;
                    Ok(format!("({} = {})", js_name, rhs))
                } else {
                    Err("subset emitter only supports assignment to simple variables".to_string())
                }
            }
            Expr::PropertyFetch {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                match *property {
                    Expr::Variable { name, .. } => {
                        let prop = self.span_name(*name);
                        Ok(format!("{}.{}", target_js, prop))
                    }
                    _ => Err("dynamic property access is not supported in subset emitter".to_string()),
                }
            }
            Expr::DotAccess {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let prop = self.token_text(property);
                Ok(format!("{}.{}", target_js, prop))
            }
            Expr::Array { items, .. } => {
                let mut values = Vec::new();
                for item in *items {
                    if item.key.is_some() || item.by_ref || item.unpack {
                        return Err("array item keys/by-ref/unpack are not supported in subset emitter"
                            .to_string());
                    }
                    values.push(self.emit_expr(item.value)?);
                }
                Ok(format!("[{}]", values.join(", ")))
            }
            Expr::ObjectLiteral { items, .. } => {
                let mut entries = Vec::new();
                for item in *items {
                    let key = match item.key {
                        ObjectKey::Ident(tok) | ObjectKey::String(tok) => self.token_text(tok),
                    };
                    let value = self.emit_expr(item.value)?;
                    entries.push(format!("{}: {}", json_string(&key), value));
                }
                Ok(format!("{{{}}}", entries.join(", ")))
            }
            Expr::JsxElement {
                name,
                attributes,
                children,
                ..
            } => self.emit_jsx(Some(*name), attributes, children),
            Expr::JsxFragment { children, .. } => self.emit_jsx(None, &[], children),
            Expr::InterpolatedString { parts, .. } => {
                let mut pieces = Vec::new();
                for part in *parts {
                    pieces.push(self.emit_expr(*part)?);
                }
                Ok(format!("({})", pieces.join(" + ")))
            }
            other => Err(format!("unsupported expression in subset emitter: {:?}", other)),
        }
    }

    fn emit_jsx(
        &mut self,
        name: Option<php_rs::parser::ast::Name<'_>>,
        attributes: &[php_rs::parser::ast::JsxAttribute<'_>],
        children: &[JsxChild<'_>],
    ) -> Result<String, String> {
        self.uses_jsx_runtime = true;

        let mut props = Vec::new();
        for attr in attributes {
            let key = self.token_text(attr.name);
            let value = if let Some(expr) = attr.value {
                self.emit_expr(expr)?
            } else {
                "true".to_string()
            };
            props.push(format!("{}: {}", json_string(&key), value));
        }

        let mut child_values = Vec::new();
        for child in children {
            match child {
                JsxChild::Text(span) => {
                    if let Some(text) = self.normalize_jsx_text(*span) {
                        child_values.push(json_string(&text));
                    }
                }
                JsxChild::Expr(expr) => child_values.push(self.emit_expr(*expr)?),
            }
        }

        if !child_values.is_empty() {
            if child_values.len() == 1 {
                props.push(format!("\"children\": {}", child_values[0]));
            } else {
                props.push(format!("\"children\": [{}]", child_values.join(", ")));
            }
        }

        let (tag_expr, component_like) = match name {
            Some(n) => {
                let raw = self.span_bytes(n.span);
                let trimmed = raw.strip_prefix(b"\\").unwrap_or(raw);
                let raw_text = String::from_utf8_lossy(trimmed).to_string();
                let last = raw_text.rsplit('\\').next().unwrap_or(raw_text.as_str());
                let is_component = last
                    .chars()
                    .next()
                    .map(|c| c.is_ascii_uppercase())
                    .unwrap_or(false);
                if is_component {
                    (last.to_string(), true)
                } else {
                    (json_string(last), false)
                }
            }
            None => (json_string("__fragment__"), false),
        };

        let props_expr = format!("{{{}}}", props.join(", "));
        let fn_name = if child_values.len() > 1 { "jsxs" } else { "jsx" };

        let _ = component_like;
        Ok(format!("{}({}, {})", fn_name, tag_expr, props_expr))
    }

    fn assignment_to_named_var(&mut self, expr: ExprId<'_>) -> Result<Option<(String, String)>, String> {
        if let Expr::Assign { var, expr, .. } = expr {
            if let Expr::Variable { name, .. } = *var {
                let js_name = self.span_name(*name);
                let rhs = self.emit_expr(*expr)?;
                return Ok(Some((js_name, rhs)));
            }
            return Err("subset emitter only supports assignment to simple variables".to_string());
        }
        Ok(None)
    }

    fn token_name(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        self.sanitize_name(self.token_text(tok).as_str())
    }

    fn span_name(&self, span: php_rs::parser::span::Span) -> String {
        let text = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        self.sanitize_name(&text)
    }

    fn sanitize_name(&self, raw: &str) -> String {
        let mut name = raw.trim().trim_start_matches('$').replace('\\', "_");
        if name.is_empty() {
            name = "_".to_string();
        }
        name
    }

    fn token_text(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        String::from_utf8_lossy(tok.text(self.source)).to_string()
    }

    fn span_bytes(&self, span: php_rs::parser::span::Span) -> &'a [u8] {
        &self.source[span.start..span.end]
    }

    fn encode_php_string_literal(&self, value: &[u8]) -> String {
        let mut bytes = value;
        if value.len() >= 2
            && ((value[0] == b'\'' && value[value.len() - 1] == b'\'')
                || (value[0] == b'"' && value[value.len() - 1] == b'"'))
        {
            bytes = &value[1..value.len() - 1];
        }
        json_string(&String::from_utf8_lossy(bytes))
    }

    fn normalize_jsx_text(&self, span: php_rs::parser::span::Span) -> Option<String> {
        let raw = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        if raw.chars().all(|c| c.is_whitespace()) {
            if raw.contains('\n') || raw.contains('\r') {
                None
            } else {
                Some(" ".to_string())
            }
        } else {
            Some(raw)
        }
    }

    fn push_scope(&mut self) {
        self.scopes.push(HashSet::new());
    }

    fn pop_scope(&mut self) {
        let _ = self.scopes.pop();
    }

    fn declare_in_scope(&mut self, name: &str) {
        if let Some(scope) = self.scopes.last_mut() {
            scope.insert(name.to_string());
        }
    }

    fn is_declared(&self, name: &str) -> bool {
        for scope in self.scopes.iter().rev() {
            if scope.contains(name) {
                return true;
            }
        }
        false
    }
}

fn json_string(input: &str) -> String {
    serde_json::to_string(input).unwrap_or_else(|_| "\"\"".to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use php_rs::parser::lexer::Lexer;
    use php_rs::parser::parser::{Parser, ParserMode};

    #[test]
    fn default_outdir_is_dist_js() {
        let path = resolve_output_path(None, Path::new("src/home.phpx")).expect("path");
        assert_eq!(path, PathBuf::from("dist/home.js"));
    }

    #[test]
    fn explicit_out_is_used() {
        let path =
            resolve_output_path(Some("build/out.js".to_string()), Path::new("src/home.phpx"))
                .expect("path");
        assert_eq!(path, PathBuf::from("build/out.js"));
    }

    #[test]
    fn emitted_js_contains_runtime_hook_for_fallback() {
        let js = emit_js_scaffold_with_reason("echo 'hi'", "main.phpx", "x");
        assert!(js.contains("runPhpx"));
        assert!(js.contains("runtime.executePhpx"));
    }

    #[test]
    fn emits_subset_ast_for_jsx_component() {
        let source = r#"
function Hello($props: object) {
  return <span style=\"color:red\">Hello {$props.name}</span>
}
$view = <div><Hello name=\"world\" /></div>
"#;
        let arena = Bump::new();
        let mut parser = Parser::new_with_mode(Lexer::new(source.as_bytes()), &arena, ParserMode::Phpx);
        let program = parser.parse_program();
        let js = emit_js_from_ast(&program, source.as_bytes()).expect("subset emit");
        assert!(js.contains("phpxBuildMode = \"subset-ast\""));
        assert!(js.contains("import { jsx, jsxs } from 'component/core'"));
        assert!(js.contains("function Hello(props)"));
        assert!(js.contains("let view = jsx"));
    }
}
