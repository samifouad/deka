use bumpalo::Bump;
use core::{CommandSpec, Context, ParamSpec, Registry};
use modules_php::compiler_api::compile_phpx;
use modules_php::validation::format_multiple_errors;
use std::fs;
use std::path::{Path, PathBuf};

const COMMAND: CommandSpec = CommandSpec {
    name: "build",
    category: "project",
    summary: "build a PHPX file into a JavaScript module scaffold",
    aliases: &[],
    subcommands: &[],
    handler: cmd,
};

pub fn register(registry: &mut Registry) {
    registry.add_command(COMMAND);
    registry.add_param(ParamSpec {
        name: "--out",
        description: "output JavaScript file path",
    });
}

pub fn cmd(context: &Context) {
    if let Err(err) = run(context) {
        stdio::error("build", &err);
    }
}

fn run(context: &Context) -> Result<(), String> {
    let input = context
        .args
        .positionals
        .first()
        .ok_or_else(|| "usage: deka build <input.phpx> [--out dist/file.js]".to_string())?;

    if !input.ends_with(".phpx") {
        return Err(format!(
            "build currently supports .phpx input only; got '{}'",
            input
        ));
    }

    let input_path = PathBuf::from(input);
    let source = fs::read_to_string(&input_path)
        .map_err(|err| format!("failed to read {}: {}", input_path.display(), err))?;

    // Reuse the real PHPX compiler validation pipeline so emitted JS respects
    // current language rules before we write any artifact.
    let arena = Bump::new();
    let result = compile_phpx(&source, input, &arena);
    if !result.errors.is_empty() {
        let formatted = format_multiple_errors(&source, input, &result.errors, &result.warnings);
        return Err(formatted);
    }

    let output_path = resolve_output_path(output_arg(context), &input_path)?;
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)
            .map_err(|err| format!("failed to create {}: {}", parent.display(), err))?;
    }

    let js = emit_js_module(&source, input);
    fs::write(&output_path, js)
        .map_err(|err| format!("failed to write {}: {}", output_path.display(), err))?;

    stdio::success(&format!(
        "built {} -> {}",
        input_path.display(),
        output_path.display()
    ));
    Ok(())
}

fn output_arg(context: &Context) -> Option<String> {
    context
        .args
        .params
        .get("--out")
        .or_else(|| context.args.params.get("-o"))
        .or_else(|| context.args.params.get("--outdir"))
        .cloned()
}

fn resolve_output_path(out: Option<String>, input_path: &Path) -> Result<PathBuf, String> {
    if let Some(out) = out {
        return Ok(PathBuf::from(out));
    }

    let stem = input_path
        .file_stem()
        .and_then(|v| v.to_str())
        .ok_or_else(|| format!("invalid input filename: {}", input_path.display()))?;

    Ok(PathBuf::from("dist").join(format!("{}.js", stem)))
}

fn emit_js_module(source: &str, file_path: &str) -> String {
    let escaped = serde_json::to_string(source).unwrap_or_else(|_| "\"\"".to_string());
    let escaped_path =
        serde_json::to_string(file_path).unwrap_or_else(|_| "\"unknown.phpx\"".to_string());

    format!(
        "// Generated by deka build. Do not edit manually.\n\
// Source: {file_path}\n\
// Note: Minimal PHPX->JS scaffold for runtime-hosted execution.\n\
\n\
export const phpxSource = {escaped};\n\
export const phpxFile = {escaped_path};\n\
\n\
export async function runPhpx(runtime, props = {{}}) {{\n\
  if (!runtime || typeof runtime.executePhpx !== 'function') {{\n\
    throw new Error('runtime.executePhpx(source, file, props) is required');\n\
  }}\n\
  return await runtime.executePhpx(phpxSource, phpxFile, props);\n\
}}\n",
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn default_outdir_is_dist_js() {
        let path = resolve_output_path(None, Path::new("src/home.phpx")).expect("path");
        assert_eq!(path, PathBuf::from("dist/home.js"));
    }

    #[test]
    fn explicit_out_is_used() {
        let path =
            resolve_output_path(Some("build/out.js".to_string()), Path::new("src/home.phpx"))
                .expect("path");
        assert_eq!(path, PathBuf::from("build/out.js"));
    }

    #[test]
    fn emitted_js_contains_runtime_hook() {
        let js = emit_js_module("echo 'hi'", "main.phpx");
        assert!(js.contains("runPhpx"));
        assert!(js.contains("runtime.executePhpx"));
    }
}
