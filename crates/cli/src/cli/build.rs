use bumpalo::Bump;
use core::{CommandSpec, Context, ParamSpec, Registry};
use modules_php::compiler_api::compile_phpx;
use modules_php::validation::format_multiple_errors;
use php_rs::parser::ast::{
    BinaryOp, Expr, ExprId, JsxChild, ObjectKey, Program, Stmt, StmtId, UnaryOp,
};
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};

const COMMAND: CommandSpec = CommandSpec {
    name: "build",
    category: "project",
    summary: "build a PHPX file into a JavaScript module scaffold",
    aliases: &[],
    subcommands: &[],
    handler: cmd,
};

pub fn register(registry: &mut Registry) {
    registry.add_command(COMMAND);
    registry.add_param(ParamSpec {
        name: "--out",
        description: "output JavaScript file path",
    });
}

pub fn cmd(context: &Context) {
    if let Err(err) = run(context) {
        stdio::error("build", &err);
    }
}

fn run(context: &Context) -> Result<(), String> {
    let input = context
        .args
        .positionals
        .first()
        .ok_or_else(|| "usage: deka build <input.phpx> [--out dist/file.js]".to_string())?;

    if !input.ends_with(".phpx") {
        return Err(format!(
            "build currently supports .phpx input only; got '{}'",
            input
        ));
    }

    let input_path = PathBuf::from(input);
    let source = fs::read_to_string(&input_path)
        .map_err(|err| format!("failed to read {}: {}", input_path.display(), err))?;

    // Reuse strict PHPX validation before writing any build artifact.
    let arena = Bump::new();
    let result = compile_phpx(&source, input, &arena);
    if !result.errors.is_empty() {
        let formatted = format_multiple_errors(&source, input, &result.errors, &result.warnings);
        return Err(formatted);
    }

    let output_path = resolve_output_path(output_arg(context), &input_path)?;
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)
            .map_err(|err| format!("failed to create {}: {}", parent.display(), err))?;
    }

    let meta = parse_source_module_meta(&source);
    let js = if let Some(program) = result.ast {
        match emit_js_from_ast(&program, source.as_bytes(), meta) {
            Ok(emitted) => emitted,
            Err(reason) => emit_js_scaffold_with_reason(&source, input, &reason),
        }
    } else {
        emit_js_scaffold_with_reason(&source, input, "no AST available after validation")
    };

    fs::write(&output_path, js)
        .map_err(|err| format!("failed to write {}: {}", output_path.display(), err))?;

    stdio::success(&format!(
        "built {} -> {}",
        input_path.display(),
        output_path.display()
    ));
    Ok(())
}

fn output_arg(context: &Context) -> Option<String> {
    context
        .args
        .params
        .get("--out")
        .or_else(|| context.args.params.get("-o"))
        .or_else(|| context.args.params.get("--outdir"))
        .cloned()
}

fn resolve_output_path(out: Option<String>, input_path: &Path) -> Result<PathBuf, String> {
    if let Some(out) = out {
        return Ok(PathBuf::from(out));
    }

    let stem = input_path
        .file_stem()
        .and_then(|v| v.to_str())
        .ok_or_else(|| format!("invalid input filename: {}", input_path.display()))?;

    Ok(PathBuf::from("dist").join(format!("{}.js", stem)))
}

fn emit_js_from_ast(
    program: &Program<'_>,
    source: &[u8],
    meta: SourceModuleMeta,
) -> Result<String, String> {
    let mut emitter = JsSubsetEmitter::new(source, meta);
    emitter.emit_program(program)?;
    Ok(emitter.finish())
}

fn emit_js_scaffold_with_reason(source: &str, file_path: &str, reason: &str) -> String {
    let escaped = serde_json::to_string(source).unwrap_or_else(|_| "\"\"".to_string());
    let escaped_path =
        serde_json::to_string(file_path).unwrap_or_else(|_| "\"unknown.phpx\"".to_string());
    let escaped_reason =
        serde_json::to_string(reason).unwrap_or_else(|_| "\"unknown\"".to_string());

    format!(
        "// Generated by deka build. Do not edit manually.\n\
// Source: {file_path}\n\
// Fallback scaffold used because subset emitter could not lower this file.\n\
export const phpxBuildMode = \"scaffold\";\n\
export const phpxBuildReason = {escaped_reason};\n\
export const phpxSource = {escaped};\n\
export const phpxFile = {escaped_path};\n\
\n\
export async function runPhpx(runtime, props = {{}}) {{\n\
  if (!runtime || typeof runtime.executePhpx !== 'function') {{\n\
    throw new Error('runtime.executePhpx(source, file, props) is required');\n\
  }}\n\
  return await runtime.executePhpx(phpxSource, phpxFile, props);\n\
}}\n",
    )
}

#[derive(Debug, Clone)]
struct ImportSpec {
    imported: String,
    local: String,
}

#[derive(Debug, Clone)]
struct ImportDecl {
    from: String,
    specs: Vec<ImportSpec>,
}

#[derive(Debug, Clone)]
struct SourceModuleMeta {
    imports: Vec<ImportDecl>,
    exported_functions: HashSet<String>,
    export_specs: Vec<ImportSpec>,
}

impl SourceModuleMeta {
    fn empty() -> Self {
        Self {
            imports: Vec::new(),
            exported_functions: HashSet::new(),
            export_specs: Vec::new(),
        }
    }
}

fn parse_source_module_meta(source: &str) -> SourceModuleMeta {
    let mut meta = SourceModuleMeta::empty();
    let lines: Vec<&str> = source.lines().collect();
    let (start, end) = frontmatter_range(&lines).unwrap_or((0, lines.len()));

    for line in &lines[start..end] {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("//") {
            continue;
        }

        if let Some(decl) = parse_import_line(trimmed) {
            meta.imports.push(decl);
            continue;
        }

        if let Some(name) = parse_export_function_line(trimmed) {
            meta.exported_functions.insert(name);
            continue;
        }

        if let Some(specs) = parse_export_specs_line(trimmed) {
            meta.export_specs.extend(specs);
        }
    }

    meta
}

fn frontmatter_range(lines: &[&str]) -> Option<(usize, usize)> {
    let mut first = None;
    let mut second = None;
    for (idx, line) in lines.iter().enumerate() {
        if line.trim() == "---" {
            if first.is_none() {
                first = Some(idx);
            } else {
                second = Some(idx);
                break;
            }
        }
    }
    match (first, second) {
        (Some(a), Some(b)) if b > a => Some((a + 1, b)),
        _ => None,
    }
}

fn parse_import_line(line: &str) -> Option<ImportDecl> {
    let trimmed = line.trim_end_matches(';').trim();
    if !trimmed.starts_with("import ") {
        return None;
    }
    let open = trimmed.find('{')?;
    let close = trimmed[open..].find('}')? + open;
    let from_pos = trimmed[close + 1..].find("from")? + close + 1;

    let inside = trimmed[open + 1..close].trim();
    let from_part = trimmed[from_pos + 4..].trim();
    let module = unquote(from_part)?;

    let mut specs = Vec::new();
    for chunk in inside.split(',') {
        let part = chunk.trim();
        if part.is_empty() {
            continue;
        }
        if let Some(as_pos) = part.find(" as ") {
            let imported = part[..as_pos].trim();
            let local = part[as_pos + 4..].trim();
            if !imported.is_empty() && !local.is_empty() {
                specs.push(ImportSpec {
                    imported: imported.to_string(),
                    local: local.to_string(),
                });
            }
        } else {
            specs.push(ImportSpec {
                imported: part.to_string(),
                local: part.to_string(),
            });
        }
    }

    if specs.is_empty() {
        return None;
    }

    Some(ImportDecl {
        from: module.to_string(),
        specs,
    })
}

fn parse_export_function_line(line: &str) -> Option<String> {
    let trimmed = line.trim_start();
    if !trimmed.starts_with("export function ") {
        return None;
    }
    let rest = &trimmed[16..];
    let name = rest.split('(').next()?.trim();
    if name.is_empty() {
        return None;
    }
    Some(name.to_string())
}

fn parse_export_specs_line(line: &str) -> Option<Vec<ImportSpec>> {
    let trimmed = line.trim_end_matches(';').trim();
    if !trimmed.starts_with("export {") || !trimmed.ends_with('}') {
        return None;
    }
    let inner = &trimmed[8..trimmed.len() - 1];
    let mut specs = Vec::new();
    for chunk in inner.split(',') {
        let part = chunk.trim();
        if part.is_empty() {
            continue;
        }
        if let Some(as_pos) = part.find(" as ") {
            let local = part[..as_pos].trim();
            let exported = part[as_pos + 4..].trim();
            if !local.is_empty() && !exported.is_empty() {
                specs.push(ImportSpec {
                    imported: exported.to_string(),
                    local: local.to_string(),
                });
            }
        } else {
            specs.push(ImportSpec {
                imported: part.to_string(),
                local: part.to_string(),
            });
        }
    }
    Some(specs)
}

fn unquote(input: &str) -> Option<&str> {
    let s = input.trim();
    if s.len() < 2 {
        return None;
    }
    let first = s.as_bytes()[0] as char;
    let last = s.as_bytes()[s.len() - 1] as char;
    if (first == '\'' && last == '\'') || (first == '"' && last == '"') {
        Some(&s[1..s.len() - 1])
    } else {
        None
    }
}

struct JsSubsetEmitter<'a> {
    source: &'a [u8],
    body: String,
    uses_jsx_runtime: bool,
    scopes: Vec<HashSet<String>>,
    meta: SourceModuleMeta,
}

impl<'a> JsSubsetEmitter<'a> {
    fn new(source: &'a [u8], meta: SourceModuleMeta) -> Self {
        Self {
            source,
            body: String::new(),
            uses_jsx_runtime: false,
            scopes: vec![HashSet::new()],
            meta,
        }
    }

    fn finish(self) -> String {
        let mut out = String::new();
        out.push_str("// Generated by deka build. Do not edit manually.\n");
        out.push_str("export const phpxBuildMode = \"subset-ast\";\n\n");

        let mut imports = self.meta.imports.clone();
        if self.uses_jsx_runtime {
            add_or_merge_import(
                &mut imports,
                "component/core",
                vec![
                    ImportSpec {
                        imported: "jsx".to_string(),
                        local: "jsx".to_string(),
                    },
                    ImportSpec {
                        imported: "jsxs".to_string(),
                        local: "jsxs".to_string(),
                    },
                ],
            );
        }

        for decl in &imports {
            out.push_str("import { ");
            for (idx, spec) in decl.specs.iter().enumerate() {
                if idx > 0 {
                    out.push_str(", ");
                }
                if spec.imported == spec.local {
                    out.push_str(&spec.local);
                } else {
                    out.push_str(&format!("{} as {}", spec.imported, spec.local));
                }
            }
            out.push_str(&format!(" }} from '{}';\n", decl.from));
        }

        if !imports.is_empty() {
            out.push('\n');
        }

        out.push_str(&self.body);

        if !self.meta.export_specs.is_empty() {
            out.push('\n');
            out.push_str("export { ");
            for (idx, spec) in self.meta.export_specs.iter().enumerate() {
                if idx > 0 {
                    out.push_str(", ");
                }
                if spec.imported == spec.local {
                    out.push_str(&spec.local);
                } else {
                    out.push_str(&format!("{} as {}", spec.local, spec.imported));
                }
            }
            out.push_str(" };\n");
        }

        out
    }

    fn emit_program(&mut self, program: &Program<'_>) -> Result<(), String> {
        for stmt in program.statements {
            self.emit_stmt(*stmt)?;
        }
        Ok(())
    }

    fn emit_stmt(&mut self, stmt: StmtId<'_>) -> Result<(), String> {
        match stmt {
            Stmt::Function {
                name, params, body, ..
            } => {
                let fn_name = self.token_name(name);
                let js_params = params
                    .iter()
                    .map(|p| self.token_name(p.name))
                    .collect::<Vec<_>>()
                    .join(", ");

                let exported = self.scopes.len() == 1 && self.meta.exported_functions.contains(&fn_name);
                if exported {
                    self.body
                        .push_str(&format!("export function {}({}) {{\n", fn_name, js_params));
                } else {
                    self.body
                        .push_str(&format!("function {}({}) {{\n", fn_name, js_params));
                }

                self.push_scope();
                for p in *params {
                    self.declare_in_scope(&self.token_name(p.name));
                }
                for inner in *body {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();

                self.body.push_str("}\n\n");
                Ok(())
            }
            Stmt::If {
                condition,
                then_block,
                else_block,
                ..
            } => {
                let cond = self.emit_expr(*condition)?;
                self.body.push_str(&format!("if ({}) {{\n", cond));
                self.push_scope();
                for inner in *then_block {
                    self.emit_stmt(*inner)?;
                }
                self.pop_scope();
                self.body.push('}');

                if let Some(else_stmts) = else_block {
                    self.body.push_str(" else {\n");
                    self.push_scope();
                    for inner in *else_stmts {
                        self.emit_stmt(*inner)?;
                    }
                    self.pop_scope();
                    self.body.push('}');
                }
                self.body.push('\n');
                Ok(())
            }
            Stmt::Return { expr, .. } => {
                if let Some(expr) = expr {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("return {};\n", value));
                } else {
                    self.body.push_str("return;\n");
                }
                Ok(())
            }
            Stmt::Echo { exprs, .. } => {
                for expr in *exprs {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("console.log({});\n", value));
                }
                Ok(())
            }
            Stmt::Expression { expr, .. } => {
                if let Some((name, rhs)) = self.assignment_to_named_var(*expr)? {
                    if !self.is_declared(&name) {
                        self.declare_in_scope(&name);
                        self.body.push_str(&format!("let {} = {};\n", name, rhs));
                    } else {
                        self.body.push_str(&format!("{} = {};\n", name, rhs));
                    }
                } else {
                    let value = self.emit_expr(*expr)?;
                    self.body.push_str(&format!("{};\n", value));
                }
                Ok(())
            }
            Stmt::Nop { .. } => Ok(()),
            other => Err(format!("unsupported statement in subset emitter: {:?}", other)),
        }
    }

    fn emit_expr(&mut self, expr: ExprId<'_>) -> Result<String, String> {
        match expr {
            Expr::Variable { name, .. } => Ok(self.span_name(*name)),
            Expr::Integer { value, .. } | Expr::Float { value, .. } => {
                Ok(String::from_utf8_lossy(value).to_string())
            }
            Expr::Boolean { value, .. } => Ok(if *value { "true" } else { "false" }.to_string()),
            Expr::Null { .. } => Ok("null".to_string()),
            Expr::String { value, .. } => Ok(self.encode_php_string_literal(value)),
            Expr::Unary { op, expr, .. } => {
                let value = self.emit_expr(*expr)?;
                let js_op = match op {
                    UnaryOp::Plus => "+",
                    UnaryOp::Minus => "-",
                    UnaryOp::Not => "!",
                    UnaryOp::BitNot => "~",
                    _ => {
                        return Err(format!("unsupported unary operator in subset emitter: {:?}", op));
                    }
                };
                Ok(format!("({}{})", js_op, value))
            }
            Expr::Binary {
                left, op, right, ..
            } => {
                let lhs = self.emit_expr(*left)?;
                let rhs = self.emit_expr(*right)?;
                let js_op = match op {
                    BinaryOp::Plus => "+",
                    BinaryOp::Minus => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Pow => "**",
                    BinaryOp::Concat => "+",
                    BinaryOp::Eq | BinaryOp::EqEq => "==",
                    BinaryOp::EqEqEq => "===",
                    BinaryOp::NotEq => "!=",
                    BinaryOp::NotEqEq => "!==",
                    BinaryOp::Lt => "<",
                    BinaryOp::LtEq => "<=",
                    BinaryOp::Gt => ">",
                    BinaryOp::GtEq => ">=",
                    BinaryOp::And | BinaryOp::LogicalAnd => "&&",
                    BinaryOp::Or | BinaryOp::LogicalOr => "||",
                    _ => {
                        return Err(format!("unsupported binary operator in subset emitter: {:?}", op));
                    }
                };
                Ok(format!("({} {} {})", lhs, js_op, rhs))
            }
            Expr::Call { func, args, .. } => {
                let callee = self.emit_expr(*func)?;
                let mut rendered = Vec::with_capacity(args.len());
                for arg in *args {
                    if arg.name.is_some() || arg.unpack {
                        return Err("named/unpack call arguments are not supported in subset emitter"
                            .to_string());
                    }
                    rendered.push(self.emit_expr(arg.value)?);
                }
                Ok(format!("{}({})", callee, rendered.join(", ")))
            }
            Expr::Assign { var, expr, .. } => {
                if let Expr::Variable { name, .. } = *var {
                    let js_name = self.span_name(*name);
                    let rhs = self.emit_expr(*expr)?;
                    Ok(format!("({} = {})", js_name, rhs))
                } else {
                    Err("subset emitter only supports assignment to simple variables".to_string())
                }
            }
            Expr::PropertyFetch {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                match *property {
                    Expr::Variable { name, .. } => {
                        let prop = self.span_name(*name);
                        Ok(format!("{}.{}", target_js, prop))
                    }
                    _ => Err("dynamic property access is not supported in subset emitter".to_string()),
                }
            }
            Expr::DotAccess {
                target, property, ..
            } => {
                let target_js = self.emit_expr(*target)?;
                let prop = self.token_text(property);
                Ok(format!("{}.{}", target_js, prop))
            }
            Expr::Array { items, .. } => {
                let mut values = Vec::new();
                for item in *items {
                    if item.key.is_some() || item.by_ref || item.unpack {
                        return Err("array item keys/by-ref/unpack are not supported in subset emitter"
                            .to_string());
                    }
                    values.push(self.emit_expr(item.value)?);
                }
                Ok(format!("[{}]", values.join(", ")))
            }
            Expr::ObjectLiteral { items, .. } => {
                let mut entries = Vec::new();
                for item in *items {
                    let key = match item.key {
                        ObjectKey::Ident(tok) | ObjectKey::String(tok) => self.token_text(tok),
                    };
                    let value = self.emit_expr(item.value)?;
                    entries.push(format!("{}: {}", json_string(&key), value));
                }
                Ok(format!("{{{}}}", entries.join(", ")))
            }
            Expr::JsxElement {
                name,
                attributes,
                children,
                ..
            } => self.emit_jsx(Some(*name), attributes, children),
            Expr::JsxFragment { children, .. } => self.emit_jsx(None, &[], children),
            Expr::InterpolatedString { parts, .. } => {
                let mut pieces = Vec::new();
                for part in *parts {
                    pieces.push(self.emit_expr(*part)?);
                }
                Ok(format!("({})", pieces.join(" + ")))
            }
            other => Err(format!("unsupported expression in subset emitter: {:?}", other)),
        }
    }

    fn emit_jsx(
        &mut self,
        name: Option<php_rs::parser::ast::Name<'_>>,
        attributes: &[php_rs::parser::ast::JsxAttribute<'_>],
        children: &[JsxChild<'_>],
    ) -> Result<String, String> {
        self.uses_jsx_runtime = true;

        let mut props = Vec::new();
        for attr in attributes {
            let key = self.token_text(attr.name);
            let value = if let Some(expr) = attr.value {
                self.emit_expr(expr)?
            } else {
                "true".to_string()
            };
            props.push(format!("{}: {}", json_string(&key), value));
        }

        let mut child_values = Vec::new();
        for child in children {
            match child {
                JsxChild::Text(span) => {
                    if let Some(text) = self.normalize_jsx_text(*span) {
                        child_values.push(json_string(&text));
                    }
                }
                JsxChild::Expr(expr) => child_values.push(self.emit_expr(*expr)?),
            }
        }

        if !child_values.is_empty() {
            if child_values.len() == 1 {
                props.push(format!("\"children\": {}", child_values[0]));
            } else {
                props.push(format!("\"children\": [{}]", child_values.join(", ")));
            }
        }

        let tag_expr = match name {
            Some(n) => {
                let raw = self.span_bytes(n.span);
                let trimmed = raw.strip_prefix(b"\\").unwrap_or(raw);
                let raw_text = String::from_utf8_lossy(trimmed).to_string();
                let last = raw_text.rsplit('\\').next().unwrap_or(raw_text.as_str());
                let is_component = last
                    .chars()
                    .next()
                    .map(|c| c.is_ascii_uppercase())
                    .unwrap_or(false);
                if is_component {
                    last.to_string()
                } else {
                    json_string(last)
                }
            }
            None => json_string("__fragment__"),
        };

        let props_expr = format!("{{{}}}", props.join(", "));
        let fn_name = if child_values.len() > 1 { "jsxs" } else { "jsx" };

        Ok(format!("{}({}, {})", fn_name, tag_expr, props_expr))
    }

    fn assignment_to_named_var(&mut self, expr: ExprId<'_>) -> Result<Option<(String, String)>, String> {
        if let Expr::Assign { var, expr, .. } = expr {
            if let Expr::Variable { name, .. } = *var {
                let js_name = self.span_name(*name);
                let rhs = self.emit_expr(*expr)?;
                return Ok(Some((js_name, rhs)));
            }
            return Err("subset emitter only supports assignment to simple variables".to_string());
        }
        Ok(None)
    }

    fn token_name(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        self.sanitize_name(self.token_text(tok).as_str())
    }

    fn span_name(&self, span: php_rs::parser::span::Span) -> String {
        let text = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        self.sanitize_name(&text)
    }

    fn sanitize_name(&self, raw: &str) -> String {
        let mut name = raw.trim().trim_start_matches('$').replace('\\', "_");
        if name.is_empty() {
            name = "_".to_string();
        }
        name
    }

    fn token_text(&self, tok: &php_rs::parser::lexer::token::Token) -> String {
        String::from_utf8_lossy(tok.text(self.source)).to_string()
    }

    fn span_bytes(&self, span: php_rs::parser::span::Span) -> &'a [u8] {
        &self.source[span.start..span.end]
    }

    fn encode_php_string_literal(&self, value: &[u8]) -> String {
        let mut bytes = value;
        if value.len() >= 2
            && ((value[0] == b'\'' && value[value.len() - 1] == b'\'')
                || (value[0] == b'"' && value[value.len() - 1] == b'"'))
        {
            bytes = &value[1..value.len() - 1];
        }
        json_string(&String::from_utf8_lossy(bytes))
    }

    fn normalize_jsx_text(&self, span: php_rs::parser::span::Span) -> Option<String> {
        let raw = String::from_utf8_lossy(self.span_bytes(span)).to_string();
        if raw.chars().all(|c| c.is_whitespace()) {
            if raw.contains('\n') || raw.contains('\r') {
                None
            } else {
                Some(" ".to_string())
            }
        } else {
            Some(raw)
        }
    }

    fn push_scope(&mut self) {
        self.scopes.push(HashSet::new());
    }

    fn pop_scope(&mut self) {
        let _ = self.scopes.pop();
    }

    fn declare_in_scope(&mut self, name: &str) {
        if let Some(scope) = self.scopes.last_mut() {
            scope.insert(name.to_string());
        }
    }

    fn is_declared(&self, name: &str) -> bool {
        for scope in self.scopes.iter().rev() {
            if scope.contains(name) {
                return true;
            }
        }
        false
    }
}

fn add_or_merge_import(imports: &mut Vec<ImportDecl>, from: &str, specs: Vec<ImportSpec>) {
    if let Some(existing) = imports.iter_mut().find(|decl| decl.from == from) {
        for spec in specs {
            if !existing
                .specs
                .iter()
                .any(|item| item.imported == spec.imported && item.local == spec.local)
            {
                existing.specs.push(spec);
            }
        }
        return;
    }
    imports.push(ImportDecl {
        from: from.to_string(),
        specs,
    });
}

fn json_string(input: &str) -> String {
    serde_json::to_string(input).unwrap_or_else(|_| "\"\"".to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use php_rs::parser::lexer::Lexer;
    use php_rs::parser::parser::{Parser, ParserMode};

    #[test]
    fn default_outdir_is_dist_js() {
        let path = resolve_output_path(None, Path::new("src/home.phpx")).expect("path");
        assert_eq!(path, PathBuf::from("dist/home.js"));
    }

    #[test]
    fn explicit_out_is_used() {
        let path =
            resolve_output_path(Some("build/out.js".to_string()), Path::new("src/home.phpx"))
                .expect("path");
        assert_eq!(path, PathBuf::from("build/out.js"));
    }

    #[test]
    fn parses_import_and_export_meta() {
        let source = r#"
---
import { jsx, jsxs as pack } from 'component/core'
export function Card($props: object) {
  return <div>{$props.title}</div>
}
export { Card as Panel }
---
<div>ok</div>
"#;
        let meta = parse_source_module_meta(source);
        assert_eq!(meta.imports.len(), 1);
        assert!(meta.exported_functions.contains("Card"));
        assert_eq!(meta.export_specs.len(), 1);
        assert_eq!(meta.export_specs[0].local, "Card");
        assert_eq!(meta.export_specs[0].imported, "Panel");
    }

    #[test]
    fn emitted_js_contains_runtime_hook_for_fallback() {
        let js = emit_js_scaffold_with_reason("echo 'hi'", "main.phpx", "x");
        assert!(js.contains("runPhpx"));
        assert!(js.contains("runtime.executePhpx"));
    }

    #[test]
    fn emits_subset_ast_for_jsx_component() {
        let source = r#"
function Hello($props: object) {
  return <span style=\"color:red\">Hello {$props.name}</span>
}
$view = <div><Hello name=\"world\" /></div>
"#;
        let arena = Bump::new();
        let mut parser =
            Parser::new_with_mode(Lexer::new(source.as_bytes()), &arena, ParserMode::Phpx);
        let program = parser.parse_program();
        let js = emit_js_from_ast(&program, source.as_bytes(), SourceModuleMeta::empty())
            .expect("subset emit");
        assert!(js.contains("phpxBuildMode = \"subset-ast\""));
        assert!(js.contains("import { jsx, jsxs } from 'component/core'"));
        assert!(js.contains("function Hello(props)"));
        assert!(js.contains("let view = jsx"));
    }

    #[test]
    fn emits_if_and_unary() {
        let source = r#"
function Flag($props: object) {
  if (!$props.on) {
    return "off"
  }
  return "on"
}
"#;
        let arena = Bump::new();
        let mut parser =
            Parser::new_with_mode(Lexer::new(source.as_bytes()), &arena, ParserMode::Phpx);
        let program = parser.parse_program();
        let js = emit_js_from_ast(&program, source.as_bytes(), SourceModuleMeta::empty())
            .expect("subset emit");
        assert!(js.contains("if ((!props.on))"));
        assert!(js.contains("return \"off\""));
    }
}
