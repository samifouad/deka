// Generated by build.rs. Do not edit.
const baseOps = Deno.core.ops;
function formatOpArg(arg) {
    if (arg === null) return "null";
    if (arg === undefined) return "undefined";
    if (typeof arg === "string") return `string(${arg.length})`;
    if (typeof arg === "number") return `number(${arg})`;
    if (typeof arg === "boolean") return `bool(${arg})`;
    if (typeof arg === "bigint") return `bigint(${arg.toString()})`;
    if (ArrayBuffer.isView(arg)) {
        return `${arg.constructor.name}(${arg.byteLength})`;
    }
    if (arg instanceof ArrayBuffer) {
        return `ArrayBuffer(${arg.byteLength})`;
    }
    if (Array.isArray(arg)) return `Array(${arg.length})`;
    if (typeof arg === "object") return `object`;
    return typeof arg;
}
function shouldSkipOpLog(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE_FILTER) return false;
    if (name !== "op_read_module_source") return false;
    const first = args[0];
    if (typeof first !== "string") return false;
    if (first.endsWith("/package.json")) return true;
    if (first.endsWith("package.json")) return true;
    return false;
}
function logOpCall(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog(name, args)) return;
    const writer = baseOps.op_stdout_write;
    if (!writer) return;
    const summary = args.map(formatOpArg).join(", ");
    writer(new TextEncoder().encode(`[op] ${name} ${summary}\n`));
}
function logOpReturn(name, startedAt, args, value) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog(name, args)) {
        return;
    }
    const writer = baseOps.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const summary = formatOpArg(value);
    writer(new TextEncoder().encode(`[op] ${name} -> ${summary} (${elapsed}ms)\n`));
}
function logOpError(name, startedAt, args, error) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog(name, args)) {
        return;
    }
    const writer = baseOps.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const message = error?.message || String(error);
    writer(new TextEncoder().encode(`[op] ${name} ! ${message} (${elapsed}ms)\n`));
}
function wrapOps(ops) {
    const wrapped = {};
    for (const [name, fn] of Object.entries(ops)){
        if (typeof fn !== "function") continue;
        if (name === "op_stdout_write" || name === "op_stderr_write") {
            wrapped[name] = fn;
            continue;
        }
        wrapped[name] = (...args)=>{
            logOpCall(name, args);
            const startedAt = Date.now();
            try {
                const result = fn(...args);
                if (result && typeof result.then === "function") {
                    return result.then((value)=>{
                        logOpReturn(name, startedAt, args, value);
                        return value;
                    }).catch((error)=>{
                        logOpError(name, startedAt, args, error);
                        throw error;
                    });
                }
                logOpReturn(name, startedAt, args, result);
                return result;
            } catch (error) {
                logOpError(name, startedAt, args, error);
                throw error;
            }
        };
    }
    return wrapped;
}
const ops = globalThis.process?.env?.DEKA_VERBOSE ? wrapOps(baseOps) : baseOps;
globalThis.__dekaOps = ops;
const { op_read_handler_source, op_read_module_source, op_read_env, op_stdout_write, op_stderr_write, op_execute_isolate, op_transform_module, op_bundle_browser, op_bundle_browser_assets, op_bundle_css, op_transform_css, op_tailwind_process, op_read_file, op_fs_exists, op_fs_stat, op_fs_read_dir, op_fs_mkdir, op_fs_remove_file, op_fs_append, op_fs_append_bytes, op_fs_open, op_fs_close, op_fs_read, op_fs_write, op_fs_copy_file, op_zlib_gzip, op_write_file, op_write_file_base64, op_introspect_stats, op_introspect_top, op_introspect_workers, op_introspect_isolate, op_introspect_kill_isolate, op_introspect_requests, op_introspect_evict, op_set_introspect_profiling, op_ws_send, op_ws_send_binary, op_ws_close, op_blob_create, op_blob_get, op_blob_size, op_blob_type, op_blob_slice, op_blob_drop, op_stream_create, op_stream_enqueue, op_stream_close, op_stream_read, op_stream_drop, op_crypto_random, op_crypto_digest, op_crypto_hmac, op_crypto_pbkdf2, op_crypto_aes_gcm_encrypt, op_crypto_aes_gcm_decrypt, op_crypto_key_info, op_crypto_key_from_secret, op_crypto_key_from_pem, op_crypto_key_from_der, op_crypto_key_from_jwk, op_crypto_key_export_pem, op_crypto_key_export_der, op_crypto_key_export_jwk, op_crypto_key_public, op_crypto_key_equals, op_crypto_sign, op_crypto_verify, op_crypto_generate_keypair, op_crypto_get_curves, op_crypto_ecdh_new, op_crypto_ecdh_generate, op_crypto_ecdh_get_public, op_crypto_ecdh_get_private, op_crypto_ecdh_set_private, op_crypto_ecdh_compute_secret, op_crypto_ecdh_convert, op_url_parse, op_napi_open, op_http_fetch, op_process_spawn, op_process_spawn_sync, op_process_read_stdout, op_process_read_stderr, op_process_write_stdin, op_process_close_stdin, op_process_wait, op_process_kill, op_sleep, op_udp_bind, op_udp_send, op_udp_recv, op_udp_close, op_udp_local_addr, op_udp_peer_addr, op_udp_connect, op_udp_disconnect, op_udp_set_broadcast, op_udp_set_ttl, op_udp_set_multicast_ttl, op_udp_set_multicast_loop, op_udp_set_multicast_if, op_udp_join_multicast, op_udp_leave_multicast, op_udp_set_recv_buffer_size, op_udp_set_send_buffer_size, op_udp_get_recv_buffer_size, op_udp_get_send_buffer_size, op_dns_lookup, op_dns_reverse, op_tcp_listen, op_tcp_accept, op_tcp_connect, op_tcp_read, op_tcp_write, op_tcp_close, op_tcp_shutdown, op_tcp_local_addr, op_tcp_peer_addr, op_tcp_listener_addr, op_tcp_listener_close } = ops;
if (typeof globalThis.process === "undefined") {
    const env = op_read_env();
    let args = [];
    const rawArgs = env.DEKA_ARGS;
    if (typeof rawArgs === "string" && rawArgs.length > 0) {
        try {
            const parsed = JSON.parse(rawArgs);
            if (Array.isArray(parsed)) {
                args = parsed.map((value)=>String(value));
            }
        } catch  {
            args = [];
        }
    }
    const handlerPath = env.HANDLER_PATH || "";
    const argv0 = env.DEKA_BIN || "deka-runtime";
    const argv = handlerPath ? [
        argv0,
        handlerPath,
        ...args
    ] : [
        argv0,
        ...args
    ];
    const isTTY = env.TERM !== undefined && env.TERM !== "dumb";
    const stdoutWrite = (chunk, encoding, cb)=>{
        const op = globalThis.__dekaOps;
        if (op?.op_stdout_write) {
            op.op_stdout_write(new TextEncoder().encode(String(chunk)));
        }
        if (typeof encoding === "function") {
            encoding();
        } else if (typeof cb === "function") {
            cb();
        }
        return true;
    };
    const stderrWrite = (chunk, encoding, cb)=>{
        const op = globalThis.__dekaOps;
        if (op?.op_stderr_write) {
            op.op_stderr_write(new TextEncoder().encode(String(chunk)));
        }
        if (typeof encoding === "function") {
            encoding();
        } else if (typeof cb === "function") {
            cb();
        }
        return true;
    };
    const createEmitter = ()=>{
        const emitterListeners = new Map();
        const onEmitter = (event, listener)=>{
            const bucket = emitterListeners.get(event) || new Set();
            bucket.add(listener);
            emitterListeners.set(event, bucket);
            return emitter;
        };
        const onceEmitter = (event, listener)=>{
            const wrapped = (...args)=>{
                offEmitter(event, wrapped);
                listener(...args);
            };
            return onEmitter(event, wrapped);
        };
        const offEmitter = (event, listener)=>{
            const bucket = emitterListeners.get(event);
            if (bucket) {
                bucket.delete(listener);
                if (bucket.size === 0) emitterListeners.delete(event);
            }
            return emitter;
        };
        const emitEmitter = (event, ...args)=>{
            const bucket = emitterListeners.get(event);
            if (!bucket) return false;
            for (const listener of Array.from(bucket)){
                try {
                    listener(...args);
                } catch  {}
            }
            return bucket.size > 0;
        };
        const emitter = {
            on: onEmitter,
            once: onceEmitter,
            off: offEmitter,
            emit: emitEmitter
        };
        return emitter;
    };
    const writeAnsi = (text)=>{
        const op = globalThis.__dekaOps;
        if (op?.op_stdout_write) {
            op.op_stdout_write(new TextEncoder().encode(text));
        }
    };
    const writeAnsiErr = (text)=>{
        const op = globalThis.__dekaOps;
        if (op?.op_stderr_write) {
            op.op_stderr_write(new TextEncoder().encode(text));
        }
    };
    const cursorTo = (x, y, cb, writer)=>{
        const out = writer || writeAnsi;
        if (typeof y === "number") {
            out(`\x1b[${y + 1};${x + 1}H`);
        } else {
            out(`\x1b[${x + 1}G`);
        }
        if (cb) cb();
        return true;
    };
    const moveCursor = (dx, dy, cb, writer)=>{
        const out = writer || writeAnsi;
        if (dy < 0) out(`\x1b[${-dy}A`);
        if (dy > 0) out(`\x1b[${dy}B`);
        if (dx > 0) out(`\x1b[${dx}C`);
        if (dx < 0) out(`\x1b[${-dx}D`);
        if (cb) cb();
        return true;
    };
    const clearLine = (_dir, cb, writer)=>{
        const out = writer || writeAnsi;
        out("\x1b[2K");
        if (cb) cb();
        return true;
    };
    const stdout = {
        write: stdoutWrite,
        isTTY,
        columns: 80,
        rows: 24,
        clearLine: (dir, cb)=>clearLine(dir, cb, writeAnsi),
        cursorTo: (x, y, cb)=>cursorTo(x, y, cb, writeAnsi),
        moveCursor: (dx, dy, cb)=>moveCursor(dx, dy, cb, writeAnsi),
        getWindowSize: ()=>[
                80,
                24
            ],
        ...createEmitter()
    };
    const stderr = {
        write: stderrWrite,
        isTTY,
        columns: 80,
        rows: 24,
        clearLine: (dir, cb)=>clearLine(dir, cb, writeAnsiErr),
        cursorTo: (x, y, cb)=>cursorTo(x, y, cb, writeAnsiErr),
        moveCursor: (dx, dy, cb)=>moveCursor(dx, dy, cb, writeAnsiErr),
        getWindowSize: ()=>[
                80,
                24
            ],
        ...createEmitter()
    };
    const stdin = {
        isTTY,
        readable: true,
        ...createEmitter(),
        resume () {
            return stdin;
        },
        pause () {
            return stdin;
        },
        setEncoding () {
            return stdin;
        },
        pipe () {
            return stdin;
        }
    };
    const listeners = new Map();
    const on = (event, listener)=>{
        const bucket = listeners.get(event) || new Set();
        bucket.add(listener);
        listeners.set(event, bucket);
        return globalThis.process;
    };
    const once = (event, listener)=>{
        const wrapped = (...args)=>{
            off(event, wrapped);
            listener(...args);
        };
        return on(event, wrapped);
    };
    const off = (event, listener)=>{
        const bucket = listeners.get(event);
        if (bucket) {
            bucket.delete(listener);
            if (bucket.size === 0) listeners.delete(event);
        }
        return globalThis.process;
    };
    const emit = (event, ...args)=>{
        const bucket = listeners.get(event);
        if (!bucket) return false;
        for (const listener of Array.from(bucket)){
            try {
                listener(...args);
            } catch  {}
        }
        return bucket.size > 0;
    };
    const perf = globalThis.performance;
    const nowNs = ()=>{
        const ms = perf?.now ? perf.now() : Date.now();
        return BigInt(Math.floor(ms * 1_000_000));
    };
    const hrtime = (time)=>{
        let ns = nowNs();
        if (Array.isArray(time) && time.length >= 2) {
            const prev = BigInt(time[0]) * 1_000_000_000n + BigInt(time[1]);
            ns = ns - prev;
        }
        if (ns < 0n) ns = 0n;
        const sec = ns / 1_000_000_000n;
        const nano = ns % 1_000_000_000n;
        return [
            Number(sec),
            Number(nano)
        ];
    };
    hrtime.bigint = ()=>nowNs();
    globalThis.process = {
        env,
        argv,
        argv0,
        cwd: ()=>env.PWD || "/",
        versions: {
            deka: "0.1.0",
            node: "20.19.4"
        },
        version: "v20.19.4",
        platform: env.DENO_PLATFORM || env.DEKA_PLATFORM || "unknown",
        arch: env.DENO_ARCH || env.DEKA_ARCH || "unknown",
        execPath: env.DEKA_BIN || argv0,
        execArgv: [],
        stdout,
        stderr,
        stdin,
        dlopen: (module1, filename)=>{
            const op = globalThis.__dekaOps?.op_napi_open;
            if (typeof op !== "function") {
                throw new Error("N-API is not available in this runtime");
            }
            const createBuffer = globalThis.__dekaNapiCreateBuffer || ((data)=>{
                const BufferCtor = globalThis.Buffer;
                return BufferCtor ? BufferCtor.from(data) : data;
            });
            const reportError = globalThis.__dekaNapiReportError || ((error)=>{
                throw error;
            });
            const exports = op(filename, globalThis, createBuffer, reportError);
            if (module1 && typeof module1 === "object") {
                module1.exports = exports;
            }
            return exports;
        },
        hrtime,
        uptime: ()=>{
            if (perf?.now) return perf.now() / 1000;
            return Date.now() / 1000;
        },
        on,
        once,
        off,
        addListener: on,
        removeListener: off,
        emit,
        nextTick: (callback, ...args)=>{
            queueMicrotask(()=>callback(...args));
        },
        exit: (code = 0)=>{
            globalThis.__dekaExitCode = Number(code);
            globalThis.__dekaExitRequested = true;
            const op = globalThis.__dekaOps;
            if (op?.op_process_exit && Number(code) === 0) {
                op.op_process_exit(Number(code));
                return undefined;
            }
            if (Number(code) !== 0) {
                try {
                    const op = globalThis.__dekaOps;
                    const writeErr = (text)=>{
                        if (op?.op_stderr_write) {
                            op.op_stderr_write(new TextEncoder().encode(`${text}\n`));
                        }
                    };
                    const stack = new Error("process.exit").stack;
                    if (stack) {
                        writeErr(stack);
                    }
                    const last = globalThis.__dekaLastError;
                    if (last) {
                        try {
                            const names = Object.getOwnPropertyNames(last);
                            const proto = Object.prototype.toString.call(last);
                            writeErr(`[last-error] ${proto}`);
                            if (names.length > 0) {
                                const details = names.map((key)=>{
                                    let value;
                                    try {
                                        value = String(last[key]);
                                    } catch  {
                                        value = "[unreadable]";
                                    }
                                    return `${key}=${value}`;
                                }).join(" ");
                                writeErr(`[last-error] ${details}`);
                            }
                        } catch  {}
                    }
                } catch  {}
            }
            const err = new Error(`DekaExit:${code}`);
            err.code = code;
            throw err;
        }
    };
    if (typeof globalThis.addEventListener === "function") {
        globalThis.addEventListener("unhandledrejection", (event)=>{
            const reason = event?.reason;
            const message = reason?.message || String(reason || "");
            if (String(message).includes("DekaExit:")) {
                if (typeof event.preventDefault === "function") {
                    event.preventDefault();
                }
                return;
            }
            emit("unhandledRejection", event?.reason, event?.promise);
        });
        globalThis.addEventListener("error", (event)=>{
            const err = event?.error || event?.message;
            const message = err?.message || String(err || "");
            if (String(message).includes("DekaExit:")) {
                if (typeof event.preventDefault === "function") {
                    event.preventDefault();
                }
                return;
            }
            emit("uncaughtException", err);
        });
    }
    if (typeof globalThis.onerror === "undefined") {
        globalThis.onerror = (_message, _source, _line, _column, error)=>{
            const msg = error?.message || String(_message || "");
            if (String(msg).includes("DekaExit:")) {
                return true;
            }
            return false;
        };
    }
}
if (typeof globalThis.self === "undefined") {
    globalThis.self = globalThis;
}
if (typeof globalThis.global === "undefined") {
    globalThis.global = globalThis;
}
if (typeof globalThis.global === "undefined") {
    globalThis.global = globalThis;
}
const handlerPath = globalThis.process?.env?.HANDLER_PATH;
if (handlerPath && typeof globalThis.__filename === "undefined") {
    globalThis.__filename = handlerPath;
    const slash = handlerPath.lastIndexOf("/");
    globalThis.__dirname = slash >= 0 ? handlerPath.slice(0, slash) : ".";
}
if (typeof globalThis.exports === "undefined") {
    globalThis.exports = {};
}
if (typeof globalThis.module === "undefined") {
    globalThis.module = {
        exports: globalThis.exports
    };
}
function defaultWrite(chunk) {
    const op = globalThis.__dekaOps;
    if (op?.op_stdout_write) {
        op.op_stdout_write(new TextEncoder().encode(chunk));
    }
}
function toWriter(stream, fallback) {
    if (stream && typeof stream.write === "function") {
        return stream;
    }
    return {
        write: fallback
    };
}
function formatValue(value) {
    if (typeof value === "string") return value;
    if (value instanceof Error) {
        return value.stack || value.message;
    }
    const util = globalThis.__dekaNodeUtil;
    if (util?.inspect) {
        try {
            return util.inspect(value);
        } catch  {}
    }
    try {
        return JSON.stringify(value);
    } catch  {
        return String(value);
    }
}
function formatArgs(args) {
    return args.map(formatValue).join(" ");
}
function nowMs() {
    const perf = globalThis.performance;
    if (perf?.now) return perf.now();
    return Date.now();
}
class Console {
    stdout;
    stderr;
    timers;
    constructor(stdout, stderr){
        this.stdout = toWriter(stdout, defaultWrite);
        this.stderr = toWriter(stderr, defaultWrite);
        this.timers = new Map();
    }
    log(...args) {
        this.stdout.write(`${formatArgs(args)}\n`);
    }
    info(...args) {
        this.stdout.write(`${formatArgs(args)}\n`);
    }
    warn(...args) {
        this.stderr.write(`${formatArgs(args)}\n`);
    }
    error(...args) {
        if (args.length > 0) {
            globalThis.__dekaLastError = args[0];
        }
        this.stderr.write(`${formatArgs(args)}\n`);
    }
    debug(...args) {
        this.stdout.write(`${formatArgs(args)}\n`);
    }
    dir(value) {
        this.stdout.write(`${formatValue(value)}\n`);
    }
    assert(condition, ...args) {
        if (condition) return;
        const prefix = "Assertion failed";
        if (args.length === 0) {
            this.stderr.write(`${prefix}\n`);
            return;
        }
        this.stderr.write(`${prefix}: ${formatArgs(args)}\n`);
    }
    time(label = "default") {
        if (!this.timers.has(label)) {
            this.timers.set(label, nowMs());
        }
    }
    timeLog(label = "default", ...args) {
        const start = this.timers.get(label);
        const delta = start === undefined ? 0 : Math.max(0, nowMs() - start);
        const extra = args.length ? ` ${formatArgs(args)}` : "";
        this.stdout.write(`${label}: ${delta.toFixed(2)}ms${extra}\n`);
    }
    timeEnd(label = "default", ...args) {
        this.timeLog(label, ...args);
        this.timers.delete(label);
    }
}
function createConsole(stdout, stderr) {
    return new Console(stdout, stderr);
}
const baseConsole = globalThis.console || createConsole();
const originalError = typeof baseConsole.error === "function" ? baseConsole.error.bind(baseConsole) : null;
baseConsole.error = (...args)=>{
    if (args.length > 0) {
        globalThis.__dekaLastError = args[0];
    }
    if (originalError) {
        originalError(...args);
    }
};
globalThis.console = baseConsole;
const BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function atobPolyfill(value) {
    const input = String(value || "");
    const clean = input.replace(/[^A-Za-z0-9+/=]/g, "");
    let buffer = 0;
    let bits = 0;
    let output = "";
    for(let i = 0; i < clean.length; i += 1){
        const ch = clean[i];
        if (ch === "=") break;
        const idx = BASE64_ALPHABET.indexOf(ch);
        if (idx < 0) continue;
        buffer = buffer << 6 | idx;
        bits += 6;
        if (bits >= 8) {
            bits -= 8;
            output += String.fromCharCode(buffer >> bits & 0xff);
        }
    }
    return output;
}
function btoaPolyfill(value) {
    const input = String(value || "");
    let buffer = 0;
    let bits = 0;
    let output = "";
    for(let i = 0; i < input.length; i += 1){
        const code = input.charCodeAt(i);
        if (code > 255) {
            throw new TypeError("The string to be encoded contains characters outside of the Latin1 range.");
        }
        buffer = buffer << 8 | code;
        bits += 8;
        while(bits >= 6){
            bits -= 6;
            output += BASE64_ALPHABET[buffer >> bits & 0x3f];
        }
    }
    if (bits > 0) {
        output += BASE64_ALPHABET[buffer << 6 - bits & 0x3f];
    }
    while(output.length % 4 !== 0){
        output += "=";
    }
    return output;
}
if (typeof globalThis.atob === "undefined") {
    globalThis.atob = atobPolyfill;
}
if (typeof globalThis.btoa === "undefined") {
    globalThis.btoa = btoaPolyfill;
}
function toUint8Array(input) {
    if (input instanceof ArrayBuffer) {
        return new Uint8Array(input);
    }
    if (ArrayBuffer.isView(input)) {
        return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
    }
    return new Uint8Array(0);
}
function encodeLatin1(text) {
    const bytes = new Uint8Array(text.length);
    for(let i = 0; i < text.length; i += 1){
        bytes[i] = text.charCodeAt(i) & 0xff;
    }
    return bytes;
}
function decodeLatin1(bytes) {
    let out = "";
    for(let i = 0; i < bytes.length; i += 1){
        out += String.fromCharCode(bytes[i]);
    }
    return out;
}
function hexToBytes(hex) {
    const normalized = hex.length % 2 === 0 ? hex : `0${hex}`;
    const bytes = new Uint8Array(normalized.length / 2);
    for(let i = 0; i < bytes.length; i += 1){
        const offset = i * 2;
        bytes[i] = parseInt(normalized.slice(offset, offset + 2), 16);
    }
    return bytes;
}
function bytesToHex(bytes) {
    const hex = [];
    for (const __byte of bytes){
        hex.push(__byte.toString(16).padStart(2, "0"));
    }
    return hex.join("");
}
function base64ToBytes(base64) {
    const binary = globalThis.atob ? globalThis.atob(base64) : "";
    const bytes = new Uint8Array(binary.length);
    for(let i = 0; i < binary.length; i += 1){
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}
function bytesToBase64(bytes) {
    const binary = decodeLatin1(bytes);
    return globalThis.btoa ? globalThis.btoa(binary) : "";
}
class Buffer1 extends Uint8Array {
    static from(input, encodingOrOffset = "utf8", length) {
        if (input instanceof ArrayBuffer && typeof encodingOrOffset === "number") {
            const offset = Math.max(0, encodingOrOffset);
            const end = typeof length === "number" ? offset + Math.max(0, length) : undefined;
            return new Buffer1(new Uint8Array(input, offset, end ? end - offset : undefined));
        }
        if (typeof input === "string") {
            const encoding = encodingOrOffset;
            switch(encoding){
                case "hex":
                    return new Buffer1(hexToBytes(input));
                case "base64":
                    return new Buffer1(base64ToBytes(input));
                case "latin1":
                case "binary":
                    return new Buffer1(encodeLatin1(input));
                case "utf8":
                case "utf-8":
                default:
                    return new Buffer1(new TextEncoder().encode(input));
            }
        }
        if (typeof input.length === "number") {
            return new Buffer1(Uint8Array.from(input));
        }
        return new Buffer1(toUint8Array(input));
    }
    static alloc(size, fill = 0) {
        const buffer = new Buffer1(size);
        buffer.fill(fill);
        return buffer;
    }
    static allocUnsafe(size) {
        return new Buffer1(size);
    }
    static isBuffer(value) {
        return value instanceof Buffer1;
    }
    static byteLength(value, encoding = "utf8") {
        return Buffer1.from(value, encoding).length;
    }
    static concat(list, totalLength) {
        const length = totalLength ?? list.reduce((sum, entry)=>sum + entry.length, 0);
        const out = new Buffer1(length);
        let offset = 0;
        for (const entry of list){
            out.set(entry, offset);
            offset += entry.length;
        }
        return out;
    }
    toString(encoding = "utf8") {
        switch(encoding){
            case "hex":
                return bytesToHex(this);
            case "base64":
                return bytesToBase64(this);
            case "latin1":
            case "binary":
                return decodeLatin1(this);
            case "utf8":
            case "utf-8":
            default:
                return new TextDecoder().decode(this);
        }
    }
}
if (typeof globalThis.Buffer === "undefined") {
    globalThis.Buffer = Buffer1;
}
function utf8Encode(value) {
    const str = String(value || "");
    const bytes = [];
    for(let i = 0; i < str.length; i += 1){
        let code = str.charCodeAt(i);
        if (code >= 0xd800 && code <= 0xdbff && i + 1 < str.length) {
            const next = str.charCodeAt(i + 1);
            if (next >= 0xdc00 && next <= 0xdfff) {
                code = (code - 0xd800) * 0x400 + (next - 0xdc00) + 0x10000;
                i += 1;
            }
        }
        if (code <= 0x7f) {
            bytes.push(code);
        } else if (code <= 0x7ff) {
            bytes.push(0xc0 | code >> 6, 0x80 | code & 0x3f);
        } else if (code <= 0xffff) {
            bytes.push(0xe0 | code >> 12, 0x80 | code >> 6 & 0x3f, 0x80 | code & 0x3f);
        } else {
            bytes.push(0xf0 | code >> 18, 0x80 | code >> 12 & 0x3f, 0x80 | code >> 6 & 0x3f, 0x80 | code & 0x3f);
        }
    }
    return new Uint8Array(bytes);
}
function utf8Decode(bytes) {
    const input = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes || []);
    let out = "";
    for(let i = 0; i < input.length; i += 1){
        const byte1 = input[i];
        if (byte1 < 0x80) {
            out += String.fromCharCode(byte1);
            continue;
        }
        if (byte1 >= 0xc0 && byte1 < 0xe0) {
            const byte2 = input[++i];
            if (byte2 === undefined) break;
            const code = (byte1 & 0x1f) << 6 | byte2 & 0x3f;
            out += String.fromCharCode(code);
            continue;
        }
        if (byte1 >= 0xe0 && byte1 < 0xf0) {
            const byte2 = input[++i];
            const byte3 = input[++i];
            if (byte2 === undefined || byte3 === undefined) break;
            const code = (byte1 & 0x0f) << 12 | (byte2 & 0x3f) << 6 | byte3 & 0x3f;
            out += String.fromCharCode(code);
            continue;
        }
        const byte2 = input[++i];
        const byte3 = input[++i];
        const byte4 = input[++i];
        if (byte2 === undefined || byte3 === undefined || byte4 === undefined) break;
        let codepoint = (byte1 & 0x07) << 18 | (byte2 & 0x3f) << 12 | (byte3 & 0x3f) << 6 | byte4 & 0x3f;
        codepoint -= 0x10000;
        out += String.fromCharCode(0xd800 + (codepoint >> 10), 0xdc00 + (codepoint & 0x3ff));
    }
    return out;
}
class TextEncoder1 {
    encode(value = "") {
        return utf8Encode(value);
    }
}
class TextDecoder1 {
    encoding;
    constructor(label = "utf-8"){
        this.encoding = String(label).toLowerCase();
        if (this.encoding !== "utf-8" && this.encoding !== "utf8") {
            throw new RangeError(`Unsupported encoding: ${label}`);
        }
    }
    decode(value) {
        if (value === undefined) return "";
        return utf8Decode(value);
    }
}
if (typeof globalThis.TextEncoder === "undefined") {
    globalThis.TextEncoder = TextEncoder1;
}
if (typeof globalThis.TextDecoder === "undefined") {
    globalThis.TextDecoder = TextDecoder1;
}
class DOMException extends Error {
    name;
    code;
    constructor(message = "", name = "Error"){
        super(String(message));
        this.name = String(name);
        this.code = 0;
    }
}
class Event {
    type;
    bubbles;
    cancelable;
    defaultPrevented;
    target;
    currentTarget;
    constructor(type, options = {}){
        this.type = String(type);
        this.bubbles = Boolean(options.bubbles);
        this.cancelable = Boolean(options.cancelable);
        this.defaultPrevented = false;
        this.target = null;
        this.currentTarget = null;
    }
    preventDefault() {
        if (this.cancelable) {
            this.defaultPrevented = true;
        }
    }
}
class CustomEvent extends Event {
    detail;
    constructor(type, options = {}){
        super(type, options);
        this.detail = options.detail;
    }
}
class EventTarget {
    listeners;
    constructor(){
        this.listeners = new Map();
    }
    addEventListener(type, listener, options = {}) {
        if (!listener) return;
        const key = String(type);
        const list = this.listeners.get(key) || [];
        const once = typeof options === "object" && Boolean(options.once);
        list.push({
            listener,
            once
        });
        this.listeners.set(key, list);
    }
    removeEventListener(type, listener) {
        const key = String(type);
        const list = this.listeners.get(key);
        if (!list) return;
        this.listeners.set(key, list.filter((entry)=>entry.listener !== listener));
    }
    dispatchEvent(event) {
        const key = String(event.type);
        const list = this.listeners.get(key);
        if (!list || list.length === 0) return true;
        event.target = this;
        for (const entry of [
            ...list
        ]){
            event.currentTarget = this;
            entry.listener.call(this, event);
            if (entry.once) {
                this.removeEventListener(key, entry.listener);
            }
        }
        return !event.defaultPrevented;
    }
}
if (typeof globalThis.DOMException === "undefined") {
    globalThis.DOMException = DOMException;
}
if (typeof globalThis.Event === "undefined") {
    globalThis.Event = Event;
}
if (typeof globalThis.CustomEvent === "undefined") {
    globalThis.CustomEvent = CustomEvent;
}
if (typeof globalThis.EventTarget === "undefined") {
    globalThis.EventTarget = EventTarget;
}
class AbortSignal extends EventTarget {
    aborted;
    reason;
    onabort;
    constructor(){
        super();
        this.aborted = false;
        this.reason = undefined;
        this.onabort = null;
    }
    _abort(reason) {
        if (this.aborted) return;
        this.aborted = true;
        this.reason = reason;
        const event = new Event("abort");
        if (this.onabort) {
            this.onabort(event);
        }
        this.dispatchEvent(event);
    }
}
class AbortController1 {
    signal;
    constructor(){
        this.signal = new AbortSignal();
    }
    abort(reason) {
        this.signal._abort(reason);
    }
}
if (typeof globalThis.AbortSignal === "undefined") {
    globalThis.AbortSignal = AbortSignal;
}
if (typeof globalThis.AbortController === "undefined") {
    globalThis.AbortController = AbortController1;
}
class MessageEvent extends Event {
    data;
    origin;
    lastEventId;
    ports;
    constructor(type, options = {}){
        super(type, options);
        this.data = options.data;
        this.origin = options.origin || "";
        this.lastEventId = options.lastEventId || "";
        this.ports = options.ports || [];
    }
}
class MessagePort extends EventTarget {
    closed;
    peer;
    constructor(){
        super();
        this.closed = false;
        this.peer = null;
    }
    postMessage(data) {
        if (this.closed || !this.peer) return;
        const event = new MessageEvent("message", {
            data,
            ports: []
        });
        setTimeout(()=>this.peer?.dispatchEvent(event), 0);
    }
    close() {
        this.closed = true;
    }
    start() {}
    _link(peer) {
        this.peer = peer;
    }
}
class MessageChannel {
    port1;
    port2;
    constructor(){
        this.port1 = new MessagePort();
        this.port2 = new MessagePort();
        this.port1._link(this.port2);
        this.port2._link(this.port1);
    }
}
class BroadcastChannel {
    static channels = new Map();
    name;
    listeners;
    constructor(name){
        this.name = String(name);
        this.listeners = new Set();
        const list = BroadcastChannel.channels.get(this.name) || new Set();
        list.add(this);
        BroadcastChannel.channels.set(this.name, list);
    }
    postMessage(data) {
        const channels = BroadcastChannel.channels.get(this.name);
        if (!channels) return;
        for (const channel of channels){
            if (channel === this) continue;
            channel.listeners.forEach((listener)=>listener.call(channel, {
                    data
                }));
        }
    }
    addEventListener(_type, listener) {
        if (!listener) return;
        this.listeners.add(listener);
    }
    removeEventListener(_type, listener) {
        this.listeners.delete(listener);
    }
    close() {
        const channels = BroadcastChannel.channels.get(this.name);
        if (!channels) return;
        channels.delete(this);
    }
}
if (typeof globalThis.MessageEvent === "undefined") {
    globalThis.MessageEvent = MessageEvent;
}
if (typeof globalThis.MessagePort === "undefined") {
    globalThis.MessagePort = MessagePort;
}
if (typeof globalThis.MessageChannel === "undefined") {
    globalThis.MessageChannel = MessageChannel;
}
if (typeof globalThis.BroadcastChannel === "undefined") {
    globalThis.BroadcastChannel = BroadcastChannel;
}
if (typeof globalThis.queueMicrotask === "undefined") {
    globalThis.queueMicrotask = (callback)=>{
        Promise.resolve().then(callback);
    };
}
let timerCounter = 1;
const timers = new Map();
function normalizeDelay(delay) {
    const value = Number(delay ?? 0);
    return Number.isFinite(value) && value > 0 ? value : 0;
}
function scheduleTimeout(id) {
    const entry = timers.get(id);
    if (!entry) return;
    op_sleep(entry.delay).then(()=>{
        if (!entry.active) return;
        entry.callback(...entry.args);
        timers.delete(id);
    });
}
function scheduleInterval(id) {
    const entry = timers.get(id);
    if (!entry) return;
    const tick = async ()=>{
        while(entry.active){
            await op_sleep(entry.delay);
            if (!entry.active) break;
            entry.callback(...entry.args);
        }
    };
    tick();
}
function setTimeoutImpl(callback, delay, ...args) {
    const id = timerCounter++;
    timers.set(id, {
        active: true,
        interval: false,
        delay: normalizeDelay(delay),
        callback,
        args
    });
    scheduleTimeout(id);
    return id;
}
function clearTimeoutImpl(id) {
    const entry = timers.get(id);
    if (entry) {
        entry.active = false;
        timers.delete(id);
    }
}
function setIntervalImpl(callback, delay, ...args) {
    const id = timerCounter++;
    timers.set(id, {
        active: true,
        interval: true,
        delay: normalizeDelay(delay),
        callback,
        args
    });
    scheduleInterval(id);
    return id;
}
function clearIntervalImpl(id) {
    clearTimeoutImpl(id);
}
if (typeof globalThis.setTimeout === "undefined") {
    globalThis.setTimeout = setTimeoutImpl;
}
if (typeof globalThis.clearTimeout === "undefined") {
    globalThis.clearTimeout = clearTimeoutImpl;
}
if (typeof globalThis.setInterval === "undefined") {
    globalThis.setInterval = setIntervalImpl;
}
if (typeof globalThis.clearInterval === "undefined") {
    globalThis.clearInterval = clearIntervalImpl;
}
const immediateIds = new Map();
let immediateCounter = 1;
function setImmediatePolyfill(callback, ...args) {
    const id = immediateCounter++;
    const handle = setTimeout(()=>{
        immediateIds.delete(id);
        callback(...args);
    }, 0);
    immediateIds.set(id, handle);
    return id;
}
function clearImmediatePolyfill(id) {
    const handle = immediateIds.get(id);
    if (handle !== undefined) {
        clearTimeout(handle);
        immediateIds.delete(id);
    }
}
if (typeof globalThis.setImmediate === "undefined") {
    globalThis.setImmediate = setImmediatePolyfill;
}
if (typeof globalThis.clearImmediate === "undefined") {
    globalThis.clearImmediate = clearImmediatePolyfill;
}
class PerformanceEntry {
    name;
    entryType;
    startTime;
    duration;
    constructor(name, entryType, startTime, duration){
        this.name = name;
        this.entryType = entryType;
        this.startTime = startTime;
        this.duration = duration;
    }
}
class PerformanceMark extends PerformanceEntry {
    constructor(name, startTime){
        super(name, "mark", startTime, 0);
    }
}
class PerformanceMeasure extends PerformanceEntry {
    constructor(name, startTime, duration){
        super(name, "measure", startTime, duration);
    }
}
class PerformanceObserverEntryList {
    entries;
    constructor(entries){
        this.entries = entries;
    }
    getEntries() {
        return [
            ...this.entries
        ];
    }
}
class PerformanceObserver {
    static observers = new Set();
    callback;
    types;
    constructor(callback){
        this.callback = callback;
        this.types = new Set();
        PerformanceObserver.observers.add(this);
    }
    observe(options = {}) {
        const entries = options.entryTypes || [];
        for (const entry of entries){
            this.types.add(entry);
        }
    }
    disconnect() {
        PerformanceObserver.observers.delete(this);
        this.types.clear();
    }
    _notify(entries) {
        const list = new PerformanceObserverEntryList(entries);
        this.callback(list, this);
    }
    _matches(entry) {
        return this.types.has(entry.entryType);
    }
}
const perfEntries = [];
const perfOrigin = Date.now();
const performance = {
    timeOrigin: perfOrigin,
    now () {
        return Date.now() - perfOrigin;
    },
    mark (name) {
        const entry = new PerformanceMark(String(name), performance.now());
        perfEntries.push(entry);
        notifyPerformanceObservers([
            entry
        ]);
        return entry;
    },
    measure (name, startMark, endMark) {
        const startEntry = typeof startMark === "string" ? perfEntries.find((entry)=>entry.name === startMark && entry.entryType === "mark") : null;
        const endEntry = typeof endMark === "string" ? perfEntries.find((entry)=>entry.name === endMark && entry.entryType === "mark") : null;
        const startTime = startEntry?.startTime ?? 0;
        const endTime = endEntry?.startTime ?? performance.now();
        const entry = new PerformanceMeasure(String(name), startTime, endTime - startTime);
        perfEntries.push(entry);
        notifyPerformanceObservers([
            entry
        ]);
        return entry;
    },
    getEntries () {
        return [
            ...perfEntries
        ];
    }
};
function notifyPerformanceObservers(entries) {
    for (const observer of PerformanceObserver.observers){
        const filtered = entries.filter((entry)=>observer._matches(entry));
        if (filtered.length > 0) {
            observer._notify(filtered);
        }
    }
}
if (typeof globalThis.performance === "undefined") {
    globalThis.performance = performance;
}
if (typeof globalThis.PerformanceEntry === "undefined") {
    globalThis.PerformanceEntry = PerformanceEntry;
}
if (typeof globalThis.PerformanceMark === "undefined") {
    globalThis.PerformanceMark = PerformanceMark;
}
if (typeof globalThis.PerformanceMeasure === "undefined") {
    globalThis.PerformanceMeasure = PerformanceMeasure;
}
if (typeof globalThis.PerformanceObserver === "undefined") {
    globalThis.PerformanceObserver = PerformanceObserver;
}
if (typeof globalThis.PerformanceObserverEntryList === "undefined") {
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
}
const baseOps1 = Deno.core.ops;
function formatOpArg1(arg) {
    if (arg === null) return "null";
    if (arg === undefined) return "undefined";
    if (typeof arg === "string") return `string(${arg.length})`;
    if (typeof arg === "number") return `number(${arg})`;
    if (typeof arg === "boolean") return `bool(${arg})`;
    if (typeof arg === "bigint") return `bigint(${arg.toString()})`;
    if (ArrayBuffer.isView(arg)) {
        return `${arg.constructor.name}(${arg.byteLength})`;
    }
    if (arg instanceof ArrayBuffer) {
        return `ArrayBuffer(${arg.byteLength})`;
    }
    if (Array.isArray(arg)) return `Array(${arg.length})`;
    if (typeof arg === "object") return `object`;
    return typeof arg;
}
function shouldSkipOpLog1(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE_FILTER) return false;
    if (name !== "op_read_module_source") return false;
    const first = args[0];
    if (typeof first !== "string") return false;
    if (first.endsWith("/package.json")) return true;
    if (first.endsWith("package.json")) return true;
    return false;
}
function logOpCall1(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog1(name, args)) return;
    const writer = baseOps1.op_stdout_write;
    if (!writer) return;
    const summary = args.map(formatOpArg1).join(", ");
    writer(new TextEncoder().encode(`[op] ${name} ${summary}\n`));
}
function logOpReturn1(name, startedAt, args, value) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog1(name, args)) {
        return;
    }
    const writer = baseOps1.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const summary = formatOpArg1(value);
    writer(new TextEncoder().encode(`[op] ${name} -> ${summary} (${elapsed}ms)\n`));
}
function logOpError1(name, startedAt, args, error) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog1(name, args)) {
        return;
    }
    const writer = baseOps1.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const message = error?.message || String(error);
    writer(new TextEncoder().encode(`[op] ${name} ! ${message} (${elapsed}ms)\n`));
}
function wrapOps1(ops) {
    const wrapped = {};
    for (const [name, fn] of Object.entries(ops)){
        if (typeof fn !== "function") continue;
        if (name === "op_stdout_write" || name === "op_stderr_write") {
            wrapped[name] = fn;
            continue;
        }
        wrapped[name] = (...args)=>{
            logOpCall1(name, args);
            const startedAt = Date.now();
            try {
                const result = fn(...args);
                if (result && typeof result.then === "function") {
                    return result.then((value)=>{
                        logOpReturn1(name, startedAt, args, value);
                        return value;
                    }).catch((error)=>{
                        logOpError1(name, startedAt, args, error);
                        throw error;
                    });
                }
                logOpReturn1(name, startedAt, args, result);
                return result;
            } catch (error) {
                logOpError1(name, startedAt, args, error);
                throw error;
            }
        };
    }
    return wrapped;
}
const ops1 = globalThis.process?.env?.DEKA_VERBOSE ? wrapOps1(baseOps1) : baseOps1;
globalThis.__dekaOps = ops1;
const { op_read_handler_source: op_read_handler_source1, op_read_module_source: op_read_module_source1, op_read_env: op_read_env1, op_stdout_write: op_stdout_write1, op_stderr_write: op_stderr_write1, op_execute_isolate: op_execute_isolate1, op_transform_module: op_transform_module1, op_bundle_browser: op_bundle_browser1, op_bundle_browser_assets: op_bundle_browser_assets1, op_bundle_css: op_bundle_css1, op_transform_css: op_transform_css1, op_tailwind_process: op_tailwind_process1, op_read_file: op_read_file1, op_fs_exists: op_fs_exists1, op_fs_stat: op_fs_stat1, op_fs_read_dir: op_fs_read_dir1, op_fs_mkdir: op_fs_mkdir1, op_fs_remove_file: op_fs_remove_file1, op_fs_append: op_fs_append1, op_fs_append_bytes: op_fs_append_bytes1, op_fs_open: op_fs_open1, op_fs_close: op_fs_close1, op_fs_read: op_fs_read1, op_fs_write: op_fs_write1, op_fs_copy_file: op_fs_copy_file1, op_zlib_gzip: op_zlib_gzip1, op_write_file: op_write_file1, op_write_file_base64: op_write_file_base641, op_introspect_stats: op_introspect_stats1, op_introspect_top: op_introspect_top1, op_introspect_workers: op_introspect_workers1, op_introspect_isolate: op_introspect_isolate1, op_introspect_kill_isolate: op_introspect_kill_isolate1, op_introspect_requests: op_introspect_requests1, op_introspect_evict: op_introspect_evict1, op_set_introspect_profiling: op_set_introspect_profiling1, op_ws_send: op_ws_send1, op_ws_send_binary: op_ws_send_binary1, op_ws_close: op_ws_close1, op_blob_create: op_blob_create1, op_blob_get: op_blob_get1, op_blob_size: op_blob_size1, op_blob_type: op_blob_type1, op_blob_slice: op_blob_slice1, op_blob_drop: op_blob_drop1, op_stream_create: op_stream_create1, op_stream_enqueue: op_stream_enqueue1, op_stream_close: op_stream_close1, op_stream_read: op_stream_read1, op_stream_drop: op_stream_drop1, op_crypto_random: op_crypto_random1, op_crypto_digest: op_crypto_digest1, op_crypto_hmac: op_crypto_hmac1, op_crypto_pbkdf2: op_crypto_pbkdf21, op_crypto_aes_gcm_encrypt: op_crypto_aes_gcm_encrypt1, op_crypto_aes_gcm_decrypt: op_crypto_aes_gcm_decrypt1, op_crypto_key_info: op_crypto_key_info1, op_crypto_key_from_secret: op_crypto_key_from_secret1, op_crypto_key_from_pem: op_crypto_key_from_pem1, op_crypto_key_from_der: op_crypto_key_from_der1, op_crypto_key_from_jwk: op_crypto_key_from_jwk1, op_crypto_key_export_pem: op_crypto_key_export_pem1, op_crypto_key_export_der: op_crypto_key_export_der1, op_crypto_key_export_jwk: op_crypto_key_export_jwk1, op_crypto_key_public: op_crypto_key_public1, op_crypto_key_equals: op_crypto_key_equals1, op_crypto_sign: op_crypto_sign1, op_crypto_verify: op_crypto_verify1, op_crypto_generate_keypair: op_crypto_generate_keypair1, op_crypto_get_curves: op_crypto_get_curves1, op_crypto_ecdh_new: op_crypto_ecdh_new1, op_crypto_ecdh_generate: op_crypto_ecdh_generate1, op_crypto_ecdh_get_public: op_crypto_ecdh_get_public1, op_crypto_ecdh_get_private: op_crypto_ecdh_get_private1, op_crypto_ecdh_set_private: op_crypto_ecdh_set_private1, op_crypto_ecdh_compute_secret: op_crypto_ecdh_compute_secret1, op_crypto_ecdh_convert: op_crypto_ecdh_convert1, op_url_parse: op_url_parse1, op_napi_open: op_napi_open1, op_http_fetch: op_http_fetch1, op_process_spawn: op_process_spawn1, op_process_spawn_sync: op_process_spawn_sync1, op_process_read_stdout: op_process_read_stdout1, op_process_read_stderr: op_process_read_stderr1, op_process_write_stdin: op_process_write_stdin1, op_process_close_stdin: op_process_close_stdin1, op_process_wait: op_process_wait1, op_process_kill: op_process_kill1, op_sleep: op_sleep1, op_udp_bind: op_udp_bind1, op_udp_send: op_udp_send1, op_udp_recv: op_udp_recv1, op_udp_close: op_udp_close1, op_udp_local_addr: op_udp_local_addr1, op_udp_peer_addr: op_udp_peer_addr1, op_udp_connect: op_udp_connect1, op_udp_disconnect: op_udp_disconnect1, op_udp_set_broadcast: op_udp_set_broadcast1, op_udp_set_ttl: op_udp_set_ttl1, op_udp_set_multicast_ttl: op_udp_set_multicast_ttl1, op_udp_set_multicast_loop: op_udp_set_multicast_loop1, op_udp_set_multicast_if: op_udp_set_multicast_if1, op_udp_join_multicast: op_udp_join_multicast1, op_udp_leave_multicast: op_udp_leave_multicast1, op_udp_set_recv_buffer_size: op_udp_set_recv_buffer_size1, op_udp_set_send_buffer_size: op_udp_set_send_buffer_size1, op_udp_get_recv_buffer_size: op_udp_get_recv_buffer_size1, op_udp_get_send_buffer_size: op_udp_get_send_buffer_size1, op_dns_lookup: op_dns_lookup1, op_dns_reverse: op_dns_reverse1, op_tcp_listen: op_tcp_listen1, op_tcp_accept: op_tcp_accept1, op_tcp_connect: op_tcp_connect1, op_tcp_read: op_tcp_read1, op_tcp_write: op_tcp_write1, op_tcp_close: op_tcp_close1, op_tcp_shutdown: op_tcp_shutdown1, op_tcp_local_addr: op_tcp_local_addr1, op_tcp_peer_addr: op_tcp_peer_addr1, op_tcp_listener_addr: op_tcp_listener_addr1, op_tcp_listener_close: op_tcp_listener_close1 } = ops1;
class ReadableStreamController {
    streamId;
    queue;
    resolvers;
    state;
    constructor(streamId, queue, resolvers, state){
        this.streamId = streamId;
        this.queue = queue;
        this.resolvers = resolvers;
        this.state = state;
    }
    enqueue(chunk) {
        if (this.queue && this.resolvers) {
            const entry = {
                value: chunk,
                done: false
            };
            const resolver = this.resolvers.shift();
            if (resolver) {
                resolver(entry);
                return;
            }
            this.queue.push(entry);
            return;
        }
        if (this.streamId !== undefined) {
            const bytes = normalizeChunk(chunk);
            op_stream_enqueue1(this.streamId, bytes);
        }
    }
    close() {
        if (this.queue && this.resolvers) {
            const entry = {
                done: true
            };
            if (this.state) {
                this.state.closed = true;
            }
            const resolver = this.resolvers.shift();
            if (resolver) {
                resolver(entry);
                return;
            }
            this.queue.push(entry);
            return;
        }
        if (this.streamId !== undefined) {
            op_stream_close1(this.streamId);
        }
    }
    error(_reason) {
        if (this.state) {
            this.state.closed = true;
        }
        this.close();
    }
}
class ReadableStreamDefaultReader {
    streamId;
    queue;
    resolvers;
    stream;
    constructor(streamId, queue, resolvers, stream){
        this.streamId = streamId;
        this.queue = queue;
        this.resolvers = resolvers;
        this.stream = stream;
    }
    async read() {
        if (this.queue && this.resolvers) {
            const entry = this.queue.shift();
            if (entry) {
                return entry;
            }
            if (this.stream?.state?.closed) {
                return {
                    done: true
                };
            }
            if (this.stream?.source && this.stream?.controller) {
                const maybe = this.stream.source.pull?.(this.stream.controller);
                if (maybe && typeof maybe.then === "function") {
                    await maybe;
                }
                const pulled = this.queue.shift();
                if (pulled) {
                    return pulled;
                }
            }
            return new Promise((resolve)=>{
                this.resolvers?.push(resolve);
            });
        }
        if (this.streamId !== undefined) {
            const result = await op_stream_read1(this.streamId);
            if (result.done) {
                return {
                    done: true
                };
            }
            if (result.chunk) {
                return {
                    value: result.chunk,
                    done: false
                };
            }
        }
        return {
            done: true
        };
    }
    releaseLock() {}
}
class ReadableStreamDefaultController {
    desiredSize = null;
    enqueue() {}
    close() {}
    error() {}
}
class ReadableByteStreamController extends ReadableStreamDefaultController {
}
class ReadableStreamBYOBRequest {
    view;
    constructor(view){
        this.view = view;
    }
    respond() {}
    respondWithNewView() {}
}
class ReadableStreamBYOBReader {
    read() {
        return Promise.resolve({
            value: undefined,
            done: true
        });
    }
    releaseLock() {}
}
class ReadableStream {
    streamId;
    queue;
    resolvers;
    state;
    raw;
    source;
    controller;
    constructor(source = {}, options = {}){
        this.raw = !!options.raw;
        this.state = {
            closed: false
        };
        if (this.raw) {
            this.queue = [];
            this.resolvers = [];
        } else {
            this.streamId = op_stream_create1();
        }
        this.source = source;
        const controller = new ReadableStreamController(this.streamId, this.queue, this.resolvers, this.state);
        this.controller = controller;
        source.start?.(controller);
    }
    getReader() {
        return new ReadableStreamDefaultReader(this.streamId, this.queue, this.resolvers, this);
    }
    async pipeTo(destination, options = {}) {
        const reader = this.getReader();
        const writer = destination.getWriter();
        const { preventClose, preventAbort, preventCancel, signal } = options;
        if (signal) {
            if (signal.aborted) {
                if (!preventAbort) await writer.abort(signal.reason);
                throw signal.reason;
            }
            signal.addEventListener("abort", ()=>{
                if (!preventAbort) {
                    writer.abort(signal.reason);
                }
            }, {
                once: true
            });
        }
        try {
            for(;;){
                const { value, done } = await reader.read();
                if (done) break;
                await writer.write(value);
            }
            if (!preventClose) {
                await writer.close();
            }
        } catch (err) {
            if (!preventAbort) {
                await writer.abort(err);
            }
            if (!preventCancel) {
                this._closeRaw();
            }
            throw err;
        }
    }
    pipeThrough(transform, options) {
        const internal = transform._transformer;
        if (internal) {
            const reader = this.getReader();
            return new ReadableStream({
                async pull (controller) {
                    const { value, done } = await reader.read();
                    if (done) {
                        internal.flush?.(controller);
                        controller.close();
                        return;
                    }
                    if (internal.transform) {
                        internal.transform(value, controller);
                        return;
                    }
                    controller.enqueue(value);
                }
            }, {
                raw: true
            });
        }
        void this.pipeTo(transform.writable, options);
        return transform.readable;
    }
    tee() {
        const reader = this.getReader();
        const queueA = [];
        const queueB = [];
        const waitersA = [];
        const waitersB = [];
        let pulling = null;
        const enqueueTo = (queue, waiters, entry)=>{
            const waiter = waiters.shift();
            if (waiter) {
                waiter(entry);
                return;
            }
            queue.push(entry);
        };
        const pullFromSource = async ()=>{
            if (pulling) {
                await pulling;
                return;
            }
            pulling = (async ()=>{
                const result = await reader.read();
                const entry = result.done ? {
                    done: true
                } : {
                    value: result.value,
                    done: false
                };
                enqueueTo(queueA, waitersA, entry);
                enqueueTo(queueB, waitersB, entry);
            })();
            try {
                await pulling;
            } finally{
                pulling = null;
            }
        };
        const makeClone = (queue, waiters)=>new ReadableStream({
                async pull (controller) {
                    const entry = queue.shift();
                    if (entry) {
                        if (entry.done) controller.close();
                        else controller.enqueue(entry.value);
                        return;
                    }
                    await pullFromSource();
                    const next = queue.shift();
                    if (next) {
                        if (next.done) controller.close();
                        else controller.enqueue(next.value);
                        return;
                    }
                    waiters.push((result)=>{
                        if (result.done) controller.close();
                        else controller.enqueue(result.value);
                    });
                }
            }, {
                raw: true
            });
        return [
            makeClone(queueA, waitersA),
            makeClone(queueB, waitersB)
        ];
    }
    async *[Symbol.asyncIterator]() {
        const reader = this.getReader();
        for(;;){
            const { value, done } = await reader.read();
            if (done) break;
            yield value;
        }
    }
    _drop() {
        if (this.streamId !== undefined) {
            op_stream_drop1(this.streamId);
        }
        this.queue = [];
        this.resolvers = [];
    }
    _enqueueRaw(chunk) {
        if (!this.queue || !this.resolvers) return;
        const entry = {
            value: chunk,
            done: false
        };
        const resolver = this.resolvers.shift();
        if (resolver) {
            resolver(entry);
            return;
        }
        this.queue.push(entry);
    }
    _closeRaw() {
        if (!this.queue || !this.resolvers) return;
        this.state.closed = true;
        const entry = {
            done: true
        };
        const resolver = this.resolvers.shift();
        if (resolver) {
            resolver(entry);
            return;
        }
        this.queue.push(entry);
    }
}
class WritableStreamDefaultWriter {
    sink;
    constructor(sink){
        this.sink = sink;
    }
    write(chunk) {
        return Promise.resolve(this.sink.write?.(chunk));
    }
    close() {
        return Promise.resolve(this.sink.close?.());
    }
    abort(reason) {
        return Promise.resolve(this.sink.abort?.(reason));
    }
}
class WritableStreamDefaultController {
    error() {}
}
class WritableStream {
    sink;
    constructor(sink = {}){
        this.sink = sink;
    }
    getWriter() {
        return new WritableStreamDefaultWriter(this.sink);
    }
    async abort(reason) {
        await this.sink.abort?.(reason);
    }
}
class TransformStream {
    readable;
    writable;
    _transformer;
    constructor(transformer){
        this._transformer = transformer;
        let controllerRef = null;
        this.readable = new ReadableStream({
            start (controller) {
                controllerRef = controller;
            }
        }, {
            raw: true
        });
        this.writable = new WritableStream({
            write (chunk) {
                if (!controllerRef) return;
                if (transformer?.transform) {
                    transformer.transform(chunk, controllerRef);
                } else {
                    controllerRef.enqueue(chunk);
                }
            },
            close () {
                if (!controllerRef) return;
                transformer?.flush?.(controllerRef);
                controllerRef.close();
            },
            abort () {
                if (!controllerRef) return;
                controllerRef.error();
            }
        });
    }
}
class TransformStreamDefaultController {
    enqueue() {}
    terminate() {}
    error() {}
}
class ByteLengthQueuingStrategy {
    highWaterMark;
    constructor({ highWaterMark } = {}){
        this.highWaterMark = Number(highWaterMark ?? 1);
    }
    size(chunk) {
        if (chunk && typeof chunk.byteLength === "number") {
            return chunk.byteLength;
        }
        return 1;
    }
}
class CountQueuingStrategy {
    highWaterMark;
    constructor({ highWaterMark } = {}){
        this.highWaterMark = Number(highWaterMark ?? 1);
    }
    size() {
        return 1;
    }
}
class TextEncoderStream {
    readable;
    writable;
    constructor(){
        const encoder = new TextEncoder();
        this.readable = new ReadableStream({}, {
            raw: true
        });
        const readable = this.readable;
        this.writable = new WritableStream({
            write (chunk) {
                readable._enqueueRaw(encoder.encode(String(chunk)));
            },
            close: ()=>readable._closeRaw(),
            abort: ()=>readable._closeRaw()
        });
    }
}
class TextDecoderStream {
    readable;
    writable;
    constructor(){
        const decoder = new TextDecoder();
        this.readable = new ReadableStream({}, {
            raw: true
        });
        const readable = this.readable;
        this.writable = new WritableStream({
            write (chunk) {
                const bytes = normalizeChunk(chunk);
                readable._enqueueRaw(decoder.decode(bytes, {
                    stream: true
                }));
            },
            close: ()=>readable._closeRaw(),
            abort: ()=>readable._closeRaw()
        });
    }
}
class CompressionStream {
    readable;
    writable;
    constructor(_format){
        const passthrough = new TransformStream();
        this.readable = passthrough.readable;
        this.writable = passthrough.writable;
    }
}
class DecompressionStream {
    readable;
    writable;
    constructor(_format){
        const passthrough = new TransformStream();
        this.readable = passthrough.readable;
        this.writable = passthrough.writable;
    }
}
async function consumeReadableStream(stream) {
    const reader = stream.getReader();
    const chunks = [];
    while(true){
        const { value, done } = await reader.read();
        if (done) break;
        if (value === undefined) continue;
        if (value instanceof Uint8Array) {
            chunks.push(new TextDecoder().decode(value));
        } else {
            chunks.push(String(value));
        }
    }
    return chunks.join("");
}
function normalizeChunk(chunk) {
    if (chunk instanceof Uint8Array) {
        return chunk;
    }
    if (chunk instanceof ArrayBuffer) {
        return new Uint8Array(chunk);
    }
    if (ArrayBuffer.isView(chunk)) {
        return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    }
    return new TextEncoder().encode(String(chunk));
}
globalThis.ReadableStream = ReadableStream;
globalThis.WritableStream = WritableStream;
globalThis.TransformStream = TransformStream;
globalThis.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
globalThis.ReadableStreamDefaultController = ReadableStreamDefaultController;
globalThis.ReadableByteStreamController = ReadableByteStreamController;
globalThis.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
globalThis.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
globalThis.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
globalThis.WritableStreamDefaultController = WritableStreamDefaultController;
globalThis.TransformStreamDefaultController = TransformStreamDefaultController;
globalThis.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
globalThis.CountQueuingStrategy = CountQueuingStrategy;
globalThis.TextEncoderStream = TextEncoderStream;
globalThis.TextDecoderStream = TextDecoderStream;
globalThis.CompressionStream = CompressionStream;
globalThis.DecompressionStream = DecompressionStream;
class Blob {
    type;
    size;
    bytes;
    id;
    static fromId(id, mime) {
        const blob = Object.create(Blob.prototype);
        blob.id = id;
        blob.type = mime.toLowerCase();
        blob.bytes = null;
        blob.size = Number(op_blob_size(id));
        return blob;
    }
    constructor(parts = [], options = {}){
        const type = options.type ? String(options.type).toLowerCase() : "";
        const buffers = [];
        let total = 0;
        for (const part of parts){
            if (part instanceof Blob) {
                buffers.push(part.bytes);
                total += part.bytes.length;
                continue;
            }
            if (part instanceof ArrayBuffer) {
                const view = new Uint8Array(part);
                buffers.push(view);
                total += view.length;
                continue;
            }
            if (ArrayBuffer.isView(part)) {
                const view = new Uint8Array(part.buffer, part.byteOffset, part.byteLength);
                buffers.push(view);
                total += view.length;
                continue;
            }
            const text = String(part);
            const encoded = utf8Encode(text);
            buffers.push(encoded);
            total += encoded.length;
        }
        const merged = new Uint8Array(total);
        let offset = 0;
        for (const chunk of buffers){
            merged.set(chunk, offset);
            offset += chunk.length;
        }
        this.type = type;
        this.size = total;
        this.bytes = merged;
        try {
            this.id = op_blob_create(merged, type);
            this.bytes = null;
        } catch  {
            this.id = undefined;
        }
    }
    slice(start = 0, end = this.size, contentType = "") {
        const relativeStart = start < 0 ? Math.max(this.size + start, 0) : Math.min(start, this.size);
        const relativeEnd = end < 0 ? Math.max(this.size + end, 0) : Math.min(end, this.size);
        if (this.id !== undefined) {
            const sliceId = op_blob_slice(this.id, relativeStart, relativeEnd, contentType);
            return Blob.fromId(sliceId, contentType);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const view = (this.bytes || new Uint8Array()).slice(relativeStart, relativeStart + span);
        return new Blob([
            view
        ], {
            type: contentType
        });
    }
    async text() {
        const bytes = await this._bytes();
        return utf8Decode(bytes);
    }
    async arrayBuffer() {
        const bytes = await this._bytes();
        return bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
    }
    stream() {
        const bytesPromise = this._bytes();
        return new ReadableStream({
            async start (controller) {
                const bytes = await bytesPromise;
                controller.enqueue(bytes);
                controller.close();
            }
        });
    }
    async _bytes() {
        if (this.bytes) return this.bytes;
        if (this.id !== undefined) {
            const data = op_blob_get(this.id);
            const bytes = new Uint8Array(data);
            this.bytes = bytes;
            this.size = bytes.length;
            this.type = op_blob_type(this.id);
            return bytes;
        }
        return new Uint8Array();
    }
    _drop() {
        if (this.id !== undefined) {
            op_blob_drop(this.id);
            this.id = undefined;
        }
    }
}
class FormData {
    entries;
    constructor(){
        this.entries = new Map();
    }
    append(name, value) {
        const key = String(name);
        const list = this.entries.get(key) || [];
        list.push(value);
        this.entries.set(key, list);
    }
    set(name, value) {
        this.entries.set(String(name), [
            value
        ]);
    }
    get(name) {
        const list = this.entries.get(String(name));
        return list && list.length ? list[0] : null;
    }
    getAll(name) {
        const list = this.entries.get(String(name));
        return list ? [
            ...list
        ] : [];
    }
    delete(name) {
        this.entries.delete(String(name));
    }
    has(name) {
        return this.entries.has(String(name));
    }
    forEach(callback, thisArg) {
        for (const [key, values] of this.entries.entries()){
            for (const value of values){
                callback.call(thisArg, value, key, this);
            }
        }
    }
    *entries() {
        for (const [key, values] of this.entries.entries()){
            for (const value of values){
                yield [
                    key,
                    value
                ];
            }
        }
    }
    *keys() {
        for (const [key] of this.entries()){
            yield key;
        }
    }
    *values() {
        for (const [, value] of this.entries()){
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}
if (typeof globalThis.Blob === "undefined") {
    globalThis.Blob = Blob;
}
if (typeof globalThis.FormData === "undefined") {
    globalThis.FormData = FormData;
}
function structuredClone(value) {
    const seen = new Map();
    return cloneStructured(value, seen);
}
function cloneStructured(value, seen) {
    if (value === null || typeof value !== "object") return value;
    if (seen.has(value)) return seen.get(value);
    if (value instanceof Date) {
        const copy = new Date(value.getTime());
        seen.set(value, copy);
        return copy;
    }
    if (value instanceof RegExp) {
        const copy = new RegExp(value.source, value.flags);
        seen.set(value, copy);
        return copy;
    }
    if (value instanceof ArrayBuffer) {
        const copy = value.slice(0);
        seen.set(value, copy);
        return copy;
    }
    if (ArrayBuffer.isView(value)) {
        const buffer = value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength);
        const copy = new value.constructor(buffer);
        seen.set(value, copy);
        return copy;
    }
    if (value instanceof Map) {
        const copy = new Map();
        seen.set(value, copy);
        for (const [key, entry] of value.entries()){
            copy.set(cloneStructured(key, seen), cloneStructured(entry, seen));
        }
        return copy;
    }
    if (value instanceof Set) {
        const copy = new Set();
        seen.set(value, copy);
        for (const entry of value.values()){
            copy.add(cloneStructured(entry, seen));
        }
        return copy;
    }
    if (Array.isArray(value)) {
        const copy = [];
        seen.set(value, copy);
        for (const entry of value){
            copy.push(cloneStructured(entry, seen));
        }
        return copy;
    }
    const copy = {};
    seen.set(value, copy);
    for (const key of Object.keys(value)){
        copy[key] = cloneStructured(value[key], seen);
    }
    return copy;
}
if (typeof globalThis.structuredClone === "undefined") {
    globalThis.structuredClone = structuredClone;
}
function normalizeAlgorithm(algorithm) {
    if (typeof algorithm === "string") return algorithm;
    return algorithm?.name || "";
}
function toBytes(data) {
    if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
    return new Uint8Array();
}
class CryptoKey {
}
class SubtleCrypto {
    async digest(algorithm, data) {
        const alg = normalizeAlgorithm(algorithm);
        const bytes = toBytes(data);
        const digest = op_crypto_digest(alg, bytes);
        const out = new Uint8Array(digest);
        return out.buffer.slice(out.byteOffset, out.byteOffset + out.byteLength);
    }
}
class Crypto {
    subtle;
    constructor(){
        this.subtle = new SubtleCrypto();
    }
    getRandomValues(buffer) {
        if (!ArrayBuffer.isView(buffer)) {
            throw new TypeError("Expected an ArrayBufferView");
        }
        const bytes = op_crypto_random(buffer.byteLength);
        const view = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        view.set(bytes);
        return buffer;
    }
    randomUUID() {
        const bytes = new Uint8Array(16);
        this.getRandomValues(bytes);
        bytes[6] = bytes[6] & 0x0f | 0x40;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        const hex = Array.from(bytes).map((b)=>b.toString(16).padStart(2, "0")).join("");
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
    }
}
if (typeof globalThis.Crypto === "undefined") {
    globalThis.Crypto = Crypto;
}
if (typeof globalThis.SubtleCrypto === "undefined") {
    globalThis.SubtleCrypto = SubtleCrypto;
}
if (typeof globalThis.CryptoKey === "undefined") {
    globalThis.CryptoKey = CryptoKey;
}
if (typeof globalThis.crypto === "undefined") {
    globalThis.crypto = new Crypto();
}
if (typeof globalThis.Atomics === "undefined") {
    globalThis.Atomics = {
        isLockFree () {
            return false;
        }
    };
}
class Headers {
    map;
    constructor(init){
        this.map = new Map();
        if (!init) return;
        if (init instanceof Headers) {
            for (const [key, value] of init.entries()){
                this.append(key, value);
            }
            return;
        }
        if (Array.isArray(init)) {
            for (const [key, value] of init){
                this.append(key, value);
            }
            return;
        }
        for (const [key, value] of Object.entries(init)){
            this.append(key, value);
        }
    }
    normalize(name) {
        return name.toLowerCase();
    }
    append(name, value) {
        const key = this.normalize(name);
        const existing = this.map.get(key);
        if (existing) {
            existing.push(value);
        } else {
            this.map.set(key, [
                value
            ]);
        }
    }
    set(name, value) {
        const key = this.normalize(name);
        this.map.set(key, [
            value
        ]);
    }
    get(name) {
        const key = this.normalize(name);
        const values = this.map.get(key);
        if (!values || values.length === 0) return null;
        return values.join(", ");
    }
    getAll(name) {
        const key = this.normalize(name);
        return this.map.get(key)?.slice() || [];
    }
    has(name) {
        return this.map.has(this.normalize(name));
    }
    delete(name) {
        this.map.delete(this.normalize(name));
    }
    entries() {
        const result = [];
        for (const [key, values] of this.map.entries()){
            for (const value of values){
                result.push([
                    key,
                    value
                ]);
            }
        }
        return result[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    keys() {
        return this.map.keys();
    }
    values() {
        const values = [];
        for (const [, vals] of this.map.entries()){
            values.push(...vals);
        }
        return values[Symbol.iterator]();
    }
    forEach(callback) {
        for (const [key, values] of this.map.entries()){
            for (const value of values){
                callback(value, key, this);
            }
        }
    }
}
function headersToObject(headers) {
    if (!headers) return {};
    if (headers instanceof Headers) {
        const out = {};
        for (const [key, values] of headers.map.entries()){
            if (key === "set-cookie") {
                out[key] = values.join("\n");
            } else {
                out[key] = values.join(", ");
            }
        }
        return out;
    }
    return {
        ...headers
    };
}
if (typeof globalThis.Headers === "undefined") {
    globalThis.Headers = Headers;
}
class ResponsePolyfill {
    status;
    headers;
    body;
    constructor(body = "", init = {}){
        this.status = init.status || 200;
        this.headers = new Headers(init.headers);
        this.body = body ?? "";
    }
    get ok() {
        return this.status >= 200 && this.status <= 299;
    }
    static json(value, init = {}) {
        const body = JSON.stringify(value);
        const headers = {
            "Content-Type": "application/json",
            ...init.headers || {}
        };
        return new Response(body, {
            ...init,
            headers
        });
    }
    static redirect(url, status = 302) {
        return new Response("", {
            status,
            headers: {
                Location: url
            }
        });
    }
    async text() {
        const body = this.body;
        if (body === undefined || body === null) return "";
        if (typeof body === "string") return body;
        if (body instanceof Uint8Array) return new TextDecoder().decode(body);
        if (body instanceof ReadableStream) return consumeReadableStream(body);
        return String(body);
    }
    async arrayBuffer() {
        const body = this.body;
        if (body === undefined || body === null) return new ArrayBuffer(0);
        if (body instanceof Uint8Array) return body.buffer.slice(body.byteOffset, body.byteOffset + body.byteLength);
        if (typeof body === "string") return new TextEncoder().encode(body).buffer;
        if (body instanceof ReadableStream) {
            const text = await consumeReadableStream(body);
            return new TextEncoder().encode(text).buffer;
        }
        return new TextEncoder().encode(String(body)).buffer;
    }
    async json() {
        const text = await this.text();
        return text ? JSON.parse(text) : null;
    }
    toJSON() {
        const payload = {
            status: this.status,
            headers: headersToObject(this.headers),
            body: this.body
        };
        const extra = this.body_base64;
        if (extra) {
            payload.body_base64 = extra;
        }
        return payload;
    }
}
const Response = globalThis.Response ?? ResponsePolyfill;
if (typeof globalThis.Response === "undefined") {
    globalThis.Response = Response;
}
class RequestPolyfill {
    url;
    method;
    headers;
    body;
    constructor(input, init = {}){
        if (input instanceof Request) {
            this.url = input.url;
            this.method = input.method;
            this.headers = new Headers(input.headers);
            this.body = input.body;
        } else {
            this.url = input;
            this.method = "GET";
            this.headers = new Headers();
            this.body = null;
        }
        if (init.method) {
            this.method = String(init.method).toUpperCase();
        }
        if (init.headers) {
            this.headers = new Headers(init.headers);
        }
        if (typeof init.body !== "undefined") {
            this.body = init.body;
        }
    }
    async text() {
        const body = this.body;
        if (body === undefined || body === null) return "";
        if (typeof body === "string") return body;
        if (body instanceof Uint8Array) return new TextDecoder().decode(body);
        if (body instanceof ReadableStream) return consumeReadableStream(body);
        return String(body);
    }
    async arrayBuffer() {
        const body = this.body;
        if (body === undefined || body === null) return new ArrayBuffer(0);
        if (body instanceof Uint8Array) return body.buffer.slice(body.byteOffset, body.byteOffset + body.byteLength);
        if (typeof body === "string") return new TextEncoder().encode(body).buffer;
        if (body instanceof ReadableStream) {
            const text = await consumeReadableStream(body);
            return new TextEncoder().encode(text).buffer;
        }
        return new TextEncoder().encode(String(body)).buffer;
    }
    async json() {
        const text = await this.text();
        return text ? JSON.parse(text) : null;
    }
}
const RequestImpl = globalThis.Request ?? RequestPolyfill;
if (typeof globalThis.Request === "undefined") {
    globalThis.Request = RequestImpl;
}
const fetchImpl = globalThis.fetch;
async function toBodyBytes(body) {
    if (body === undefined || body === null) return new Uint8Array(0);
    if (typeof body === "string") return new TextEncoder().encode(body);
    if (body instanceof Uint8Array) return body;
    if (body instanceof ReadableStream) {
        const text = await consumeReadableStream(body);
        return new TextEncoder().encode(text);
    }
    return new TextEncoder().encode(String(body));
}
if (typeof fetchImpl !== "function") {
    globalThis.fetch = async (input, init)=>{
        const request = input instanceof RequestImpl ? input : new RequestImpl(input, init);
        const headers = request.headers instanceof Headers ? headersToObject(request.headers) : headersToObject(new Headers(request.headers));
        const bodyBytes = await toBodyBytes(request.body);
        const response = await op_http_fetch(request.url, request.method, headers, bodyBytes);
        const body = await op_blob_get(response.body_id);
        return new Response(body, {
            status: response.status,
            headers: response.headers || {}
        });
    };
}
function resolveModulePath(referrer, specifier) {
    if (specifier.startsWith("/") || specifier.startsWith("http")) {
        return specifier;
    }
    if (!referrer || !specifier.startsWith(".")) {
        return specifier;
    }
    const base = referrer.split("/").slice(0, -1);
    const parts = specifier.split("/");
    const combined = [
        ...base,
        ...parts
    ];
    const resolved = [];
    for (const part of combined){
        if (!part || part === ".") continue;
        if (part === "..") {
            resolved.pop();
            continue;
        }
        resolved.push(part);
    }
    return `/${resolved.join("/")}`;
}
function normalizePath(path) {
    const parts = path.split("/");
    const stack = [];
    for (const part of parts){
        if (!part || part === ".") continue;
        if (part === "..") {
            stack.pop();
            continue;
        }
        stack.push(part);
    }
    return `/${stack.join("/")}`;
}
function dirname(path) {
    const parts = path.split("/");
    parts.pop();
    const dir = parts.join("/");
    return dir || "/";
}
function resolvePathFrom(baseDir, relativePath) {
    if (relativePath.startsWith("/")) return normalizePath(relativePath);
    return normalizePath(`${baseDir}/${relativePath}`);
}
function getCwd() {
    return globalThis.process?.env?.PWD || globalThis.process?.env?.INIT_CWD || "/";
}
function splitNodePath(value) {
    if (!value) return [];
    const delimiter = value.includes(";") ? ";" : ":";
    return value.split(delimiter).map((entry)=>entry.trim()).filter(Boolean);
}
function isBareSpecifier(specifier) {
    return !!specifier && !specifier.startsWith(".") && !specifier.startsWith("/") && !specifier.startsWith("http") && !specifier.startsWith("#");
}
function isImportsSpecifier(specifier) {
    return !!specifier && specifier.startsWith("#");
}
function hasExtension(path) {
    return /\.[^/]+$/.test(path);
}
function extensionOf(path) {
    const match = path.match(/(\.[^/.]+)$/);
    return match ? match[1].toLowerCase() : "";
}
function readModuleSource(path) {
    return op_read_module_source1(path);
}
function wrapRead(path) {
    return readModuleSource(path);
}
function readPackageJson(pkgRoot) {
    const info = wrapRead(`${pkgRoot}/package.json`);
    return JSON.parse(info.source);
}
function parsePackageSpecifier(specifier) {
    const parts = specifier.split("/");
    if (specifier.startsWith("@")) {
        return {
            name: parts.slice(0, 2).join("/"),
            subpath: parts.slice(2).join("/")
        };
    }
    return {
        name: parts[0],
        subpath: parts.slice(1).join("/")
    };
}
function resolveExportsTarget(target, mode) {
    if (typeof target === "string") return target;
    if (Array.isArray(target)) {
        for (const entry of target){
            const resolved = resolveExportsTarget(entry, mode);
            if (resolved) return resolved;
        }
        return null;
    }
    if (target && typeof target === "object") {
        const keys = [
            "bun",
            mode === "require" ? "require" : "import",
            "default"
        ];
        for (const key of keys){
            if (Object.prototype.hasOwnProperty.call(target, key)) {
                const resolved = resolveExportsTarget(target[key], mode);
                if (resolved) return resolved;
            }
        }
    }
    return null;
}
function applyExportPattern(pattern, subpath) {
    if (!pattern.includes("*")) return pattern;
    const [prefix, suffix] = pattern.split("*");
    if (!subpath.startsWith(prefix) || !subpath.endsWith(suffix)) return null;
    return subpath.slice(prefix.length, subpath.length - suffix.length);
}
function resolveExportsForSubpath(exportsField, subpath, mode) {
    if (typeof exportsField === "string" || Array.isArray(exportsField)) {
        if (subpath !== ".") return null;
        return resolveExportsTarget(exportsField, mode);
    }
    if (!exportsField || typeof exportsField !== "object") return null;
    const exportKeys = Object.keys(exportsField);
    const hasSubpathKeys = exportKeys.some((key)=>key.startsWith("."));
    if (!hasSubpathKeys) {
        if (subpath !== ".") return null;
        return resolveExportsTarget(exportsField, mode);
    }
    const direct = exportsField[subpath];
    if (direct !== undefined) {
        return resolveExportsTarget(direct, mode);
    }
    for (const key of exportKeys){
        if (!key.includes("*")) continue;
        const capture = applyExportPattern(key, subpath);
        if (capture === null) continue;
        const target = resolveExportsTarget(exportsField[key], mode);
        if (typeof target === "string") {
            return target.replace("*", capture);
        }
    }
    return null;
}
function resolvePackageEntry(pkgRoot, pkgJson, mode, subpath) {
    if (subpath) {
        return resolvePathFrom(pkgRoot, subpath);
    }
    if (mode === "import" && typeof pkgJson.module === "string") {
        return resolvePathFrom(pkgRoot, pkgJson.module);
    }
    if (typeof pkgJson.main === "string") {
        return resolvePathFrom(pkgRoot, pkgJson.main);
    }
    return resolvePathFrom(pkgRoot, "index");
}
function resolvePackageSpecifier(specifier, referrer, mode) {
    if (specifier.startsWith("@rollup/rollup-") && !globalThis.process?.env?.DEKA_ROLLUP_NATIVE) {
        specifier = "@rollup/wasm-node";
    }
    const { name, subpath } = parsePackageSpecifier(specifier);
    const searchDirs = [];
    const nodePathEntries = splitNodePath(globalThis.process?.env?.NODE_PATH);
    const cwd = getCwd();
    for (const entry of nodePathEntries){
        const dir = entry.startsWith("/") ? entry : resolvePathFrom(cwd, entry);
        searchDirs.push(dir);
    }
    const startDir = referrer ? dirname(referrer) : cwd;
    let current = startDir;
    while(true){
        searchDirs.push(`${current}/node_modules`);
        if (current === "/") break;
        current = dirname(current);
    }
    for (const base of searchDirs){
        const pkgRoot = `${base}/${name}`;
        let pkgJson;
        try {
            pkgJson = readPackageJson(pkgRoot);
        } catch (error) {
            continue;
        }
        if (pkgJson.exports) {
            const subpathKey = subpath ? `./${subpath}` : ".";
            const target = resolveExportsForSubpath(pkgJson.exports, subpathKey, mode);
            if (!target) {
                throw new Error(`Package subpath "${specifier}" is not exported by ${name}`);
            }
            return resolvePathFrom(pkgRoot, target.replace(/^\.\//, ""));
        }
        return resolvePackageEntry(pkgRoot, pkgJson, mode, subpath);
    }
    return null;
}
function resolveImportsSpecifier(specifier, referrer, mode) {
    const startDir = referrer ? dirname(referrer) : getCwd();
    let current = startDir;
    while(true){
        let pkgJson;
        try {
            pkgJson = readPackageJson(current);
        } catch (error) {}
        if (pkgJson?.imports) {
            const target = resolveExportsForSubpath(pkgJson.imports, specifier, mode);
            if (target) {
                return resolvePathFrom(current, target.replace(/^\.\//, ""));
            }
        }
        if (current === "/") break;
        current = dirname(current);
    }
    return null;
}
function resolveWithExtensions(path, context = {}) {
    let base = path;
    if (base.length > 1 && base.endsWith("/")) {
        base = base.slice(0, -1);
    }
    const attempts = [];
    try {
        return readModuleSource(base);
    } catch (error) {
        attempts.push(base);
    }
    if (hasExtension(base)) {
        const ext = extensionOf(base);
        const candidates = [
            base
        ];
        if (ext === ".js") {
            candidates.push(base.slice(0, -3) + ".ts");
        } else if (ext === ".jsx") {
            candidates.push(base.slice(0, -4) + ".tsx");
        }
        for (const candidate of candidates){
            try {
                return readModuleSource(candidate);
            } catch (error) {
                attempts.push(candidate);
            }
        }
        const spec = context.specifier || base;
        const ref = context.referrer ? ` from "${context.referrer}"` : "";
        throw new Error(`Unable to resolve module "${spec}"${ref}\nTried:\n- ${attempts.join("\n- ")}`);
    }
    const candidates = [
        ".tsx",
        ".jsx",
        ".ts",
        ".mjs",
        ".js",
        ".cjs",
        ".node",
        ".wasm",
        ".json",
        ".jsonc",
        ".toml",
        ".yaml",
        ".yml",
        ".txt",
        ".html",
        ".css"
    ];
    for (const ext of candidates){
        try {
            return readModuleSource(`${base}${ext}`);
        } catch (error) {
            attempts.push(`${base}${ext}`);
        }
    }
    for (const ext of candidates){
        try {
            return readModuleSource(`${base}/index${ext}`);
        } catch (error) {
            attempts.push(`${base}/index${ext}`);
        }
    }
    try {
        return readModuleSource(base);
    } catch (error) {
        attempts.push(base);
    }
    const spec = context.specifier || base;
    const ref = context.referrer ? ` from "${context.referrer}"` : "";
    throw new Error(`Unable to resolve module "${spec}"${ref}\nTried:\n- ${attempts.join("\n- ")}`);
}
const moduleCache = new Map();
let mainModule = null;
let dekaImportInstalled = false;
const requireExtensions = Object.create(null);
requireExtensions[".js"] = (mod, filename)=>{
    const info = readModuleSource(filename);
    const source = stripShebang(info.source);
    mod._compile(source, filename);
};
requireExtensions[".cjs"] = requireExtensions[".js"];
requireExtensions[".json"] = (mod, filename)=>{
    const info = readModuleSource(filename);
    mod.exports = JSON.parse(info.source);
};
requireExtensions[".mjs"] = ()=>{
    throw new Error("Cannot require ES module");
};
requireExtensions[".node"] = (mod, filename)=>{
    const createBuffer = globalThis.__dekaNapiCreateBuffer || ((data)=>Buffer.from(data));
    const reportError = globalThis.__dekaNapiReportError || ((error)=>{
        throw error;
    });
    mod.exports = op_napi_open1(filename, globalThis, createBuffer, reportError);
};
function waitForPromise(promise) {
    const sab = new SharedArrayBuffer(4);
    const view = new Int32Array(sab);
    let done = false;
    let result;
    let error;
    promise.then((value)=>{
        result = value;
        done = true;
        Atomics.store(view, 0, 1);
        Atomics.notify(view, 0, 1);
    }, (err)=>{
        error = err;
        done = true;
        Atomics.store(view, 0, 1);
        Atomics.notify(view, 0, 1);
    });
    while(!done){
        Atomics.wait(view, 0, 0, 100);
    }
    if (error) {
        throw error;
    }
    return result;
}
function stripShebang(source) {
    if (!source.startsWith("#!")) return source;
    const newline = source.indexOf("\n");
    if (newline === -1) return "";
    return `//${source.slice(2, newline)}\n${source.slice(newline + 1)}`;
}
function installDekaImport() {
    if (dekaImportInstalled) return;
    dekaImportInstalled = true;
    if (typeof globalThis.__dekaImportSync !== "function") {
        globalThis.__dekaImportSync = (specifier, referrer)=>{
            return loadModuleExportsInternal(specifier, referrer || null, "import", false);
        };
    }
    if (typeof globalThis.__dekaImportAsync !== "function") {
        globalThis.__dekaImportAsync = (specifier, referrer)=>{
            return Promise.resolve(loadModuleExportsInternal(specifier, referrer || null, "import", true));
        };
    }
    if (typeof globalThis.__dekaImport !== "function") {
        globalThis.__dekaImport = globalThis.__dekaImportSync;
    }
}
function findPackageType(path) {
    let current = path;
    let stopAt = "/";
    const marker = "/node_modules/";
    const markerIndex = path.lastIndexOf(marker);
    if (markerIndex !== -1) {
        const after = path.slice(markerIndex + marker.length);
        const parts = after.split("/").filter(Boolean);
        if (parts.length > 0) {
            const pkgName = parts[0].startsWith("@") && parts.length > 1 ? `${parts[0]}/${parts[1]}` : parts[0];
            stopAt = path.slice(0, markerIndex + marker.length + pkgName.length);
        }
    }
    for(let i = 0; i < 100; i++){
        const parent = dirname(current);
        if (!parent || parent === current) break;
        current = parent;
        try {
            const info = readModuleSource(`${current}/package.json`);
            const parsed = JSON.parse(info.source);
            const type = parsed?.type;
            if (type === "module" || type === "commonjs") {
                return type;
            }
        } catch  {}
        if (current === stopAt || current === "/") break;
    }
    return null;
}
function detectModuleKind(path, source) {
    const lower = path.toLowerCase();
    if (lower.endsWith(".cjs")) return "cjs";
    if (lower.endsWith(".mjs")) return "esm";
    if (lower.endsWith(".ts") || lower.endsWith(".tsx") || lower.endsWith(".jsx")) {
        return "esm";
    }
    const pkgType = findPackageType(path);
    if (pkgType === "module") return "esm";
    if (pkgType === "commonjs") return "cjs";
    if (/\bmodule\.exports\b/.test(source) || /\bexports\./.test(source) || /\brequire\(/.test(source)) {
        return "cjs";
    }
    if (/\bimport\.meta\b/.test(source) || /^\s*import\s/m.test(source) || /^\s*export\s/m.test(source)) {
        return "esm";
    }
    return "cjs";
}
function toFileUrl(path) {
    if (path.startsWith("file://")) return path;
    const normalized = path.startsWith("/") ? path : `/${path}`;
    return `file://${normalized}`;
}
function fromFileUrl(path) {
    if (!path) return null;
    if (!path.startsWith("file://")) return path;
    return path.replace(/^file:\/\//, "");
}
function isDekaExitError(error) {
    const message = error?.message || String(error);
    return message.includes("DekaExit:");
}
function wrapCjsExports(exportsValue) {
    if (exportsValue && typeof exportsValue === "object") {
        if (exportsValue.__esModule && "default" in exportsValue) {
            return exportsValue;
        }
        return {
            default: exportsValue,
            ...exportsValue
        };
    }
    if (typeof exportsValue === "function") {
        const wrapped = {
            default: exportsValue
        };
        for (const key of Object.keys(exportsValue)){
            wrapped[key] = exportsValue[key];
        }
        return wrapped;
    }
    return {
        default: exportsValue
    };
}
function debugPrint(message) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_RUN_DEBUG) return;
    const op = globalThis.__dekaOps;
    if (op?.op_stdout_write) {
        op.op_stdout_write(new TextEncoder().encode(`${message}\n`));
    }
}
function verbosePrint(message) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    const op = globalThis.__dekaOps;
    if (op?.op_stdout_write) {
        op.op_stdout_write(new TextEncoder().encode(`${message}\n`));
    }
}
function depsAreFresh(entry) {
    if (!entry.deps) return true;
    for (const dep of entry.deps){
        let info;
        try {
            info = readModuleSource(dep.path);
        } catch (error) {
            return false;
        }
        if (info.modified_ms !== dep.modifiedMs) {
            return false;
        }
    }
    return true;
}
function createRequire(referrer) {
    const requireFn = function require1(specifier) {
        verbosePrint(`[verbose] require ${specifier} from ${referrer || "<root>"}`);
        return loadModuleExports(specifier, referrer, "require");
    };
    requireFn.resolve = (specifier)=>{
        if (isBareSpecifier(specifier)) {
            const resolved = resolvePackageSpecifier(specifier, referrer, "require");
            if (!resolved) {
                throw new Error(`Unable to resolve package "${specifier}"`);
            }
            return resolved;
        }
        const resolved = resolveModulePath(referrer, specifier);
        const info = resolveWithExtensions(resolved, {
            referrer: referrer || undefined,
            specifier
        });
        return info.path;
    };
    requireFn.cache = Object.create(null);
    requireFn.main = mainModule || undefined;
    requireFn.extensions = requireExtensions;
    return requireFn;
}
globalThis.__dekaCreateRequire = createRequire;
globalThis.__dekaRequireExtensions = requireExtensions;
function loadCjsModule(info, mode, isMain) {
    const cacheKey = info.path;
    const entry = moduleCache.get(cacheKey);
    if (entry && entry.modifiedMs === info.modified_ms) {
        return mode === "require" ? entry.exports : wrapCjsExports(entry.exports);
    }
    installDekaImport();
    verbosePrint(`[verbose] exec cjs ${info.path}`);
    debugPrint(`[deka-run] load ${info.path}`);
    const module1 = {
        id: info.path,
        filename: info.path,
        loaded: false,
        exports: {},
        require: undefined,
        parent: null,
        children: [],
        paths: [],
        path: info.path.split("/").slice(0, -1).join("/") || "/"
    };
    const localRequire = createRequire(info.path);
    module1.require = localRequire;
    if (isMain) {
        mainModule = module1;
        localRequire.main = module1;
    }
    const dirname = info.path.split("/").slice(0, -1).join("/") || "/";
    const source = info.source.replace(/\bimport\s*\(/g, "__dekaImportAsync(");
    const wrapper = new Function("require", "module", "exports", "__filename", "__dirname", "__dekaImport", "__dekaImportAsync", source);
    moduleCache.set(cacheKey, {
        exports: module1.exports,
        modifiedMs: info.modified_ms,
        deps: [],
        kind: "cjs",
        loading: true
    });
    try {
        const localImport = (specifier)=>globalThis.__dekaImport(specifier, info.path);
        const localImportAsync = (specifier)=>Promise.resolve(loadModuleExportsInternal(specifier, info.path, "import", true));
        wrapper(localRequire, module1, module1.exports, info.path, dirname, localImport, localImportAsync);
        debugPrint(`[deka-run] executed ${info.path}`);
        verbosePrint(`[verbose] done cjs ${info.path}`);
    } catch (error) {
        if (isDekaExitError(error)) {
            throw error;
        }
        const message = error?.stack || error?.message || String(error);
        throw new Error(`Module execution failed for ${info.path}\n\n${message}`);
    }
    module1.loaded = true;
    const cached = moduleCache.get(cacheKey);
    if (cached) {
        cached.exports = module1.exports;
        cached.modifiedMs = info.modified_ms;
        cached.deps = [];
        cached.kind = "cjs";
        cached.loading = false;
    } else {
        moduleCache.set(cacheKey, {
            exports: module1.exports,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs",
            loading: false
        });
    }
    return mode === "require" ? module1.exports : wrapCjsExports(module1.exports);
}
function loadTextModule(info, mode) {
    const cacheKey = info.path;
    const value = info.source;
    if (mode === "require") {
        moduleCache.set(cacheKey, {
            exports: value,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs"
        });
        return value;
    }
    const exports = wrapCjsExports(value);
    moduleCache.set(cacheKey, {
        exports,
        modifiedMs: info.modified_ms,
        deps: []
    });
    return exports;
}
function loadHtmlModule(info, mode) {
    const cacheKey = info.path;
    const value = new String(info.source);
    value.__dekaHtml = true;
    value.__dekaHtmlPath = info.path;
    if (mode === "require") {
        moduleCache.set(cacheKey, {
            exports: value,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs"
        });
        return value;
    }
    const exports = wrapCjsExports(value);
    moduleCache.set(cacheKey, {
        exports,
        modifiedMs: info.modified_ms,
        deps: []
    });
    return exports;
}
function stripJsonc(input) {
    const withoutBlock = input.replace(/\/\*[\s\S]*?\*\//g, "");
    const withoutLine = withoutBlock.replace(/^\s*\/\/.*$/gm, "");
    return withoutLine.replace(/,\s*([}\]])/g, "$1");
}
function loadJsoncModule(info, mode) {
    let parsed;
    try {
        parsed = JSON.parse(stripJsonc(info.source));
    } catch (error) {
        const message = error?.message ? error.message : String(error);
        throw new Error(`Failed to parse JSONC module ${info.path}\\n\\n${message}`);
    }
    if (mode === "require") {
        moduleCache.set(info.path, {
            exports: parsed,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs"
        });
        return parsed;
    }
    const exports = wrapCjsExports(parsed);
    moduleCache.set(info.path, {
        exports,
        modifiedMs: info.modified_ms,
        deps: []
    });
    return exports;
}
function loadModuleExportsInternal(specifier, referrer, mode, asyncMode) {
    referrer = fromFileUrl(referrer);
    specifier = fromFileUrl(specifier) || specifier;
    if (specifier === "#module-sync-enabled") {
        return mode === "require" ? false : {
            default: false
        };
    }
    verbosePrint(`[verbose] ${mode} ${specifier} from ${referrer || "<root>"} async=${asyncMode ? "1" : "0"}`);
    if (specifier === "node:worker_threads" || specifier === "worker_threads") {
        const raw = globalThis.process?.env?.DEKA_WORKER_THREADS;
        const enabled = raw === undefined || raw === "" || raw === "1" || raw === "true" || raw === "yes" || raw === "on";
        if (!enabled) {
            throw new Error("worker_threads disabled");
        }
    }
    if (specifier.includes("/rollup/dist/native.js") || specifier.endsWith("rollup/dist/native.js")) {
        return loadModuleExportsInternal("@rollup/wasm-node/dist/native.js", referrer, mode, asyncMode);
    }
    const builtin = getBuiltinModule(specifier);
    if (builtin) {
        return mode === "require" ? builtin : {
            default: builtin,
            ...builtin
        };
    }
    if (specifier === "fsevents") {
        const err = new Error("Cannot find module 'fsevents'");
        err.code = "MODULE_NOT_FOUND";
        throw err;
    }
    if (isImportsSpecifier(specifier)) {
        const resolved = resolveImportsSpecifier(specifier, referrer, mode);
        if (!resolved) {
            throw new Error(`Unable to resolve import map specifier "${specifier}"`);
        }
        return loadModuleExportsInternal(resolved, referrer, mode, asyncMode);
    }
    if (isBareSpecifier(specifier)) {
        const resolved = resolvePackageSpecifier(specifier, referrer, mode);
        if (!resolved) {
            throw new Error(`Unable to resolve package "${specifier}"`);
        }
        return loadModuleExportsInternal(resolved, referrer, mode, asyncMode);
    }
    const resolved = resolveModulePath(referrer, specifier);
    if (resolved.includes("/rollup/dist/native.js") || resolved.endsWith("rollup/dist/native.js")) {
        return loadModuleExportsInternal("@rollup/wasm-node/dist/native.js", referrer, mode, asyncMode);
    }
    const info = resolveWithExtensions(resolved, {
        referrer: referrer || undefined,
        specifier
    });
    verbosePrint(`[verbose] resolved ${specifier} -> ${info.path}`);
    debugPrint(`[deka-run] load ${info.path}`);
    if (info.source.startsWith("#!")) {
        info.source = stripShebang(info.source);
    }
    const cacheKey = info.path;
    const entry = moduleCache.get(cacheKey);
    if (entry && entry.modifiedMs === info.modified_ms && depsAreFresh(entry)) {
        if (entry.kind === "cjs") {
            return mode === "require" ? entry.exports : wrapCjsExports(entry.exports);
        }
        return entry.exports;
    }
    let moduleKind = detectModuleKind(info.path, info.source);
    if (info.path.endsWith("bindings_wasm.js")) {
        const cjsModule = /\bmodule\.exports\b/.test(info.source);
        const cjsExports = /\bexports\./.test(info.source);
        const cjsRequire = /\brequire\(/.test(info.source);
        if (cjsModule || cjsExports || cjsRequire) {
            moduleKind = "cjs";
        }
        debugPrint(`[deka-run] module-kind ${moduleKind} for ${info.path}`);
        debugPrint(`[deka-run] bindings_wasm cjs flags module=${cjsModule} exports=${cjsExports} require=${cjsRequire}`);
    }
    if (info.path.endsWith(".node")) {
        const isMain = referrer === null;
        return loadCjsModule(info, mode, isMain);
    }
    if (moduleKind === "cjs") {
        const isMain = referrer === null;
        return loadCjsModule(info, mode, isMain);
    }
    if (info.path.endsWith(".jsonc")) {
        return loadJsoncModule(info, mode);
    }
    if (info.path.endsWith(".json")) {
        let parsed;
        try {
            parsed = JSON.parse(info.source);
        } catch (error) {
            const message = error?.message ? error.message : String(error);
            throw new Error(`Failed to parse JSON module ${info.path}\n\n${message}`);
        }
        if (mode === "require") {
            moduleCache.set(cacheKey, {
                exports: parsed,
                modifiedMs: info.modified_ms,
                deps: [],
                kind: "cjs"
            });
            return parsed;
        }
        const exports = wrapCjsExports(parsed);
        moduleCache.set(cacheKey, {
            exports,
            modifiedMs: info.modified_ms,
            deps: []
        });
        return exports;
    }
    if (info.path.endsWith(".html")) {
        return loadHtmlModule(info, mode);
    }
    if (info.path.endsWith(".module.css")) {
        const bundled = op_bundle_css1(info.path, {
            css_modules: true,
            minify: true
        });
        const exports = bundled.exports || {};
        if (mode === "require") {
            moduleCache.set(cacheKey, {
                exports,
                modifiedMs: info.modified_ms,
                deps: [],
                kind: "cjs"
            });
            return exports;
        }
        const wrapped = wrapCjsExports(exports);
        moduleCache.set(cacheKey, {
            exports: wrapped,
            modifiedMs: info.modified_ms,
            deps: []
        });
        return wrapped;
    }
    if (info.path.endsWith(".txt") || info.path.endsWith(".css") || info.path.endsWith(".toml") || info.path.endsWith(".yaml") || info.path.endsWith(".yml")) {
        return loadTextModule(info, mode);
    }
    let transformed;
    try {
        transformed = op_transform_module1(info.path, info.source);
    } catch (error) {
        const message = error?.message ? error.message : String(error);
        if (message.includes("Validation Error")) {
            throw new Error(message);
        }
        throw new Error(`Module transform failed for ${info.path}\n\n${message}`);
    }
    if (mode === "require" && transformed.top_level_await) {
        throw new Error(`Cannot require() ${info.path} because it uses top-level await.\n` + "Use import() or static import instead.");
    }
    const exports = {};
    const module1 = {
        exports
    };
    const deps = transformed.deps.filter((spec)=>spec.startsWith(".") || spec.startsWith("/")).map((spec)=>{
        const depPath = resolveModulePath(info.path, spec);
        const depInfo = resolveWithExtensions(depPath, {
            referrer: info.path,
            specifier: spec
        });
        return {
            path: depInfo.path,
            modifiedMs: depInfo.modified_ms
        };
    });
    const importMeta = {
        url: toFileUrl(info.path)
    };
    const hasTopLevelAwait = transformed.top_level_await;
    const rewrittenCode = transformed.code.replace(/\bimport\s*\(/g, "__dekaImportAsync(");
    const wrappedCode = hasTopLevelAwait ? `return (async () => {\n${rewrittenCode}\n})()` : rewrittenCode;
    const wrapper = new Function("exports", "module", "__dekaImport", "__dekaImportAsync", "require", "__dekaImportMeta", wrappedCode);
    moduleCache.set(cacheKey, {
        exports: module1.exports,
        modifiedMs: info.modified_ms,
        deps
    });
    try {
        verbosePrint(`[verbose] exec esm ${info.path}`);
        const result = wrapper(module1.exports, module1, (spec)=>loadModuleExportsInternal(spec, info.path, "import", false), (spec)=>Promise.resolve(loadModuleExportsInternal(spec, info.path, "import", true)), createRequire(info.path), importMeta);
        if (result && typeof result.then === "function") {
            if (asyncMode) {
                return result.then(()=>{
                    if (module1.exports.default === undefined && globalThis.app !== undefined) {
                        module1.exports.default = globalThis.app;
                    }
                    return module1.exports;
                });
            }
            waitForPromise(result);
        }
        verbosePrint(`[verbose] done esm ${info.path}`);
    } catch (error) {
        if (isDekaExitError(error)) {
            throw error;
        }
        const message = error?.stack || error?.message || String(error);
        throw new Error(`Module execution failed for ${info.path}\n\n${message}`);
    }
    if (module1.exports.default === undefined && globalThis.app !== undefined) {
        module1.exports.default = globalThis.app;
    }
    return module1.exports;
}
function loadModuleExports(specifier, referrer, mode = "import") {
    return loadModuleExportsInternal(specifier, referrer, mode, false);
}
function getBuiltinModule(specifier) {
    if (specifier === "deka") return globalThis.__deka;
    if (specifier === "node:buffer" || specifier === "buffer") {
        return {
            Buffer: globalThis.Buffer
        };
    }
    if (specifier === "esbuild") {
        const env = globalThis.process?.env || {};
        if (env.DEKA_ESBUILD_SHIM === "1" || env.DEKA_ESBUILD_SHIM === "true") {
            return globalThis.__dekaEsbuild;
        }
        return undefined;
    }
    if (specifier === "node:assert" || specifier === "assert") {
        return globalThis.__dekaNodeAssert;
    }
    if (specifier === "node:console" || specifier === "console") {
        return globalThis.__dekaNodeConsole || {
            console: globalThis.console
        };
    }
    if (specifier === "node:events" || specifier === "events") {
        return globalThis.__dekaNodeEvents;
    }
    if (specifier === "node:process" || specifier === "process") {
        return globalThis.process;
    }
    if (specifier === "node:timers" || specifier === "timers") {
        return globalThis.__dekaNodeTimers;
    }
    if (specifier === "node:timers/promises" || specifier === "timers/promises") {
        return globalThis.__dekaNodeTimersPromises;
    }
    if (specifier === "node:util" || specifier === "util") {
        return globalThis.__dekaNodeUtil;
    }
    if (specifier === "node:util/types" || specifier === "util/types") {
        return globalThis.__dekaNodeUtil?.types;
    }
    if (specifier === "node:os" || specifier === "os") {
        return globalThis.__dekaNodeOs;
    }
    if (specifier === "node:fs" || specifier === "fs") {
        return globalThis.__dekaNodeFs;
    }
    if (specifier === "node:fs/promises" || specifier === "fs/promises") {
        return globalThis.__dekaNodeFs?.promises;
    }
    if (specifier === "node:path" || specifier === "path") {
        return globalThis.__dekaNodePath;
    }
    if (specifier === "node:constants" || specifier === "constants") {
        return globalThis.__dekaNodeConstants;
    }
    if (specifier === "node:path/posix" || specifier === "path/posix") {
        return globalThis.__dekaNodePath?.posix;
    }
    if (specifier === "node:path/win32" || specifier === "path/win32") {
        return globalThis.__dekaNodePath?.win32;
    }
    if (specifier === "node:string_decoder" || specifier === "string_decoder") {
        return globalThis.__dekaNodeStringDecoder;
    }
    if (specifier === "node:querystring" || specifier === "querystring") {
        return globalThis.__dekaNodeQuerystring;
    }
    if (specifier === "node:crypto" || specifier === "crypto") {
        return globalThis.__dekaNodeCrypto;
    }
    if (specifier === "node:stream/web" || specifier === "stream/web") {
        return globalThis.__dekaNodeStreamWeb || globalThis;
    }
    if (specifier === "node:stream" || specifier === "stream") {
        return globalThis.__dekaNodeStream;
    }
    if (specifier === "node:stream/promises" || specifier === "stream/promises") {
        return globalThis.__dekaNodeStreamPromises;
    }
    if (specifier === "node:url" || specifier === "url") {
        return globalThis.__dekaNodeUrl;
    }
    if (specifier === "node:tty" || specifier === "tty") {
        return globalThis.__dekaNodeTty;
    }
    if (specifier === "node:punycode" || specifier === "punycode") {
        return globalThis.__dekaNodePunycode;
    }
    if (specifier === "node:diagnostics_channel" || specifier === "diagnostics_channel") {
        return globalThis.__dekaNodeDiagnosticsChannel;
    }
    if (specifier === "node:async_hooks" || specifier === "async_hooks") {
        return globalThis.__dekaNodeAsyncHooks;
    }
    if (specifier === "node:perf_hooks" || specifier === "perf_hooks") {
        return globalThis.__dekaNodePerfHooks;
    }
    if (specifier === "node:http" || specifier === "http") {
        return globalThis.__dekaNodeHttp;
    }
    if (specifier === "node:https" || specifier === "https") {
        return globalThis.__dekaNodeHttps;
    }
    if (specifier === "node:tls" || specifier === "tls") {
        return globalThis.__dekaNodeTls;
    }
    if (specifier === "node:sqlite" || specifier === "sqlite") {
        return globalThis.__dekaNodeSqlite;
    }
    if (specifier === "node:test" || specifier === "test") {
        return globalThis.__dekaNodeTest;
    }
    if (specifier === "node:readline" || specifier === "readline") {
        return globalThis.__dekaNodeReadline;
    }
    if (specifier === "node:domain" || specifier === "domain") {
        return globalThis.__dekaNodeDomain;
    }
    if (specifier === "node:http2" || specifier === "http2") {
        return globalThis.__dekaNodeHttp2;
    }
    if (specifier === "node:module" || specifier === "module") {
        return globalThis.__dekaNodeModule;
    }
    if (specifier === "node:trace_events" || specifier === "trace_events") {
        return globalThis.__dekaNodeTraceEvents;
    }
    if (specifier === "node:inspector" || specifier === "inspector") {
        return globalThis.__dekaNodeInspector;
    }
    if (specifier === "node:dgram" || specifier === "dgram") {
        return globalThis.__dekaNodeDgram;
    }
    if (specifier === "node:dns" || specifier === "dns") {
        return globalThis.__dekaNodeDns;
    }
    if (specifier === "node:dns/promises" || specifier === "dns/promises") {
        return globalThis.__dekaNodeDns?.promises;
    }
    if (specifier === "node:net" || specifier === "net") {
        return globalThis.__dekaNodeNet;
    }
    if (specifier === "node:zlib" || specifier === "zlib") {
        return globalThis.__dekaNodeZlib;
    }
    if (specifier === "node:child_process" || specifier === "child_process") {
        return globalThis.__dekaNodeChildProcess;
    }
    if (specifier === "node:cluster" || specifier === "cluster") {
        return globalThis.__dekaNodeCluster;
    }
    if (specifier === "node:sys" || specifier === "sys") {
        return globalThis.__dekaNodeSys;
    }
    if (specifier === "node:v8" || specifier === "v8") {
        return globalThis.__dekaNodeV8;
    }
    if (specifier === "node:vm" || specifier === "vm") {
        return globalThis.__dekaNodeVm;
    }
    if (specifier === "node:wasi" || specifier === "wasi") {
        return globalThis.__dekaNodeWasi;
    }
    if (specifier === "node:worker_threads" || specifier === "worker_threads") {
        return globalThis.__dekaNodeWorkerThreads;
    }
    if (specifier === "node:repl" || specifier === "repl") {
        return globalThis.__dekaNodeRepl;
    }
    if (specifier === "node:ws" || specifier === "ws") {
        return globalThis.__dekaWs;
    }
    if (!specifier.startsWith("deka/")) return null;
    switch(specifier){
        case "deka/router":
            return globalThis.__dekaRouter;
        case "deka/sqlite":
            return globalThis.__dekaSqlite;
        case "deka/t4":
            return globalThis.__dekaT4;
        case "deka/postgres":
            return globalThis.__dekaPostgres;
        case "deka/docker":
            return globalThis.__dekaDocker;
        case "deka/redis":
            return globalThis.__dekaRedis;
        case "deka/jsx-runtime":
            return globalThis.__dekaJsxRuntime;
        case "deka/jsx-dev-runtime":
            return globalThis.__dekaJsxDevRuntime;
        default:
            return null;
    }
}
if (typeof globalThis.require === "undefined") {
    globalThis.require = createRequire(null);
}
const baseOps2 = Deno.core.ops;
function formatOpArg2(arg) {
    if (arg === null) return "null";
    if (arg === undefined) return "undefined";
    if (typeof arg === "string") return `string(${arg.length})`;
    if (typeof arg === "number") return `number(${arg})`;
    if (typeof arg === "boolean") return `bool(${arg})`;
    if (typeof arg === "bigint") return `bigint(${arg.toString()})`;
    if (ArrayBuffer.isView(arg)) {
        return `${arg.constructor.name}(${arg.byteLength})`;
    }
    if (arg instanceof ArrayBuffer) {
        return `ArrayBuffer(${arg.byteLength})`;
    }
    if (Array.isArray(arg)) return `Array(${arg.length})`;
    if (typeof arg === "object") return `object`;
    return typeof arg;
}
function shouldSkipOpLog2(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE_FILTER) return false;
    if (name !== "op_read_module_source") return false;
    const first = args[0];
    if (typeof first !== "string") return false;
    if (first.endsWith("/package.json")) return true;
    if (first.endsWith("package.json")) return true;
    return false;
}
function logOpCall2(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog2(name, args)) return;
    const writer = baseOps2.op_stdout_write;
    if (!writer) return;
    const summary = args.map(formatOpArg2).join(", ");
    writer(new TextEncoder().encode(`[op] ${name} ${summary}\n`));
}
function logOpReturn2(name, startedAt, args, value) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog2(name, args)) {
        return;
    }
    const writer = baseOps2.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const summary = formatOpArg2(value);
    writer(new TextEncoder().encode(`[op] ${name} -> ${summary} (${elapsed}ms)\n`));
}
function logOpError2(name, startedAt, args, error) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog2(name, args)) {
        return;
    }
    const writer = baseOps2.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const message = error?.message || String(error);
    writer(new TextEncoder().encode(`[op] ${name} ! ${message} (${elapsed}ms)\n`));
}
function wrapOps2(ops) {
    const wrapped = {};
    for (const [name, fn] of Object.entries(ops)){
        if (typeof fn !== "function") continue;
        if (name === "op_stdout_write" || name === "op_stderr_write") {
            wrapped[name] = fn;
            continue;
        }
        wrapped[name] = (...args)=>{
            logOpCall2(name, args);
            const startedAt = Date.now();
            try {
                const result = fn(...args);
                if (result && typeof result.then === "function") {
                    return result.then((value)=>{
                        logOpReturn2(name, startedAt, args, value);
                        return value;
                    }).catch((error)=>{
                        logOpError2(name, startedAt, args, error);
                        throw error;
                    });
                }
                logOpReturn2(name, startedAt, args, result);
                return result;
            } catch (error) {
                logOpError2(name, startedAt, args, error);
                throw error;
            }
        };
    }
    return wrapped;
}
const ops2 = globalThis.process?.env?.DEKA_VERBOSE ? wrapOps2(baseOps2) : baseOps2;
globalThis.__dekaOps = ops2;
const { op_read_handler_source: op_read_handler_source2, op_read_module_source: op_read_module_source2, op_read_env: op_read_env2, op_stdout_write: op_stdout_write2, op_stderr_write: op_stderr_write2, op_execute_isolate: op_execute_isolate2, op_transform_module: op_transform_module2, op_bundle_browser: op_bundle_browser2, op_bundle_browser_assets: op_bundle_browser_assets2, op_bundle_css: op_bundle_css2, op_transform_css: op_transform_css2, op_tailwind_process: op_tailwind_process2, op_read_file: op_read_file2, op_fs_exists: op_fs_exists2, op_fs_stat: op_fs_stat2, op_fs_read_dir: op_fs_read_dir2, op_fs_mkdir: op_fs_mkdir2, op_fs_remove_file: op_fs_remove_file2, op_fs_append: op_fs_append2, op_fs_append_bytes: op_fs_append_bytes2, op_fs_open: op_fs_open2, op_fs_close: op_fs_close2, op_fs_read: op_fs_read2, op_fs_write: op_fs_write2, op_fs_copy_file: op_fs_copy_file2, op_zlib_gzip: op_zlib_gzip2, op_write_file: op_write_file2, op_write_file_base64: op_write_file_base642, op_introspect_stats: op_introspect_stats2, op_introspect_top: op_introspect_top2, op_introspect_workers: op_introspect_workers2, op_introspect_isolate: op_introspect_isolate2, op_introspect_kill_isolate: op_introspect_kill_isolate2, op_introspect_requests: op_introspect_requests2, op_introspect_evict: op_introspect_evict2, op_set_introspect_profiling: op_set_introspect_profiling2, op_ws_send: op_ws_send2, op_ws_send_binary: op_ws_send_binary2, op_ws_close: op_ws_close2, op_blob_create: op_blob_create2, op_blob_get: op_blob_get2, op_blob_size: op_blob_size2, op_blob_type: op_blob_type2, op_blob_slice: op_blob_slice2, op_blob_drop: op_blob_drop2, op_stream_create: op_stream_create2, op_stream_enqueue: op_stream_enqueue2, op_stream_close: op_stream_close2, op_stream_read: op_stream_read2, op_stream_drop: op_stream_drop2, op_crypto_random: op_crypto_random2, op_crypto_digest: op_crypto_digest2, op_crypto_hmac: op_crypto_hmac2, op_crypto_pbkdf2: op_crypto_pbkdf22, op_crypto_aes_gcm_encrypt: op_crypto_aes_gcm_encrypt2, op_crypto_aes_gcm_decrypt: op_crypto_aes_gcm_decrypt2, op_crypto_key_info: op_crypto_key_info2, op_crypto_key_from_secret: op_crypto_key_from_secret2, op_crypto_key_from_pem: op_crypto_key_from_pem2, op_crypto_key_from_der: op_crypto_key_from_der2, op_crypto_key_from_jwk: op_crypto_key_from_jwk2, op_crypto_key_export_pem: op_crypto_key_export_pem2, op_crypto_key_export_der: op_crypto_key_export_der2, op_crypto_key_export_jwk: op_crypto_key_export_jwk2, op_crypto_key_public: op_crypto_key_public2, op_crypto_key_equals: op_crypto_key_equals2, op_crypto_sign: op_crypto_sign2, op_crypto_verify: op_crypto_verify2, op_crypto_generate_keypair: op_crypto_generate_keypair2, op_crypto_get_curves: op_crypto_get_curves2, op_crypto_ecdh_new: op_crypto_ecdh_new2, op_crypto_ecdh_generate: op_crypto_ecdh_generate2, op_crypto_ecdh_get_public: op_crypto_ecdh_get_public2, op_crypto_ecdh_get_private: op_crypto_ecdh_get_private2, op_crypto_ecdh_set_private: op_crypto_ecdh_set_private2, op_crypto_ecdh_compute_secret: op_crypto_ecdh_compute_secret2, op_crypto_ecdh_convert: op_crypto_ecdh_convert2, op_url_parse: op_url_parse2, op_napi_open: op_napi_open2, op_http_fetch: op_http_fetch2, op_process_spawn: op_process_spawn2, op_process_spawn_sync: op_process_spawn_sync2, op_process_read_stdout: op_process_read_stdout2, op_process_read_stderr: op_process_read_stderr2, op_process_write_stdin: op_process_write_stdin2, op_process_close_stdin: op_process_close_stdin2, op_process_wait: op_process_wait2, op_process_kill: op_process_kill2, op_sleep: op_sleep2, op_udp_bind: op_udp_bind2, op_udp_send: op_udp_send2, op_udp_recv: op_udp_recv2, op_udp_close: op_udp_close2, op_udp_local_addr: op_udp_local_addr2, op_udp_peer_addr: op_udp_peer_addr2, op_udp_connect: op_udp_connect2, op_udp_disconnect: op_udp_disconnect2, op_udp_set_broadcast: op_udp_set_broadcast2, op_udp_set_ttl: op_udp_set_ttl2, op_udp_set_multicast_ttl: op_udp_set_multicast_ttl2, op_udp_set_multicast_loop: op_udp_set_multicast_loop2, op_udp_set_multicast_if: op_udp_set_multicast_if2, op_udp_join_multicast: op_udp_join_multicast2, op_udp_leave_multicast: op_udp_leave_multicast2, op_udp_set_recv_buffer_size: op_udp_set_recv_buffer_size2, op_udp_set_send_buffer_size: op_udp_set_send_buffer_size2, op_udp_get_recv_buffer_size: op_udp_get_recv_buffer_size2, op_udp_get_send_buffer_size: op_udp_get_send_buffer_size2, op_dns_lookup: op_dns_lookup2, op_dns_reverse: op_dns_reverse2, op_tcp_listen: op_tcp_listen2, op_tcp_accept: op_tcp_accept2, op_tcp_connect: op_tcp_connect2, op_tcp_read: op_tcp_read2, op_tcp_write: op_tcp_write2, op_tcp_close: op_tcp_close2, op_tcp_shutdown: op_tcp_shutdown2, op_tcp_local_addr: op_tcp_local_addr2, op_tcp_peer_addr: op_tcp_peer_addr2, op_tcp_listener_addr: op_tcp_listener_addr2, op_tcp_listener_close: op_tcp_listener_close2 } = ops2;
class ReadableStreamController1 {
    streamId;
    queue;
    resolvers;
    state;
    constructor(streamId, queue, resolvers, state){
        this.streamId = streamId;
        this.queue = queue;
        this.resolvers = resolvers;
        this.state = state;
    }
    enqueue(chunk) {
        if (this.queue && this.resolvers) {
            const entry = {
                value: chunk,
                done: false
            };
            const resolver = this.resolvers.shift();
            if (resolver) {
                resolver(entry);
                return;
            }
            this.queue.push(entry);
            return;
        }
        if (this.streamId !== undefined) {
            const bytes = normalizeChunk1(chunk);
            op_stream_enqueue2(this.streamId, bytes);
        }
    }
    close() {
        if (this.queue && this.resolvers) {
            const entry = {
                done: true
            };
            if (this.state) {
                this.state.closed = true;
            }
            const resolver = this.resolvers.shift();
            if (resolver) {
                resolver(entry);
                return;
            }
            this.queue.push(entry);
            return;
        }
        if (this.streamId !== undefined) {
            op_stream_close2(this.streamId);
        }
    }
    error(_reason) {
        if (this.state) {
            this.state.closed = true;
        }
        this.close();
    }
}
class ReadableStreamDefaultReader1 {
    streamId;
    queue;
    resolvers;
    stream;
    constructor(streamId, queue, resolvers, stream){
        this.streamId = streamId;
        this.queue = queue;
        this.resolvers = resolvers;
        this.stream = stream;
    }
    async read() {
        if (this.queue && this.resolvers) {
            const entry = this.queue.shift();
            if (entry) {
                return entry;
            }
            if (this.stream?.state?.closed) {
                return {
                    done: true
                };
            }
            if (this.stream?.source && this.stream?.controller) {
                const maybe = this.stream.source.pull?.(this.stream.controller);
                if (maybe && typeof maybe.then === "function") {
                    await maybe;
                }
                const pulled = this.queue.shift();
                if (pulled) {
                    return pulled;
                }
            }
            return new Promise((resolve)=>{
                this.resolvers?.push(resolve);
            });
        }
        if (this.streamId !== undefined) {
            const result = await op_stream_read2(this.streamId);
            if (result.done) {
                return {
                    done: true
                };
            }
            if (result.chunk) {
                return {
                    value: result.chunk,
                    done: false
                };
            }
        }
        return {
            done: true
        };
    }
    releaseLock() {}
}
class ReadableStreamDefaultController1 {
    desiredSize = null;
    enqueue() {}
    close() {}
    error() {}
}
class ReadableByteStreamController1 extends ReadableStreamDefaultController1 {
}
class ReadableStreamBYOBRequest1 {
    view;
    constructor(view){
        this.view = view;
    }
    respond() {}
    respondWithNewView() {}
}
class ReadableStreamBYOBReader1 {
    read() {
        return Promise.resolve({
            value: undefined,
            done: true
        });
    }
    releaseLock() {}
}
class ReadableStream1 {
    streamId;
    queue;
    resolvers;
    state;
    raw;
    source;
    controller;
    constructor(source = {}, options = {}){
        this.raw = !!options.raw;
        this.state = {
            closed: false
        };
        if (this.raw) {
            this.queue = [];
            this.resolvers = [];
        } else {
            this.streamId = op_stream_create2();
        }
        this.source = source;
        const controller = new ReadableStreamController1(this.streamId, this.queue, this.resolvers, this.state);
        this.controller = controller;
        source.start?.(controller);
    }
    getReader() {
        return new ReadableStreamDefaultReader1(this.streamId, this.queue, this.resolvers, this);
    }
    async pipeTo(destination, options = {}) {
        const reader = this.getReader();
        const writer = destination.getWriter();
        const { preventClose, preventAbort, preventCancel, signal } = options;
        if (signal) {
            if (signal.aborted) {
                if (!preventAbort) await writer.abort(signal.reason);
                throw signal.reason;
            }
            signal.addEventListener("abort", ()=>{
                if (!preventAbort) {
                    writer.abort(signal.reason);
                }
            }, {
                once: true
            });
        }
        try {
            for(;;){
                const { value, done } = await reader.read();
                if (done) break;
                await writer.write(value);
            }
            if (!preventClose) {
                await writer.close();
            }
        } catch (err) {
            if (!preventAbort) {
                await writer.abort(err);
            }
            if (!preventCancel) {
                this._closeRaw();
            }
            throw err;
        }
    }
    pipeThrough(transform, options) {
        const internal = transform._transformer;
        if (internal) {
            const reader = this.getReader();
            return new ReadableStream1({
                async pull (controller) {
                    const { value, done } = await reader.read();
                    if (done) {
                        internal.flush?.(controller);
                        controller.close();
                        return;
                    }
                    if (internal.transform) {
                        internal.transform(value, controller);
                        return;
                    }
                    controller.enqueue(value);
                }
            }, {
                raw: true
            });
        }
        void this.pipeTo(transform.writable, options);
        return transform.readable;
    }
    tee() {
        const reader = this.getReader();
        const queueA = [];
        const queueB = [];
        const waitersA = [];
        const waitersB = [];
        let pulling = null;
        const enqueueTo = (queue, waiters, entry)=>{
            const waiter = waiters.shift();
            if (waiter) {
                waiter(entry);
                return;
            }
            queue.push(entry);
        };
        const pullFromSource = async ()=>{
            if (pulling) {
                await pulling;
                return;
            }
            pulling = (async ()=>{
                const result = await reader.read();
                const entry = result.done ? {
                    done: true
                } : {
                    value: result.value,
                    done: false
                };
                enqueueTo(queueA, waitersA, entry);
                enqueueTo(queueB, waitersB, entry);
            })();
            try {
                await pulling;
            } finally{
                pulling = null;
            }
        };
        const makeClone = (queue, waiters)=>new ReadableStream1({
                async pull (controller) {
                    const entry = queue.shift();
                    if (entry) {
                        if (entry.done) controller.close();
                        else controller.enqueue(entry.value);
                        return;
                    }
                    await pullFromSource();
                    const next = queue.shift();
                    if (next) {
                        if (next.done) controller.close();
                        else controller.enqueue(next.value);
                        return;
                    }
                    waiters.push((result)=>{
                        if (result.done) controller.close();
                        else controller.enqueue(result.value);
                    });
                }
            }, {
                raw: true
            });
        return [
            makeClone(queueA, waitersA),
            makeClone(queueB, waitersB)
        ];
    }
    async *[Symbol.asyncIterator]() {
        const reader = this.getReader();
        for(;;){
            const { value, done } = await reader.read();
            if (done) break;
            yield value;
        }
    }
    _drop() {
        if (this.streamId !== undefined) {
            op_stream_drop2(this.streamId);
        }
        this.queue = [];
        this.resolvers = [];
    }
    _enqueueRaw(chunk) {
        if (!this.queue || !this.resolvers) return;
        const entry = {
            value: chunk,
            done: false
        };
        const resolver = this.resolvers.shift();
        if (resolver) {
            resolver(entry);
            return;
        }
        this.queue.push(entry);
    }
    _closeRaw() {
        if (!this.queue || !this.resolvers) return;
        this.state.closed = true;
        const entry = {
            done: true
        };
        const resolver = this.resolvers.shift();
        if (resolver) {
            resolver(entry);
            return;
        }
        this.queue.push(entry);
    }
}
class WritableStreamDefaultWriter1 {
    sink;
    constructor(sink){
        this.sink = sink;
    }
    write(chunk) {
        return Promise.resolve(this.sink.write?.(chunk));
    }
    close() {
        return Promise.resolve(this.sink.close?.());
    }
    abort(reason) {
        return Promise.resolve(this.sink.abort?.(reason));
    }
}
class WritableStreamDefaultController1 {
    error() {}
}
class WritableStream1 {
    sink;
    constructor(sink = {}){
        this.sink = sink;
    }
    getWriter() {
        return new WritableStreamDefaultWriter1(this.sink);
    }
    async abort(reason) {
        await this.sink.abort?.(reason);
    }
}
class TransformStream1 {
    readable;
    writable;
    _transformer;
    constructor(transformer){
        this._transformer = transformer;
        let controllerRef = null;
        this.readable = new ReadableStream1({
            start (controller) {
                controllerRef = controller;
            }
        }, {
            raw: true
        });
        this.writable = new WritableStream1({
            write (chunk) {
                if (!controllerRef) return;
                if (transformer?.transform) {
                    transformer.transform(chunk, controllerRef);
                } else {
                    controllerRef.enqueue(chunk);
                }
            },
            close () {
                if (!controllerRef) return;
                transformer?.flush?.(controllerRef);
                controllerRef.close();
            },
            abort () {
                if (!controllerRef) return;
                controllerRef.error();
            }
        });
    }
}
class TransformStreamDefaultController1 {
    enqueue() {}
    terminate() {}
    error() {}
}
class ByteLengthQueuingStrategy1 {
    highWaterMark;
    constructor({ highWaterMark } = {}){
        this.highWaterMark = Number(highWaterMark ?? 1);
    }
    size(chunk) {
        if (chunk && typeof chunk.byteLength === "number") {
            return chunk.byteLength;
        }
        return 1;
    }
}
class CountQueuingStrategy1 {
    highWaterMark;
    constructor({ highWaterMark } = {}){
        this.highWaterMark = Number(highWaterMark ?? 1);
    }
    size() {
        return 1;
    }
}
class TextEncoderStream1 {
    readable;
    writable;
    constructor(){
        const encoder = new TextEncoder();
        this.readable = new ReadableStream1({}, {
            raw: true
        });
        const readable = this.readable;
        this.writable = new WritableStream1({
            write (chunk) {
                readable._enqueueRaw(encoder.encode(String(chunk)));
            },
            close: ()=>readable._closeRaw(),
            abort: ()=>readable._closeRaw()
        });
    }
}
class TextDecoderStream1 {
    readable;
    writable;
    constructor(){
        const decoder = new TextDecoder();
        this.readable = new ReadableStream1({}, {
            raw: true
        });
        const readable = this.readable;
        this.writable = new WritableStream1({
            write (chunk) {
                const bytes = normalizeChunk1(chunk);
                readable._enqueueRaw(decoder.decode(bytes, {
                    stream: true
                }));
            },
            close: ()=>readable._closeRaw(),
            abort: ()=>readable._closeRaw()
        });
    }
}
class CompressionStream1 {
    readable;
    writable;
    constructor(_format){
        const passthrough = new TransformStream1();
        this.readable = passthrough.readable;
        this.writable = passthrough.writable;
    }
}
class DecompressionStream1 {
    readable;
    writable;
    constructor(_format){
        const passthrough = new TransformStream1();
        this.readable = passthrough.readable;
        this.writable = passthrough.writable;
    }
}
function normalizeChunk1(chunk) {
    if (chunk instanceof Uint8Array) {
        return chunk;
    }
    if (chunk instanceof ArrayBuffer) {
        return new Uint8Array(chunk);
    }
    if (ArrayBuffer.isView(chunk)) {
        return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    }
    return new TextEncoder().encode(String(chunk));
}
globalThis.ReadableStream = ReadableStream1;
globalThis.WritableStream = WritableStream1;
globalThis.TransformStream = TransformStream1;
globalThis.ReadableStreamDefaultReader = ReadableStreamDefaultReader1;
globalThis.ReadableStreamDefaultController = ReadableStreamDefaultController1;
globalThis.ReadableByteStreamController = ReadableByteStreamController1;
globalThis.ReadableStreamBYOBReader = ReadableStreamBYOBReader1;
globalThis.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest1;
globalThis.WritableStreamDefaultWriter = WritableStreamDefaultWriter1;
globalThis.WritableStreamDefaultController = WritableStreamDefaultController1;
globalThis.TransformStreamDefaultController = TransformStreamDefaultController1;
globalThis.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy1;
globalThis.CountQueuingStrategy = CountQueuingStrategy1;
globalThis.TextEncoderStream = TextEncoderStream1;
globalThis.TextDecoderStream = TextDecoderStream1;
globalThis.CompressionStream = CompressionStream1;
globalThis.DecompressionStream = DecompressionStream1;
function decode(value) {
    return decodeURIComponent(value.replace(/\+/g, " "));
}
function encode(value) {
    return encodeURIComponent(value);
}
class URLSearchParams {
    entries;
    owner;
    constructor(init = "", owner){
        this.entries = [];
        this.owner = owner;
        if (typeof init === "string") {
            const input = init.startsWith("?") ? init.slice(1) : init;
            if (input.length > 0) {
                for (const pair of input.split("&")){
                    if (!pair) continue;
                    const [key, value = ""] = pair.split("=");
                    this.entries.push([
                        decode(key),
                        decode(value)
                    ]);
                }
            }
            return;
        }
        if (Array.isArray(init)) {
            for (const [key, value] of init){
                this.append(key, value);
            }
            return;
        }
        for (const [key, value] of Object.entries(init)){
            this.append(key, value);
        }
    }
    append(name, value) {
        this.entries.push([
            String(name),
            String(value)
        ]);
        this.sync();
    }
    set(name, value) {
        const key = String(name);
        const next = [];
        let replaced = false;
        for (const entry of this.entries){
            if (entry[0] === key) {
                if (!replaced) {
                    next.push([
                        key,
                        String(value)
                    ]);
                    replaced = true;
                }
            } else {
                next.push(entry);
            }
        }
        if (!replaced) next.push([
            key,
            String(value)
        ]);
        this.entries = next;
        this.sync();
    }
    get(name) {
        const key = String(name);
        for (const [entryKey, entryValue] of this.entries){
            if (entryKey === key) return entryValue;
        }
        return null;
    }
    getAll(name) {
        const key = String(name);
        return this.entries.filter((entry)=>entry[0] === key).map((entry)=>entry[1]);
    }
    delete(name) {
        const key = String(name);
        this.entries = this.entries.filter((entry)=>entry[0] !== key);
        this.sync();
    }
    toString() {
        return this.entries.map(([key, value])=>`${encode(key)}=${encode(value)}`).join("&");
    }
    sync() {
        if (this.owner) {
            const serialized = this.toString();
            this.owner._updateSearch(serialized ? `?${serialized}` : "");
        }
    }
}
class URL1 {
    href;
    protocol;
    hostname;
    port;
    pathname;
    search;
    hash;
    searchParams;
    constructor(input, base){
        const baseHref = base instanceof URL1 ? base.href : base;
        const parsed = op_url_parse2(input, baseHref ?? null);
        this.href = parsed.href;
        this.protocol = parsed.protocol;
        this.hostname = parsed.hostname;
        this.port = parsed.port;
        this.pathname = parsed.pathname;
        this.search = parsed.search;
        this.hash = parsed.hash;
        this.searchParams = new URLSearchParams(this.search, this);
    }
    _updateSearch(value) {
        this.search = value;
        this.href = `${this.protocol}//${this.hostname}${this.port ? `:${this.port}` : ""}${this.pathname}${this.search}${this.hash}`;
    }
}
if (typeof globalThis.URL === "undefined") {
    globalThis.URL = URL1;
}
if (typeof globalThis.URLSearchParams === "undefined") {
    globalThis.URLSearchParams = URLSearchParams;
}
const URLImpl = globalThis.URL;
const URLSearchParamsImpl = globalThis.URLSearchParams;
class Headers1 {
    map;
    constructor(init){
        this.map = new Map();
        if (!init) return;
        if (init instanceof Headers1) {
            for (const [key, value] of init.entries()){
                this.append(key, value);
            }
            return;
        }
        if (Array.isArray(init)) {
            for (const [key, value] of init){
                this.append(key, value);
            }
            return;
        }
        for (const [key, value] of Object.entries(init)){
            this.append(key, value);
        }
    }
    normalize(name) {
        return name.toLowerCase();
    }
    append(name, value) {
        const key = this.normalize(name);
        const existing = this.map.get(key);
        if (existing) {
            existing.push(value);
        } else {
            this.map.set(key, [
                value
            ]);
        }
    }
    set(name, value) {
        const key = this.normalize(name);
        this.map.set(key, [
            value
        ]);
    }
    get(name) {
        const key = this.normalize(name);
        const values = this.map.get(key);
        if (!values || values.length === 0) return null;
        return values.join(", ");
    }
    getAll(name) {
        const key = this.normalize(name);
        return this.map.get(key)?.slice() || [];
    }
    has(name) {
        return this.map.has(this.normalize(name));
    }
    delete(name) {
        this.map.delete(this.normalize(name));
    }
    entries() {
        const result = [];
        for (const [key, values] of this.map.entries()){
            for (const value of values){
                result.push([
                    key,
                    value
                ]);
            }
        }
        return result[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    keys() {
        return this.map.keys();
    }
    values() {
        const values = [];
        for (const [, vals] of this.map.entries()){
            values.push(...vals);
        }
        return values[Symbol.iterator]();
    }
    forEach(callback) {
        for (const [key, values] of this.map.entries()){
            for (const value of values){
                callback(value, key, this);
            }
        }
    }
}
function headersToObject1(headers) {
    if (!headers) return {};
    if (headers instanceof Headers1) {
        const out = {};
        for (const [key, values] of headers.map.entries()){
            if (key === "set-cookie") {
                out[key] = values.join("\n");
            } else {
                out[key] = values.join(", ");
            }
        }
        return out;
    }
    return {
        ...headers
    };
}
if (typeof globalThis.Headers === "undefined") {
    globalThis.Headers = Headers1;
}
class DekaWebSocket {
    id;
    data;
    constructor(id, data){
        this.id = id;
        this.data = data;
    }
    send(message) {
        if (message instanceof Uint8Array) {
            op_ws_send_binary2(BigInt(this.id), message);
            return;
        }
        const payload = String(message);
        op_ws_send2(BigInt(this.id), payload);
    }
    close(code, reason) {
        op_ws_close2(BigInt(this.id), code ?? 1000, reason ?? "");
    }
}
function createWebSocket(id, data) {
    return new DekaWebSocket(id, data);
}
class WebSocketStub {
    send(_message) {
        throw new Error("WebSocket is not available in this runtime yet");
    }
    close(_code, _reason) {}
}
if (typeof globalThis.WebSocket === "undefined") {
    globalThis.WebSocket = WebSocketStub;
}
globalThis.__dekaWsCreate = createWebSocket;
function defaultWrite1(chunk) {
    const op = globalThis.__dekaOps;
    if (op?.op_stdout_write) {
        op.op_stdout_write(new TextEncoder().encode(chunk));
    }
}
function toWriter1(stream, fallback) {
    if (stream && typeof stream.write === "function") {
        return stream;
    }
    return {
        write: fallback
    };
}
function formatValue1(value) {
    if (typeof value === "string") return value;
    if (value instanceof Error) {
        return value.stack || value.message;
    }
    const util = globalThis.__dekaNodeUtil;
    if (util?.inspect) {
        try {
            return util.inspect(value);
        } catch  {}
    }
    try {
        return JSON.stringify(value);
    } catch  {
        return String(value);
    }
}
function formatArgs1(args) {
    return args.map(formatValue1).join(" ");
}
function nowMs1() {
    const perf = globalThis.performance;
    if (perf?.now) return perf.now();
    return Date.now();
}
class Console1 {
    stdout;
    stderr;
    timers;
    constructor(stdout, stderr){
        this.stdout = toWriter1(stdout, defaultWrite1);
        this.stderr = toWriter1(stderr, defaultWrite1);
        this.timers = new Map();
    }
    log(...args) {
        this.stdout.write(`${formatArgs1(args)}\n`);
    }
    info(...args) {
        this.stdout.write(`${formatArgs1(args)}\n`);
    }
    warn(...args) {
        this.stderr.write(`${formatArgs1(args)}\n`);
    }
    error(...args) {
        if (args.length > 0) {
            globalThis.__dekaLastError = args[0];
        }
        this.stderr.write(`${formatArgs1(args)}\n`);
    }
    debug(...args) {
        this.stdout.write(`${formatArgs1(args)}\n`);
    }
    dir(value) {
        this.stdout.write(`${formatValue1(value)}\n`);
    }
    assert(condition, ...args) {
        if (condition) return;
        const prefix = "Assertion failed";
        if (args.length === 0) {
            this.stderr.write(`${prefix}\n`);
            return;
        }
        this.stderr.write(`${prefix}: ${formatArgs1(args)}\n`);
    }
    time(label = "default") {
        if (!this.timers.has(label)) {
            this.timers.set(label, nowMs1());
        }
    }
    timeLog(label = "default", ...args) {
        const start = this.timers.get(label);
        const delta = start === undefined ? 0 : Math.max(0, nowMs1() - start);
        const extra = args.length ? ` ${formatArgs1(args)}` : "";
        this.stdout.write(`${label}: ${delta.toFixed(2)}ms${extra}\n`);
    }
    timeEnd(label = "default", ...args) {
        this.timeLog(label, ...args);
        this.timers.delete(label);
    }
}
function createConsole1(stdout, stderr) {
    return new Console1(stdout, stderr);
}
if (!globalThis.console) {
    globalThis.console = createConsole1();
}
globalThis.__dekaNodeConsole = {
    Console: Console1,
    console: globalThis.console
};
function fail(message) {
    const error = new Error(message || "Assertion failed");
    error.code = "ERR_ASSERTION";
    throw error;
}
function ok(value, message) {
    if (!value) fail(message);
}
function equal(actual, expected, message) {
    if (actual != expected) {
        fail(message || `Expected ${String(actual)} == ${String(expected)}`);
    }
}
function strictEqual(actual, expected, message) {
    if (!Object.is(actual, expected)) {
        fail(message || `Expected ${String(actual)} === ${String(expected)}`);
    }
}
function deepEqual(actual, expected, message) {
    if (!isDeepEqual(actual, expected)) {
        fail(message || "Expected values to be deeply equal");
    }
}
function __throws(fn, expected, message) {
    let thrown;
    try {
        fn();
    } catch (error) {
        thrown = error;
    }
    if (!thrown) {
        fail(message || "Expected function to throw");
    }
    if (expected) {
        const msg = thrown?.message ?? String(thrown);
        if (!expected.test(msg)) {
            fail(message || `Expected error message to match ${expected}`);
        }
    }
}
function isDeepEqual(a, b) {
    if (Object.is(a, b)) return true;
    if (typeof a !== typeof b) return false;
    if (!a || !b) return false;
    if (typeof a !== "object") return false;
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) return false;
        for(let i = 0; i < a.length; i += 1){
            if (!isDeepEqual(a[i], b[i])) return false;
        }
        return true;
    }
    if (Array.isArray(a) || Array.isArray(b)) return false;
    const aKeys = Object.keys(a).sort();
    const bKeys = Object.keys(b).sort();
    if (aKeys.length !== bKeys.length) return false;
    for(let i = 0; i < aKeys.length; i += 1){
        if (aKeys[i] !== bKeys[i]) return false;
        const key = aKeys[i];
        if (!isDeepEqual(a[key], b[key])) {
            return false;
        }
    }
    return true;
}
const nodeAssert = {
    AssertionError: Error,
    ok,
    equal,
    strictEqual,
    deepEqual,
    throws: __throws,
    fail
};
globalThis.__dekaNodeAssert = nodeAssert;
class EventEmitter {
    listeners = new Map();
    on(event, listener) {
        const list = this.listeners.get(event) || new Set();
        list.add(listener);
        this.listeners.set(event, list);
        return this;
    }
    addListener(event, listener) {
        return this.on(event, listener);
    }
    once(event, listener) {
        const wrapped = (...args)=>{
            this.off(event, wrapped);
            listener(...args);
        };
        return this.on(event, wrapped);
    }
    prependListener(event, listener) {
        const list = this.listeners.get(event) || new Set();
        const next = new Set();
        next.add(listener);
        for (const existing of list){
            next.add(existing);
        }
        this.listeners.set(event, next);
        return this;
    }
    prependOnceListener(event, listener) {
        const wrapped = (...args)=>{
            this.off(event, wrapped);
            listener(...args);
        };
        return this.prependListener(event, wrapped);
    }
    off(event, listener) {
        const list = this.listeners.get(event);
        if (list) {
            list.delete(listener);
            if (list.size === 0) {
                this.listeners.delete(event);
            }
        }
        return this;
    }
    removeListener(event, listener) {
        return this.off(event, listener);
    }
    emit(event, ...args) {
        const list = this.listeners.get(event);
        if (!list) return false;
        for (const listener of Array.from(list)){
            listener(...args);
        }
        return true;
    }
    listenersFor(event) {
        return Array.from(this.listeners.get(event) || []);
    }
}
const events = EventEmitter;
events.EventEmitter = EventEmitter;
events.default = EventEmitter;
events.once = (emitter, event)=>{
    return new Promise((resolve)=>{
        emitter.once(event, (...args)=>resolve(args));
    });
};
events.on = (emitter, event)=>{
    let ended = false;
    const queue = [];
    let resolve = null;
    const handler = (...args)=>{
        if (resolve) {
            const current = resolve;
            resolve = null;
            current({
                value: args,
                done: false
            });
        } else {
            queue.push(args);
        }
    };
    emitter.on(event, handler);
    return {
        [Symbol.asyncIterator] () {
            return this;
        },
        next () {
            if (ended) return Promise.resolve({
                value: undefined,
                done: true
            });
            if (queue.length > 0) {
                return Promise.resolve({
                    value: queue.shift(),
                    done: false
                });
            }
            return new Promise((res)=>{
                resolve = res;
            });
        },
        return () {
            ended = true;
            if (typeof emitter.off === "function") {
                emitter.off(event, handler);
            }
            return Promise.resolve({
                value: undefined,
                done: true
            });
        }
    };
};
globalThis.__dekaNodeEvents = events;
function inspect(value) {
    if (typeof value === "string") return value;
    if (value instanceof Error) {
        return value.stack || `${value.name}: ${value.message}`;
    }
    if (value && typeof value === "object") {
        const errLike = value;
        const message = typeof errLike.message === "string" ? errLike.message : String(errLike.message || "");
        const stack = typeof errLike.stack === "string" ? errLike.stack : "";
        if (stack || message) {
            const name = typeof errLike.name === "string" ? errLike.name : "Error";
            return stack || `${name}: ${message}`;
        }
        const keys = Object.getOwnPropertyNames(value);
        if (keys.length > 0) {
            const entries = keys.map((key)=>{
                let field;
                try {
                    field = String(value[key]);
                } catch  {
                    field = "[unreadable]";
                }
                return `${key}: ${field}`;
            });
            return `{ ${entries.join(", ")} }`;
        }
        try {
            return Object.prototype.toString.call(value);
        } catch  {}
    }
    try {
        return JSON.stringify(value);
    } catch  {
        return String(value);
    }
}
function format(...args) {
    if (args.length === 0) return "";
    const first = args[0];
    if (typeof first !== "string") {
        return args.map((arg)=>inspect(arg)).join(" ");
    }
    let formatString = first;
    let index = 1;
    const replacer = (match)=>{
        if (match === "%%") return "%";
        if (index >= args.length) return match;
        const value = args[index++];
        switch(match){
            case "%s":
                return String(value);
            case "%d":
            case "%i":
                return `${Number(value)}`;
            case "%f":
                return `${Number(value)}`;
            case "%j":
                try {
                    return JSON.stringify(value);
                } catch  {
                    return "[Circular]";
                }
            case "%o":
            case "%O":
                return inspect(value);
            case "%c":
                return "";
            default:
                return match;
        }
    };
    formatString = formatString.replace(/%[%sdifjoOc]/g, replacer);
    if (index < args.length) {
        const rest = args.slice(index).map((arg)=>inspect(arg)).join(" ");
        if (rest.length > 0) formatString += ` ${rest}`;
    }
    return formatString;
}
function formatWithOptions(_options, ...args) {
    return format(...args);
}
function promisify(fn) {
    return (...args)=>new Promise((resolve, reject)=>{
            fn(...args, (err, result)=>{
                if (err) {
                    reject(err);
                    return;
                }
                resolve(result);
            });
        });
}
function deprecate(fn, msg, code) {
    if (typeof fn !== "function") {
        throw new TypeError("util.deprecate expects a function");
    }
    let warned = false;
    const wrapper = function(...args) {
        if (!warned) {
            warned = true;
            if (globalThis.process?.emitWarning) {
                globalThis.process.emitWarning(msg, {
                    code
                });
            } else if (msg) {
                console.warn(msg);
            }
        }
        return fn.apply(this, args);
    };
    wrapper.prototype = fn.prototype;
    return wrapper;
}
function debuglog(_section) {
    return (..._args)=>{};
}
const types = {
    isPromise (value) {
        return !!value && typeof value.then === "function";
    }
};
globalThis.__dekaNodeUtil = {
    inspect,
    format,
    formatWithOptions,
    deprecate,
    promisify,
    debuglog,
    types,
    TextEncoder: globalThis.TextEncoder,
    TextDecoder: globalThis.TextDecoder
};
const timers1 = {
    setTimeout,
    clearTimeout,
    setInterval,
    clearInterval,
    setImmediate: (callback, ...args)=>{
        const id = setTimeout(()=>callback(...args), 0);
        return id;
    },
    clearImmediate: (id)=>{
        clearTimeout(id);
    }
};
globalThis.__dekaNodeTimers = timers1;
const env = globalThis.process?.env || {};
function platform() {
    return globalThis.process?.platform || "unknown";
}
function arch() {
    return env.DENO_ARCH || env.DEKA_ARCH || "unknown";
}
function hostname() {
    return env.HOSTNAME || env.COMPUTERNAME || "localhost";
}
function tmpdir() {
    return env.TMPDIR || env.TEMP || "/tmp";
}
function homedir() {
    return env.HOME || env.USERPROFILE || "/";
}
function type() {
    const plat = platform().toLowerCase();
    if (plat.includes("darwin") || plat.includes("mac")) return "Darwin";
    if (plat.includes("win")) return "Windows_NT";
    if (plat.includes("linux")) return "Linux";
    return "Unknown";
}
function endianness() {
    return "LE";
}
const EOL = "\n";
function cpus() {
    const count = Number(env.DEKA_CPU_COUNT || env.CPU_COUNT || 1) || 1;
    const info = {
        model: "deka",
        speed: 0,
        times: {
            user: 0,
            nice: 0,
            sys: 0,
            idle: 0,
            irq: 0
        }
    };
    return Array.from({
        length: count
    }, ()=>({
            ...info
        }));
}
function totalmem() {
    const value = Number(env.DEKA_TOTAL_MEM || env.TOTAL_MEM || 0);
    return Number.isFinite(value) ? value : 0;
}
function freemem() {
    const value = Number(env.DEKA_FREE_MEM || env.FREE_MEM || 0);
    return Number.isFinite(value) ? value : 0;
}
globalThis.__dekaNodeOs = {
    platform,
    arch,
    hostname,
    tmpdir,
    homedir,
    type,
    endianness,
    EOL,
    cpus,
    totalmem,
    freemem
};
function toURL(input) {
    return input instanceof URLImpl ? input : new URLImpl(String(input));
}
function ensureFileProtocol(url) {
    if (url.protocol !== "file:") {
        throw new Error("Invalid file URL");
    }
}
function normalizePath1(path) {
    if (!path) return "/";
    const replaced = path.replace(/\\/g, "/");
    return replaced.startsWith("/") ? replaced : `/${replaced}`;
}
function pathToFileURL(path) {
    const normalized = normalizePath1(path);
    const encoded = encodeURI(normalized);
    return new URLImpl(`file://${encoded}`);
}
function fileURLToPath(path) {
    const url = toURL(path);
    ensureFileProtocol(url);
    return decodeURI(url.pathname);
}
function format1(input) {
    return toURL(input).toString();
}
function parse(input, base) {
    if (base) {
        const baseUrl = base instanceof URLImpl ? base : new URLImpl(String(base));
        return new URLImpl(input, baseUrl);
    }
    if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(input)) {
        return new URLImpl(input);
    }
    return new URLImpl(input, "http://localhost/");
}
function resolve(from, to) {
    return new URLImpl(to, parse(from)).toString();
}
function domainToASCII(domain) {
    return domain;
}
function domainToUnicode(domain) {
    return domain;
}
globalThis.__dekaNodeUrl = {
    URL: URLImpl,
    URLSearchParams: URLSearchParamsImpl,
    pathToFileURL,
    fileURLToPath,
    format: format1,
    parse,
    resolve,
    domainToASCII,
    domainToUnicode
};
const constants = {
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    O_RDONLY: 0,
    O_WRONLY: -1,
    O_RDWR: -1,
    O_CREAT: -1,
    O_TRUNC: -1,
    O_APPEND: -1,
    O_EXCL: -1,
    O_DIRECTORY: -1
};
function normalizePathInput(path) {
    if (typeof path === "string") {
        if (path.startsWith("file://")) {
            return fileURLToPath(path);
        }
        return path;
    }
    try {
        return fileURLToPath(path);
    } catch  {
        return String(path);
    }
}
function normalizeEncoding(options) {
    if (!options) return null;
    if (typeof options === "string") return options;
    return options.encoding ?? null;
}
function parseOpenFlags(flags) {
    const flag = typeof flags === "string" ? flags : "r";
    switch(flag){
        case "r":
            return {
                read: true,
                write: false,
                append: false,
                create: false,
                truncate: false
            };
        case "r+":
            return {
                read: true,
                write: true,
                append: false,
                create: false,
                truncate: false
            };
        case "w":
            return {
                read: false,
                write: true,
                append: false,
                create: true,
                truncate: true
            };
        case "w+":
            return {
                read: true,
                write: true,
                append: false,
                create: true,
                truncate: true
            };
        case "a":
            return {
                read: false,
                write: true,
                append: true,
                create: true,
                truncate: false
            };
        case "a+":
            return {
                read: true,
                write: true,
                append: true,
                create: true,
                truncate: false
            };
        default:
            return {
                read: true,
                write: false,
                append: false,
                create: false,
                truncate: false
            };
    }
}
function decodeBytes(bytes, encoding) {
    const BufferImpl = globalThis.Buffer || Buffer;
    if (!encoding) return BufferImpl.from(bytes);
    switch(encoding){
        case "latin1":
        case "binary":
            return BufferImpl.from(bytes).toString("latin1");
        case "hex":
            return BufferImpl.from(bytes).toString("hex");
        case "base64":
            return BufferImpl.from(bytes).toString("base64");
        case "utf8":
        case "utf-8":
        default:
            return new TextDecoder().decode(bytes);
    }
}
function encodeContent(data, encoding) {
    if (typeof data !== "string") {
        return {
            bytes: data,
            isBinary: true
        };
    }
    if (!encoding || encoding === "utf8" || encoding === "utf-8") {
        return {
            text: data,
            isBinary: false
        };
    }
    const buffer = Buffer.from(data, encoding);
    return {
        bytes: buffer,
        isBinary: true
    };
}
function readFileSync(path, options) {
    const bytes = op_read_file2(normalizePathInput(path));
    const encoding = normalizeEncoding(options);
    return decodeBytes(bytes, encoding);
}
function writeFileSync(path, data, options) {
    const encoding = normalizeEncoding(options);
    const payload = encodeContent(data, encoding);
    if (payload.isBinary && payload.bytes) {
        const base64 = Buffer.from(payload.bytes).toString("base64");
        op_write_file_base642(normalizePathInput(path), base64);
        return;
    }
    op_write_file2(normalizePathInput(path), payload.text ?? "");
}
function appendFileSync(path, data, options) {
    const encoding = normalizeEncoding(options);
    const payload = encodeContent(data, encoding);
    if (payload.isBinary && payload.bytes) {
        op_fs_append_bytes2(normalizePathInput(path), payload.bytes);
        return;
    }
    op_fs_append2(normalizePathInput(path), payload.text ?? "");
}
function copyFileSync(src, dest, options) {
    op_fs_copy_file2(normalizePathInput(src), normalizePathInput(dest));
}
function copyFile(src, dest, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    (async ()=>{
        try {
            copyFileSync(src, dest, typeof options === "function" ? null : options ?? null);
            cb?.(null);
        } catch (err) {
            cb?.(err);
        }
    })();
}
function readFile(path, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    const encoding = normalizeEncoding(typeof options === "function" ? null : options);
    (async ()=>{
        try {
            const bytes = op_read_file2(normalizePathInput(path));
            cb?.(null, decodeBytes(bytes, encoding));
        } catch (err) {
            cb?.(err);
        }
    })();
}
function writeFile(path, data, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    const encoding = normalizeEncoding(typeof options === "function" ? null : options);
    (async ()=>{
        try {
            writeFileSync(path, data, encoding ?? undefined);
            cb?.(null);
        } catch (err) {
            cb?.(err);
        }
    })();
}
function appendFile(path, data, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    const encoding = normalizeEncoding(typeof options === "function" ? null : options);
    (async ()=>{
        try {
            appendFileSync(path, data, encoding ?? undefined);
            cb?.(null);
        } catch (err) {
            cb?.(err);
        }
    })();
}
function existsSync(path) {
    return op_fs_exists2(normalizePathInput(path));
}
function statSync(path) {
    const stat = op_fs_stat2(normalizePathInput(path));
    return {
        size: stat.size,
        mtimeMs: stat.mtime_ms ?? 0,
        isFile: ()=>stat.is_file,
        isDirectory: ()=>stat.is_dir
    };
}
function lstatSync(path) {
    return statSync(path);
}
function realpathSync(path) {
    return normalizePathInput(path);
}
realpathSync.native = realpathSync;
function accessSync(path) {
    statSync(path);
}
function mkdirSync(path, options) {
    let recursive = false;
    if (typeof options === "boolean") recursive = options;
    else if (options && typeof options.recursive === "boolean") recursive = options.recursive;
    op_fs_mkdir2(normalizePathInput(path), recursive ? 1 : 0);
}
function readdirSync(path, options) {
    const entries = op_fs_read_dir2(normalizePathInput(path));
    if (options && options.withFileTypes) {
        return entries.map((entry)=>new Dirent(entry));
    }
    return entries.map((entry)=>entry.name);
}
function unlinkSync(path) {
    op_fs_remove_file2(normalizePathInput(path));
}
function rmSync(path) {
    unlinkSync(path);
}
class FSWatcher extends EventEmitter {
    timer;
    lastMtime;
    lastExists;
    closed;
    path;
    constructor(path, listener){
        super();
        this.path = path;
        this.timer = null;
        this.lastMtime = null;
        this.lastExists = false;
        this.closed = false;
        if (listener) this.on("change", listener);
    }
    start(interval) {
        const tick = ()=>{
            if (this.closed) return;
            let exists = false;
            let mtime = null;
            try {
                const stat = statSync(this.path);
                exists = true;
                mtime = stat.mtimeMs ?? 0;
            } catch (_err) {
                exists = false;
                mtime = null;
            }
            if (this.lastExists !== exists) {
                this.emit("change", "rename", this.path);
            } else if (exists && this.lastMtime !== null && mtime !== null && mtime !== this.lastMtime) {
                this.emit("change", "change", this.path);
            }
            this.lastExists = exists;
            this.lastMtime = mtime;
        };
        tick();
        this.timer = setInterval(tick, interval);
    }
    close() {
        if (this.timer !== null) {
            clearInterval(this.timer);
            this.timer = null;
        }
        this.closed = true;
    }
}
function watch(path, options, listener) {
    const opts = typeof options === "function" ? undefined : options;
    const cb = typeof options === "function" ? options : listener;
    const watcher = new FSWatcher(String(path), cb);
    const interval = opts?.interval ?? 250;
    watcher.start(interval);
    return watcher;
}
function watchFile(filename, options, listener) {
    const opts = typeof options === "function" ? undefined : options;
    const cb = typeof options === "function" ? options : listener;
    const interval = opts?.interval ?? 5007;
    let prevStat = null;
    let closed = false;
    const tick = ()=>{
        if (closed) return;
        let currStat = null;
        try {
            currStat = statSync(filename);
        } catch (_err) {
            currStat = null;
        }
        if (cb) cb(currStat, prevStat);
        prevStat = currStat;
    };
    tick();
    const timer = setInterval(tick, interval);
    return {
        close () {
            closed = true;
            clearInterval(timer);
        }
    };
}
function unwatchFile(_filename, _listener) {}
function readdir(path, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    const opts = typeof options === "function" ? undefined : options;
    (async ()=>{
        try {
            const entries = readdirSync(path, opts);
            cb?.(null, entries);
        } catch (err) {
            cb?.(err);
        }
    })();
}
function openSync(path, flags) {
    const options = parseOpenFlags(flags);
    return op_fs_open2(normalizePathInput(path), options);
}
function closeSync(fd) {
    op_fs_close2(fd);
}
function readSync(fd, buffer, offset = 0, length = buffer.length, position = null) {
    const result = op_fs_read2(fd, length, position ?? -1);
    buffer.set(result.data, offset);
    return result.bytes_read;
}
function writeSync(fd, buffer, offset = 0, length = buffer.length, position = null) {
    const slice = buffer.slice(offset, offset + length);
    return op_fs_write2(fd, slice, position ?? -1);
}
function open(path, flags, callback) {
    const cb = typeof flags === "function" ? flags : callback;
    const openFlags = typeof flags === "function" ? undefined : flags;
    (async ()=>{
        try {
            const fd = openSync(path, openFlags);
            cb?.(null, fd);
        } catch (err) {
            cb?.(err);
        }
    })();
}
function close(fd, callback) {
    (async ()=>{
        try {
            closeSync(fd);
            callback?.(null);
        } catch (err) {
            callback?.(err);
        }
    })();
}
function read(fd, buffer, offset, length, position, callback) {
    (async ()=>{
        try {
            const bytesRead = readSync(fd, buffer, offset, length, position);
            callback?.(null, bytesRead, buffer);
        } catch (err) {
            callback?.(err);
        }
    })();
}
function write(fd, buffer, offset, length, position, callback) {
    (async ()=>{
        try {
            const bytesWritten = writeSync(fd, buffer, offset, length, position);
            callback?.(null, bytesWritten, buffer);
        } catch (err) {
            callback?.(err);
        }
    })();
}
function lstat(path, callback) {
    (async ()=>{
        try {
            const stats = lstatSync(path);
            callback?.(null, stats);
        } catch (err) {
            callback?.(err);
        }
    })();
}
function stat(path, callback) {
    (async ()=>{
        try {
            const stats = statSync(path);
            callback?.(null, stats);
        } catch (err) {
            callback?.(err);
        }
    })();
}
function rm(path, callback) {
    (async ()=>{
        try {
            rmSync(path);
            callback?.(null);
        } catch (err) {
            callback?.(err);
        }
    })();
}
function unlink(path, callback) {
    (async ()=>{
        try {
            unlinkSync(path);
            callback?.(null);
        } catch (err) {
            callback?.(err);
        }
    })();
}
class Dirent {
    name;
    isFileValue;
    isDirValue;
    isSymlinkValue;
    constructor(entry){
        this.name = entry.name;
        this.isFileValue = entry.is_file;
        this.isDirValue = entry.is_dir;
        this.isSymlinkValue = entry.is_symlink ?? false;
    }
    isFile() {
        return this.isFileValue;
    }
    isDirectory() {
        return this.isDirValue;
    }
    isSymbolicLink() {
        return this.isSymlinkValue;
    }
}
const promises = {
    readFile: (path, options)=>Promise.resolve(readFileSync(path, options)),
    writeFile: (path, data, options)=>Promise.resolve(writeFileSync(path, data, options)),
    appendFile: (path, data, options)=>Promise.resolve(appendFileSync(path, data, options)),
    copyFile: (src, dest, options)=>Promise.resolve(copyFileSync(src, dest, options)),
    stat: (path)=>Promise.resolve(statSync(path)),
    lstat: (path)=>Promise.resolve(lstatSync(path)),
    readdir: (path, options)=>Promise.resolve(readdirSync(path, options)),
    mkdir: (path, options)=>Promise.resolve(mkdirSync(path, options)),
    unlink: (path)=>Promise.resolve(unlinkSync(path)),
    rm: (path)=>Promise.resolve(rmSync(path)),
    access: (path)=>Promise.resolve(accessSync(path)),
    realpath: (path)=>Promise.resolve(realpathSync(path)),
    open: async (path, flags)=>{
        const fd = openSync(path, flags);
        return new FileHandle(fd);
    }
};
class FileHandle {
    fd;
    constructor(fd){
        this.fd = fd;
    }
    async close() {
        closeSync(this.fd);
    }
    async read(options) {
        const { buffer, offset = 0, length = buffer.length, position = null } = options;
        const bytesRead = readSync(this.fd, buffer, offset, length, position);
        return {
            bytesRead,
            buffer
        };
    }
    async write(buffer, offset = 0, length = buffer.length, position = null) {
        const bytesWritten = writeSync(this.fd, buffer, offset, length, position);
        return {
            bytesWritten,
            buffer
        };
    }
    async readFile(options) {
        const chunks = [];
        let offset = 0;
        for(;;){
            const buffer = new Uint8Array(4096);
            const bytesRead = readSync(this.fd, buffer, 0, buffer.length, offset);
            if (bytesRead <= 0) break;
            chunks.push(buffer.slice(0, bytesRead));
            offset += bytesRead;
        }
        const total = chunks.reduce((sum, chunk)=>sum + chunk.length, 0);
        const merged = new Uint8Array(total);
        let cursor = 0;
        for (const chunk of chunks){
            merged.set(chunk, cursor);
            cursor += chunk.length;
        }
        return decodeBytes(merged, normalizeEncoding(options));
    }
    async writeFile(data, options) {
        const encoding = normalizeEncoding(options);
        const payload = encodeContent(data, encoding);
        if (payload.isBinary && payload.bytes) {
            writeSync(this.fd, payload.bytes, 0, payload.bytes.length, 0);
            return;
        }
        const bytes = new TextEncoder().encode(payload.text ?? "");
        writeSync(this.fd, bytes, 0, bytes.length, 0);
    }
}
globalThis.__dekaNodeFs = {
    readFileSync,
    writeFileSync,
    appendFileSync,
    copyFileSync,
    readFile,
    writeFile,
    appendFile,
    copyFile,
    existsSync,
    statSync,
    stat,
    lstatSync,
    realpathSync,
    mkdirSync,
    readdirSync,
    unlinkSync,
    unlink,
    rmSync,
    accessSync,
    openSync,
    closeSync,
    readSync,
    writeSync,
    open,
    close,
    read,
    write,
    readdir,
    lstat,
    rm,
    watch,
    watchFile,
    unwatchFile,
    Dirent,
    promises,
    constants
};
if (typeof globalThis.fs === "undefined") {
    globalThis.fs = globalThis.__dekaNodeFs;
}
const sep = "/";
const delimiter = ":";
function normalize(path) {
    if (!path) return ".";
    const isAbs = path.startsWith(sep);
    const parts = path.split(sep);
    const out = [];
    for (const part of parts){
        if (!part || part === ".") continue;
        if (part === "..") {
            if (out.length && out[out.length - 1] !== "..") {
                out.pop();
            } else if (!isAbs) {
                out.push("..");
            }
            continue;
        }
        out.push(part);
    }
    const joined = out.join(sep);
    if (isAbs) return `${sep}${joined}` || sep;
    return joined || ".";
}
function join(...parts) {
    const filtered = parts.filter((part)=>part && typeof part === "string");
    return normalize(filtered.join(sep));
}
function dirname1(path) {
    if (!path) return ".";
    const normalized = normalize(path);
    if (normalized === sep) return sep;
    const idx = normalized.lastIndexOf(sep);
    if (idx === -1) return ".";
    if (idx === 0) return sep;
    return normalized.slice(0, idx);
}
function basename(path, ext = "") {
    if (!path) return "";
    const normalized = normalize(path);
    if (normalized === sep) return sep;
    const idx = normalized.lastIndexOf(sep);
    let base = idx === -1 ? normalized : normalized.slice(idx + 1);
    if (ext && base.endsWith(ext)) {
        base = base.slice(0, base.length - ext.length);
    }
    return base;
}
function extname(path) {
    const base = basename(path);
    const idx = base.lastIndexOf(".");
    if (idx <= 0) return "";
    return base.slice(idx);
}
function isAbsolute(path) {
    return path.startsWith(sep) || /^[A-Za-z]:[\\/]/.test(path);
}
function relative(from, to) {
    const fromNorm = normalize(resolve1(from));
    const toNorm = normalize(resolve1(to));
    if (fromNorm === toNorm) return "";
    const fromParts = fromNorm.split(sep).filter(Boolean);
    const toParts = toNorm.split(sep).filter(Boolean);
    let i = 0;
    while(i < fromParts.length && i < toParts.length && fromParts[i] === toParts[i]){
        i += 1;
    }
    const up = fromParts.slice(i).map(()=>"..");
    const down = toParts.slice(i);
    const joined = [
        ...up,
        ...down
    ].join(sep);
    return joined || ".";
}
function parse1(path) {
    const normalized = normalize(path);
    const dir = dirname1(normalized);
    const base = basename(normalized);
    const ext = extname(base);
    const name = ext ? base.slice(0, base.length - ext.length) : base;
    return {
        root: normalized.startsWith(sep) ? sep : "",
        dir,
        base,
        ext,
        name
    };
}
function format2(parts) {
    const dir = parts.dir || parts.root || "";
    const base = parts.base || `${parts.name || ""}${parts.ext || ""}`;
    if (!dir) return base;
    return dir.endsWith(sep) ? `${dir}${base}` : `${dir}${sep}${base}`;
}
function resolve1(...parts) {
    let resolved = "";
    for (const part of parts){
        if (!part) continue;
        if (part.startsWith(sep)) {
            resolved = part;
        } else {
            resolved = resolved ? `${resolved}${sep}${part}` : part;
        }
    }
    const cwd = globalThis.process?.cwd?.() || sep;
    if (!resolved) return normalize(cwd);
    if (!resolved.startsWith(sep)) {
        resolved = `${cwd}${sep}${resolved}`;
    }
    return normalize(resolved);
}
const posix = {
    sep,
    delimiter,
    normalize,
    join,
    dirname: dirname1,
    basename,
    extname,
    resolve: resolve1,
    isAbsolute,
    relative,
    parse: parse1,
    format: format2
};
globalThis.__dekaNodePath = {
    sep,
    delimiter,
    normalize,
    join,
    dirname: dirname1,
    basename,
    extname,
    resolve: resolve1,
    isAbsolute,
    relative,
    parse: parse1,
    format: format2,
    posix,
    win32: posix
};
if (typeof globalThis.path === "undefined") {
    globalThis.path = globalThis.__dekaNodePath;
}
class StringDecoder {
    decoder;
    encoding;
    constructor(encoding = "utf-8"){
        this.encoding = encoding;
        this.decoder = new TextDecoder(encoding);
    }
    write(buffer) {
        return this.decoder.decode(buffer, {
            stream: true
        });
    }
    end(buffer) {
        if (buffer) return this.decoder.decode(buffer, {
            stream: false
        });
        return this.decoder.decode();
    }
}
globalThis.__dekaNodeStringDecoder = {
    StringDecoder
};
function parse2(input = "", sep = "&", eq = "=") {
    const out = {};
    if (!input) return out;
    const pairs = input.split(sep);
    for (const pair of pairs){
        const idx = pair.indexOf(eq);
        const rawKey = idx >= 0 ? pair.slice(0, idx) : pair;
        const rawValue = idx >= 0 ? pair.slice(idx + eq.length) : "";
        const key = decodeURIComponent(rawKey.replace(/\+/g, " "));
        const value = decodeURIComponent(rawValue.replace(/\+/g, " "));
        const existing = out[key];
        if (existing === undefined) {
            out[key] = value;
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            out[key] = [
                existing,
                value
            ];
        }
    }
    return out;
}
function stringify(obj, sep = "&", eq = "=") {
    const parts = [];
    for (const [key, value] of Object.entries(obj || {})){
        const encodedKey = encodeURIComponent(key);
        if (Array.isArray(value)) {
            for (const entry of value){
                parts.push(`${encodedKey}${eq}${encodeURIComponent(String(entry))}`);
            }
            continue;
        }
        parts.push(`${encodedKey}${eq}${encodeURIComponent(String(value))}`);
    }
    return parts.join(sep);
}
globalThis.__dekaNodeQuerystring = {
    parse: parse2,
    stringify
};
const streamWeb = {
    ReadableStream: globalThis.ReadableStream,
    WritableStream: globalThis.WritableStream,
    TransformStream: globalThis.TransformStream,
    ReadableStreamDefaultReader: globalThis.ReadableStreamDefaultReader,
    ReadableStreamDefaultController: globalThis.ReadableStreamDefaultController,
    ReadableByteStreamController: globalThis.ReadableByteStreamController,
    ReadableStreamBYOBReader: globalThis.ReadableStreamBYOBReader,
    ReadableStreamBYOBRequest: globalThis.ReadableStreamBYOBRequest,
    WritableStreamDefaultWriter: globalThis.WritableStreamDefaultWriter,
    WritableStreamDefaultController: globalThis.WritableStreamDefaultController,
    TransformStreamDefaultController: globalThis.TransformStreamDefaultController,
    ByteLengthQueuingStrategy: globalThis.ByteLengthQueuingStrategy,
    CountQueuingStrategy: globalThis.CountQueuingStrategy,
    TextEncoderStream: globalThis.TextEncoderStream,
    TextDecoderStream: globalThis.TextDecoderStream
};
globalThis.__dekaNodeStreamWeb = streamWeb;
const HASH_ALIASES = {
    "sha-1": "sha1",
    sha1: "sha1",
    sha128: "sha1",
    "sha-224": "sha224",
    sha224: "sha224",
    "sha-256": "sha256",
    sha256: "sha256",
    "sha-384": "sha384",
    sha384: "sha384",
    "sha-512": "sha512",
    sha512: "sha512",
    "sha512-224": "sha512-224",
    "sha512/224": "sha512-224",
    "sha512_224": "sha512-224",
    sha512224: "sha512-224",
    "sha512-256": "sha512-256",
    "sha512/256": "sha512-256",
    "sha512_256": "sha512-256",
    sha512256: "sha512-256",
    "sha3-224": "sha3-224",
    "sha3-256": "sha3-256",
    "sha3-384": "sha3-384",
    "sha3-512": "sha3-512",
    shake128: "shake128",
    shake256: "shake256",
    blake2b256: "blake2b256",
    blake2b512: "blake2b512",
    blake2s256: "blake2s256",
    ripemd160: "ripemd160",
    rmd160: "ripemd160",
    md4: "md4",
    md5: "md5"
};
const HASHES = [
    "blake2b256",
    "blake2b512",
    "blake2s256",
    "md4",
    "md5",
    "ripemd160",
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "sha512-224",
    "sha512-256",
    "sha3-224",
    "sha3-256",
    "sha3-384",
    "sha3-512",
    "shake128",
    "shake256"
];
function normalizeAlgorithm1(algorithm) {
    const raw = String(algorithm).toLowerCase();
    const normalized = raw.replace(/_/g, "-");
    return HASH_ALIASES[normalized] || normalized;
}
function toBuffer(data, encoding) {
    if (Buffer.isBuffer(data)) return data;
    if (typeof data === "string") return Buffer.from(data, encoding);
    if (data instanceof ArrayBuffer) return Buffer.from(data);
    if (ArrayBuffer.isView(data)) {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("Unsupported data type");
}
function toOutput(bytes, encoding) {
    const buffer = Buffer.from(bytes);
    if (!encoding || encoding === "buffer") return buffer;
    return buffer.toString(encoding);
}
function digestBytes(algorithm, data) {
    return op_crypto_digest2(algorithm, data);
}
function hmacDigest(algorithm, key, data) {
    const alg = normalizeAlgorithm1(algorithm);
    if (!HASHES.includes(alg)) {
        throw new Error(`Unsupported HMAC algorithm: ${algorithm}`);
    }
    return op_crypto_hmac2(alg, key, data);
}
class Hash {
    algorithm;
    chunks = [];
    finalized = false;
    constructor(algorithm){
        this.algorithm = normalizeAlgorithm1(algorithm);
        if (!HASHES.includes(this.algorithm)) {
            throw new Error(`Unsupported hash algorithm: ${algorithm}`);
        }
    }
    update(data, encoding) {
        if (this.finalized) {
            throw new Error("Hash has already been finalized");
        }
        this.chunks.push(toBuffer(data, encoding));
        return this;
    }
    digest(encoding) {
        if (this.finalized) {
            throw new Error("Hash has already been finalized");
        }
        this.finalized = true;
        const input = this.chunks.length ? Buffer.concat(this.chunks) : Buffer.alloc(0);
        const digest = digestBytes(this.algorithm, input);
        return toOutput(digest, encoding);
    }
}
class Hmac {
    algorithm;
    key;
    chunks = [];
    finalized = false;
    constructor(algorithm, key){
        this.algorithm = normalizeAlgorithm1(algorithm);
        if (!HASHES.includes(this.algorithm)) {
            throw new Error(`Unsupported HMAC algorithm: ${algorithm}`);
        }
        this.key = toBuffer(key);
    }
    update(data, encoding) {
        if (this.finalized) {
            throw new Error("Hmac has already been finalized");
        }
        this.chunks.push(toBuffer(data, encoding));
        return this;
    }
    digest(encoding) {
        if (this.finalized) {
            throw new Error("Hmac has already been finalized");
        }
        this.finalized = true;
        const input = this.chunks.length ? Buffer.concat(this.chunks) : Buffer.alloc(0);
        const digest = hmacDigest(this.algorithm, this.key, input);
        return toOutput(digest, encoding);
    }
}
class Cipheriv {
    algorithm;
    key;
    iv;
    aad = new Uint8Array(0);
    chunks = [];
    tag = null;
    finalized = false;
    constructor(algorithm, key, iv){
        this.algorithm = normalizeAlgorithm1(algorithm);
        this.key = toBuffer(key);
        this.iv = toBuffer(iv);
    }
    setAAD(aad) {
        this.aad = toBuffer(aad);
        return this;
    }
    update(data, inputEncoding, outputEncoding) {
        if (this.finalized) {
            throw new Error("Cipher has already been finalized");
        }
        this.chunks.push(toBuffer(data, inputEncoding));
        return outputEncoding ? "" : Buffer.alloc(0);
    }
    final(outputEncoding) {
        if (this.finalized) {
            throw new Error("Cipher has already been finalized");
        }
        this.finalized = true;
        if (this.algorithm !== "aes256gcm") {
            throw new Error(`Unsupported cipher: ${this.algorithm}`);
        }
        const input = this.chunks.length ? Buffer.concat(this.chunks) : Buffer.alloc(0);
        const result = op_crypto_aes_gcm_encrypt2(this.key, this.iv, input, this.aad);
        this.tag = result.tag;
        return toOutput(result.ciphertext, outputEncoding);
    }
    getAuthTag() {
        if (!this.tag) {
            throw new Error("Auth tag not available until final()");
        }
        return Buffer.from(this.tag);
    }
}
class Decipheriv {
    algorithm;
    key;
    iv;
    aad = new Uint8Array(0);
    tag = null;
    chunks = [];
    finalized = false;
    constructor(algorithm, key, iv){
        this.algorithm = normalizeAlgorithm1(algorithm);
        this.key = toBuffer(key);
        this.iv = toBuffer(iv);
    }
    setAAD(aad) {
        this.aad = toBuffer(aad);
        return this;
    }
    setAuthTag(tag) {
        this.tag = toBuffer(tag);
        return this;
    }
    update(data, inputEncoding, outputEncoding) {
        if (this.finalized) {
            throw new Error("Decipher has already been finalized");
        }
        this.chunks.push(toBuffer(data, inputEncoding));
        return outputEncoding ? "" : Buffer.alloc(0);
    }
    final(outputEncoding) {
        if (this.finalized) {
            throw new Error("Decipher has already been finalized");
        }
        if (!this.tag) {
            throw new Error("Auth tag must be set before final()");
        }
        this.finalized = true;
        if (this.algorithm !== "aes256gcm") {
            throw new Error(`Unsupported cipher: ${this.algorithm}`);
        }
        const input = this.chunks.length ? Buffer.concat(this.chunks) : Buffer.alloc(0);
        const plaintext = op_crypto_aes_gcm_decrypt2(this.key, this.iv, input, this.tag, this.aad);
        return toOutput(plaintext, outputEncoding);
    }
}
function createHash(algorithm) {
    return new Hash(algorithm);
}
function createHmac(algorithm, key) {
    return new Hmac(algorithm, key);
}
function createCipheriv(algorithm, key, iv) {
    return new Cipheriv(algorithm, key, iv);
}
function createDecipheriv(algorithm, key, iv) {
    return new Decipheriv(algorithm, key, iv);
}
function randomBytes(size, callback) {
    const bytes = Buffer.from(op_crypto_random2(size));
    if (callback) {
        callback(null, bytes);
        return undefined;
    }
    return bytes;
}
function randomFillSync(buffer, offset = 0, size) {
    const view = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    const length = size ?? view.length - offset;
    const bytes = op_crypto_random2(length);
    view.set(bytes, offset);
    return buffer;
}
function randomFill(buffer, offset, size, callback) {
    const cb = typeof offset === "function" ? offset : callback;
    const off = typeof offset === "number" ? offset : 0;
    const len = typeof size === "number" ? size : undefined;
    try {
        randomFillSync(buffer, off, len);
        cb?.(null, buffer);
    } catch (err) {
        cb?.(err);
    }
}
function randomInt(min, max, callback) {
    let low = min;
    let high = max;
    if (high === undefined) {
        high = low;
        low = 0;
    }
    if (high <= low) {
        const err = new RangeError("max must be greater than min");
        if (callback) {
            callback(err);
            return undefined;
        }
        throw err;
    }
    const range = high - low;
    const threshold = 0xffffffff - 0xffffffff % range;
    let value = 0;
    do {
        const bytes = op_crypto_random2(4);
        value = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength).getUint32(0, false);
    }while (value >= threshold)
    const result = low + value % range;
    if (callback) {
        callback(null, result);
        return undefined;
    }
    return result;
}
function timingSafeEqual(a, b) {
    const aBuf = Buffer.from(a.buffer, a.byteOffset, a.byteLength);
    const bBuf = Buffer.from(b.buffer, b.byteOffset, b.byteLength);
    if (aBuf.length !== bBuf.length) {
        throw new Error("Input buffers must have the same length");
    }
    let diff = 0;
    for(let i = 0; i < aBuf.length; i += 1){
        diff |= aBuf[i] ^ bBuf[i];
    }
    return diff === 0;
}
function getHashes() {
    return [
        ...HASHES
    ];
}
function hash(algorithm, data, outputEncoding) {
    const alg = normalizeAlgorithm1(algorithm);
    if (!HASHES.includes(alg)) {
        throw new Error(`Unsupported hash algorithm: ${algorithm}`);
    }
    const digest = digestBytes(alg, toBuffer(data));
    return toOutput(digest, outputEncoding);
}
function pbkdf2Sync(password, salt, iterations, keylen, digest) {
    return Buffer.from(op_crypto_pbkdf22(toBuffer(password), toBuffer(salt), iterations, keylen, digest));
}
function pbkdf2(password, salt, iterations, keylen, digest, callback) {
    try {
        const out = pbkdf2Sync(password, salt, iterations, keylen, digest);
        callback(null, out);
    } catch (err) {
        callback(err);
    }
}
function hkdfSync(hashName, ikm, salt, info, length) {
    const alg = normalizeAlgorithm1(hashName);
    if (!HASHES.includes(alg)) {
        throw new Error(`Unsupported HKDF hash: ${hashName}`);
    }
    const saltBuf = toBuffer(salt);
    const ikmBuf = toBuffer(ikm);
    const infoBuf = toBuffer(info);
    const hashLen = digestBytes(alg, new Uint8Array(0)).length;
    const saltKey = saltBuf.length ? saltBuf : Buffer.alloc(hashLen);
    const prk = hmacDigest(alg, saltKey, ikmBuf);
    const blocks = [];
    let prev = Buffer.alloc(0);
    let counter = 1;
    while(Buffer.concat(blocks).length < length){
        const input = Buffer.concat([
            prev,
            infoBuf,
            Buffer.from([
                counter
            ])
        ]);
        prev = Buffer.from(hmacDigest(alg, Buffer.from(prk), input));
        blocks.push(prev);
        counter += 1;
    }
    return Buffer.concat(blocks).subarray(0, length);
}
function hkdf(hashName, ikm, salt, info, length, callback) {
    try {
        const out = hkdfSync(hashName, ikm, salt, info, length);
        callback(null, out);
    } catch (err) {
        callback(err);
    }
}
function decodeBytes1(input, encoding) {
    if (typeof input === "string") return Buffer.from(input, encoding);
    return toBuffer(input);
}
function outputBytes(bytes, encoding) {
    return toOutput(bytes, encoding);
}
function normalizePassphrase(passphrase) {
    if (!passphrase) return "";
    if (Buffer.isBuffer(passphrase)) return passphrase.toString();
    return String(passphrase);
}
class KeyObject {
    _id;
    type;
    asymmetricKeyType;
    asymmetricKeyDetails;
    symmetricKeySize;
    constructor(id){
        this._id = id;
        const info = op_crypto_key_info2(id);
        this.type = info.key_type;
        this.asymmetricKeyType = info.asymmetric_key_type || undefined;
        if (info.asymmetric_key_details) {
            const details = {
                ...info.asymmetric_key_details
            };
            if (typeof details.publicExponent === "string") {
                details.publicExponent = BigInt(details.publicExponent);
            }
            this.asymmetricKeyDetails = details;
        }
        this.symmetricKeySize = info.symmetric_key_size ?? undefined;
    }
    export(options) {
        if (options !== undefined && (typeof options !== "object" || options === null)) {
            throw new Error("Invalid export options");
        }
        if (!options || options.format === undefined || options.format === "buffer") {
            if (this.type === "secret") {
                return Buffer.from(op_crypto_key_export_der2(this._id, "buffer"));
            }
        }
        const format = options?.format || (this.type === "public" ? "pem" : "pem");
        if (format === "jwk") {
            if (options?.passphrase || options?.cipher) {
                throw new Error("JWK export does not support encryption");
            }
            return op_crypto_key_export_jwk2(this._id);
        }
        if (format === "der") {
            const typ = options?.type || (this.type === "public" ? "spki" : "pkcs8");
            return Buffer.from(op_crypto_key_export_der2(this._id, typ));
        }
        const typ = options?.type || (this.type === "public" ? "spki" : "pkcs8");
        const cipher = options?.cipher || "";
        const passphrase = normalizePassphrase(options?.passphrase);
        return Buffer.from(op_crypto_key_export_pem2(this._id, typ, cipher, passphrase));
    }
    equals(other) {
        return op_crypto_key_equals2(this._id, other._id);
    }
    toString() {
        return "[object KeyObject]";
    }
}
function createSecretKey(key) {
    const id = op_crypto_key_from_secret2(toBuffer(key));
    return new KeyObject(id);
}
function resolveKeyInput(input) {
    if (input instanceof KeyObject) {
        return input;
    }
    if (typeof input === "string" || Buffer.isBuffer(input) || input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
        return {
            key: input,
            format: "pem"
        };
    }
    if (typeof input === "object" && input && "key" in input) {
        return input;
    }
    throw new Error("Invalid key input");
}
function createPublicKey(input) {
    if (input instanceof KeyObject) {
        if (input.type === "public") {
            throw new Error("Public key already provided");
        }
        if (input.type !== "private") {
            throw new Error("Invalid key type");
        }
        const pubId = op_crypto_key_public2(input._id);
        return new KeyObject(pubId);
    }
    const keyInput = resolveKeyInput(input);
    if (keyInput instanceof KeyObject) return keyInput;
    if (keyInput.format === "jwk") {
        const id = op_crypto_key_from_jwk2(keyInput.key);
        return new KeyObject(id);
    }
    if (keyInput.format === "der") {
        const typ = keyInput.type || "spki";
        const id = op_crypto_key_from_der2(decodeBytes1(keyInput.key), "public", typ);
        return new KeyObject(id);
    }
    const passphrase = normalizePassphrase(keyInput.passphrase);
    const id = op_crypto_key_from_pem2(decodeBytes1(keyInput.key), "public", passphrase);
    return new KeyObject(id);
}
function createPrivateKey(input) {
    if (input instanceof KeyObject) {
        throw new Error("KeyObject is not supported here");
    }
    const keyInput = resolveKeyInput(input);
    if (keyInput instanceof KeyObject) return keyInput;
    if (keyInput.format === "jwk") {
        const id = op_crypto_key_from_jwk2(keyInput.key);
        return new KeyObject(id);
    }
    if (keyInput.format === "der") {
        const typ = keyInput.type || "pkcs8";
        const id = op_crypto_key_from_der2(decodeBytes1(keyInput.key), "private", typ);
        return new KeyObject(id);
    }
    const passphrase = normalizePassphrase(keyInput.passphrase);
    const id = op_crypto_key_from_pem2(decodeBytes1(keyInput.key), "private", passphrase);
    return new KeyObject(id);
}
function createSign(algorithm) {
    const chunks = [];
    return {
        update (data, encoding) {
            chunks.push(toBuffer(data, encoding));
            return this;
        },
        sign (options, outputEncoding) {
            const key = createPrivateKey(options);
            const padding = options?.padding ?? 0;
            const saltLength = options?.saltLength ?? 0;
            const dsaEncoding = options?.dsaEncoding ?? "der";
            const data = chunks.length ? Buffer.concat(chunks) : Buffer.alloc(0);
            const sig = op_crypto_sign2(algorithm, data, key._id, padding, saltLength, dsaEncoding);
            return outputBytes(sig, outputEncoding);
        }
    };
}
function createVerify(algorithm) {
    const chunks = [];
    return {
        update (data, encoding) {
            chunks.push(toBuffer(data, encoding));
            return this;
        },
        verify (options, signature, sigEncoding) {
            const key = createPublicKey(options);
            const padding = options?.padding ?? 0;
            const saltLength = options?.saltLength ?? 0;
            const dsaEncoding = options?.dsaEncoding ?? "der";
            const data = chunks.length ? Buffer.concat(chunks) : Buffer.alloc(0);
            const sigBytes = decodeBytes1(signature, sigEncoding);
            return op_crypto_verify2(algorithm, data, key._id, sigBytes, padding, saltLength, dsaEncoding);
        }
    };
}
function sign(algorithm, data, options) {
    const signer = createSign(algorithm);
    signer.update(data);
    return signer.sign(options);
}
function verify(algorithm, data, options, signature, sigEncoding) {
    const verifier = createVerify(algorithm);
    verifier.update(data);
    return verifier.verify(options, signature, sigEncoding);
}
function generateKeyPairSync(type, options = {}) {
    const result = op_crypto_generate_keypair2(type, options);
    return {
        publicKey: new KeyObject(result.public_id),
        privateKey: new KeyObject(result.private_id)
    };
}
function generateKeyPair(type, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    try {
        const result = generateKeyPairSync(type, options);
        callback?.(null, result.publicKey, result.privateKey);
    } catch (err) {
        callback?.(err);
    }
}
class ECDH {
    _id;
    constructor(curve){
        this._id = op_crypto_ecdh_new2(curve);
    }
    generateKeys(encoding = "buffer", format = "uncompressed") {
        const bytes = op_crypto_ecdh_generate2(this._id, String(encoding), format);
        return outputBytes(bytes, encoding);
    }
    getPublicKey(encoding = "buffer", format = "uncompressed") {
        const bytes = op_crypto_ecdh_get_public2(this._id, format);
        return outputBytes(bytes, encoding);
    }
    getPrivateKey(encoding = "buffer") {
        const bytes = op_crypto_ecdh_get_private2(this._id);
        return outputBytes(bytes, encoding);
    }
    setPrivateKey(key, encoding) {
        const bytes = decodeBytes1(key, encoding);
        op_crypto_ecdh_set_private2(this._id, bytes);
        return this;
    }
    computeSecret(otherPublicKey, inputEncoding, outputEncoding) {
        const bytes = decodeBytes1(otherPublicKey, inputEncoding);
        const secret = op_crypto_ecdh_compute_secret2(this._id, bytes);
        return outputBytes(secret, outputEncoding || "buffer");
    }
    static convertKey(key, curve, inputEncoding = "buffer", outputEncoding = "buffer", format = "uncompressed") {
        const input = decodeBytes1(key, inputEncoding);
        const converted = op_crypto_ecdh_convert2(curve, input, String(inputEncoding), String(outputEncoding), format);
        if (outputEncoding === "hex" || outputEncoding === "base64") {
            return Buffer.from(converted).toString(outputEncoding);
        }
        return Buffer.from(converted);
    }
}
function createECDH(curve) {
    return new ECDH(curve);
}
function getCurves() {
    return op_crypto_get_curves2();
}
const constants1 = {
    RSA_PKCS1_PADDING: 1,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_PKCS1_PSS_PADDING: 6
};
const webcrypto = globalThis.crypto;
globalThis.__dekaNodeCrypto = {
    webcrypto,
    getRandomValues: webcrypto?.getRandomValues?.bind(webcrypto),
    randomUUID: webcrypto?.randomUUID?.bind(webcrypto),
    constants: constants1,
    randomBytes,
    randomFillSync,
    randomFill,
    randomInt,
    timingSafeEqual,
    createHash,
    createHmac,
    createSign,
    createVerify,
    sign,
    verify,
    createSecretKey,
    createPublicKey,
    createPrivateKey,
    generateKeyPair,
    generateKeyPairSync,
    KeyObject,
    createECDH,
    ECDH,
    getCurves,
    createCipheriv,
    createDecipheriv,
    Hash,
    Hmac,
    Cipheriv,
    Decipheriv,
    pbkdf2,
    pbkdf2Sync,
    hkdf,
    hkdfSync,
    getHashes,
    hash
};
const env1 = globalThis.process?.env || {};
const EventEmitter1 = globalThis.__dekaNodeEvents?.EventEmitter;
function readEnvNumber(name, fallback) {
    const value = env1[name];
    if (typeof value !== "string") return fallback;
    const parsed = Number.parseInt(value, 10);
    return Number.isFinite(parsed) ? parsed : fallback;
}
function isatty(_fd) {
    return env1.TERM !== undefined && env1.TERM !== "dumb";
}
function colorDepth(isTTY) {
    if (!isTTY) return 1;
    const term = (env1.TERM || "").toLowerCase();
    const colorTerm = (env1.COLORTERM || "").toLowerCase();
    if (colorTerm.includes("truecolor") || colorTerm.includes("24bit")) return 24;
    if (term.includes("truecolor") || term.includes("24bit")) return 24;
    if (term.includes("256color")) return 8;
    return 4;
}
class ReadStream extends (EventEmitter1 || class {
}) {
    isTTY;
    isRaw;
    constructor(fd = 0){
        super();
        this.isTTY = isatty(fd);
        this.isRaw = false;
    }
    setRawMode(mode) {
        this.isRaw = Boolean(mode);
        return this;
    }
}
class WriteStream extends (EventEmitter1 || class {
}) {
    isTTY;
    columns;
    rows;
    constructor(fd = 1){
        super();
        this.isTTY = isatty(fd);
        this.columns = readEnvNumber("COLUMNS", 80);
        this.rows = readEnvNumber("LINES", 24);
    }
    getColorDepth() {
        return colorDepth(this.isTTY);
    }
    hasColors(count = 16) {
        if (!this.isTTY) return false;
        const depth = this.getColorDepth();
        if (depth >= 24) return true;
        if (depth >= 8) return count <= 256;
        return count <= 16;
    }
    getWindowSize() {
        return [
            this.columns,
            this.rows
        ];
    }
}
globalThis.__dekaNodeTty = {
    isatty,
    ReadStream,
    WriteStream
};
function encode1(input) {
    return String(input);
}
function decode1(input) {
    return String(input);
}
function toASCII(input) {
    return String(input);
}
function toUnicode(input) {
    return String(input);
}
globalThis.__dekaNodePunycode = {
    encode: encode1,
    decode: decode1,
    toASCII,
    toUnicode,
    ucs2: {
        decode: (input)=>Array.from(input).map((__char)=>__char.codePointAt(0) || 0),
        encode: (codePoints)=>codePoints.map((point)=>String.fromCodePoint(point)).join("")
    },
    version: "2.3.1"
};
class Channel {
    name;
    subscribers;
    constructor(name){
        this.name = name;
        this.subscribers = new Set();
    }
    subscribe(listener) {
        this.subscribers.add(listener);
    }
    unsubscribe(listener) {
        this.subscribers.delete(listener);
    }
    hasSubscribers() {
        return this.subscribers.size > 0;
    }
    publish(message) {
        for (const listener of this.subscribers){
            listener(message, this.name);
        }
    }
}
const channels = new Map();
function channel(name) {
    const key = String(name);
    const existing = channels.get(key);
    if (existing) return existing;
    const created = new Channel(key);
    channels.set(key, created);
    return created;
}
globalThis.__dekaNodeDiagnosticsChannel = {
    channel,
    Channel
};
const CONTEXT_SYMBOL = Symbol.for("deka.async_hooks.context");
const getAsyncContext = Deno.core?.ops?.op_async_context_get || (()=>globalThis[CONTEXT_SYMBOL]);
const setAsyncContext = Deno.core?.ops?.op_async_context_set || ((value)=>{
    globalThis[CONTEXT_SYMBOL] = value;
});
function getContextMap() {
    const current = getAsyncContext();
    if (current instanceof Map) return current;
    const map = new Map();
    setAsyncContext(map);
    return map;
}
const promiseContext = new WeakMap();
const contextStack = [];
if (Deno.core?.ops?.op_set_promise_hooks) {
    const initHook = (promise, parent)=>{
        if (parent && promiseContext.has(parent)) {
            promiseContext.set(promise, promiseContext.get(parent));
        } else {
            promiseContext.set(promise, getContextMap());
        }
    };
    const beforeHook = (promise)=>{
        const ctx = promiseContext.get(promise);
        if (!ctx) return;
        contextStack.push(getContextMap());
        setAsyncContext(ctx);
    };
    const afterHook = ()=>{
        const prev = contextStack.pop();
        if (prev) {
            setAsyncContext(prev);
        }
    };
    globalThis.__dekaPromiseHooks = {
        initHook,
        beforeHook,
        afterHook
    };
    Deno.core.ops.op_set_promise_hooks(initHook, beforeHook, afterHook, undefined);
}
function captureContext() {
    return new Map(getContextMap());
}
class AsyncLocalStorage {
    run(store, callback, ...args) {
        const ctx = captureContext();
        ctx.set(this, store);
        const prev = getContextMap();
        setAsyncContext(ctx);
        const result = callback(...args);
        if (result && typeof result.finally === "function") {
            return result.finally(()=>{
                setAsyncContext(prev);
            });
        }
        setAsyncContext(prev);
        return result;
    }
    getStore() {
        return getContextMap().get(this);
    }
    enterWith(store) {
        const ctx = captureContext();
        ctx.set(this, store);
        setAsyncContext(ctx);
    }
}
class AsyncResource {
    type;
    constructor(type = "DEKA_ASYNC_RESOURCE"){
        this.type = String(type);
    }
    runInAsyncScope(fn, thisArg, ...args) {
        return fn.apply(thisArg, args);
    }
    emitDestroy() {}
    asyncId() {
        return 0;
    }
    triggerAsyncId() {
        return 0;
    }
}
const createHook = ()=>{
    return {
        enable () {},
        disable () {}
    };
};
const executionAsyncId = ()=>0;
const triggerAsyncId = ()=>0;
globalThis.__dekaNodeAsyncHooks = {
    AsyncLocalStorage,
    AsyncResource,
    createHook,
    executionAsyncId,
    triggerAsyncId
};
const fallbackOrigin = Date.now();
const performance1 = globalThis.performance || {
    timeOrigin: fallbackOrigin,
    now () {
        return Date.now() - fallbackOrigin;
    },
    mark () {},
    measure () {},
    getEntries () {
        return [];
    }
};
const PerformanceObserver1 = globalThis.PerformanceObserver;
const PerformanceObserverEntryList1 = globalThis.PerformanceObserverEntryList;
const PerformanceEntry1 = globalThis.PerformanceEntry;
const PerformanceMark1 = globalThis.PerformanceMark;
const PerformanceMeasure1 = globalThis.PerformanceMeasure;
const constants2 = {
    NODE_PERFORMANCE_GC_MAJOR: 0,
    NODE_PERFORMANCE_GC_MINOR: 1,
    NODE_PERFORMANCE_GC_INCREMENTAL: 2,
    NODE_PERFORMANCE_GC_WEAKCB: 3
};
const monitorEventLoopDelay = ()=>{
    return {
        enable () {},
        disable () {},
        reset () {},
        min: 0,
        max: 0,
        mean: 0,
        stddev: 0
    };
};
const createHistogram = ()=>{
    return {
        record () {},
        reset () {},
        min: 0,
        max: 0,
        mean: 0,
        stddev: 0
    };
};
const perfHooks = {
    performance: performance1,
    PerformanceObserver: PerformanceObserver1,
    PerformanceObserverEntryList: PerformanceObserverEntryList1,
    PerformanceEntry: PerformanceEntry1,
    PerformanceMark: PerformanceMark1,
    PerformanceMeasure: PerformanceMeasure1,
    constants: constants2,
    monitorEventLoopDelay,
    createHistogram
};
globalThis.__dekaNodePerfHooks = perfHooks;
const baseOps3 = Deno.core.ops;
function formatOpArg3(arg) {
    if (arg === null) return "null";
    if (arg === undefined) return "undefined";
    if (typeof arg === "string") return `string(${arg.length})`;
    if (typeof arg === "number") return `number(${arg})`;
    if (typeof arg === "boolean") return `bool(${arg})`;
    if (typeof arg === "bigint") return `bigint(${arg.toString()})`;
    if (ArrayBuffer.isView(arg)) {
        return `${arg.constructor.name}(${arg.byteLength})`;
    }
    if (arg instanceof ArrayBuffer) {
        return `ArrayBuffer(${arg.byteLength})`;
    }
    if (Array.isArray(arg)) return `Array(${arg.length})`;
    if (typeof arg === "object") return `object`;
    return typeof arg;
}
function shouldSkipOpLog3(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE_FILTER) return false;
    if (name !== "op_read_module_source") return false;
    const first = args[0];
    if (typeof first !== "string") return false;
    if (first.endsWith("/package.json")) return true;
    if (first.endsWith("package.json")) return true;
    return false;
}
function logOpCall3(name, args) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog3(name, args)) return;
    const writer = baseOps3.op_stdout_write;
    if (!writer) return;
    const summary = args.map(formatOpArg3).join(", ");
    writer(new TextEncoder().encode(`[op] ${name} ${summary}\n`));
}
function logOpReturn3(name, startedAt, args, value) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog3(name, args)) {
        return;
    }
    const writer = baseOps3.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const summary = formatOpArg3(value);
    writer(new TextEncoder().encode(`[op] ${name} -> ${summary} (${elapsed}ms)\n`));
}
function logOpError3(name, startedAt, args, error) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    if (shouldSkipOpLog3(name, args)) {
        return;
    }
    const writer = baseOps3.op_stdout_write;
    if (!writer) return;
    const elapsed = Date.now() - startedAt;
    const message = error?.message || String(error);
    writer(new TextEncoder().encode(`[op] ${name} ! ${message} (${elapsed}ms)\n`));
}
function wrapOps3(ops) {
    const wrapped = {};
    for (const [name, fn] of Object.entries(ops)){
        if (typeof fn !== "function") continue;
        if (name === "op_stdout_write" || name === "op_stderr_write") {
            wrapped[name] = fn;
            continue;
        }
        wrapped[name] = (...args)=>{
            logOpCall3(name, args);
            const startedAt = Date.now();
            try {
                const result = fn(...args);
                if (result && typeof result.then === "function") {
                    return result.then((value)=>{
                        logOpReturn3(name, startedAt, args, value);
                        return value;
                    }).catch((error)=>{
                        logOpError3(name, startedAt, args, error);
                        throw error;
                    });
                }
                logOpReturn3(name, startedAt, args, result);
                return result;
            } catch (error) {
                logOpError3(name, startedAt, args, error);
                throw error;
            }
        };
    }
    return wrapped;
}
const ops3 = globalThis.process?.env?.DEKA_VERBOSE ? wrapOps3(baseOps3) : baseOps3;
globalThis.__dekaOps = ops3;
const { op_read_handler_source: op_read_handler_source3, op_read_module_source: op_read_module_source3, op_read_env: op_read_env3, op_stdout_write: op_stdout_write3, op_stderr_write: op_stderr_write3, op_execute_isolate: op_execute_isolate3, op_transform_module: op_transform_module3, op_bundle_browser: op_bundle_browser3, op_bundle_browser_assets: op_bundle_browser_assets3, op_bundle_css: op_bundle_css3, op_transform_css: op_transform_css3, op_tailwind_process: op_tailwind_process3, op_read_file: op_read_file3, op_fs_exists: op_fs_exists3, op_fs_stat: op_fs_stat3, op_fs_read_dir: op_fs_read_dir3, op_fs_mkdir: op_fs_mkdir3, op_fs_remove_file: op_fs_remove_file3, op_fs_append: op_fs_append3, op_fs_append_bytes: op_fs_append_bytes3, op_fs_open: op_fs_open3, op_fs_close: op_fs_close3, op_fs_read: op_fs_read3, op_fs_write: op_fs_write3, op_fs_copy_file: op_fs_copy_file3, op_zlib_gzip: op_zlib_gzip3, op_write_file: op_write_file3, op_write_file_base64: op_write_file_base643, op_introspect_stats: op_introspect_stats3, op_introspect_top: op_introspect_top3, op_introspect_workers: op_introspect_workers3, op_introspect_isolate: op_introspect_isolate3, op_introspect_kill_isolate: op_introspect_kill_isolate3, op_introspect_requests: op_introspect_requests3, op_introspect_evict: op_introspect_evict3, op_set_introspect_profiling: op_set_introspect_profiling3, op_ws_send: op_ws_send3, op_ws_send_binary: op_ws_send_binary3, op_ws_close: op_ws_close3, op_blob_create: op_blob_create3, op_blob_get: op_blob_get3, op_blob_size: op_blob_size3, op_blob_type: op_blob_type3, op_blob_slice: op_blob_slice3, op_blob_drop: op_blob_drop3, op_stream_create: op_stream_create3, op_stream_enqueue: op_stream_enqueue3, op_stream_close: op_stream_close3, op_stream_read: op_stream_read3, op_stream_drop: op_stream_drop3, op_crypto_random: op_crypto_random3, op_crypto_digest: op_crypto_digest3, op_crypto_hmac: op_crypto_hmac3, op_crypto_pbkdf2: op_crypto_pbkdf23, op_crypto_aes_gcm_encrypt: op_crypto_aes_gcm_encrypt3, op_crypto_aes_gcm_decrypt: op_crypto_aes_gcm_decrypt3, op_crypto_key_info: op_crypto_key_info3, op_crypto_key_from_secret: op_crypto_key_from_secret3, op_crypto_key_from_pem: op_crypto_key_from_pem3, op_crypto_key_from_der: op_crypto_key_from_der3, op_crypto_key_from_jwk: op_crypto_key_from_jwk3, op_crypto_key_export_pem: op_crypto_key_export_pem3, op_crypto_key_export_der: op_crypto_key_export_der3, op_crypto_key_export_jwk: op_crypto_key_export_jwk3, op_crypto_key_public: op_crypto_key_public3, op_crypto_key_equals: op_crypto_key_equals3, op_crypto_sign: op_crypto_sign3, op_crypto_verify: op_crypto_verify3, op_crypto_generate_keypair: op_crypto_generate_keypair3, op_crypto_get_curves: op_crypto_get_curves3, op_crypto_ecdh_new: op_crypto_ecdh_new3, op_crypto_ecdh_generate: op_crypto_ecdh_generate3, op_crypto_ecdh_get_public: op_crypto_ecdh_get_public3, op_crypto_ecdh_get_private: op_crypto_ecdh_get_private3, op_crypto_ecdh_set_private: op_crypto_ecdh_set_private3, op_crypto_ecdh_compute_secret: op_crypto_ecdh_compute_secret3, op_crypto_ecdh_convert: op_crypto_ecdh_convert3, op_url_parse: op_url_parse3, op_napi_open: op_napi_open3, op_http_fetch: op_http_fetch3, op_process_spawn: op_process_spawn3, op_process_spawn_sync: op_process_spawn_sync3, op_process_read_stdout: op_process_read_stdout3, op_process_read_stderr: op_process_read_stderr3, op_process_write_stdin: op_process_write_stdin3, op_process_close_stdin: op_process_close_stdin3, op_process_wait: op_process_wait3, op_process_kill: op_process_kill3, op_sleep: op_sleep3, op_udp_bind: op_udp_bind3, op_udp_send: op_udp_send3, op_udp_recv: op_udp_recv3, op_udp_close: op_udp_close3, op_udp_local_addr: op_udp_local_addr3, op_udp_peer_addr: op_udp_peer_addr3, op_udp_connect: op_udp_connect3, op_udp_disconnect: op_udp_disconnect3, op_udp_set_broadcast: op_udp_set_broadcast3, op_udp_set_ttl: op_udp_set_ttl3, op_udp_set_multicast_ttl: op_udp_set_multicast_ttl3, op_udp_set_multicast_loop: op_udp_set_multicast_loop3, op_udp_set_multicast_if: op_udp_set_multicast_if3, op_udp_join_multicast: op_udp_join_multicast3, op_udp_leave_multicast: op_udp_leave_multicast3, op_udp_set_recv_buffer_size: op_udp_set_recv_buffer_size3, op_udp_set_send_buffer_size: op_udp_set_send_buffer_size3, op_udp_get_recv_buffer_size: op_udp_get_recv_buffer_size3, op_udp_get_send_buffer_size: op_udp_get_send_buffer_size3, op_dns_lookup: op_dns_lookup3, op_dns_reverse: op_dns_reverse3, op_tcp_listen: op_tcp_listen3, op_tcp_accept: op_tcp_accept3, op_tcp_connect: op_tcp_connect3, op_tcp_read: op_tcp_read3, op_tcp_write: op_tcp_write3, op_tcp_close: op_tcp_close3, op_tcp_shutdown: op_tcp_shutdown3, op_tcp_local_addr: op_tcp_local_addr3, op_tcp_peer_addr: op_tcp_peer_addr3, op_tcp_listener_addr: op_tcp_listener_addr3, op_tcp_listener_close: op_tcp_listener_close3 } = ops3;
class ReadableStreamController2 {
    streamId;
    queue;
    resolvers;
    state;
    constructor(streamId, queue, resolvers, state){
        this.streamId = streamId;
        this.queue = queue;
        this.resolvers = resolvers;
        this.state = state;
    }
    enqueue(chunk) {
        if (this.queue && this.resolvers) {
            const entry = {
                value: chunk,
                done: false
            };
            const resolver = this.resolvers.shift();
            if (resolver) {
                resolver(entry);
                return;
            }
            this.queue.push(entry);
            return;
        }
        if (this.streamId !== undefined) {
            const bytes = normalizeChunk2(chunk);
            op_stream_enqueue3(this.streamId, bytes);
        }
    }
    close() {
        if (this.queue && this.resolvers) {
            const entry = {
                done: true
            };
            if (this.state) {
                this.state.closed = true;
            }
            const resolver = this.resolvers.shift();
            if (resolver) {
                resolver(entry);
                return;
            }
            this.queue.push(entry);
            return;
        }
        if (this.streamId !== undefined) {
            op_stream_close3(this.streamId);
        }
    }
    error(_reason) {
        if (this.state) {
            this.state.closed = true;
        }
        this.close();
    }
}
class ReadableStreamDefaultReader2 {
    streamId;
    queue;
    resolvers;
    stream;
    constructor(streamId, queue, resolvers, stream){
        this.streamId = streamId;
        this.queue = queue;
        this.resolvers = resolvers;
        this.stream = stream;
    }
    async read() {
        if (this.queue && this.resolvers) {
            const entry = this.queue.shift();
            if (entry) {
                return entry;
            }
            if (this.stream?.state?.closed) {
                return {
                    done: true
                };
            }
            if (this.stream?.source && this.stream?.controller) {
                const maybe = this.stream.source.pull?.(this.stream.controller);
                if (maybe && typeof maybe.then === "function") {
                    await maybe;
                }
                const pulled = this.queue.shift();
                if (pulled) {
                    return pulled;
                }
            }
            return new Promise((resolve)=>{
                this.resolvers?.push(resolve);
            });
        }
        if (this.streamId !== undefined) {
            const result = await op_stream_read3(this.streamId);
            if (result.done) {
                return {
                    done: true
                };
            }
            if (result.chunk) {
                return {
                    value: result.chunk,
                    done: false
                };
            }
        }
        return {
            done: true
        };
    }
    releaseLock() {}
}
class ReadableStreamDefaultController2 {
    desiredSize = null;
    enqueue() {}
    close() {}
    error() {}
}
class ReadableByteStreamController2 extends ReadableStreamDefaultController2 {
}
class ReadableStreamBYOBRequest2 {
    view;
    constructor(view){
        this.view = view;
    }
    respond() {}
    respondWithNewView() {}
}
class ReadableStreamBYOBReader2 {
    read() {
        return Promise.resolve({
            value: undefined,
            done: true
        });
    }
    releaseLock() {}
}
class ReadableStream2 {
    streamId;
    queue;
    resolvers;
    state;
    raw;
    source;
    controller;
    constructor(source = {}, options = {}){
        this.raw = !!options.raw;
        this.state = {
            closed: false
        };
        if (this.raw) {
            this.queue = [];
            this.resolvers = [];
        } else {
            this.streamId = op_stream_create3();
        }
        this.source = source;
        const controller = new ReadableStreamController2(this.streamId, this.queue, this.resolvers, this.state);
        this.controller = controller;
        source.start?.(controller);
    }
    getReader() {
        return new ReadableStreamDefaultReader2(this.streamId, this.queue, this.resolvers, this);
    }
    async pipeTo(destination, options = {}) {
        const reader = this.getReader();
        const writer = destination.getWriter();
        const { preventClose, preventAbort, preventCancel, signal } = options;
        if (signal) {
            if (signal.aborted) {
                if (!preventAbort) await writer.abort(signal.reason);
                throw signal.reason;
            }
            signal.addEventListener("abort", ()=>{
                if (!preventAbort) {
                    writer.abort(signal.reason);
                }
            }, {
                once: true
            });
        }
        try {
            for(;;){
                const { value, done } = await reader.read();
                if (done) break;
                await writer.write(value);
            }
            if (!preventClose) {
                await writer.close();
            }
        } catch (err) {
            if (!preventAbort) {
                await writer.abort(err);
            }
            if (!preventCancel) {
                this._closeRaw();
            }
            throw err;
        }
    }
    pipeThrough(transform, options) {
        const internal = transform._transformer;
        if (internal) {
            const reader = this.getReader();
            return new ReadableStream2({
                async pull (controller) {
                    const { value, done } = await reader.read();
                    if (done) {
                        internal.flush?.(controller);
                        controller.close();
                        return;
                    }
                    if (internal.transform) {
                        internal.transform(value, controller);
                        return;
                    }
                    controller.enqueue(value);
                }
            }, {
                raw: true
            });
        }
        void this.pipeTo(transform.writable, options);
        return transform.readable;
    }
    tee() {
        const reader = this.getReader();
        const queueA = [];
        const queueB = [];
        const waitersA = [];
        const waitersB = [];
        let pulling = null;
        const enqueueTo = (queue, waiters, entry)=>{
            const waiter = waiters.shift();
            if (waiter) {
                waiter(entry);
                return;
            }
            queue.push(entry);
        };
        const pullFromSource = async ()=>{
            if (pulling) {
                await pulling;
                return;
            }
            pulling = (async ()=>{
                const result = await reader.read();
                const entry = result.done ? {
                    done: true
                } : {
                    value: result.value,
                    done: false
                };
                enqueueTo(queueA, waitersA, entry);
                enqueueTo(queueB, waitersB, entry);
            })();
            try {
                await pulling;
            } finally{
                pulling = null;
            }
        };
        const makeClone = (queue, waiters)=>new ReadableStream2({
                async pull (controller) {
                    const entry = queue.shift();
                    if (entry) {
                        if (entry.done) controller.close();
                        else controller.enqueue(entry.value);
                        return;
                    }
                    await pullFromSource();
                    const next = queue.shift();
                    if (next) {
                        if (next.done) controller.close();
                        else controller.enqueue(next.value);
                        return;
                    }
                    waiters.push((result)=>{
                        if (result.done) controller.close();
                        else controller.enqueue(result.value);
                    });
                }
            }, {
                raw: true
            });
        return [
            makeClone(queueA, waitersA),
            makeClone(queueB, waitersB)
        ];
    }
    async *[Symbol.asyncIterator]() {
        const reader = this.getReader();
        for(;;){
            const { value, done } = await reader.read();
            if (done) break;
            yield value;
        }
    }
    _drop() {
        if (this.streamId !== undefined) {
            op_stream_drop3(this.streamId);
        }
        this.queue = [];
        this.resolvers = [];
    }
    _enqueueRaw(chunk) {
        if (!this.queue || !this.resolvers) return;
        const entry = {
            value: chunk,
            done: false
        };
        const resolver = this.resolvers.shift();
        if (resolver) {
            resolver(entry);
            return;
        }
        this.queue.push(entry);
    }
    _closeRaw() {
        if (!this.queue || !this.resolvers) return;
        this.state.closed = true;
        const entry = {
            done: true
        };
        const resolver = this.resolvers.shift();
        if (resolver) {
            resolver(entry);
            return;
        }
        this.queue.push(entry);
    }
}
class WritableStreamDefaultWriter2 {
    sink;
    constructor(sink){
        this.sink = sink;
    }
    write(chunk) {
        return Promise.resolve(this.sink.write?.(chunk));
    }
    close() {
        return Promise.resolve(this.sink.close?.());
    }
    abort(reason) {
        return Promise.resolve(this.sink.abort?.(reason));
    }
}
class WritableStreamDefaultController2 {
    error() {}
}
class WritableStream2 {
    sink;
    constructor(sink = {}){
        this.sink = sink;
    }
    getWriter() {
        return new WritableStreamDefaultWriter2(this.sink);
    }
    async abort(reason) {
        await this.sink.abort?.(reason);
    }
}
class TransformStream2 {
    readable;
    writable;
    _transformer;
    constructor(transformer){
        this._transformer = transformer;
        let controllerRef = null;
        this.readable = new ReadableStream2({
            start (controller) {
                controllerRef = controller;
            }
        }, {
            raw: true
        });
        this.writable = new WritableStream2({
            write (chunk) {
                if (!controllerRef) return;
                if (transformer?.transform) {
                    transformer.transform(chunk, controllerRef);
                } else {
                    controllerRef.enqueue(chunk);
                }
            },
            close () {
                if (!controllerRef) return;
                transformer?.flush?.(controllerRef);
                controllerRef.close();
            },
            abort () {
                if (!controllerRef) return;
                controllerRef.error();
            }
        });
    }
}
class TransformStreamDefaultController2 {
    enqueue() {}
    terminate() {}
    error() {}
}
class ByteLengthQueuingStrategy2 {
    highWaterMark;
    constructor({ highWaterMark } = {}){
        this.highWaterMark = Number(highWaterMark ?? 1);
    }
    size(chunk) {
        if (chunk && typeof chunk.byteLength === "number") {
            return chunk.byteLength;
        }
        return 1;
    }
}
class CountQueuingStrategy2 {
    highWaterMark;
    constructor({ highWaterMark } = {}){
        this.highWaterMark = Number(highWaterMark ?? 1);
    }
    size() {
        return 1;
    }
}
class TextEncoderStream2 {
    readable;
    writable;
    constructor(){
        const encoder = new TextEncoder();
        this.readable = new ReadableStream2({}, {
            raw: true
        });
        const readable = this.readable;
        this.writable = new WritableStream2({
            write (chunk) {
                readable._enqueueRaw(encoder.encode(String(chunk)));
            },
            close: ()=>readable._closeRaw(),
            abort: ()=>readable._closeRaw()
        });
    }
}
class TextDecoderStream2 {
    readable;
    writable;
    constructor(){
        const decoder = new TextDecoder();
        this.readable = new ReadableStream2({}, {
            raw: true
        });
        const readable = this.readable;
        this.writable = new WritableStream2({
            write (chunk) {
                const bytes = normalizeChunk2(chunk);
                readable._enqueueRaw(decoder.decode(bytes, {
                    stream: true
                }));
            },
            close: ()=>readable._closeRaw(),
            abort: ()=>readable._closeRaw()
        });
    }
}
class CompressionStream2 {
    readable;
    writable;
    constructor(_format){
        const passthrough = new TransformStream2();
        this.readable = passthrough.readable;
        this.writable = passthrough.writable;
    }
}
class DecompressionStream2 {
    readable;
    writable;
    constructor(_format){
        const passthrough = new TransformStream2();
        this.readable = passthrough.readable;
        this.writable = passthrough.writable;
    }
}
async function consumeReadableStream1(stream) {
    const reader = stream.getReader();
    const chunks = [];
    while(true){
        const { value, done } = await reader.read();
        if (done) break;
        if (value === undefined) continue;
        if (value instanceof Uint8Array) {
            chunks.push(new TextDecoder().decode(value));
        } else {
            chunks.push(String(value));
        }
    }
    return chunks.join("");
}
function normalizeChunk2(chunk) {
    if (chunk instanceof Uint8Array) {
        return chunk;
    }
    if (chunk instanceof ArrayBuffer) {
        return new Uint8Array(chunk);
    }
    if (ArrayBuffer.isView(chunk)) {
        return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    }
    return new TextEncoder().encode(String(chunk));
}
globalThis.ReadableStream = ReadableStream2;
globalThis.WritableStream = WritableStream2;
globalThis.TransformStream = TransformStream2;
globalThis.ReadableStreamDefaultReader = ReadableStreamDefaultReader2;
globalThis.ReadableStreamDefaultController = ReadableStreamDefaultController2;
globalThis.ReadableByteStreamController = ReadableByteStreamController2;
globalThis.ReadableStreamBYOBReader = ReadableStreamBYOBReader2;
globalThis.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest2;
globalThis.WritableStreamDefaultWriter = WritableStreamDefaultWriter2;
globalThis.WritableStreamDefaultController = WritableStreamDefaultController2;
globalThis.TransformStreamDefaultController = TransformStreamDefaultController2;
globalThis.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy2;
globalThis.CountQueuingStrategy = CountQueuingStrategy2;
globalThis.TextEncoderStream = TextEncoderStream2;
globalThis.TextDecoderStream = TextDecoderStream2;
globalThis.CompressionStream = CompressionStream2;
globalThis.DecompressionStream = DecompressionStream2;
class Headers2 {
    map;
    constructor(init){
        this.map = new Map();
        if (!init) return;
        if (init instanceof Headers2) {
            for (const [key, value] of init.entries()){
                this.append(key, value);
            }
            return;
        }
        if (Array.isArray(init)) {
            for (const [key, value] of init){
                this.append(key, value);
            }
            return;
        }
        for (const [key, value] of Object.entries(init)){
            this.append(key, value);
        }
    }
    normalize(name) {
        return name.toLowerCase();
    }
    append(name, value) {
        const key = this.normalize(name);
        const existing = this.map.get(key);
        if (existing) {
            existing.push(value);
        } else {
            this.map.set(key, [
                value
            ]);
        }
    }
    set(name, value) {
        const key = this.normalize(name);
        this.map.set(key, [
            value
        ]);
    }
    get(name) {
        const key = this.normalize(name);
        const values = this.map.get(key);
        if (!values || values.length === 0) return null;
        return values.join(", ");
    }
    getAll(name) {
        const key = this.normalize(name);
        return this.map.get(key)?.slice() || [];
    }
    has(name) {
        return this.map.has(this.normalize(name));
    }
    delete(name) {
        this.map.delete(this.normalize(name));
    }
    entries() {
        const result = [];
        for (const [key, values] of this.map.entries()){
            for (const value of values){
                result.push([
                    key,
                    value
                ]);
            }
        }
        return result[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    keys() {
        return this.map.keys();
    }
    values() {
        const values = [];
        for (const [, vals] of this.map.entries()){
            values.push(...vals);
        }
        return values[Symbol.iterator]();
    }
    forEach(callback) {
        for (const [key, values] of this.map.entries()){
            for (const value of values){
                callback(value, key, this);
            }
        }
    }
}
function headersToObject2(headers) {
    if (!headers) return {};
    if (headers instanceof Headers2) {
        const out = {};
        for (const [key, values] of headers.map.entries()){
            if (key === "set-cookie") {
                out[key] = values.join("\n");
            } else {
                out[key] = values.join(", ");
            }
        }
        return out;
    }
    return {
        ...headers
    };
}
if (typeof globalThis.Headers === "undefined") {
    globalThis.Headers = Headers2;
}
class ResponsePolyfill1 {
    status;
    headers;
    body;
    constructor(body = "", init = {}){
        this.status = init.status || 200;
        this.headers = new Headers2(init.headers);
        this.body = body ?? "";
    }
    get ok() {
        return this.status >= 200 && this.status <= 299;
    }
    static json(value, init = {}) {
        const body = JSON.stringify(value);
        const headers = {
            "Content-Type": "application/json",
            ...init.headers || {}
        };
        return new Response1(body, {
            ...init,
            headers
        });
    }
    static redirect(url, status = 302) {
        return new Response1("", {
            status,
            headers: {
                Location: url
            }
        });
    }
    async text() {
        const body = this.body;
        if (body === undefined || body === null) return "";
        if (typeof body === "string") return body;
        if (body instanceof Uint8Array) return new TextDecoder().decode(body);
        if (body instanceof ReadableStream2) return consumeReadableStream1(body);
        return String(body);
    }
    async arrayBuffer() {
        const body = this.body;
        if (body === undefined || body === null) return new ArrayBuffer(0);
        if (body instanceof Uint8Array) return body.buffer.slice(body.byteOffset, body.byteOffset + body.byteLength);
        if (typeof body === "string") return new TextEncoder().encode(body).buffer;
        if (body instanceof ReadableStream2) {
            const text = await consumeReadableStream1(body);
            return new TextEncoder().encode(text).buffer;
        }
        return new TextEncoder().encode(String(body)).buffer;
    }
    async json() {
        const text = await this.text();
        return text ? JSON.parse(text) : null;
    }
    toJSON() {
        const payload = {
            status: this.status,
            headers: headersToObject2(this.headers),
            body: this.body
        };
        const extra = this.body_base64;
        if (extra) {
            payload.body_base64 = extra;
        }
        return payload;
    }
}
const Response1 = globalThis.Response ?? ResponsePolyfill1;
if (typeof globalThis.Response === "undefined") {
    globalThis.Response = Response1;
}
const LOCAL_SERVERS = new Map();
const METHODS = [
    "GET",
    "HEAD",
    "POST",
    "PUT",
    "PATCH",
    "DELETE",
    "OPTIONS",
    "TRACE",
    "CONNECT"
];
function normalizeHeaders(headers) {
    const result = {};
    if (!headers) return result;
    for (const [key, value] of Object.entries(headers)){
        result[key.toLowerCase()] = String(value);
    }
    return result;
}
function buildUrl(options, pathOverride, defaultProtocol = "http:") {
    const protocol = options.protocol || defaultProtocol;
    const host = options.hostname || options.host || "localhost";
    const port = options.port ? `:${options.port}` : "";
    const path = pathOverride || options.path || "/";
    return `${protocol}//${host}${port}${path}`;
}
function normalizeRequestArgs(input, options, defaultProtocol = "http:") {
    let callback;
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    if (typeof input === "function") {
        callback = input;
        input = undefined;
    }
    let url = "";
    let requestOptions = {};
    if (typeof input === "string") {
        if (input.includes("://")) {
            url = input;
            requestOptions = options || {};
        } else {
            requestOptions = options || {};
            url = buildUrl(requestOptions, input, defaultProtocol);
        }
    } else if (input instanceof URL) {
        url = input.toString();
        requestOptions = options || {};
    } else if (input && typeof input === "object") {
        requestOptions = input;
        url = buildUrl(requestOptions, undefined, defaultProtocol);
    } else {
        requestOptions = options || {};
        url = buildUrl(requestOptions, undefined, defaultProtocol);
    }
    const method = (requestOptions.method || "GET").toUpperCase();
    const headers = normalizeHeaders(requestOptions.headers);
    return {
        url,
        method,
        headers,
        callback
    };
}
function coerceChunk(chunk) {
    if (typeof chunk === "string") {
        return new TextEncoder().encode(chunk);
    }
    if (chunk instanceof ArrayBuffer) {
        return new Uint8Array(chunk);
    }
    return chunk;
}
function joinChunks(chunks) {
    if (chunks.length === 0) return undefined;
    const total = chunks.reduce((sum, chunk)=>sum + chunk.length, 0);
    const buffer = new Uint8Array(total);
    let offset = 0;
    for (const chunk of chunks){
        buffer.set(chunk, offset);
        offset += chunk.length;
    }
    return buffer;
}
function concatBytes(left, right) {
    if (left.length === 0) return right;
    if (right.length === 0) return left;
    const buffer = new Uint8Array(left.length + right.length);
    buffer.set(left, 0);
    buffer.set(right, left.length);
    return buffer;
}
function parseHeaders(text) {
    const lines = text.split("\r\n");
    const [requestLine, ...rest] = lines;
    const [method = "GET", url = "/"] = requestLine.split(" ");
    const headers = {};
    for (const line of rest){
        if (!line) continue;
        const index = line.indexOf(":");
        if (index === -1) continue;
        const key = line.slice(0, index).trim().toLowerCase();
        const value = line.slice(index + 1).trim();
        headers[key] = value;
    }
    return {
        method,
        url,
        headers
    };
}
function statusMessageFor(code) {
    switch(code){
        case 200:
            return "OK";
        case 201:
            return "Created";
        case 204:
            return "No Content";
        case 400:
            return "Bad Request";
        case 401:
            return "Unauthorized";
        case 403:
            return "Forbidden";
        case 404:
            return "Not Found";
        case 500:
            return "Internal Server Error";
        default:
            return "OK";
    }
}
class IncomingMessage extends EventEmitter {
    statusCode;
    statusMessage;
    headers;
    url;
    method;
    encoding;
    constructor(init){
        super();
        this.statusCode = init.statusCode;
        this.statusMessage = init.statusMessage;
        this.headers = init.headers;
        this.url = init.url;
    }
    setEncoding(encoding) {
        this.encoding = encoding;
    }
    emitBody(body) {
        if (this.encoding) {
            const decoder = new TextDecoder(this.encoding);
            this.emit("data", decoder.decode(body));
        } else {
            this.emit("data", body);
        }
        this.emit("end");
    }
}
class ClientRequest extends EventEmitter {
    url;
    method;
    headers;
    chunks = [];
    ended = false;
    timeoutMs;
    abortController;
    constructor(init, callback){
        super();
        this.url = init.url;
        this.method = init.method;
        this.headers = init.headers;
        if (callback) {
            this.once("response", callback);
        }
    }
    setHeader(name, value) {
        this.headers[name.toLowerCase()] = String(value);
    }
    getHeader(name) {
        return this.headers[name.toLowerCase()];
    }
    removeHeader(name) {
        delete this.headers[name.toLowerCase()];
    }
    setTimeout(ms, callback) {
        this.timeoutMs = ms;
        if (callback) this.once("timeout", callback);
        return this;
    }
    abort() {
        if (this.abortController) {
            this.abortController.abort();
            this.emit("abort");
        }
    }
    write(chunk) {
        this.chunks.push(coerceChunk(chunk));
        return true;
    }
    end(chunk) {
        if (chunk !== undefined) {
            this.write(chunk);
        }
        if (this.ended) return;
        this.ended = true;
        queueMicrotask(()=>this.emit("finish"));
        this.performRequest();
    }
    async performRequest() {
        try {
            const body = joinChunks(this.chunks);
            const urlObj = new URL(this.url);
            const port = urlObj.port ? Number(urlObj.port) : 80;
            const localServer = urlObj.hostname === "localhost" || urlObj.hostname === "127.0.0.1" ? LOCAL_SERVERS.get(port) : undefined;
            if (localServer) {
                const response = await localServer.handleLocalRequest({
                    url: this.url,
                    method: this.method,
                    headers: this.headers,
                    body: body && body.length > 0 ? body : undefined
                });
                const headers = {};
                response.headers.forEach((value, key)=>{
                    headers[key.toLowerCase()] = value;
                });
                const message = new IncomingMessage({
                    statusCode: response.status,
                    statusMessage: response.statusText,
                    headers,
                    url: response.url
                });
                this.emit("response", message);
                const buffer = new Uint8Array(await response.arrayBuffer());
                message.emitBody(buffer);
                return;
            }
            const controller = typeof AbortController !== "undefined" ? new AbortController() : undefined;
            this.abortController = controller;
            let timeout;
            if (this.timeoutMs && controller) {
                timeout = setTimeout(()=>{
                    this.emit("timeout");
                    controller.abort();
                }, this.timeoutMs);
            }
            const response = await fetch(this.url, {
                method: this.method,
                headers: this.headers,
                body: body && body.length > 0 ? body : undefined,
                signal: controller?.signal
            });
            if (timeout) clearTimeout(timeout);
            const headers = {};
            response.headers.forEach((value, key)=>{
                headers[key.toLowerCase()] = value;
            });
            const message = new IncomingMessage({
                statusCode: response.status,
                statusMessage: response.statusText,
                headers,
                url: response.url
            });
            this.emit("response", message);
            const buffer = new Uint8Array(await response.arrayBuffer());
            message.emitBody(buffer);
        } catch (error) {
            this.emit("error", error);
        }
    }
}
class ServerResponse extends EventEmitter {
    statusCode = 200;
    statusMessage = "OK";
    headers = {};
    chunks = [];
    resolved = false;
    resolve;
    streamId;
    constructor(resolve, streamId){
        super();
        this.resolve = resolve;
        this.streamId = streamId;
    }
    setHeader(name, value) {
        this.headers[name.toLowerCase()] = String(value);
    }
    getHeader(name) {
        return this.headers[name.toLowerCase()];
    }
    getHeaderNames() {
        return Object.keys(this.headers);
    }
    hasHeader(name) {
        return name.toLowerCase() in this.headers;
    }
    removeHeader(name) {
        delete this.headers[name.toLowerCase()];
    }
    write(chunk) {
        this.chunks.push(coerceChunk(chunk));
        return true;
    }
    writeHead(statusCode, statusMessageOrHeaders, headers) {
        this.statusCode = statusCode;
        if (typeof statusMessageOrHeaders === "string") {
            this.statusMessage = statusMessageOrHeaders;
            if (headers) {
                for (const [key, value] of Object.entries(headers)){
                    this.setHeader(key, value);
                }
            }
            return;
        }
        if (statusMessageOrHeaders) {
            for (const [key, value] of Object.entries(statusMessageOrHeaders)){
                this.setHeader(key, value);
            }
        }
    }
    end(chunk) {
        if (chunk !== undefined) {
            this.write(chunk);
        }
        if (this.resolved) return;
        this.resolved = true;
        const body = joinChunks(this.chunks);
        if (this.streamId !== undefined) {
            this.flushTcp(body || new Uint8Array());
        } else {
            this.resolve(new Response1(body || "", {
                status: this.statusCode,
                headers: this.headers
            }));
        }
        this.emit("finish");
    }
    async flushTcp(body) {
        const headers = {
            ...this.headers
        };
        headers["content-length"] = String(body.length);
        if (!headers["connection"]) {
            headers["connection"] = "close";
        }
        const lines = [
            `HTTP/1.1 ${this.statusCode} ${this.statusMessage || statusMessageFor(this.statusCode)}`
        ];
        for (const [key, value] of Object.entries(headers)){
            lines.push(`${key}: ${value}`);
        }
        lines.push("", "");
        const headerBytes = new TextEncoder().encode(lines.join("\r\n"));
        const payload = concatBytes(headerBytes, body);
        await op_tcp_write2(this.streamId, payload);
        await op_tcp_shutdown2(this.streamId);
        await op_tcp_close2(this.streamId);
    }
}
class Server extends EventEmitter {
    handler;
    listening = false;
    internal;
    port;
    listenerId;
    closing = false;
    constructor(handler){
        super();
        this.handler = handler;
    }
    listen(port, host, callback) {
        let resolvedPort;
        if (typeof port === "object") {
            resolvedPort = port.port;
            if (typeof host === "function") callback = host;
        } else {
            resolvedPort = port;
            if (typeof host === "function") {
                callback = host;
            }
        }
        const portValue = resolvedPort ?? 8530;
        this.port = portValue;
        this.internal = {
            url: `http://localhost:${portValue}`
        };
        LOCAL_SERVERS.set(portValue, this);
        (async ()=>{
            if (globalThis.process?.env?.DEKA_HTTP_DEBUG) {
                console.log(`[http] listen ${portValue}`);
            }
            const result = await op_tcp_listen2("0.0.0.0", portValue);
            this.listenerId = result.id;
            this.listening = true;
            this.emit("listening");
            if (callback) callback();
            this.acceptLoop();
        })();
        return this;
    }
    close(callback) {
        if (this.port !== undefined) {
            LOCAL_SERVERS.delete(this.port);
        }
        this.listening = false;
        this.closing = true;
        if (this.listenerId !== undefined) {
            op_tcp_listener_close2(this.listenerId);
        }
        this.emit("close");
        if (callback) callback();
    }
    async handleLocalRequest(request) {
        return new Promise((resolve)=>{
            const reqHeaders = {};
            Object.entries(request.headers || {}).forEach(([key, value])=>{
                reqHeaders[key.toLowerCase()] = String(value);
            });
            const req = new IncomingMessage({
                statusCode: 200,
                statusMessage: "OK",
                headers: reqHeaders,
                url: request.url
            });
            req.method = request.method || "GET";
            const res = new ServerResponse(resolve);
            this.emit("request", req, res);
            if (this.handler) {
                const result = this.handler(req, res);
                if (result && typeof result.then === "function") {
                    result.catch((error)=>{
                        res.writeHead(500, {
                            "content-type": "text/plain"
                        });
                        res.end(String(error));
                    });
                }
            }
            if (request.body && request.body.length > 0) {
                req.emitBody(request.body);
            } else {
                req.emit("end");
            }
        });
    }
    async acceptLoop() {
        if (!this.listenerId) return;
        while(this.listening && !this.closing && this.listenerId !== undefined){
            try {
                const incoming = await op_tcp_accept2(this.listenerId);
                this.handleTcpConnection(incoming.id);
            } catch (err) {
                if (!this.closing) {
                    this.emit("error", err);
                }
            }
        }
    }
    async handleTcpConnection(streamId) {
        const decoder = new TextDecoder();
        let buffer = new Uint8Array();
        let headerIndex = -1;
        while(headerIndex === -1){
            const chunk = await op_tcp_read2(streamId, 65536);
            if (chunk.eof) {
                await op_tcp_close2(streamId);
                return;
            }
            buffer = concatBytes(buffer, new Uint8Array(chunk.data));
            const text = decoder.decode(buffer);
            headerIndex = text.indexOf("\r\n\r\n");
        }
        const headerText = decoder.decode(buffer.slice(0, headerIndex));
        const { method, url, headers } = parseHeaders(headerText);
        const bodyStart = headerIndex + 4;
        let body = buffer.slice(bodyStart);
        const contentLength = Number(headers["content-length"] || "0");
        while(body.length < contentLength){
            const chunk = await op_tcp_read2(streamId, 65536);
            if (chunk.eof) break;
            body = concatBytes(body, new Uint8Array(chunk.data));
        }
        const req = new IncomingMessage({
            statusCode: 200,
            statusMessage: "OK",
            headers,
            url
        });
        req.method = method;
        const res = new ServerResponse(()=>new Response1(""), streamId);
        this.emit("request", req, res);
        if (this.handler) {
            const result = this.handler(req, res);
            if (result && typeof result.then === "function") {
                result.catch((error)=>{
                    res.writeHead(500, {
                        "content-type": "text/plain"
                    });
                    res.end(String(error));
                });
            }
        }
        if (body.length > 0) {
            req.emitBody(body);
        } else {
            req.emit("end");
        }
    }
}
function createServer(handler) {
    if (globalThis.process?.env?.DEKA_HTTP_DEBUG) {
        console.log("[http] createServer");
    }
    return new Server(handler);
}
function request(input, options, callback) {
    const { url, method, headers, callback: normalizedCallback } = normalizeRequestArgs(input, options, "http:");
    const req = new ClientRequest({
        url,
        method,
        headers
    }, callback || normalizedCallback);
    return req;
}
function get(input, options, callback) {
    const req = request(input, options, callback);
    req.end();
    return req;
}
globalThis.__dekaNodeHttp = {
    createServer,
    request,
    get,
    Server,
    ClientRequest,
    IncomingMessage,
    ServerResponse,
    METHODS
};
function request1(input, options, callback) {
    const requestOptions = typeof input === "object" && !(input instanceof URL) ? input : options;
    const normalized = {
        ...requestOptions || {},
        protocol: "https:"
    };
    if (typeof input === "string" || input instanceof URL) {
        return request(input, normalized, callback);
    }
    return request(normalized, callback);
}
function get1(input, options, callback) {
    const req = request1(input, options, callback);
    req.end();
    return req;
}
function createServer1(handler) {
    return createServer(handler);
}
globalThis.__dekaNodeHttps = {
    createServer: createServer1,
    request: request1,
    get: get1,
    Server,
    ClientRequest,
    IncomingMessage,
    ServerResponse,
    METHODS
};
function createSecureContext(options) {
    return {
        options: options || {}
    };
}
class TLSSocket extends EventEmitter {
    authorized = false;
    encrypted = true;
    end() {
        this.emit("end");
    }
    write(_chunk) {
        return true;
    }
    getCipher() {
        return {
            name: "TLS_FAKE",
            version: "TLSv1.3"
        };
    }
    getPeerCertificate() {
        return {};
    }
}
function connect(input, host, callback) {
    if (typeof host === "function") {
        callback = host;
    }
    const socket = new TLSSocket();
    socket.authorized = true;
    if (callback) callback();
    return socket;
}
globalThis.__dekaNodeTls = {
    createSecureContext,
    connect,
    TLSSocket
};
const sqlite = globalThis.__dekaSqlite;
class Database {
    constructor(_path){
        if (!sqlite?.Database) {
            throw new Error("SQLite is not available");
        }
        return new sqlite.Database(_path);
    }
}
globalThis.__dekaNodeSqlite = {
    Database: sqlite?.Database || Database,
    Statement: sqlite?.Statement
};
sqlite?.Statement;
class Interface {
    question(_prompt, callback) {
        callback("");
    }
    close() {}
    on(_event, _listener) {
        return this;
    }
}
function createInterface() {
    return new Interface();
}
globalThis.__dekaNodeReadline = {
    createInterface,
    Interface
};
class Domain {
    on(_event, _listener) {
        return this;
    }
    add() {}
    remove() {}
    run(fn) {
        return fn();
    }
    emit(_event, ..._args) {
        return true;
    }
}
function create() {
    return new Domain();
}
globalThis.__dekaNodeDomain = {
    create,
    Domain
};
const constants3 = {
    HTTP2_HEADER_STATUS: ":status",
    HTTP2_HEADER_METHOD: ":method",
    HTTP2_HEADER_AUTHORITY: ":authority",
    HTTP2_HEADER_SCHEME: ":scheme",
    HTTP2_HEADER_PATH: ":path",
    HTTP2_HEADER_CONTENT_LENGTH: "content-length",
    HTTP2_HEADER_EXPECT: "expect"
};
class Http2Server {
    listen(_port, _host, callback) {
        if (typeof _host === "function") {
            callback = _host;
        }
        if (callback) callback();
        return this;
    }
    close(callback) {
        if (callback) callback();
    }
    on() {
        return this;
    }
}
class ClientHttp2Session {
    close() {}
    on() {
        return this;
    }
}
function createServer2() {
    return new Http2Server();
}
function createSecureServer() {
    return new Http2Server();
}
function connect1(_authority) {
    return new ClientHttp2Session();
}
globalThis.__dekaNodeHttp2 = {
    createServer: createServer2,
    createSecureServer,
    connect: connect1,
    Http2Server,
    ClientHttp2Session,
    constants: constants3
};
class Readable extends EventEmitter {
    buffer = [];
    ended = false;
    constructor(){
        super();
    }
    push(chunk) {
        if (chunk === null) {
            this.ended = true;
            this.emit("end");
            return false;
        }
        const data = typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
        this.buffer.push(data);
        this.emit("data", data);
        return true;
    }
    read() {
        return this.buffer.shift() || null;
    }
}
class Writable extends EventEmitter {
    write(_chunk, _encoding, callback) {
        if (callback) callback();
        return true;
    }
    end(_chunk, _encoding, callback) {
        if (callback) callback();
        this.emit("finish");
    }
}
class PassThrough extends Readable {
    write(chunk, encoding, callback) {
        const data = typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
        this.push(data);
        if (callback) callback();
        return true;
    }
}
class Transform extends PassThrough {
}
globalThis.__dekaNodeStream = {
    Readable,
    Writable,
    PassThrough,
    Transform
};
const builtinModules = [
    "node:http",
    "node:https",
    "node:tls",
    "node:path",
    "node:url",
    "url",
    "node:os",
    "node:util",
    "node:events",
    "node:crypto",
    "crypto"
];
function normalizeReferrer(specifier) {
    if (!specifier) return process.cwd?.() || "/";
    if (specifier instanceof URL) {
        return specifier.pathname;
    }
    return specifier;
}
function createRequire1(specifier) {
    const factory = globalThis.__dekaCreateRequire;
    if (typeof factory !== "function") {
        throw new Error("createRequire is not available in this runtime");
    }
    return factory(normalizeReferrer(specifier));
}
class Module {
    id;
    filename;
    loaded;
    exports;
    paths;
    parent;
    children = [];
    constructor(id = "", parent){
        this.id = id;
        this.filename = id;
        this.loaded = false;
        this.exports = {};
        this.paths = Module._nodeModulePaths(id || process.cwd?.() || "/");
        this.parent = parent;
        if (parent) {
            parent.children.push(this);
        }
    }
    static builtinModules = builtinModules;
    static createRequire = createRequire1;
    static _extensions = globalThis.__dekaRequireExtensions || {};
    static _resolveFilename(request, parent) {
        const base = parent?.filename || parent?.id || process.cwd?.() || "/";
        const req = createRequire1(base);
        return req.resolve(request);
    }
    static _nodeModulePaths(from) {
        const pathApi = globalThis.__dekaNodePath;
        const paths = [];
        let current = pathApi?.dirname ? pathApi.dirname(from) : from;
        if (!current || current === ".") {
            current = process.cwd?.() || "/";
        }
        while(true){
            if (pathApi?.join) {
                paths.push(pathApi.join(current, "node_modules"));
            } else {
                paths.push(`${current}/node_modules`);
            }
            const parentDir = pathApi?.dirname ? pathApi.dirname(current) : "";
            if (!parentDir || parentDir === current) break;
            current = parentDir;
        }
        return paths;
    }
    _compile(content, filename) {
        const pathApi = globalThis.__dekaNodePath;
        const dirname = pathApi?.dirname ? pathApi.dirname(filename) : filename.split("/").slice(0, -1).join("/") || "/";
        this.filename = filename;
        this.loaded = true;
        const localRequire = createRequire1(filename);
        this.require = localRequire;
        const wrapper = new Function("exports", "require", "module", "__filename", "__dirname", content);
        return wrapper(this.exports, localRequire, this, filename, dirname);
    }
    require(request) {
        const req = createRequire1(this.filename || this.id || process.cwd?.() || "/");
        return req(request);
    }
}
Module.Module = Module;
Module.builtinModules = builtinModules;
Module.createRequire = createRequire1;
Module._resolveFilename = Module._resolveFilename;
globalThis.__dekaNodeModule = Module;
class Tracing {
    enable() {}
    disable() {}
}
function createTracing() {
    return new Tracing();
}
globalThis.__dekaNodeTraceEvents = {
    createTracing,
    Tracing
};
function open1() {}
function close1() {}
function url() {
    return null;
}
class Session {
    connect() {}
    disconnect() {}
    post(_method, _params, callback) {
        if (callback) callback();
    }
}
globalThis.__dekaNodeInspector = {
    open: open1,
    close: close1,
    url,
    Session
};
class Suite {
    name;
    entries = [];
    before = [];
    after = [];
    beforeEach = [];
    afterEach = [];
    skip = false;
    only = false;
    hasOnly = false;
    timeoutMs;
    concurrency;
    constructor(name){
        this.name = name;
    }
}
const rootSuite = new Suite("root");
const suiteStack = [
    rootSuite
];
let scheduled = false;
let hasOnly = false;
function runHookList(hooks) {
    let chain = null;
    for (const hook of hooks){
        if (chain) {
            chain = chain.then(()=>hook());
            continue;
        }
        const result = hook();
        if (result && typeof result.then === "function") {
            chain = result;
        }
    }
    return chain;
}
function runSequential(steps) {
    let chain = null;
    for (const step of steps){
        if (chain) {
            chain = chain.then(()=>step());
            continue;
        }
        const result = step();
        if (result && typeof result.then === "function") {
            chain = result;
        }
    }
    return chain;
}
function markHasOnly(suite) {
    let found = suite.only;
    for (const entry of suite.entries){
        if (entry.type === "test") {
            if (entry.only) found = true;
        } else if (markHasOnly(entry.suite)) {
            found = true;
        }
    }
    suite.hasOnly = found;
    return found;
}
function withTimeout(promise, timeoutMs, name) {
    if (!timeoutMs || timeoutMs <= 0) return promise;
    return new Promise((resolve, reject)=>{
        const timer = setTimeout(()=>{
            reject(new Error(`Test timed out${name ? `: ${name}` : ""}`));
        }, timeoutMs);
        promise.then((value)=>{
            clearTimeout(timer);
            resolve(value);
        }).catch((err)=>{
            clearTimeout(timer);
            reject(err);
        });
    });
}
async function runTestEntry(entry, context) {
    if (entry.skip || !entry.fn) return;
    const steps = runSequential([
        ()=>runHookList(context.beforeEach),
        ()=>entry.fn?.(),
        ()=>runHookList(context.afterEach)
    ]);
    await withTimeout(Promise.resolve(steps), entry.timeoutMs ?? context.timeoutMs, entry.name);
}
async function runConcurrent(entries, limit, context) {
    let index = 0;
    const workerCount = Math.max(1, Math.min(limit, entries.length));
    const workers = Array.from({
        length: workerCount
    }, async ()=>{
        while(true){
            const current = entries[index++];
            if (!current) break;
            await runTestEntry(current, context);
        }
    });
    await Promise.all(workers);
}
async function runSuite(suite, context) {
    if (suite.skip) return;
    const inOnlyPath = context.inOnlyPath || suite.only;
    if (hasOnly && !suite.hasOnly && !inOnlyPath) return;
    await runHookList(suite.before);
    const nextContext = {
        beforeEach: context.beforeEach.concat(suite.beforeEach),
        afterEach: suite.afterEach.concat(context.afterEach),
        inOnlyPath,
        timeoutMs: suite.timeoutMs ?? context.timeoutMs
    };
    const concurrentLimit = suite.concurrency ?? 1;
    const concurrentEntries = [];
    for (const entry of suite.entries){
        if (entry.type === "suite") {
            await runSuite(entry.suite, nextContext);
            continue;
        }
        if (entry.skip) continue;
        if (hasOnly && !entry.only && !nextContext.inOnlyPath) continue;
        if (entry.concurrent || concurrentLimit > 1) {
            concurrentEntries.push(entry);
            continue;
        }
        await runTestEntry(entry, nextContext);
    }
    if (concurrentEntries.length > 0) {
        await runConcurrent(concurrentEntries, concurrentLimit, nextContext);
    }
    await runHookList(suite.after);
}
function scheduleRun() {
    if (scheduled) return;
    scheduled = true;
    queueMicrotask(()=>{
        scheduled = false;
        hasOnly = markHasOnly(rootSuite);
        void runSuite(rootSuite, {
            beforeEach: [],
            afterEach: [],
            inOnlyPath: false
        });
    });
}
function registerTest(name, fn, flags) {
    const suite = suiteStack[suiteStack.length - 1];
    const entry = {
        type: "test",
        name,
        fn,
        skip: flags?.skip,
        only: flags?.only,
        timeoutMs: flags?.timeoutMs,
        concurrent: flags?.concurrent
    };
    if (entry.only) hasOnly = true;
    suite.entries.push(entry);
    scheduleRun();
    return {
        name
    };
}
function parseTestArgs(name, optionsOrFn, fn) {
    if (typeof optionsOrFn === "function") {
        return {
            name,
            fn: optionsOrFn
        };
    }
    return {
        name,
        options: optionsOrFn,
        fn
    };
}
function test(name, optionsOrFn, fn) {
    const parsed = parseTestArgs(name, optionsOrFn, fn);
    const opts = parsed.options;
    if (opts?.todo) {
        return registerTest(name, undefined, {
            skip: true
        });
    }
    return registerTest(name, parsed.fn, {
        skip: opts?.skip,
        only: opts?.only,
        timeoutMs: opts?.timeout,
        concurrent: opts?.concurrency === true || typeof opts?.concurrency === "number" && opts.concurrency > 1
    });
}
test.skip = (name, optionsOrFn, fn)=>{
    const parsed = parseTestArgs(name, optionsOrFn, fn);
    return registerTest(name, parsed.fn, {
        skip: true
    });
};
test.only = (name, optionsOrFn, fn)=>{
    const parsed = parseTestArgs(name, optionsOrFn, fn);
    return registerTest(name, parsed.fn, {
        only: true
    });
};
test.todo = (name)=>registerTest(name, undefined, {
        skip: true
    });
test.concurrent = (name, fn)=>registerTest(name, fn, {
        concurrent: true
    });
const it = test;
it.skip = test.skip;
it.only = test.only;
it.todo = test.todo;
it.concurrent = test.concurrent;
function parseDescribeArgs(name, optionsOrFn, fn) {
    if (typeof optionsOrFn === "function") {
        return {
            name,
            fn: optionsOrFn
        };
    }
    return {
        name,
        options: optionsOrFn,
        fn
    };
}
function describe(name, optionsOrFn, fn) {
    const parsed = parseDescribeArgs(name, optionsOrFn, fn);
    const suite = new Suite(name);
    if (parsed.options) {
        suite.skip = Boolean(parsed.options.skip);
        suite.only = Boolean(parsed.options.only);
        if (typeof parsed.options.timeout === "number") {
            suite.timeoutMs = parsed.options.timeout;
        }
        if (parsed.options.concurrency === true) {
            suite.concurrency = 4;
        } else if (typeof parsed.options.concurrency === "number") {
            suite.concurrency = Math.max(1, parsed.options.concurrency);
        }
    }
    const parent = suiteStack[suiteStack.length - 1];
    parent.entries.push({
        type: "suite",
        suite
    });
    suiteStack.push(suite);
    if (parsed.fn) parsed.fn();
    suiteStack.pop();
    scheduleRun();
    return {
        name
    };
}
describe.skip = (name, optionsOrFn, fn)=>{
    const parsed = parseDescribeArgs(name, optionsOrFn, fn);
    return describe(name, {
        ...parsed.options || {},
        skip: true
    }, parsed.fn);
};
describe.only = (name, optionsOrFn, fn)=>{
    const parsed = parseDescribeArgs(name, optionsOrFn, fn);
    return describe(name, {
        ...parsed.options || {},
        only: true
    }, parsed.fn);
};
describe.concurrent = (name, optionsOrFn, fn)=>{
    const parsed = parseDescribeArgs(name, optionsOrFn, fn);
    return describe(name, {
        ...parsed.options || {},
        concurrency: true
    }, parsed.fn);
};
function before(fn) {
    suiteStack[suiteStack.length - 1].before.push(fn);
}
function after(fn) {
    suiteStack[suiteStack.length - 1].after.push(fn);
}
function beforeEach(fn) {
    suiteStack[suiteStack.length - 1].beforeEach.push(fn);
}
function afterEach(fn) {
    suiteStack[suiteStack.length - 1].afterEach.push(fn);
}
globalThis.__dekaNodeTest = {
    test,
    it,
    describe,
    before,
    after,
    beforeEach,
    afterEach
};
function normalizeMessage(msg) {
    if (msg instanceof Uint8Array) return msg;
    if (msg instanceof ArrayBuffer) return new Uint8Array(msg);
    if (Array.isArray(msg)) {
        const parts = msg.map(normalizeMessage);
        const total = parts.reduce((sum, part)=>sum + part.length, 0);
        const merged = new Uint8Array(total);
        let offset = 0;
        for (const part of parts){
            merged.set(part, offset);
            offset += part.length;
        }
        return merged;
    }
    if (typeof msg === "string") return new TextEncoder().encode(msg);
    throw createDgramError("ERR_INVALID_ARG_TYPE", "Message must be a string, Buffer, ArrayBuffer, or array of these");
}
function parseBindArgs(port, address, callback) {
    let bindPort = 0;
    let bindAddress = "";
    let bindCallback = callback;
    let exclusive = false;
    if (typeof port === "object" && port !== null) {
        bindPort = port.port ?? 0;
        bindAddress = port.address ?? "";
        exclusive = Boolean(port.exclusive);
    } else if (typeof port === "number") {
        bindPort = port;
    }
    if (typeof address === "function") {
        bindCallback = address;
    } else if (typeof address === "string") {
        bindAddress = address;
    }
    return {
        bindPort,
        bindAddress,
        bindCallback,
        exclusive
    };
}
function isIPv4(addr) {
    return /^[0-9.]+$/.test(addr);
}
function isIPv6(addr) {
    return addr.includes(":");
}
function createDgramError(code, message) {
    const err = new Error(message);
    err.code = code;
    return err;
}
function requireRunning(socketId) {
    if (socketId === null) {
        throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
    }
}
function validateBufferSlice(buf, offset, length) {
    if (offset < 0 || offset > buf.length) {
        throw createDgramError("ERR_OUT_OF_RANGE", "Offset out of range");
    }
    if (length !== undefined && (length < 0 || offset + length > buf.length)) {
        throw createDgramError("ERR_OUT_OF_RANGE", "Length out of range");
    }
}
function normalizePort(value) {
    if (value === undefined) return undefined;
    if (!Number.isFinite(value) || value < 0 || value > 65535) {
        throw createDgramError("ERR_SOCKET_BAD_PORT", "Port should be >= 0 and < 65536");
    }
    return value;
}
class Socket extends EventEmitter {
    socketType;
    socketId = null;
    closed = false;
    receiving = false;
    hasRefFlag = true;
    connected = false;
    lookup;
    reuseAddr;
    reusePort;
    ipv6Only;
    recvBufferSize;
    sendBufferSize;
    broadcast = false;
    ttl = null;
    multicastTTL = null;
    multicastLoop = null;
    multicastInterface = null;
    sendQueueCount = 0;
    sendQueueBytes = 0;
    bindPromise = null;
    constructor(typeOrOptions = "udp4", listener){
        super();
        if (typeof typeOrOptions === "string") {
            this.socketType = typeOrOptions;
            this.reuseAddr = false;
            this.reusePort = false;
            this.ipv6Only = false;
            this.recvBufferSize = 0;
            this.sendBufferSize = 0;
        } else {
            this.socketType = typeOrOptions.type || "udp4";
            this.reuseAddr = Boolean(typeOrOptions.reuseAddr);
            this.reusePort = Boolean(typeOrOptions.reusePort);
            this.ipv6Only = Boolean(typeOrOptions.ipv6Only);
            this.recvBufferSize = typeOrOptions.recvBufferSize ?? 0;
            this.sendBufferSize = typeOrOptions.sendBufferSize ?? 0;
            this.lookup = typeOrOptions.lookup;
            if (typeOrOptions.signal) {
                if (typeOrOptions.signal.aborted) {
                    this.close();
                } else {
                    typeOrOptions.signal.addEventListener("abort", ()=>this.close(), {
                        once: true
                    });
                }
            }
        }
        if (listener) {
            this.on("message", listener);
        }
    }
    bind(port, address, callback) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.bindPromise) {
            if (callback) {
                this.bindPromise.then(()=>callback()).catch(()=>callback());
            }
            return this;
        }
        const { bindPort, bindAddress, bindCallback, exclusive } = parseBindArgs(port, address, callback);
        const resolvedAddress = bindAddress || (this.socketType === "udp6" ? "::" : "0.0.0.0");
        this.bindPromise = (async ()=>{
            const reusePort = exclusive ? false : this.reusePort;
            const normalizedPort = normalizePort(bindPort ?? 0) ?? 0;
            this.socketId = await op_udp_bind2(resolvedAddress, normalizedPort, this.reuseAddr, reusePort, this.ipv6Only, this.broadcast, this.recvBufferSize, this.sendBufferSize);
            if (this.ttl !== null) {
                op_udp_set_ttl2(this.socketId, this.ttl);
            }
            if (this.multicastTTL !== null) {
                op_udp_set_multicast_ttl2(this.socketId, this.multicastTTL);
            }
            if (this.multicastLoop !== null) {
                op_udp_set_multicast_loop2(this.socketId, this.multicastLoop);
            }
            if (this.multicastInterface) {
                op_udp_set_multicast_if2(this.socketId, this.multicastInterface);
            }
            this.startReceiveLoop();
            this.emit("listening");
            if (bindCallback) bindCallback();
        })();
        return this;
    }
    connect(port, address, callback) {
        if (this.connected) {
            throw createDgramError("ERR_SOCKET_DGRAM_IS_CONNECTED", "Socket is already connected");
        }
        const targetPort = normalizePort(port);
        const target = address || (this.socketType === "udp6" ? "::1" : "127.0.0.1");
        (async ()=>{
            if (this.socketId === null) {
                this.bind();
            }
            if (this.bindPromise) {
                await this.bindPromise;
            }
            let resolved = target;
            if (!isIPv4(resolved) && !isIPv6(resolved)) {
                const addrs = await op_dns_lookup2(resolved, this.socketType === "udp6" ? 6 : 4);
                resolved = addrs[0] || resolved;
            }
            await op_udp_connect2(this.socketId, resolved, targetPort ?? 0);
            this.connected = true;
            this.emit("connect");
            if (callback) callback();
        })();
        return this;
    }
    disconnect() {
        if (!this.connected) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_CONNECTED", "Socket is not connected");
        }
        if (this.socketId !== null) {
            try {
                op_udp_disconnect2(this.socketId);
            } catch  {}
        }
        this.connected = false;
        return this;
    }
    close(callback) {
        if (this.closed) {
            if (callback) callback();
            return;
        }
        this.closed = true;
        if (this.socketId !== null) {
            op_udp_close2(this.socketId);
        }
        this.bindPromise = null;
        this.connected = false;
        this.emit("close");
        if (callback) callback();
    }
    send(...args) {
        let msg = args[0];
        let offset = 0;
        let length;
        let port;
        let address;
        let callback;
        if (typeof args[1] === "number" && typeof args[2] === "number") {
            offset = args[1];
            length = args[2];
            port = normalizePort(args[3]);
            address = args[4];
            callback = args[5];
        } else if (typeof args[1] === "number") {
            port = normalizePort(args[1]);
            address = args[2];
            callback = args[3];
        } else if (typeof args[1] === "object" && args[1] !== null) {
            const options = args[1];
            port = normalizePort(options.port);
            address = options.address;
            offset = options.offset ?? 0;
            length = options.length;
            callback = args[2];
        } else if (typeof args[1] === "function") {
            callback = args[1];
        }
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        const payload = normalizeMessage(msg);
        validateBufferSlice(payload, offset, length);
        const slice = length !== undefined ? payload.slice(offset, offset + length) : payload.slice(offset);
        const fallbackAddress = this.socketType === "udp6" ? "::1" : "127.0.0.1";
        let targetAddress = address || "";
        this.sendQueueCount += 1;
        this.sendQueueBytes += slice.length;
        const finalizeSend = ()=>{
            this.sendQueueCount = Math.max(0, this.sendQueueCount - 1);
            this.sendQueueBytes = Math.max(0, this.sendQueueBytes - slice.length);
        };
        (async ()=>{
            if (this.socketId === null) {
                this.bind();
            }
            if (this.bindPromise) {
                await this.bindPromise;
            }
            if (!targetAddress && this.connected) {
                const remote = op_udp_peer_addr2(this.socketId);
                targetAddress = remote.address;
                port = remote.port;
            }
            if (!targetAddress) {
                targetAddress = fallbackAddress;
            }
            if (!port) {
                throw createDgramError("ERR_SOCKET_DGRAM_NOT_CONNECTED", "Socket is not connected");
            }
            let resolvedAddress = targetAddress;
            if (!isIPv4(resolvedAddress) && !isIPv6(resolvedAddress) && this.lookup) {
                const lookupResult = await new Promise((resolve, reject)=>{
                    this.lookup(resolvedAddress, {
                        family: this.socketType === "udp6" ? 6 : 4
                    }, (err, addr)=>{
                        if (err) reject(err);
                        else resolve(addr || resolvedAddress);
                    });
                });
                resolvedAddress = lookupResult;
            } else if (!isIPv4(resolvedAddress) && !isIPv6(resolvedAddress)) {
                const addrs = await op_dns_lookup2(resolvedAddress, this.socketType === "udp6" ? 6 : 4);
                resolvedAddress = addrs[0] || resolvedAddress;
            }
            try {
                const sent = await op_udp_send2(this.socketId, slice, port ?? 0, resolvedAddress);
                finalizeSend();
                if (callback) callback(null, sent);
            } catch (err) {
                finalizeSend();
                if (callback) callback(err);
                else this.emit("error", err);
            }
        })();
    }
    address() {
        requireRunning(this.socketId);
        const addr = op_udp_local_addr2(this.socketId);
        return {
            address: addr.address,
            family: addr.address.includes(":") ? "IPv6" : "IPv4",
            port: addr.port
        };
    }
    remoteAddress() {
        requireRunning(this.socketId);
        if (!this.connected) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_CONNECTED", "Socket is not connected");
        }
        const addr = op_udp_peer_addr2(this.socketId);
        return {
            address: addr.address,
            family: addr.address.includes(":") ? "IPv6" : "IPv4",
            port: addr.port
        };
    }
    addMembership(multicastAddress, interfaceAddress) {
        (async ()=>{
            try {
                if (this.socketId === null) {
                    this.bind();
                }
                if (this.bindPromise) {
                    await this.bindPromise;
                }
                requireRunning(this.socketId);
                op_udp_join_multicast2(this.socketId, multicastAddress, interfaceAddress ?? null);
            } catch (err) {
                this.emit("error", err);
            }
        })();
    }
    dropMembership(multicastAddress, interfaceAddress) {
        (async ()=>{
            try {
                if (this.socketId === null) {
                    this.bind();
                }
                if (this.bindPromise) {
                    await this.bindPromise;
                }
                requireRunning(this.socketId);
                op_udp_leave_multicast2(this.socketId, multicastAddress, interfaceAddress ?? null);
            } catch (err) {
                this.emit("error", err);
            }
        })();
    }
    setBroadcast(flag) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.socketId !== null) {
            op_udp_set_broadcast2(this.socketId, flag);
        }
        this.broadcast = flag;
        return this;
    }
    setTTL(ttl) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.socketId !== null) {
            op_udp_set_ttl2(this.socketId, ttl);
        }
        this.ttl = ttl;
        return this;
    }
    setMulticastTTL(ttl) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.socketId !== null) {
            op_udp_set_multicast_ttl2(this.socketId, ttl);
        }
        this.multicastTTL = ttl;
        return this;
    }
    setMulticastLoopback(flag) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.socketId !== null) {
            op_udp_set_multicast_loop2(this.socketId, flag);
        }
        this.multicastLoop = flag;
        return this;
    }
    setMulticastInterface(iface) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.socketId !== null) {
            op_udp_set_multicast_if2(this.socketId, iface);
        }
        this.multicastInterface = iface;
        return this;
    }
    setRecvBufferSize(size) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.socketId !== null) {
            op_udp_set_recv_buffer_size2(this.socketId, size);
        } else {
            this.recvBufferSize = size;
        }
        return this;
    }
    setSendBufferSize(size) {
        if (this.closed) {
            throw createDgramError("ERR_SOCKET_DGRAM_NOT_RUNNING", "Socket is not running");
        }
        if (this.socketId !== null) {
            op_udp_set_send_buffer_size2(this.socketId, size);
        } else {
            this.sendBufferSize = size;
        }
        return this;
    }
    getRecvBufferSize() {
        if (this.socketId === null) return this.recvBufferSize;
        return op_udp_get_recv_buffer_size2(this.socketId);
    }
    getSendBufferSize() {
        if (this.socketId === null) return this.sendBufferSize;
        return op_udp_get_send_buffer_size2(this.socketId);
    }
    getSendQueueSize() {
        return this.sendQueueBytes;
    }
    getSendQueueCount() {
        return this.sendQueueCount;
    }
    async [Symbol.asyncDispose]() {
        this.close();
    }
    ref() {
        this.hasRefFlag = true;
        return this;
    }
    unref() {
        this.hasRefFlag = false;
        return this;
    }
    hasRef() {
        return this.hasRefFlag;
    }
    startReceiveLoop() {
        if (this.receiving || this.socketId === null) return;
        this.receiving = true;
        const loop = async ()=>{
            while(!this.closed && this.socketId !== null){
                try {
                    const result = await op_udp_recv2(this.socketId, 65535);
                    const info = {
                        address: result.address,
                        family: result.address.includes(":") ? "IPv6" : "IPv4",
                        port: result.port,
                        size: result.data.length
                    };
                    this.emit("message", new Uint8Array(result.data), info);
                } catch (err) {
                    if (!this.closed) {
                        this.emit("error", err);
                    }
                    break;
                }
            }
        };
        loop();
    }
}
function createSocket(typeOrOptions = "udp4", listener) {
    return new Socket(typeOrOptions, listener);
}
globalThis.__dekaNodeDgram = {
    createSocket,
    Socket
};
function createDnsError(code, message) {
    const err = new Error(message);
    err.code = code;
    return err;
}
function resolveFamily(rrtype) {
    if (!rrtype) return 0;
    const upper = rrtype.toUpperCase();
    if (upper === "A") return 4;
    if (upper === "AAAA") return 6;
    return 0;
}
function lookup(hostname, options, callback) {
    let family = 0;
    let all = false;
    let cb = callback;
    if (typeof options === "function") {
        cb = options;
    } else if (typeof options === "number") {
        family = options;
    } else if (options) {
        family = options.family ?? 0;
        all = Boolean(options.all);
    }
    const doLookup = async ()=>{
        try {
            const addrs = await op_dns_lookup2(hostname, family);
            if (addrs.length === 0) {
                throw createDnsError("ENOTFOUND", "DNS lookup failed");
            }
            if (all) {
                const result = addrs.map((address)=>({
                        address,
                        family: address.includes(":") ? 6 : 4
                    }));
                if (cb) cb(null, result);
            } else {
                const address = addrs[0];
                const result = {
                    address,
                    family: address.includes(":") ? 6 : 4
                };
                if (cb) cb(null, result);
            }
        } catch (err) {
            if (cb) cb(err, all ? [] : {
                address: "",
                family: family || 0
            });
        }
    };
    doLookup();
}
function resolveRecord(hostname, rrtype, callback) {
    let type = rrtype;
    let cb = callback;
    if (typeof rrtype === "function") {
        type = undefined;
        cb = rrtype;
    }
    const doResolve = async ()=>{
        try {
            if (type && type.toUpperCase() === "PTR") {
                const hosts = await op_dns_reverse2(hostname);
                if (cb) cb(null, hosts);
                return;
            }
            const family = resolveFamily(type);
            if (type && family === 0) {
                throw createDnsError("ENOTIMP", "Unsupported rrtype");
            }
            const addrs = await op_dns_lookup2(hostname, family);
            if (cb) cb(null, addrs);
        } catch (err) {
            if (cb) cb(err, []);
        }
    };
    doResolve();
}
function resolve4(hostname, callback) {
    resolveRecord(hostname, "A", callback);
}
function resolve6(hostname, callback) {
    resolveRecord(hostname, "AAAA", callback);
}
function reverse(address, callback) {
    const doReverse = async ()=>{
        try {
            const hosts = await op_dns_reverse2(address);
            callback(null, hosts);
        } catch (err) {
            callback(err, []);
        }
    };
    doReverse();
}
class Resolver {
    servers = [];
    getServers() {
        return [
            ...this.servers
        ];
    }
    setServers(servers) {
        this.servers = [
            ...servers
        ];
    }
    lookup(hostname, options, callback) {
        return lookup(hostname, options, callback);
    }
    resolve(hostname, rrtype, callback) {
        return resolveRecord(hostname, rrtype, callback);
    }
    resolve4(hostname, callback) {
        return resolve4(hostname, callback);
    }
    resolve6(hostname, callback) {
        return resolve6(hostname, callback);
    }
    reverse(address, callback) {
        return reverse(address, callback);
    }
}
const promises1 = {
    lookup (hostname, options) {
        return new Promise((resolve, reject)=>{
            lookup(hostname, options, (err, result)=>{
                if (err) reject(err);
                else resolve(result);
            });
        });
    },
    resolve (hostname, rrtype) {
        return new Promise((resolvePromise, reject)=>{
            resolveRecord(hostname, rrtype, (err, result)=>{
                if (err) reject(err);
                else resolvePromise(result);
            });
        });
    },
    resolve4 (hostname) {
        return new Promise((resolve, reject)=>{
            resolve4(hostname, (err, result)=>{
                if (err) reject(err);
                else resolve(result);
            });
        });
    },
    resolve6 (hostname) {
        return new Promise((resolve, reject)=>{
            resolve6(hostname, (err, result)=>{
                if (err) reject(err);
                else resolve(result);
            });
        });
    },
    reverse (address) {
        return new Promise((resolve, reject)=>{
            reverse(address, (err, result)=>{
                if (err) reject(err);
                else resolve(result);
            });
        });
    }
};
globalThis.__dekaNodeDns = {
    lookup,
    resolve: resolveRecord,
    resolve4,
    resolve6,
    reverse,
    Resolver,
    promises: promises1
};
function createNetError(code, message) {
    const err = new Error(message);
    err.code = code;
    return err;
}
function normalizePort1(value) {
    if (value === undefined) return undefined;
    const num = typeof value === "string" ? Number(value) : value;
    if (!Number.isFinite(num) || num < 0 || num > 65535) {
        throw createNetError("ERR_INVALID_ARG_VALUE", "Port must be >= 0 and < 65536");
    }
    return num;
}
function isIPv41(addr) {
    return /^[0-9.]+$/.test(addr);
}
function isIPv61(addr) {
    return addr.includes(":");
}
class Socket1 extends EventEmitter {
    streamId = null;
    destroyed = false;
    connecting = false;
    reading = false;
    constructor(streamId, autoStart = true){
        super();
        if (streamId !== undefined) {
            this.streamId = streamId;
            if (autoStart) {
                this.startReadLoop();
            }
        }
    }
    connect(port, host, callback) {
        const targetPort = normalizePort1(port);
        const targetHost = String(host || "127.0.0.1");
        this.connecting = true;
        (async ()=>{
            const streamId = await op_tcp_connect2(targetHost, targetPort ?? 0);
            this.streamId = streamId;
            this.connecting = false;
            this.startReadLoop();
            this.emit("connect");
            if (callback) callback();
        })();
        return this;
    }
    write(data, callback) {
        if (this.destroyed || this.streamId === null) {
            const err = createNetError("ERR_STREAM_DESTROYED", "Socket is destroyed");
            if (callback) callback(err);
            else this.emit("error", err);
            return false;
        }
        const payload = typeof data === "string" ? new TextEncoder().encode(data) : data;
        (async ()=>{
            try {
                await op_tcp_write2(this.streamId, payload);
                if (callback) callback();
            } catch (err) {
                if (callback) callback(err);
                else this.emit("error", err);
            }
        })();
        return true;
    }
    end(data, callback) {
        if (data !== undefined) {
            this.write(data);
        }
        if (this.streamId !== null) {
            op_tcp_shutdown2(this.streamId);
        }
        if (callback) callback();
        return this;
    }
    destroy() {
        if (this.streamId !== null) {
            op_tcp_close2(this.streamId);
        }
        this.destroyed = true;
        this.emit("close");
    }
    address() {
        if (this.streamId === null) {
            throw createNetError("ERR_SOCKET_CLOSED", "Socket is not open");
        }
        return op_tcp_local_addr2(this.streamId);
    }
    remoteAddress() {
        if (this.streamId === null) {
            throw createNetError("ERR_SOCKET_CLOSED", "Socket is not open");
        }
        return op_tcp_peer_addr2(this.streamId);
    }
    startReadLoop() {
        if (this.reading || this.streamId === null) return;
        this.reading = true;
        const loop = async ()=>{
            while(!this.destroyed && this.streamId !== null){
                const result = await op_tcp_read2(this.streamId, 65536);
                if (result.eof) {
                    this.emit("end");
                    this.destroy();
                    break;
                }
                this.emit("data", new Uint8Array(result.data));
            }
        };
        loop();
    }
    _start() {
        this.startReadLoop();
    }
}
class Server1 extends EventEmitter {
    listenerId = null;
    accepting = false;
    closed = false;
    boundAddress = null;
    sockets = new Set();
    listen(port, host, callback) {
        const targetPort = normalizePort1(port) ?? 0;
        const targetHost = host || "0.0.0.0";
        (async ()=>{
            const result = await op_tcp_listen2(targetHost, targetPort);
            this.listenerId = result.id;
            this.boundAddress = {
                address: result.address,
                port: result.port
            };
            this.accepting = true;
            this.emit("listening");
            if (callback) callback();
            this.acceptLoop();
        })();
        return this;
    }
    close(callback) {
        this.closed = true;
        if (this.listenerId !== null) {
            op_tcp_listener_close2(this.listenerId);
        }
        for (const socket of Array.from(this.sockets)){
            socket.destroy();
            this.sockets.delete(socket);
        }
        this.accepting = false;
        if (callback) callback();
        return this;
    }
    address() {
        if (this.listenerId === null || this.boundAddress === null) {
            throw createNetError("ERR_SERVER_NOT_RUNNING", "Server is not running");
        }
        return this.boundAddress;
    }
    acceptLoop() {
        if (this.listenerId === null) return;
        const loop = async ()=>{
            while(this.accepting && !this.closed && this.listenerId !== null){
                try {
                    const incoming = await op_tcp_accept2(this.listenerId);
                    const socket = new Socket1(incoming.id, false);
                    this.sockets.add(socket);
                    socket.on("close", ()=>{
                        this.sockets.delete(socket);
                    });
                    this.emit("connection", socket);
                    socket._start();
                } catch (err) {
                    if (!this.closed) {
                        this.emit("error", err);
                    }
                }
            }
        };
        loop();
    }
}
function createServer3(connectionListener) {
    const server = new Server1();
    if (connectionListener) {
        server.on("connection", connectionListener);
    }
    return server;
}
function createConnection(port, host, callback) {
    if (typeof port !== "number" || !Number.isFinite(port)) {
        throw createNetError("ERR_INVALID_ARG_VALUE", "Port must be a number");
    }
    const socket = new Socket1();
    return socket.connect(port, host, callback);
}
const connect2 = createConnection;
function isIP(addr) {
    if (isIPv41(addr)) return 4;
    if (isIPv61(addr)) return 6;
    return 0;
}
globalThis.__dekaNodeNet = {
    Socket: Socket1,
    Server: Server1,
    createServer: createServer3,
    createConnection,
    connect: connect2,
    isIP,
    isIPv4: isIPv41,
    isIPv6: isIPv61
};
function zero$1(buf) {
    let len = buf.length;
    while(--len >= 0){
        buf[len] = 0;
    }
}
const LITERALS$1 = 256;
const L_CODES$1 = 256 + 1 + 29;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const extra_lbits = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
]);
const extra_dbits = new Uint8Array([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
]);
const extra_blbits = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
]);
const bl_order = new Uint8Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]);
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(30 * 2);
zero$1(static_dtree);
const _dist_code = new Array(512);
zero$1(_dist_code);
const _length_code = new Array(258 - 3 + 1);
zero$1(_length_code);
const base_length = new Array(29);
zero$1(base_length);
const base_dist = new Array(30);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
}
const d_code = (dist)=>{
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s, w)=>{
    s.pending_buf[s.pending++] = w & 0xff;
    s.pending_buf[s.pending++] = w >>> 8 & 0xff;
};
const send_bits = (s, value, length)=>{
    if (s.bi_valid > 16 - length) {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
    } else {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        s.bi_valid += length;
    }
};
const send_code = (s, c, tree)=>{
    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
};
const bi_reverse = (code, len)=>{
    let res = 0;
    do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
    }while (--len > 0)
    return res >>> 1;
};
const bi_flush = (s)=>{
    if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
    }
};
const gen_bitlen = (s, desc)=>{
    const tree = desc.dyn_tree;
    const max_code = desc.max_code;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const extra = desc.stat_desc.extra_bits;
    const base = desc.stat_desc.extra_base;
    const max_length = desc.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f;
    let overflow = 0;
    for(bits = 0; bits <= 15; bits++){
        s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for(h = s.heap_max + 1; h < HEAP_SIZE$1; h++){
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
            bits = max_length;
            overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
            continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
            xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
    }
    if (overflow === 0) {
        return;
    }
    do {
        bits = max_length - 1;
        while(s.bl_count[bits] === 0){
            bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
    }while (overflow > 0)
    for(bits = max_length; bits !== 0; bits--){
        n = s.bl_count[bits];
        while(n !== 0){
            m = s.heap[--h];
            if (m > max_code) {
                continue;
            }
            if (tree[m * 2 + 1] !== bits) {
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
            }
            n--;
        }
    }
};
const gen_codes = (tree, max_code, bl_count)=>{
    const next_code = new Array(15 + 1);
    let code = 0;
    let bits;
    let n;
    for(bits = 1; bits <= 15; bits++){
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
    }
    for(n = 0; n <= max_code; n++){
        let len = tree[n * 2 + 1];
        if (len === 0) {
            continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
};
const tr_static_init = ()=>{
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Array(15 + 1);
    length = 0;
    for(code = 0; code < 29 - 1; code++){
        base_length[code] = length;
        for(n = 0; n < 1 << extra_lbits[code]; n++){
            _length_code[length++] = code;
        }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for(code = 0; code < 16; code++){
        base_dist[code] = dist;
        for(n = 0; n < 1 << extra_dbits[code]; n++){
            _dist_code[dist++] = code;
        }
    }
    dist >>= 7;
    for(; code < 30; code++){
        base_dist[code] = dist << 7;
        for(n = 0; n < 1 << extra_dbits[code] - 7; n++){
            _dist_code[256 + dist++] = code;
        }
    }
    for(bits = 0; bits <= 15; bits++){
        bl_count[bits] = 0;
    }
    n = 0;
    while(n <= 143){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    while(n <= 255){
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
    }
    while(n <= 279){
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
    }
    while(n <= 287){
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
    for(n = 0; n < 30; n++){
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s)=>{
    let n;
    for(n = 0; n < L_CODES$1; n++){
        s.dyn_ltree[n * 2] = 0;
    }
    for(n = 0; n < 30; n++){
        s.dyn_dtree[n * 2] = 0;
    }
    for(n = 0; n < 19; n++){
        s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.sym_next = s.matches = 0;
};
const bi_windup = (s)=>{
    if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
};
const smaller = (tree, n, m, depth)=>{
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s, tree, k)=>{
    const v = s.heap[k];
    let j = k << 1;
    while(j <= s.heap_len){
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
    }
    s.heap[k] = v;
};
const compress_block = (s, ltree, dtree)=>{
    let dist;
    let lc;
    let sx = 0;
    let code;
    let extra;
    if (s.sym_next !== 0) {
        do {
            dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
            dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
            lc = s.pending_buf[s.sym_buf + sx++];
            if (dist === 0) {
                send_code(s, lc, ltree);
            } else {
                code = _length_code[lc];
                send_code(s, code + 256 + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                    lc -= base_length[code];
                    send_bits(s, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                    dist -= base_dist[code];
                    send_bits(s, dist, extra);
                }
            }
        }while (sx < s.sym_next)
    }
    send_code(s, 256, ltree);
};
const build_tree = (s, desc)=>{
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE$1;
    for(n = 0; n < elems; n++){
        if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
        } else {
            tree[n * 2 + 1] = 0;
        }
    }
    while(s.heap_len < 2){
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
        }
    }
    desc.max_code = max_code;
    for(n = s.heap_len >> 1; n >= 1; n--){
        pqdownheap(s, tree, n);
    }
    node = elems;
    do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
    }while (s.heap_len >= 2)
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code)=>{
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 0xffff;
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
            continue;
        } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
            if (curlen !== prevlen) {
                s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[16 * 2]++;
        } else if (count <= 10) {
            s.bl_tree[17 * 2]++;
        } else {
            s.bl_tree[18 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
};
const send_tree = (s, tree, max_code)=>{
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    for(n = 0; n <= max_code; n++){
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
            continue;
        } else if (count < min_count) {
            do {
                send_code(s, curlen, s.bl_tree);
            }while (--count !== 0)
        } else if (curlen !== 0) {
            if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
            }
            send_code(s, 16, s.bl_tree);
            send_bits(s, count - 3, 2);
        } else if (count <= 10) {
            send_code(s, 17, s.bl_tree);
            send_bits(s, count - 3, 3);
        } else {
            send_code(s, 18, s.bl_tree);
            send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
};
const build_bl_tree = (s)=>{
    let max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for(max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--){
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
        }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes)=>{
    let rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for(rank = 0; rank < blcodes; rank++){
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s)=>{
    let block_mask = 0xf3ffc07f;
    let n;
    for(n = 0; n <= 31; n++, block_mask >>>= 1){
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return 0;
        }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return 1;
    }
    for(n = 32; n < 256; n++){
        if (s.dyn_ltree[n * 2] !== 0) {
            return 1;
        }
    }
    return 0;
};
let static_init_done = false;
const _tr_init$1 = (s)=>{
    if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last)=>{
    send_bits(s, (0 << 1) + (last ? 1 : 0), 3);
    bi_windup(s);
    put_short(s, stored_len);
    put_short(s, ~stored_len);
    if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
    }
    s.pending += stored_len;
};
const _tr_align$1 = (s)=>{
    send_bits(s, 1 << 1, 3);
    send_code(s, 256, static_ltree);
    bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last)=>{
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
        if (s.strm.data_type === 2) {
            s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
        }
    } else {
        opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s, buf, stored_len, last);
    } else if (s.strategy === 4 || static_lenb === opt_lenb) {
        send_bits(s, (1 << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
    } else {
        send_bits(s, (2 << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
        bi_windup(s);
    }
};
const _tr_tally$1 = (s, dist, lc)=>{
    s.pending_buf[s.sym_buf + s.sym_next++] = dist;
    s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
    s.pending_buf[s.sym_buf + s.sym_next++] = lc;
    if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
    } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + 256 + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
    _tr_init: _tr_init_1,
    _tr_stored_block: _tr_stored_block_1,
    _tr_flush_block: _tr_flush_block_1,
    _tr_tally: _tr_tally_1,
    _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos)=>{
    let s1 = adler & 0xffff | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0;
    while(len !== 0){
        n = len > 2000 ? 2000 : len;
        len -= n;
        do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
        }while (--n)
        s1 %= 65521;
        s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = ()=>{
    let c, table = [];
    for(var n = 0; n < 256; n++){
        c = n;
        for(var k = 0; k < 8; k++){
            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
    }
    return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos)=>{
    const t = crcTable;
    const end = pos + len;
    crc ^= -1;
    for(let i = pos; i < end; i++){
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }
    return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
    2: 'need dictionary',
    1: 'stream end',
    0: '',
    '-1': 'file error',
    '-2': 'stream error',
    '-3': 'data error',
    '-4': 'insufficient memory',
    '-5': 'buffer error',
    '-6': 'incompatible version'
};
var constants$2 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const { Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2 } = constants$2;
const L_CODES = 256 + 1 + 29;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = 258 + 3 + 1;
const PRESET_DICT = 0x20;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const err = (strm, errorCode)=>{
    strm.msg = messages[errorCode];
    return errorCode;
};
const rank = (f)=>{
    return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf)=>{
    let len = buf.length;
    while(--len >= 0){
        buf[len] = 0;
    }
};
const slide_hash = (s)=>{
    let n, m;
    let p;
    let wsize = s.w_size;
    n = s.hash_size;
    p = n;
    do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
    }while (--n)
    n = wsize;
    p = n;
    do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
    }while (--n)
};
let HASH_ZLIB = (s, prev, data)=>(prev << s.hash_shift ^ data) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm)=>{
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
        len = strm.avail_out;
    }
    if (len === 0) {
        return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
        s.pending_out = 0;
    }
};
const flush_block_only = (s, last)=>{
    _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
};
const put_byte = (s, b)=>{
    s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b)=>{
    s.pending_buf[s.pending++] = b >>> 8 & 0xff;
    s.pending_buf[s.pending++] = b & 0xff;
};
const read_buf = (strm, buf, start, size)=>{
    let len = strm.avail_in;
    if (len > size) {
        len = size;
    }
    if (len === 0) {
        return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
};
const longest_match = (s, cur_match)=>{
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + 258;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
    }
    do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
        }
        scan += 2;
        match++;
        do {}while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend)
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
                break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
        }
    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)
    if (best_len <= s.lookahead) {
        return best_len;
    }
    return s.lookahead;
};
const fill_window = (s)=>{
    const _w_size = s.w_size;
    let n, more, str;
    do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            if (s.insert > s.strstart) {
                s.insert = s.strstart;
            }
            slide_hash(s);
            more += _w_size;
        }
        if (s.strm.avail_in === 0) {
            break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= 3) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
            while(s.insert){
                s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < 3) {
                    break;
                }
            }
        }
    }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
};
const deflate_stored = (s, flush)=>{
    let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
    let len, left, have, last = 0;
    let used = s.strm.avail_in;
    do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
            break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
            len = left + s.strm.avail_in;
        }
        if (len > have) {
            len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
            break;
        }
        last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
            if (left > len) {
                left = len;
            }
            s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
            s.strm.next_out += left;
            s.strm.avail_out -= left;
            s.strm.total_out += left;
            s.block_start += left;
            len -= left;
        }
        if (len) {
            read_buf(s.strm, s.strm.output, s.strm.next_out, len);
            s.strm.next_out += len;
            s.strm.avail_out -= len;
            s.strm.total_out += len;
        }
    }while (last === 0)
    used -= s.strm.avail_in;
    if (used) {
        if (used >= s.w_size) {
            s.matches = 2;
            s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
            s.strstart = s.w_size;
            s.insert = s.strstart;
        } else {
            if (s.window_size - s.strstart <= used) {
                s.strstart -= s.w_size;
                s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
                if (s.matches < 2) {
                    s.matches++;
                }
                if (s.insert > s.strstart) {
                    s.insert = s.strstart;
                }
            }
            s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
            s.strstart += used;
            s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
    }
    if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
    }
    if (last) {
        return 4;
    }
    if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return 2;
    }
    have = s.window_size - s.strstart;
    if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
            s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
            s.insert = s.strstart;
        }
    }
    if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
    }
    if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
    }
    if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
    }
    have = s.bi_valid + 42 >> 3;
    have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
    min_block = have > s.w_size ? s.w_size : have;
    left = s.strstart - s.block_start;
    if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
    }
    return last ? 3 : 1;
};
const deflate_fast = (s, flush)=>{
    let hash_head;
    let bflush;
    for(;;){
        if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s.lookahead === 0) {
                break;
            }
        }
        hash_head = 0;
        if (s.lookahead >= 3) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= 3) {
            bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
                s.match_length--;
                do {
                    s.strstart++;
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                }while (--s.match_length !== 0)
                s.strstart++;
            } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
            }
        } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
        }
        if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_slow = (s, flush)=>{
    let hash_head;
    let bflush;
    let max_insert;
    for(;;){
        if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s.lookahead === 0) {
                break;
            }
        }
        hash_head = 0;
        if (s.lookahead >= 3) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === 3 && s.strstart - s.match_start > 4096)) {
                s.match_length = MIN_MATCH - 1;
            }
        }
        if (s.prev_length >= 3 && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
                if (++s.strstart <= max_insert) {
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                }
            }while (--s.prev_length !== 0)
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return 1;
                }
            }
        } else if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
                flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
                return 1;
            }
        } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
        }
    }
    if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_rle = (s, flush)=>{
    let bflush;
    let prev;
    let scan, strend;
    const _win = s.window;
    for(;;){
        if (s.lookahead <= 258) {
            fill_window(s);
            if (s.lookahead <= 258 && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s.lookahead === 0) {
                break;
            }
        }
        s.match_length = 0;
        if (s.lookahead >= 3 && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do {}while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend)
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) {
                    s.match_length = s.lookahead;
                }
            }
        }
        if (s.match_length >= 3) {
            bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
        } else {
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
        }
        if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_huff = (s, flush)=>{
    let bflush;
    for(;;){
        if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH$2) {
                    return 1;
                }
                break;
            }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
}
const configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
];
const lm_init = (s)=>{
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
};
function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED$2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.sym_buf = 0;
    this.lit_bufsize = 0;
    this.sym_next = 0;
    this.sym_end = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
}
const deflateStateCheck = (strm)=>{
    if (!strm) {
        return 1;
    }
    const s = strm.state;
    if (!s || s.strm !== strm || s.status !== 42 && s.status !== 57 && s.status !== 69 && s.status !== 73 && s.status !== 91 && s.status !== 103 && s.status !== 113 && s.status !== 666) {
        return 1;
    }
    return 0;
};
const deflateResetKeep = (strm)=>{
    if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR$2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    const s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
        s.wrap = -s.wrap;
    }
    s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = -2;
    _tr_init(s);
    return Z_OK$3;
};
const deflateReset = (strm)=>{
    const ret = deflateResetKeep(strm);
    if (ret === Z_OK$3) {
        lm_init(strm.state);
    }
    return ret;
};
const deflateSetHeader = (strm, head)=>{
    if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$2;
    }
    strm.state.gzhead = head;
    return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy)=>{
    if (!strm) {
        return Z_STREAM_ERROR$2;
    }
    let wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
    }
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > 9 || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR$2);
    }
    if (windowBits === 8) {
        windowBits = 9;
    }
    const s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.status = INIT_STATE;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.sym_buf = s.lit_bufsize;
    s.sym_end = (s.lit_bufsize - 1) * 3;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
};
const deflateInit = (strm, level)=>{
    return deflateInit2(strm, level, Z_DEFLATED$2, 15, 8, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush)=>{
    if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === 666 && flush !== Z_FINISH$3) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
    }
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK$3;
        }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
    }
    if (s.status === 666 && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
    }
    if (s.status === 42 && s.wrap === 0) {
        s.status = BUSY_STATE;
    }
    if (s.status === 42) {
        let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
        } else if (s.level < 6) {
            level_flags = 1;
        } else if (s.level === 6) {
            level_flags = 2;
        } else {
            level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
            header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
        }
    }
    if (s.status === 57) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, 0x03);
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, s.gzhead.time >> 8 & 0xff);
            put_byte(s, s.gzhead.time >> 16 & 0xff);
            put_byte(s, s.gzhead.time >> 24 & 0xff);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 0xff);
                put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
            }
            if (s.gzhead.hcrc) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
        }
    }
    if (s.status === 69) {
        if (s.gzhead.extra) {
            let beg = s.pending;
            let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
            while(s.pending + left > s.pending_buf_size){
                let copy = s.pending_buf_size - s.pending;
                s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
                s.pending = s.pending_buf_size;
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                s.gzindex += copy;
                flush_pending(strm);
                if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
                beg = 0;
                left -= copy;
            }
            let gzhead_extra = new Uint8Array(s.gzhead.extra);
            s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
            s.pending += left;
            if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
        }
        s.status = NAME_STATE;
    }
    if (s.status === 73) {
        if (s.gzhead.name) {
            let beg = s.pending;
            let val;
            do {
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                    beg = 0;
                }
                if (s.gzindex < s.gzhead.name.length) {
                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                } else {
                    val = 0;
                }
                put_byte(s, val);
            }while (val !== 0)
            if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
    }
    if (s.status === 91) {
        if (s.gzhead.comment) {
            let beg = s.pending;
            let val;
            do {
                if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                    beg = 0;
                }
                if (s.gzindex < s.gzhead.comment.length) {
                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                } else {
                    val = 0;
                }
                put_byte(s, val);
            }while (val !== 0)
            if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
        }
        s.status = HCRC_STATE;
    }
    if (s.status === 103) {
        if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
                flush_pending(strm);
                if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            }
            put_byte(s, strm.adler & 0xff);
            put_byte(s, strm.adler >> 8 & 0xff);
            strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
        }
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== 666) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === 3 || bstate === 4) {
            s.status = FINISH_STATE;
        }
        if (bstate === 1 || bstate === 3) {
            if (strm.avail_out === 0) {
                s.last_flush = -1;
            }
            return Z_OK$3;
        }
        if (bstate === 2) {
            if (flush === Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else if (flush !== Z_BLOCK$1) {
                _tr_stored_block(s, 0, 0, false);
                if (flush === Z_FULL_FLUSH$1) {
                    zero(s.head);
                    if (s.lookahead === 0) {
                        s.strstart = 0;
                        s.block_start = 0;
                        s.insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
    }
    if (flush !== Z_FINISH$3) {
        return Z_OK$3;
    }
    if (s.wrap <= 0) {
        return Z_STREAM_END$3;
    }
    if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        put_byte(s, strm.adler >> 16 & 0xff);
        put_byte(s, strm.adler >> 24 & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, strm.total_in >> 8 & 0xff);
        put_byte(s, strm.total_in >> 16 & 0xff);
        put_byte(s, strm.total_in >> 24 & 0xff);
    } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
        s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm)=>{
    if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
    }
    const status = strm.state.status;
    strm.state = null;
    return status === 113 ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary)=>{
    let dictLength = dictionary.length;
    if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== 42 || s.lookahead) {
        return Z_STREAM_ERROR$2;
    }
    if (wrap === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
        if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while(s.lookahead >= 3){
        let str = s.strstart;
        let n = s.lookahead - (3 - 1);
        do {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
        }while (--n)
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';
var deflate_1$2 = {
    deflateInit: deflateInit_1,
    deflateInit2: deflateInit2_1,
    deflateReset: deflateReset_1,
    deflateResetKeep: deflateResetKeep_1,
    deflateSetHeader: deflateSetHeader_1,
    deflate: deflate_2$1,
    deflateEnd: deflateEnd_1,
    deflateSetDictionary: deflateSetDictionary_1,
    deflateInfo: deflateInfo
};
const _has = (obj, key)=>{
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while(sources.length){
        const source = sources.shift();
        if (!source) {
            continue;
        }
        if (typeof source !== 'object') {
            throw new TypeError(source + 'must be non-object');
        }
        for(const p in source){
            if (_has(source, p)) {
                obj[p] = source[p];
            }
        }
    }
    return obj;
};
var flattenChunks = (chunks)=>{
    let len = 0;
    for(let i = 0, l = chunks.length; i < l; i++){
        len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for(let i = 0, pos = 0, l = chunks.length; i < l; i++){
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
    }
    return result;
};
var common = {
    assign: assign,
    flattenChunks: flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
    String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
    STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for(let q = 0; q < 256; q++){
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str)=>{
    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
    }
    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for(m_pos = 0; m_pos < str_len; m_pos++){
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for(i = 0, m_pos = 0; i < buf_len; m_pos++){
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            buf[i++] = c;
        } else if (c < 0x800) {
            buf[i++] = 0xC0 | c >>> 6;
            buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
            buf[i++] = 0xE0 | c >>> 12;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        } else {
            buf[i++] = 0xf0 | c >>> 18;
            buf[i++] = 0x80 | c >>> 12 & 0x3f;
            buf[i++] = 0x80 | c >>> 6 & 0x3f;
            buf[i++] = 0x80 | c & 0x3f;
        }
    }
    return buf;
};
const buf2binstring = (buf, len)=>{
    if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
    }
    let result = '';
    for(let i = 0; i < len; i++){
        result += String.fromCharCode(buf[i]);
    }
    return result;
};
var buf2string = (buf, max)=>{
    const len = max || buf.length;
    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
    }
    let i, out;
    const utf16buf = new Array(len * 2);
    for(out = 0, i = 0; i < len;){
        let c = buf[i++];
        if (c < 0x80) {
            utf16buf[out++] = c;
            continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
            utf16buf[out++] = 0xfffd;
            i += c_len - 1;
            continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while(c_len > 1 && i < len){
            c = c << 6 | buf[i++] & 0x3f;
            c_len--;
        }
        if (c_len > 1) {
            utf16buf[out++] = 0xfffd;
            continue;
        }
        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
            utf16buf[out++] = 0xdc00 | c & 0x3ff;
        }
    }
    return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max)=>{
    max = max || buf.length;
    if (max > buf.length) {
        max = buf.length;
    }
    let pos = max - 1;
    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){
        pos--;
    }
    if (pos < 0) {
        return max;
    }
    if (pos === 0) {
        return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
    string2buf: string2buf,
    buf2string: buf2string,
    utf8border: utf8border
};
function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = '';
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const { Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1 } = constants$2;
function Deflate$1(options) {
    this.options = common.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED$1,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = '';
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK$2) {
        throw new Error(messages[status]);
    }
    if (opt.header) {
        deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === 'string') {
            dict = strings.string2buf(opt.dictionary);
        } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
            dict = new Uint8Array(opt.dictionary);
        } else {
            dict = opt.dictionary;
        }
        status = deflate_1$2.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK$2) {
            throw new Error(messages[status]);
        }
        this._dict_set = true;
    }
}
Deflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;
    if (this.ended) {
        return false;
    }
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
    if (typeof data === 'string') {
        strm.input = strings.string2buf(data);
    } else if (toString$1.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
    } else {
        strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for(;;){
        if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
            if (strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = deflate_1$2.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
        }
        if (strm.avail_in === 0) break;
    }
    return true;
};
Deflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK$2) {
        this.result = common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
function deflate$1(input, options) {
    const deflator = new Deflate$1(options);
    deflator.push(input, true);
    if (deflator.err) {
        throw deflator.msg || messages[deflator.err];
    }
    return deflator.result;
}
function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
}
function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
    Deflate: Deflate_1$1,
    deflate: deflate_2,
    deflateRaw: deflateRaw_1$1,
    gzip: gzip_1$1,
    constants: constants$1
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input, output;
    const state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
        if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for(;;){
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff;
            if (op === 0) {
                output[_out++] = here & 0xffff;
            } else if (op & 16) {
                len = here & 0xffff;
                op &= 15;
                if (op) {
                    if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                }
                if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                }
                here = dcode[hold & dmask];
                dodist: for(;;){
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 0xff;
                    if (op & 16) {
                        dist = here & 0xffff;
                        op &= 15;
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                            strm.msg = 'invalid distance too far back';
                            state.mode = BAD$1;
                            break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                                if (state.sane) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD$1;
                                    break top;
                                }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                                from += wsize - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            } else if (wnext < op) {
                                from += wsize + wnext - op;
                                op -= wnext;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = 0;
                                    if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        }while (--op)
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                            } else {
                                from += wnext - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            }
                            while(len > 2){
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                len -= 3;
                            }
                            if (len) {
                                output[_out++] = from_source[from++];
                                if (len > 1) {
                                    output[_out++] = from_source[from++];
                                }
                            }
                        } else {
                            from = _out - dist;
                            do {
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                len -= 3;
                            }while (len > 2)
                            if (len) {
                                output[_out++] = output[from++];
                                if (len > 1) {
                                    output[_out++] = output[from++];
                                }
                            }
                        }
                    } else if ((op & 64) === 0) {
                        here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];
                        continue dodist;
                    } else {
                        strm.msg = 'invalid distance code';
                        state.mode = BAD$1;
                        break top;
                    }
                    break;
                }
            } else if ((op & 64) === 0) {
                here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];
                continue dolen;
            } else if (op & 32) {
                state.mode = TYPE$1;
                break top;
            } else {
                strm.msg = 'invalid literal/length code';
                state.mode = BAD$1;
                break top;
            }
            break;
        }
    }while (_in < last && _out < end)
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
};
const MAXBITS = 15;
const lbase = new Uint16Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
]);
const lext = new Uint8Array([
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
]);
const dbase = new Uint16Array([
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
]);
const dext = new Uint8Array([
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts)=>{
    const bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min = 0, max = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base = null;
    let match;
    const count = new Uint16Array(15 + 1);
    const offs = new Uint16Array(15 + 1);
    let extra = null;
    let here_bits, here_op, here_val;
    for(len = 0; len <= 15; len++){
        count[len] = 0;
    }
    for(sym = 0; sym < codes; sym++){
        count[lens[lens_index + sym]]++;
    }
    root = bits;
    for(max = MAXBITS; max >= 1; max--){
        if (count[max] !== 0) {
            break;
        }
    }
    if (root > max) {
        root = max;
    }
    if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
    }
    for(min = 1; min < max; min++){
        if (count[min] !== 0) {
            break;
        }
    }
    if (root < min) {
        root = min;
    }
    left = 1;
    for(len = 1; len <= 15; len++){
        left <<= 1;
        left -= count[len];
        if (left < 0) {
            return -1;
        }
    }
    if (left > 0 && (type === 0 || max !== 1)) {
        return -1;
    }
    offs[1] = 0;
    for(len = 1; len < 15; len++){
        offs[len + 1] = offs[len] + count[len];
    }
    for(sym = 0; sym < codes; sym++){
        if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
        }
    }
    if (type === 0) {
        base = extra = work;
        match = 20;
    } else if (type === 1) {
        base = lbase;
        extra = lext;
        match = 257;
    } else {
        base = dbase;
        extra = dext;
        match = 0;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === 1 && used > 852 || type === 2 && used > 592) {
        return 1;
    }
    for(;;){
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
            here_op = 0;
            here_val = work[sym];
        } else if (work[sym] >= match) {
            here_op = extra[work[sym] - match];
            here_val = base[work[sym] - match];
        } else {
            here_op = 32 + 64;
            here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        }while (fill !== 0)
        incr = 1 << len - 1;
        while(huff & incr){
            incr >>= 1;
        }
        if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
        } else {
            huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
            if (len === max) {
                break;
            }
            len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
                drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while(curr + drop < max){
                left -= count[curr + drop];
                if (left <= 0) {
                    break;
                }
                curr++;
                left <<= 1;
            }
            used += 1 << curr;
            if (type === 1 && used > 852 || type === 2 && used > 592) {
                return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
    }
    if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const { Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED } = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const zswap32 = (q)=>{
    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
};
function InflateState() {
    this.strm = null;
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
}
const inflateStateCheck = (strm)=>{
    if (!strm) {
        return 1;
    }
    const state = strm.state;
    if (!state || state.strm !== strm || state.mode < 16180 || state.mode > 16211) {
        return 1;
    }
    return 0;
};
const inflateResetKeep = (strm)=>{
    if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = '';
    if (state.wrap) {
        strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.flags = -1;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK$1;
};
const inflateReset = (strm)=>{
    if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits)=>{
    let wrap;
    if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
            windowBits &= 15;
        }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits)=>{
    if (!strm) {
        return Z_STREAM_ERROR$1;
    }
    const state = new InflateState();
    strm.state = state;
    state.strm = strm;
    state.window = null;
    state.mode = HEAD;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
        strm.state = null;
    }
    return ret;
};
const inflateInit = (strm)=>{
    return inflateInit2(strm, 15);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state)=>{
    if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while(sym < 144){
            state.lens[sym++] = 8;
        }
        while(sym < 256){
            state.lens[sym++] = 9;
        }
        while(sym < 280){
            state.lens[sym++] = 7;
        }
        while(sym < 288){
            state.lens[sym++] = 8;
        }
        inftrees(1, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
        });
        sym = 0;
        while(sym < 32){
            state.lens[sym++] = 5;
        }
        inftrees(2, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
        });
        virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
};
const updatewindow = (strm, src, end, copy)=>{
    let dist;
    const state = strm.state;
    if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
    } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
            dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
            state.window.set(src.subarray(end - copy, end), 0);
            state.wnext = copy;
            state.whave = state.wsize;
        } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
                state.wnext = 0;
            }
            if (state.whave < state.wsize) {
                state.whave += dist;
            }
        }
    }
    return 0;
};
const inflate$2 = (strm, flush)=>{
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    const order = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]);
    if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.mode === 16191) {
        state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK$1;
    inf_leave: for(;;){
        switch(state.mode){
            case 16180:
                if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                }
                while(bits < 16){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.wrap & 2 && hold === 0x8b1f) {
                    if (state.wbits === 0) {
                        state.wbits = 15;
                    }
                    state.check = 0;
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                }
                if (state.head) {
                    state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
                    strm.msg = 'incorrect header check';
                    state.mode = BAD;
                    break;
                }
                if ((hold & 0x0f) !== Z_DEFLATED) {
                    strm.msg = 'unknown compression method';
                    state.mode = BAD;
                    break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 0x0f) + 8;
                if (state.wbits === 0) {
                    state.wbits = len;
                }
                if (len > 15 || len > state.wbits) {
                    strm.msg = 'invalid window size';
                    state.mode = BAD;
                    break;
                }
                state.dmax = 1 << state.wbits;
                state.flags = 0;
                strm.adler = state.check = 1;
                state.mode = hold & 0x200 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
            case 16181:
                while(bits < 16){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 0xff) !== Z_DEFLATED) {
                    strm.msg = 'unknown compression method';
                    state.mode = BAD;
                    break;
                }
                if (state.flags & 0xe000) {
                    strm.msg = 'unknown header flags set';
                    state.mode = BAD;
                    break;
                }
                if (state.head) {
                    state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 0x0200 && state.wrap & 4) {
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
            case 16182:
                while(bits < 32){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.time = hold;
                }
                if (state.flags & 0x0200 && state.wrap & 4) {
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    hbuf[2] = hold >>> 16 & 0xff;
                    hbuf[3] = hold >>> 24 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
            case 16183:
                while(bits < 16){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.xflags = hold & 0xff;
                    state.head.os = hold >> 8;
                }
                if (state.flags & 0x0200 && state.wrap & 4) {
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
            case 16184:
                if (state.flags & 0x0400) {
                    while(bits < 16){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                        state.head.extra_len = hold;
                    }
                    if (state.flags & 0x0200 && state.wrap & 4) {
                        hbuf[0] = hold & 0xff;
                        hbuf[1] = hold >>> 8 & 0xff;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                } else if (state.head) {
                    state.head.extra = null;
                }
                state.mode = EXTRA;
            case 16185:
                if (state.flags & 0x0400) {
                    copy = state.length;
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy) {
                        if (state.head) {
                            len = state.head.extra_len - state.length;
                            if (!state.head.extra) {
                                state.head.extra = new Uint8Array(state.head.extra_len);
                            }
                            state.head.extra.set(input.subarray(next, next + copy), len);
                        }
                        if (state.flags & 0x0200 && state.wrap & 4) {
                            state.check = crc32_1(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        state.length -= copy;
                    }
                    if (state.length) {
                        break inf_leave;
                    }
                }
                state.length = 0;
                state.mode = NAME;
            case 16186:
                if (state.flags & 0x0800) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.name += String.fromCharCode(len);
                        }
                    }while (len && copy < have)
                    if (state.flags & 0x0200 && state.wrap & 4) {
                        state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
            case 16187:
                if (state.flags & 0x1000) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.comment += String.fromCharCode(len);
                        }
                    }while (len && copy < have)
                    if (state.flags & 0x0200 && state.wrap & 4) {
                        state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.comment = null;
                }
                state.mode = HCRC;
            case 16188:
                if (state.flags & 0x0200) {
                    while(bits < 16){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.check & 0xffff)) {
                        strm.msg = 'header crc mismatch';
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
            case 16189:
                while(bits < 32){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
            case 16190:
                if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT$1;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
            case 16191:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                }
            case 16192:
                if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                }
                while(bits < 3){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.last = hold & 0x01;
                hold >>>= 1;
                bits -= 1;
                switch(hold & 0x03){
                    case 0:
                        state.mode = STORED;
                        break;
                    case 1:
                        fixedtables(state);
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                            hold >>>= 2;
                            bits -= 2;
                            break inf_leave;
                        }
                        break;
                    case 2:
                        state.mode = TABLE;
                        break;
                    case 3:
                        strm.msg = 'invalid block type';
                        state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
            case 16193:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while(bits < 32){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
                    strm.msg = 'invalid stored block lengths';
                    state.mode = BAD;
                    break;
                }
                state.length = hold & 0xffff;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }
            case 16194:
                state.mode = COPY;
            case 16195:
                copy = state.length;
                if (copy) {
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy > left) {
                        copy = left;
                    }
                    if (copy === 0) {
                        break inf_leave;
                    }
                    output.set(input.subarray(next, next + copy), put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                }
                state.mode = TYPE;
                break;
            case 16196:
                while(bits < 14){
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.nlen = (hold & 0x1f) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 0x1f) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 0x0f) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = 'too many length or distance symbols';
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = LENLENS;
            case 16197:
                while(state.have < state.ncode){
                    while(bits < 3){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 0x07;
                    hold >>>= 3;
                    bits -= 3;
                }
                while(state.have < 19){
                    state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = {
                    bits: state.lenbits
                };
                ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = 'invalid code lengths set';
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = CODELENS;
            case 16198:
                while(state.have < state.nlen + state.ndist){
                    for(;;){
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 0xff;
                        here_val = here & 0xffff;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.lens[state.have++] = here_val;
                    } else {
                        if (here_val === 16) {
                            n = here_bits + 2;
                            while(bits < n){
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            if (state.have === 0) {
                                strm.msg = 'invalid bit length repeat';
                                state.mode = BAD;
                                break;
                            }
                            len = state.lens[state.have - 1];
                            copy = 3 + (hold & 0x03);
                            hold >>>= 2;
                            bits -= 2;
                        } else if (here_val === 17) {
                            n = here_bits + 3;
                            while(bits < n){
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 3 + (hold & 0x07);
                            hold >>>= 3;
                            bits -= 3;
                        } else {
                            n = here_bits + 7;
                            while(bits < n){
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 11 + (hold & 0x7f);
                            hold >>>= 7;
                            bits -= 7;
                        }
                        if (state.have + copy > state.nlen + state.ndist) {
                            strm.msg = 'invalid bit length repeat';
                            state.mode = BAD;
                            break;
                        }
                        while(copy--){
                            state.lens[state.have++] = len;
                        }
                    }
                }
                if (state.mode === 16209) {
                    break;
                }
                if (state.lens[256] === 0) {
                    strm.msg = 'invalid code -- missing end-of-block';
                    state.mode = BAD;
                    break;
                }
                state.lenbits = 9;
                opts = {
                    bits: state.lenbits
                };
                ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = 'invalid literal/lengths set';
                    state.mode = BAD;
                    break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = {
                    bits: state.distbits
                };
                ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                    strm.msg = 'invalid distances set';
                    state.mode = BAD;
                    break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }
            case 16199:
                state.mode = LEN;
            case 16200:
                if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inffast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === 16191) {
                        state.back = -1;
                    }
                    break;
                }
                state.back = 0;
                for(;;){
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (here_op && (here_op & 0xf0) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 0xff;
                        here_val = here & 0xffff;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                    state.mode = LIT;
                    break;
                }
                if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                }
                if (here_op & 64) {
                    strm.msg = 'invalid literal/length code';
                    state.mode = BAD;
                    break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
            case 16201:
                if (state.extra) {
                    n = state.extra;
                    while(bits < n){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
            case 16202:
                for(;;){
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((here_op & 0xf0) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 0xff;
                        here_val = here & 0xffff;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                    strm.msg = 'invalid distance code';
                    state.mode = BAD;
                    break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
            case 16203:
                if (state.extra) {
                    n = state.extra;
                    while(bits < n){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break;
                }
                state.mode = MATCH;
            case 16204:
                if (left === 0) {
                    break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                        if (state.sane) {
                            strm.msg = 'invalid distance too far back';
                            state.mode = BAD;
                            break;
                        }
                    }
                    if (copy > state.wnext) {
                        copy -= state.wnext;
                        from = state.wsize - copy;
                    } else {
                        from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                        copy = state.length;
                    }
                    from_source = state.window;
                } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                }
                if (copy > left) {
                    copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                    output[put++] = from_source[from++];
                }while (--copy)
                if (state.length === 0) {
                    state.mode = LEN;
                }
                break;
            case 16205:
                if (left === 0) {
                    break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
            case 16206:
                if (state.wrap) {
                    while(bits < 32){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold |= input[next++] << bits;
                        bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (state.wrap & 4 && _out) {
                        strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = 'incorrect data check';
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = LENGTH;
            case 16207:
                if (state.wrap && state.flags) {
                    while(bits < 32){
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.total & 0xffffffff)) {
                        strm.msg = 'incorrect length check';
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = DONE;
            case 16208:
                ret = Z_STREAM_END$1;
                break inf_leave;
            case 16209:
                ret = Z_DATA_ERROR$1;
                break inf_leave;
            case 16210:
                return Z_MEM_ERROR$1;
            case 16211:
            default:
                return Z_STREAM_ERROR$1;
        }
    }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < 16209 && (state.mode < 16206 || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap & 4 && _out) {
        strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
    }
    return ret;
};
const inflateEnd = (strm)=>{
    if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
    }
    let state = strm.state;
    if (state.window) {
        state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
};
const inflateGetHeader = (strm, head)=>{
    if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$1;
    }
    state.head = head;
    head.done = false;
    return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary)=>{
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== 16190) {
        return Z_STREAM_ERROR$1;
    }
    if (state.mode === 16190) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
            return Z_DATA_ERROR$1;
        }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';
var inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo: inflateInfo
};
function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = '';
    this.comment = '';
    this.hcrc = 0;
    this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const { Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR } = constants$2;
function Inflate$1(options) {
    this.options = common.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ''
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
            opt.windowBits = -15;
        }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
        }
    }
    this.err = 0;
    this.msg = '';
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
    if (status !== Z_OK) {
        throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
        if (typeof opt.dictionary === 'string') {
            opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
            opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
            status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== Z_OK) {
                throw new Error(messages[status]);
            }
        }
    }
}
Inflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
    } else {
        strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for(;;){
        if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
            status = inflate_1$2.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
                status = inflate_1$2.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
                status = Z_NEED_DICT;
            }
        }
        while(strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0){
            inflate_1$2.inflateReset(strm);
            status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch(status){
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
                this.onEnd(status);
                this.ended = true;
                return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
                if (this.options.to === 'string') {
                    let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                    let tail = strm.next_out - next_out_utf8;
                    let utf8str = strings.buf2string(strm.output, next_out_utf8);
                    strm.next_out = tail;
                    strm.avail_out = chunkSize - tail;
                    if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                    this.onData(utf8str);
                } else {
                    this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                }
            }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
            status = inflate_1$2.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
        }
        if (strm.avail_in === 0) break;
    }
    return true;
};
Inflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK) {
        if (this.options.to === 'string') {
            this.result = this.chunks.join('');
        } else {
            this.result = common.flattenChunks(this.chunks);
        }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
}
function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants4 = constants$2;
var inflate_1$1 = {
    Inflate: Inflate_1$1,
    inflate: inflate_2,
    inflateRaw: inflateRaw_1$1,
    ungzip: ungzip$1,
    constants: constants4
};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
const nodePkg = require('./pkg.node/brotli_wasm');
module.exports = nodePkg;
module.exports.default = Promise.resolve(nodePkg);
const __default = nodePkg;
const BufferImpl = globalThis.Buffer || Buffer;
const brotliCompressRaw = __default.compress;
const brotliDecompressRaw = __default.decompress;
const BROTLI_CONSTANTS = {
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const { BROTLI_PARAM_MODE, BROTLI_PARAM_QUALITY, BROTLI_PARAM_LGWIN, BROTLI_PARAM_LGBLOCK, BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING, BROTLI_PARAM_SIZE_HINT, BROTLI_PARAM_LARGE_WINDOW, BROTLI_PARAM_NPOSTFIX, BROTLI_PARAM_NDIRECT } = BROTLI_CONSTANTS;
const VALID_BROTLI_PARAMS = new Set([
    BROTLI_PARAM_MODE,
    BROTLI_PARAM_QUALITY,
    BROTLI_PARAM_LGWIN,
    BROTLI_PARAM_LGBLOCK,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING,
    BROTLI_PARAM_SIZE_HINT,
    BROTLI_PARAM_LARGE_WINDOW,
    BROTLI_PARAM_NPOSTFIX,
    BROTLI_PARAM_NDIRECT
]);
const BOOLEAN_BROTLI_PARAMS = new Set([
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING
]);
function toBufferSource(data) {
    if (typeof data === "string") {
        return BufferImpl.from(data);
    }
    return BufferImpl.from(data);
}
function normalizeOptions(options) {
    if (!options) return undefined;
    const normalized = {};
    if (typeof options.level === "number") normalized.level = options.level;
    if (typeof options.windowBits === "number") normalized.windowBits = options.windowBits;
    return normalized;
}
function throwInvalidBrotliParam(key) {
    const error = new RangeError(`${key} is not a valid Brotli parameter`);
    error.code = "ERR_BROTLI_INVALID_PARAM";
    throw error;
}
function ensureFlushRange(name, value) {
    if (value === undefined) return;
    const numeric = Number(value);
    if (!Number.isFinite(numeric) || numeric < 0 || numeric > 3) {
        const error = new RangeError(`The value of "options.${name}" is out of range. It must be >= 0 and <= 3. Received ${value}`);
        error.code = "ERR_OUT_OF_RANGE";
        throw error;
    }
}
function validateBrotliFlush(options) {
    if (!options) return;
    ensureFlushRange("flush", options.flush);
    ensureFlushRange("finishFlush", options.finishFlush);
}
function parseBrotliParams(params) {
    const normalized = new Map();
    if (!params) return normalized;
    for (const [key, value] of Object.entries(params)){
        const paramId = Number(key);
        if (!Number.isFinite(paramId) || !VALID_BROTLI_PARAMS.has(paramId) || normalized.has(paramId)) {
            throwInvalidBrotliParam(key);
        }
        if (value === undefined) continue;
        const numericValue = typeof value === "boolean" ? value ? 1 : 0 : Number(value);
        if (!Number.isFinite(numericValue)) {
            throwInvalidBrotliParam(key);
        }
        if (BOOLEAN_BROTLI_PARAMS.has(paramId) && numericValue !== 0 && numericValue !== 1) {
            const err = new Error("Initialization failed");
            err.code = "ERR_ZLIB_INITIALIZATION_FAILED";
            throw err;
        }
        normalized.set(paramId, numericValue);
    }
    return normalized;
}
function normalizeBrotliOptions(options) {
    validateBrotliFlush(options);
    const params = parseBrotliParams(options?.params);
    return {
        quality: params.get(BROTLI_PARAM_QUALITY)
    };
}
class ZlibStream extends EventEmitter {
    queue = [];
    length = 0;
    processFn;
    opts;
    _readableState = {
        endEmitted: false
    };
    constructor(processFn, options){
        super();
        this.processFn = processFn;
        this.opts = options;
    }
    write(data, _encoding, cb) {
        const chunk = toBufferSource(data);
        this.queue.push(chunk);
        this.length += chunk.length;
        if (cb) cb();
        return true;
    }
    flush(modeOrCb, cb) {
        const callback = typeof modeOrCb === "function" ? modeOrCb : cb;
        try {
            const input = this.length > 0 ? BufferImpl.concat(this.queue, this.length) : BufferImpl.alloc(0);
            this.queue = [];
            this.length = 0;
            const result = this.processFn(input, this.opts);
            const output = BufferImpl.from(result);
            this.emit("data", output);
            if (callback) callback();
        } catch (error) {
            const err = error instanceof Error ? error : new Error(String(error));
            this.emit("error", err);
            if (callback) callback();
        }
    }
    reset() {
        this.queue = [];
        this.length = 0;
        this._readableState.endEmitted = false;
    }
    end(chunk, cb) {
        if (chunk !== undefined) {
            this.write(chunk);
        }
        this.flush(()=>{
            this._readableState.endEmitted = true;
            this.emit("end");
            if (cb) cb();
        });
    }
    close() {
        this.emit("close");
    }
    pause() {
        return this;
    }
    resume() {
        return this;
    }
}
function createDeflateStream(options) {
    return new ZlibStream((input, opts)=>deflateRaw_1(input, opts), normalizeOptions(options));
}
function createInflateStream(options) {
    return new ZlibStream((input, opts)=>inflateRaw_1(input, opts), normalizeOptions(options));
}
function createGzipStream(options) {
    return new ZlibStream((input)=>gzip_1(input, normalizeOptions(options)), normalizeOptions(options));
}
function createGunzipStream(options) {
    return new ZlibStream((input)=>ungzip_1(input, normalizeOptions(options)), normalizeOptions(options));
}
function createBrotliCompress(options) {
    const { quality } = normalizeBrotliOptions(options);
    return new ZlibStream((input)=>{
        const args = quality !== undefined ? {
            quality
        } : undefined;
        return brotliCompressRaw(input, args);
    });
}
function createBrotliDecompress(options) {
    normalizeBrotliOptions(options);
    return new ZlibStream((input)=>brotliDecompressRaw(input));
}
function gzip1(data, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    const opts = typeof options === "function" ? undefined : options;
    const source = toBufferSource(data);
    const promise = Promise.resolve().then(()=>op_zlib_gzip2(source, opts));
    if (cb) {
        promise.then((result)=>cb(null, BufferImpl.from(result))).catch((error)=>cb(error));
        return;
    }
    return promise.then((result)=>BufferImpl.from(result));
}
function gzipSync(data, options) {
    const result = op_zlib_gzip2(toBufferSource(data), options);
    return BufferImpl.from(result);
}
function brotliCompress(data, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    const opts = typeof options === "function" ? undefined : options;
    const promise = Promise.resolve().then(()=>brotliCompressSync(data, opts));
    if (cb) {
        promise.then((result)=>cb(null, result)).catch((error)=>cb(error));
        return;
    }
    return promise;
}
function brotliCompressSync(data, options) {
    const { quality } = normalizeBrotliOptions(options);
    const args = quality !== undefined ? {
        quality
    } : undefined;
    const result = brotliCompressRaw(toBufferSource(data), args);
    return BufferImpl.from(result);
}
function brotliDecompress(data, options, callback) {
    const cb = typeof options === "function" ? options : callback;
    const opts = typeof options === "function" ? undefined : options;
    const promise = Promise.resolve().then(()=>brotliDecompressSync(data, opts));
    if (cb) {
        promise.then((result)=>cb(null, result)).catch((error)=>cb(error));
        return;
    }
    return promise;
}
function brotliDecompressSync(data, options) {
    normalizeBrotliOptions(options);
    const result = brotliDecompressRaw(toBufferSource(data));
    return BufferImpl.from(result);
}
const constants5 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4865,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
function createGzip(options) {
    return createGzipStream(options);
}
function createGunzip(options) {
    return createGunzipStream(options);
}
globalThis.__dekaNodeZlib = {
    gzip: gzip1,
    gzipSync,
    createGzip,
    createGunzip,
    brotliCompress,
    brotliCompressSync,
    brotliDecompress,
    brotliDecompressSync,
    createBrotliCompress,
    createBrotliDecompress,
    createDeflateRaw: createDeflateStream,
    createInflateRaw: createInflateStream,
    ZlibStream,
    constants: constants5
};
'use strict';
const WebSocket = require('./lib/websocket');
WebSocket.createWebSocketStream = require('./lib/stream');
WebSocket.Server = require('./lib/websocket-server');
WebSocket.Receiver = require('./lib/receiver');
WebSocket.Sender = require('./lib/sender');
WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;
module.exports = WebSocket;
globalThis.__dekaWs = __default;
class ChildProcess extends EventEmitter {
    pid;
    stdout;
    stderr;
    stdin;
    ready;
    pendingWrites = [];
    pendingKill = false;
    pendingClose = false;
    constructor(pidPromise){
        super();
        this.pid = null;
        this.stdout = new Readable();
        this.stderr = new Readable();
        this.stdout.unref = ()=>{};
        this.stdout.ref = ()=>{};
        this.stderr.unref = ()=>{};
        this.stderr.ref = ()=>{};
        const stdinEmitter = new EventEmitter();
        stdinEmitter.write = (data, cb)=>{
            const bytes = typeof data === "string" ? new TextEncoder().encode(data) : data;
            if (this.pid === null) {
                this.pendingWrites.push(bytes);
                if (cb) cb(null);
                return;
            }
            op_process_write_stdin2(this.pid, bytes);
            if (cb) cb(null);
        };
        stdinEmitter.destroy = ()=>{
            if (this.pid !== null) {
                op_process_close_stdin2(this.pid);
            } else {
                this.pendingClose = true;
            }
            stdinEmitter.emit("close");
        };
        stdinEmitter.end = (data, cb)=>{
            if (data !== undefined) {
                stdinEmitter.write(data, cb);
            }
            if (this.pid !== null) {
                op_process_close_stdin2(this.pid);
            } else {
                this.pendingClose = true;
            }
        };
        stdinEmitter.unref = ()=>{};
        stdinEmitter.ref = ()=>{};
        this.stdin = stdinEmitter;
        this.ready = Promise.resolve(-1);
        if (pidPromise) {
            this.attachPid(pidPromise);
        }
    }
    attachPid(pidPromise) {
        this.ready = pidPromise.then((pid)=>{
            if (pid <= 0) return pid;
            this.pid = pid;
            this.attachReaders();
            for (const queued of this.pendingWrites){
                op_process_write_stdin2(pid, queued);
            }
            this.pendingWrites = [];
            if (this.pendingClose) {
                op_process_close_stdin2(pid);
            }
            if (this.pendingKill) {
                op_process_kill2(pid);
            }
            return pid;
        });
    }
    kill() {
        if (this.pid === null) {
            this.pendingKill = true;
            return;
        }
        op_process_kill2(this.pid);
    }
    attachReaders() {
        if (this.pid === null) return;
        const debugReads = !!(globalThis.process?.env?.DEKA_CHILD_DEBUG || globalThis.process?.env?.DEKA_VERBOSE);
        const readLoop = async (op, emitter, event)=>{
            const pushable = typeof emitter.push === "function";
            if (debugReads) {
                console.log(`[child_process] readLoop start pid=${this.pid} event=${event}`);
            }
            while(true){
                const chunk = await op(this.pid, 65536);
                if (debugReads) {
                    const size = chunk?.data ? chunk.data.length : 0;
                    let preview = "";
                    if (chunk?.data && chunk.data.length > 0) {
                        const max = Math.min(chunk.data.length, 256);
                        let bytes;
                        if (chunk.data instanceof Uint8Array) {
                            bytes = chunk.data;
                        } else if (chunk.data instanceof ArrayBuffer) {
                            bytes = new Uint8Array(chunk.data);
                        } else if (Array.isArray(chunk.data)) {
                            bytes = Uint8Array.from(chunk.data);
                        } else {
                            bytes = new Uint8Array([]);
                        }
                        const slice = bytes.subarray(0, max);
                        try {
                            preview = new TextDecoder().decode(slice);
                        } catch  {
                            preview = "";
                        }
                        const safe = preview.replace(/[\x00-\x08\x0B-\x1F\x7F]/g, ".");
                        preview = safe;
                    }
                    console.log(`[child_process] readLoop pid=${this.pid} event=${event} eof=${chunk.eof} size=${size} preview="${preview}"`);
                }
                if (chunk.eof || !chunk.data || chunk.data.length === 0) {
                    if (pushable) {
                        emitter.push(null);
                    } else {
                        emitter.emit("end");
                    }
                    break;
                }
                const buffer = typeof Buffer !== "undefined" ? Buffer.from(chunk.data) : chunk.data;
                if (pushable) {
                    emitter.push(buffer);
                } else {
                    emitter.emit(event, buffer);
                }
            }
        };
        readLoop(op_process_read_stdout2, this.stdout, "data");
        readLoop(op_process_read_stderr2, this.stderr, "data");
        (async ()=>{
            const code = await op_process_wait2(this.pid);
            this.emit("exit", code);
            this.emit("close", code);
        })();
    }
    ref() {}
    unref() {}
}
function spawn(command, args = [], options) {
    const envPairs = buildEnvPairs(options);
    const { cmd, cmdArgs } = applyShebangOverride(command, args, options?.cwd);
    if (globalThis.process?.env?.DEKA_CHILD_DEBUG) {
        console.log(`[child_process] spawn ${cmd} ${cmdArgs.join(" ")}`);
    }
    const child = new ChildProcess();
    const pidPromise = op_process_spawn2(cmd, cmdArgs, options?.cwd, envPairs).then((pid)=>Number(pid)).catch((error)=>{
        queueMicrotask(()=>child.emit("error", error));
        return -1;
    });
    child.attachPid(pidPromise);
    return child;
}
function applyShebangOverride(command, args, cwd) {
    const env = globalThis.process?.env || {};
    const mode = env.DEKA_SHEBANG || "";
    if (!mode) {
        return {
            cmd: command,
            cmdArgs: args
        };
    }
    const fs = globalThis.__dekaNodeFs;
    const pathApi = globalThis.__dekaNodePath;
    if (!fs?.readFileSync || !fs?.existsSync) {
        return {
            cmd: command,
            cmdArgs: args
        };
    }
    const base = cwd || globalThis.process?.cwd?.() || env.PWD || "/";
    const full = command.startsWith("/") || !pathApi?.resolve ? command : pathApi.resolve(base, command);
    if (!full || !fs.existsSync(full)) {
        return {
            cmd: command,
            cmdArgs: args
        };
    }
    let firstLine = "";
    try {
        const content = fs.readFileSync(full, "utf8");
        firstLine = typeof content === "string" ? content.split("\n")[0] || "" : "";
    } catch  {
        return {
            cmd: command,
            cmdArgs: args
        };
    }
    if (!firstLine.startsWith("#!")) {
        return {
            cmd: command,
            cmdArgs: args
        };
    }
    const lower = firstLine.toLowerCase();
    if (!lower.includes("node") && !lower.includes("bun")) {
        return {
            cmd: command,
            cmdArgs: args
        };
    }
    if (mode !== "deka") {
        return {
            cmd: command,
            cmdArgs: args
        };
    }
    const execPath = globalThis.process?.execPath || globalThis.process?.argv0 || "deka-runtime";
    return {
        cmd: execPath,
        cmdArgs: [
            full,
            ...args
        ]
    };
}
function buildEnvPairs(options) {
    const env = {
        ...globalThis.process?.env || {},
        ...options?.env || {}
    };
    const pathApi = globalThis.__dekaNodePath;
    const fs = globalThis.__dekaNodeFs;
    const cwd = options?.cwd || globalThis.process?.cwd?.() || env.PWD || "/";
    const delimiter = pathApi?.delimiter || ":";
    const extraBins = [];
    if (fs?.existsSync) {
        let current = cwd;
        for(let i = 0; i < 40; i += 1){
            const bin = pathApi?.join ? pathApi.join(current, "node_modules", ".bin") : `${current}/node_modules/.bin`;
            if (!extraBins.includes(bin) && fs.existsSync(bin)) {
                extraBins.push(bin);
            }
            const parent = pathApi?.dirname ? pathApi.dirname(current) : "";
            if (!parent || parent === current) break;
            current = parent;
        }
    }
    if (extraBins.length > 0) {
        const currentPath = env.PATH || env.Path || "";
        env.PATH = [
            ...extraBins,
            currentPath
        ].filter(Boolean).join(delimiter);
    }
    return Object.entries(env);
}
function getEncoding(options) {
    if (!options) return null;
    if (options.encoding === "buffer") return null;
    return options.encoding ?? null;
}
function toBytes1(input, encoding) {
    if (input === undefined) return new Uint8Array();
    if (typeof input !== "string") return input;
    if (encoding && typeof Buffer !== "undefined") {
        return Buffer.from(input, encoding);
    }
    return new TextEncoder().encode(input);
}
function concatChunks(chunks) {
    const BufferImpl = globalThis.Buffer || Buffer;
    if (BufferImpl && typeof BufferImpl.concat === "function") {
        return BufferImpl.concat(chunks.map((chunk)=>BufferImpl.from(chunk)));
    }
    let total = 0;
    for (const chunk of chunks)total += chunk.length;
    const merged = new Uint8Array(total);
    let offset = 0;
    for (const chunk of chunks){
        merged.set(chunk, offset);
        offset += chunk.length;
    }
    return merged;
}
function decodeOutput(buffer, encoding) {
    if (!encoding) return buffer;
    if (typeof Buffer !== "undefined") {
        return Buffer.from(buffer).toString(encoding);
    }
    return new TextDecoder().decode(buffer);
}
function exec(command, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    return execFile("/bin/sh", [
        "-c",
        command
    ], options, callback);
}
function execFile(file, args, options, callback) {
    if (!Array.isArray(args)) {
        callback = options;
        options = args;
        args = [];
    }
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    const execOptions = options || {};
    const encoding = getEncoding(execOptions);
    const child = spawn(file, args, {
        cwd: execOptions.cwd,
        env: execOptions.env
    });
    const stdoutChunks = [];
    const stderrChunks = [];
    child.stdout.on("data", (chunk)=>{
        stdoutChunks.push(chunk);
    });
    child.stderr.on("data", (chunk)=>{
        stderrChunks.push(chunk);
    });
    child.on("error", (err)=>{
        if (callback) {
            callback(err);
        }
    });
    child.on("exit", (code)=>{
        if (!callback) return;
        const stdoutBuffer = concatChunks(stdoutChunks);
        const stderrBuffer = concatChunks(stderrChunks);
        const stdout = decodeOutput(stdoutBuffer, encoding);
        const stderr = decodeOutput(stderrBuffer, encoding);
        const error = code === 0 ? null : new Error(`Command failed with code ${code}`);
        callback(error, stdout, stderr);
    });
    return child;
}
function spawnSync(command, args, options) {
    if (!Array.isArray(args)) {
        options = args;
        args = [];
    }
    const spawnOptions = options || {};
    const encoding = getEncoding(spawnOptions);
    const envPairs = buildEnvPairs(spawnOptions);
    const input = toBytes1(spawnOptions.input, encoding);
    try {
        const result = op_process_spawn_sync2(command, args, spawnOptions.cwd, envPairs, input);
        const stdout = decodeOutput(result.stdout, encoding);
        const stderr = decodeOutput(result.stderr, encoding);
        return {
            pid: 0,
            output: [
                null,
                stdout,
                stderr
            ],
            stdout,
            stderr,
            status: result.status,
            signal: null,
            error: undefined
        };
    } catch (error) {
        return {
            pid: 0,
            output: [
                null,
                new Uint8Array(),
                new Uint8Array()
            ],
            stdout: new Uint8Array(),
            stderr: new Uint8Array(),
            status: null,
            signal: null,
            error: error
        };
    }
}
function execSync(command, options) {
    const result = spawnSync("/bin/sh", [
        "-c",
        command
    ], options);
    if (result.error) {
        throw result.error;
    }
    if (result.status !== 0) {
        const error = new Error(`Command failed with code ${result.status}`);
        error.stdout = result.stdout;
        error.stderr = result.stderr;
        throw error;
    }
    return result.stdout;
}
function execFileSync(file, args, options) {
    if (!Array.isArray(args)) {
        options = args;
        args = [];
    }
    const result = spawnSync(file, args, options);
    if (result.error) {
        throw result.error;
    }
    if (result.status !== 0) {
        const error = new Error(`Command failed with code ${result.status}`);
        error.stdout = result.stdout;
        error.stderr = result.stderr;
        throw error;
    }
    return result.stdout;
}
function fork(modulePath, args = [], options) {
    if (!Array.isArray(args)) {
        options = args;
        args = [];
    }
    const execPath = globalThis.process?.execPath || globalThis.process?.argv0 || "deka-runtime";
    const execArgs = options?.execArgv ? [
        ...options.execArgv
    ] : [];
    return spawn(execPath, [
        ...execArgs,
        modulePath,
        ...args
    ], {
        cwd: options?.cwd,
        env: options?.env
    });
}
globalThis.__dekaNodeChildProcess = {
    spawn,
    exec,
    execFile,
    execSync,
    execFileSync,
    spawnSync,
    fork,
    ChildProcess
};
class Worker {
    on() {
        return this;
    }
}
const isPrimary = true;
function fork1() {
    return new Worker();
}
globalThis.__dekaNodeCluster = {
    isPrimary,
    fork: fork1,
    Worker
};
globalThis.__dekaNodeSys = globalThis.__dekaNodeUtil || {};
function getHeapStatistics() {
    return {
        total_heap_size: 0,
        used_heap_size: 0
    };
}
globalThis.__dekaNodeV8 = {
    getHeapStatistics
};
const CONTEXT_SYMBOL1 = Symbol.for("deka.vm.context");
function ensureContext(value) {
    if (!value || typeof value !== "object") {
        return {};
    }
    return value;
}
function markContext(ctx) {
    Object.defineProperty(ctx, CONTEXT_SYMBOL1, {
        value: true,
        enumerable: false,
        configurable: false
    });
}
function createContext(sandbox) {
    const ctx = ensureContext(sandbox);
    markContext(ctx);
    return ctx;
}
function isContext(value) {
    return Boolean(value && typeof value === "object" && value[CONTEXT_SYMBOL1]);
}
function runInContext(code, context) {
    const ctx = ensureContext(context);
    return new Function("context", "code", "with (context) { return eval(code); }")(ctx, code);
}
function runInNewContext(code, sandbox) {
    const ctx = createContext(sandbox);
    return runInContext(code, ctx);
}
function runInThisContext(code) {
    return (0, eval)(code);
}
class Script {
    code;
    constructor(code){
        this.code = String(code);
    }
    runInContext(context) {
        return runInContext(this.code, context);
    }
    runInThisContext() {
        return runInThisContext(this.code);
    }
}
function compileFunction(code, params) {
    if (Array.isArray(params)) {
        return new Function(...params, code);
    }
    return new Function(code);
}
globalThis.__dekaNodeVm = {
    Script,
    createContext,
    isContext,
    runInContext,
    runInNewContext,
    runInThisContext,
    compileFunction
};
class WASI {
    constructor(_options){}
    start() {}
}
globalThis.__dekaNodeWasi = {
    WASI
};
const encoder = new TextEncoder();
const decoder = new TextDecoder();
let nextThreadId = 1;
function mergeBuffers(a, b) {
    const out = new Uint8Array(a.length + b.length);
    out.set(a, 0);
    out.set(b, a.length);
    return out;
}
function encodeFrame(value) {
    const payload = JSON.stringify(value ?? null);
    const data = encoder.encode(payload);
    const frame = new Uint8Array(4 + data.length);
    const view = new DataView(frame.buffer);
    view.setUint32(0, data.length);
    frame.set(data, 4);
    return frame;
}
class FrameDecoder {
    buffer = new Uint8Array(0);
    onMessage;
    constructor(onMessage){
        this.onMessage = onMessage;
    }
    push(chunk) {
        this.buffer = mergeBuffers(this.buffer, chunk);
        while(this.buffer.length >= 4){
            const view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
            const length = view.getUint32(0);
            if (this.buffer.length < 4 + length) {
                return;
            }
            const payload = this.buffer.subarray(4, 4 + length);
            const text = decoder.decode(payload);
            try {
                const value = JSON.parse(text);
                this.onMessage(value);
            } catch  {}
            this.buffer = this.buffer.subarray(4 + length);
        }
    }
}
class MessagePort1 extends EventEmitter {
    socket;
    decoder;
    queue = [];
    constructor(socket){
        super();
        this.socket = socket;
        this.decoder = new FrameDecoder((value)=>this.enqueueMessage(value));
        socket.on("data", (chunk)=>{
            this.decoder.push(chunk);
        });
        socket.on("close", ()=>{
            this.emit("close");
        });
        socket.on("error", (err)=>{
            this.emit("error", err);
        });
    }
    enqueueMessage(value) {
        if (this.listenerCount("message") === 0) {
            this.queue.push(value);
            return;
        }
        this.emit("message", value);
        const handler = this.onmessage;
        if (handler) handler(value);
    }
    postMessage(value) {
        const frame = encodeFrame(value);
        this.socket.write(frame);
    }
    close() {
        this.socket.end();
    }
    start() {
        if (this.queue.length > 0) {
            const queued = [
                ...this.queue
            ];
            this.queue = [];
            for (const value of queued){
                this.emit("message", value);
                const handler = this.onmessage;
                if (handler) handler(value);
            }
        }
    }
    ref() {}
    unref() {}
}
class Worker1 extends EventEmitter {
    threadId;
    stdout = null;
    stderr = null;
    childProcess = null;
    socket;
    pendingMessages = [];
    ready;
    constructor(path, options){
        super();
        this.threadId = nextThreadId++;
        const resolved = normalizeWorkerPath(path);
        const baseEnv = {
            ...globalThis.process?.env || {},
            ...options?.env || {},
            DEKA_WORKER: "1",
            DEKA_WORKER_THREADS: "1",
            DEKA_WORKER_ENTRY: resolved,
            DEKA_WORKER_DATA: safeStringify(options?.workerData),
            DEKA_WORKER_THREAD_ID: String(this.threadId)
        };
        const decoder = new FrameDecoder((value)=>this.emit("message", value));
        const server = createServer3((socket)=>{
            this.socket = socket;
            this.emit("online");
            for (const value of this.pendingMessages){
                this.sendMessage(value);
            }
            this.pendingMessages = [];
            socket.on("data", (chunk)=>{
                decoder.push(chunk);
            });
        });
        this.ready = new Promise((resolve, reject)=>{
            server.on("listening", ()=>{
                const address = server.address();
                const env = {
                    ...baseEnv,
                    DEKA_WORKER_PORT: String(address.port),
                    DEKA_WORKER_HOST: address.address
                };
                const bootstrapPath = ensureBootstrapFile();
                const execPath = globalThis.process?.execPath || globalThis.process?.argv0 || "deka-runtime";
                const child = spawn(execPath, [
                    "run",
                    bootstrapPath
                ], {
                    env
                });
                this.childProcess = child;
                if (options?.stdout) this.stdout = child.stdout;
                if (options?.stderr) this.stderr = child.stderr;
                child.on("exit", (code)=>{
                    server.close();
                    this.emit("exit", code);
                });
                child.on("error", (err)=>{
                    server.close();
                    this.emit("error", err);
                });
                resolve();
            });
            server.on("error", (err)=>{
                this.emit("error", err);
                reject(err);
            });
        });
        server.listen(0, "127.0.0.1");
    }
    postMessage(value) {
        if (!this.socket) {
            this.pendingMessages.push(value);
            return;
        }
        this.sendMessage(value);
    }
    sendMessage(value) {
        if (!this.socket) return;
        const frame = encodeFrame(value);
        this.socket.write(frame);
    }
    terminate() {
        if (this.childProcess) {
            this.childProcess.kill();
        }
        return this.ready.then(()=>new Promise((resolve)=>{
                if (!this.childProcess || this.childProcess.pid === null) {
                    resolve(0);
                    return;
                }
                this.childProcess.on("exit", (code)=>resolve(code));
            }));
    }
    ref() {}
    unref() {}
}
function normalizeWorkerPath(path) {
    if (typeof path === "object" && path !== null && "href" in path) {
        const href = path.href;
        if (href.startsWith("file://")) {
            return href.replace(/^file:\/\//, "");
        }
        return href;
    }
    if (typeof path !== "string") {
        return String(path);
    }
    if (path.startsWith("file://")) {
        return path.replace(/^file:\/\//, "");
    }
    if (path.startsWith("/")) {
        return path;
    }
    const pathApi = globalThis.__dekaNodePath;
    const cwd = globalThis.process?.cwd?.() || globalThis.process?.env?.PWD || "/";
    return pathApi?.resolve ? pathApi.resolve(cwd, path) : path;
}
function safeStringify(value) {
    try {
        return JSON.stringify(value ?? null);
    } catch  {
        throw new Error("workerData must be JSON-serializable");
    }
}
function ensureBootstrapFile() {
    const fs = globalThis.__dekaNodeFs;
    const pathApi = globalThis.__dekaNodePath;
    const os = globalThis.__dekaNodeOs;
    const base = os?.tmpdir?.() || "/tmp";
    const filePath = pathApi?.join ? pathApi.join(base, "deka-worker-bootstrap.js") : `${base}/deka-worker-bootstrap.js`;
    if (fs?.existsSync && fs.existsSync(filePath)) {
        return filePath;
    }
    if (!fs?.writeFileSync) {
        throw new Error("worker_threads requires fs write access for bootstrap");
    }
    fs.writeFileSync(filePath, WORKER_BOOTSTRAP_SOURCE);
    return filePath;
}
const WORKER_BOOTSTRAP_SOURCE = `import { createConnection } from "node:net";
const host = (globalThis.process && globalThis.process.env && globalThis.process.env.DEKA_WORKER_HOST) || "127.0.0.1";
const port = Number((globalThis.process && globalThis.process.env && globalThis.process.env.DEKA_WORKER_PORT) || 0);
const entry = (globalThis.process && globalThis.process.env && globalThis.process.env.DEKA_WORKER_ENTRY) || "";
const rawData = (globalThis.process && globalThis.process.env && globalThis.process.env.DEKA_WORKER_DATA) || "null";
const threadId = Number((globalThis.process && globalThis.process.env && globalThis.process.env.DEKA_WORKER_THREAD_ID) || 0);
let workerData = null;
try { workerData = JSON.parse(rawData); } catch {}
const socket = createConnection(port, host);
globalThis.__dekaWorkerSocket = socket;
globalThis.__dekaWorkerData = workerData;
globalThis.__dekaWorkerThreadId = threadId;
if (!globalThis.__dekaLoadModuleAsync) {
  throw new Error("Module loader not installed");
}
globalThis.__dekaLoadModuleAsync(entry).catch((err) => {
  const message = err && (err.stack || err.message) ? (err.stack || err.message) : String(err);
  console.error(message);
});
`;
const isWorker = globalThis.process?.env?.DEKA_WORKER === "1";
const isMainThread = !isWorker;
const parentPort = isWorker && globalThis.__dekaWorkerSocket ? new MessagePort1(globalThis.__dekaWorkerSocket) : null;
const workerData = isWorker ? globalThis.__dekaWorkerData ?? null : null;
const threadId = isWorker ? Number(globalThis.__dekaWorkerThreadId || 0) : 0;
globalThis.__dekaNodeWorkerThreads = {
    Worker: Worker1,
    isMainThread,
    parentPort,
    workerData,
    threadId
};
class REPLServer {
    close() {}
}
function start() {
    return new REPLServer();
}
globalThis.__dekaNodeRepl = {
    start,
    REPLServer
};
function resolveWasmPath() {
    const env = globalThis.process?.env || {};
    const cwd = globalThis.process?.cwd?.() || env.PWD || env.INIT_CWD || "/";
    const candidates = [
        `${cwd}/node_modules/esbuild-wasm/esbuild.wasm`,
        `${cwd}/node_modules/esbuild-wasm/esm/esbuild.wasm`
    ];
    const fs = globalThis.__dekaNodeFs;
    for (const candidate of candidates){
        try {
            if (fs?.existsSync(candidate)) {
                return candidate;
            }
        } catch  {}
    }
    return null;
}
function resolveBrowserPath() {
    const env = globalThis.process?.env || {};
    const cwd = globalThis.process?.cwd?.() || env.PWD || env.INIT_CWD || "/";
    const candidates = [
        `${cwd}/node_modules/esbuild-wasm/esm/browser.js`,
        `${cwd}/node_modules/esbuild-wasm/esm/browser.min.js`
    ];
    const fs = globalThis.__dekaNodeFs;
    for (const candidate of candidates){
        try {
            if (fs?.existsSync(candidate)) {
                return candidate;
            }
        } catch  {}
    }
    return null;
}
function debugLog(message) {
    if (!globalThis.process?.env?.DEKA_ESBUILD_DEBUG) return;
    console.log(message);
}
function ensureGoRuntimeGlobals() {
    if (typeof globalThis.fs === "undefined") {
        globalThis.fs = globalThis.__dekaNodeFs;
    }
    if (typeof globalThis.TextEncoder === "undefined") {
        globalThis.TextEncoder = TextEncoder;
    }
    if (typeof globalThis.TextDecoder === "undefined") {
        globalThis.TextDecoder = TextDecoder;
    }
}
function createGoFsStub() {
    const enosys = ()=>{
        const err = new Error("not implemented");
        err.code = "ENOSYS";
        return err;
    };
    let outputBuf = "";
    const decoder = new TextDecoder();
    return {
        constants: {
            O_WRONLY: -1,
            O_RDWR: -1,
            O_CREAT: -1,
            O_TRUNC: -1,
            O_APPEND: -1,
            O_EXCL: -1,
            O_DIRECTORY: -1
        },
        writeSync (_fd, buf) {
            outputBuf += decoder.decode(buf);
            const nl = outputBuf.lastIndexOf("\n");
            if (nl !== -1) {
                console.log(outputBuf.substring(0, nl));
                outputBuf = outputBuf.substring(nl + 1);
            }
            return buf.length;
        },
        write (fd, buf, _offset, _length, _position, callback) {
            try {
                const n = this.writeSync(fd, buf);
                callback(null, n);
            } catch (err) {
                callback(err);
            }
        },
        chmod (_path, _mode, callback) {
            callback(enosys());
        },
        chown (_path, _uid, _gid, callback) {
            callback(enosys());
        },
        close (_fd, callback) {
            callback(enosys());
        },
        fchmod (_fd, _mode, callback) {
            callback(enosys());
        },
        fchown (_fd, _uid, _gid, callback) {
            callback(enosys());
        },
        fstat (_fd, callback) {
            callback(enosys());
        },
        fsync (_fd, callback) {
            callback(null);
        },
        ftruncate (_fd, _length, callback) {
            callback(enosys());
        },
        lchown (_path, _uid, _gid, callback) {
            callback(enosys());
        },
        link (_path, _link, callback) {
            callback(enosys());
        },
        lstat (_path, callback) {
            callback(enosys());
        },
        mkdir (_path, _perm, callback) {
            callback(enosys());
        },
        open (_path, _flags, _mode, callback) {
            callback(enosys());
        },
        read (_fd, _buffer, _offset, _length, _position, callback) {
            callback(enosys());
        },
        readdir (_path, callback) {
            callback(enosys());
        },
        readlink (_path, callback) {
            callback(enosys());
        },
        rename (_from, _to, callback) {
            callback(enosys());
        },
        rmdir (_path, callback) {
            callback(enosys());
        },
        stat (_path, callback) {
            callback(enosys());
        },
        symlink (_path, _link, callback) {
            callback(enosys());
        },
        truncate (_path, _length, callback) {
            callback(enosys());
        },
        unlink (_path, callback) {
            callback(enosys());
        },
        utimes (_path, _atime, _mtime, callback) {
            callback(enosys());
        }
    };
}
async function loadEsbuild() {
    const cwd = globalThis.process?.cwd?.() || "/";
    debugLog(`[esbuild] require esbuild-wasm from ${cwd}`);
    const browserPath = resolveBrowserPath();
    if (!browserPath) {
        throw new Error("Unable to locate esbuild-wasm/esm/browser.js");
    }
    if (typeof globalThis.__dekaLoadModuleAsync === "function") {
        ensureGoRuntimeGlobals();
        const prevFs = globalThis.fs;
        globalThis.fs = prevFs || createGoFsStub();
        const mod = await globalThis.__dekaLoadModuleAsync(browserPath);
        if (prevFs !== undefined) {
            globalThis.fs = prevFs;
        }
        debugLog(`[esbuild] exports ${Object.keys(mod || {}).join(",")}`);
        debugLog(`[esbuild] default.transform ${typeof mod?.default?.transform} mod.transform ${typeof mod?.transform}`);
        return mod?.default || mod;
    }
    throw new Error("esbuild shim requires __dekaLoadModuleAsync");
}
let esbuildImpl = null;
let initPromise = null;
async function ensureInitialized() {
    if (initPromise) return initPromise;
    initPromise = (async ()=>{
        if (!esbuildImpl) esbuildImpl = await loadEsbuild();
        debugLog(`[esbuild] impl transform ${typeof esbuildImpl?.transform}`);
        debugLog(`[esbuild] impl keys ${Object.keys(esbuildImpl || {}).join(",")}`);
        if (esbuildImpl.initialize) {
            debugLog(`[esbuild] fs constants ${typeof globalThis.fs?.constants}`);
            const wasmPath = resolveWasmPath();
            if (!wasmPath) {
                throw new Error("Unable to locate esbuild-wasm/esbuild.wasm");
            }
            debugLog(`[esbuild] init ${wasmPath}`);
            const fs = globalThis.__dekaNodeFs;
            const bytes = fs.readFileSync(wasmPath);
            const wasmModule = new WebAssembly.Module(bytes);
            const prevFs = globalThis.fs;
            globalThis.fs = createGoFsStub();
            await esbuildImpl.initialize({
                wasmModule,
                worker: false
            });
            if (prevFs !== undefined) {
                globalThis.fs = prevFs;
            }
            debugLog("[esbuild] ready");
        }
    })();
    return initPromise;
}
async function build(options) {
    await ensureInitialized();
    return esbuildImpl.build(options);
}
async function transform(input, options) {
    await ensureInitialized();
    return esbuildImpl.transform(input, options);
}
async function formatMessages(messages, options) {
    await ensureInitialized();
    return esbuildImpl.formatMessages(messages, options);
}
async function analyzeMetafile(metafile, options) {
    await ensureInitialized();
    return esbuildImpl.analyzeMetafile(metafile, options);
}
async function context(options) {
    await ensureInitialized();
    return esbuildImpl.context(options);
}
async function initialize(options) {
    if (!esbuildImpl) esbuildImpl = await loadEsbuild();
    return esbuildImpl.initialize(options);
}
function buildSync(_options) {
    throw new Error("esbuild-wasm does not support buildSync in deka");
}
function transformSync(_input, _options) {
    throw new Error("esbuild-wasm does not support transformSync in deka");
}
function formatMessagesSync(_messages, _options) {
    throw new Error("esbuild-wasm does not support formatMessagesSync in deka");
}
function analyzeMetafileSync(_metafile, _options) {
    throw new Error("esbuild-wasm does not support analyzeMetafileSync in deka");
}
function stop() {
    if (esbuildImpl?.stop) {
        esbuildImpl.stop();
    }
}
const esbuildShim = {
    build,
    transform,
    formatMessages,
    analyzeMetafile,
    context,
    initialize,
    buildSync,
    transformSync,
    formatMessagesSync,
    analyzeMetafileSync,
    stop,
    get version () {
        return esbuildImpl?.version || "0.27.2";
    }
};
globalThis.__dekaEsbuild = esbuildShim;
const constants6 = {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4,
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18,
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20,
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    EXTENSIONLESS_FORMAT_JAVASCRIPT: 0,
    EXTENSIONLESS_FORMAT_WASM: 1,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4,
    OPENSSL_VERSION_NUMBER: 805306608,
    SSL_OP_ALL: 2147485776,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    RSA_PKCS1_PADDING: 1,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
globalThis.__dekaNodeConstants = constants6;
function detach(stream, event, listener) {
    if (!stream) return;
    if (typeof stream.off === "function") {
        stream.off(event, listener);
        return;
    }
    if (typeof stream.removeListener === "function") {
        stream.removeListener(event, listener);
    }
}
function finished(stream) {
    return new Promise((resolve, reject)=>{
        if (!stream) {
            resolve();
            return;
        }
        const onFinish = ()=>cleanup(resolve);
        const onError = (error)=>cleanup(()=>reject(error));
        const cleanup = (callback)=>{
            detach(stream, "finish", onFinish);
            detach(stream, "end", onFinish);
            detach(stream, "close", onFinish);
            detach(stream, "error", onError);
            callback();
        };
        stream.on("finish", onFinish);
        stream.on("end", onFinish);
        stream.on("close", onFinish);
        stream.on("error", onError);
    });
}
function pipeline(...streams) {
    return new Promise((resolve, reject)=>{
        if (streams.length === 0) {
            resolve();
            return;
        }
        const last = streams.at(-1);
        const onError = (err)=>cleanup(()=>reject(err));
        const cleanup = (callback)=>{
            for (const stream of streams){
                stream.off("error", onError);
            }
            callback();
        };
        for (const stream of streams){
            stream.on("error", onError);
        }
        for(let i = 0; i < streams.length - 1; i += 1){
            const current = streams[i];
            const next = streams[i + 1];
            if (current.pipe && next) {
                current.pipe(next);
            }
        }
        if (last) {
            finished(last).then(()=>cleanup(resolve)).catch((error)=>cleanup(()=>reject(error)));
        } else {
            cleanup(resolve);
        }
    });
}
const streamPromises = {
    finished,
    pipeline
};
globalThis.__dekaNodeStreamPromises = streamPromises;
function setTimeoutPromise(delay, value) {
    return new Promise((resolve)=>{
        const timeout = typeof delay === "number" ? delay : 0;
        setTimeout(()=>resolve(value), timeout);
    });
}
function setImmediatePromise(value) {
    return new Promise((resolve)=>{
        if (typeof setImmediate === "function") {
            setImmediate(()=>resolve(value));
            return;
        }
        setTimeout(()=>resolve(value), 0);
    });
}
async function* setIntervalPromise(delay, value) {
    const interval = typeof delay === "number" ? delay : 0;
    while(true){
        await setTimeoutPromise(interval);
        yield value;
    }
}
const timersPromises = {
    setTimeout: setTimeoutPromise,
    setImmediate: setImmediatePromise,
    setInterval: setIntervalPromise
};
globalThis.__dekaNodeTimersPromises = timersPromises;
const Fragment = Symbol.for("deka.jsx.fragment");
function jsx(type, props, key) {
    return {
        type,
        props: props || {},
        key: key ?? null
    };
}
function jsxs(type, props, key) {
    return jsx(type, props, key);
}
function jsxDEV(type, props, key) {
    return jsx(type, props, key);
}
function createElement(type, props, ...children) {
    const normalized = props ? {
        ...props
    } : {};
    if (children.length > 0) {
        normalized.children = children.length === 1 ? children[0] : children;
    }
    return {
        type,
        props: normalized,
        key: normalized.key ?? null
    };
}
function installJsxRuntime() {
    globalThis.__dekaJsxRuntime = {
        jsx,
        jsxs,
        Fragment,
        createElement
    };
    globalThis.__dekaJsxDevRuntime = {
        jsxDEV,
        Fragment
    };
}
function normalizeArgs(args) {
    const flattened = [];
    for (const arg of args){
        if (Array.isArray(arg)) {
            flattened.push(...arg);
        } else {
            flattened.push(arg);
        }
    }
    return flattened;
}
class RedisClient {
    url;
    id;
    constructor(url){
        this.url = url;
    }
    async connect() {
        if (!this.id) {
            this.id = await op_redis_connect(this.url ?? null);
        }
    }
    async close() {
        if (this.id) {
            await op_redis_close(this.id);
            this.id = undefined;
        }
    }
    async call(command, args = []) {
        await this.connect();
        const id = this.id;
        return op_redis_call(id, command, normalizeArgs(args));
    }
    async get(key) {
        return this.call("GET", [
            key
        ]);
    }
    async getBuffer(key) {
        await this.connect();
        const id = this.id;
        const data = await op_redis_get_buffer(id, key);
        return new Uint8Array(data);
    }
    async set(key, value) {
        return this.call("SET", [
            key,
            value
        ]);
    }
    async del(...keys) {
        return this.call("DEL", keys);
    }
    async exists(key) {
        return this.call("EXISTS", [
            key
        ]);
    }
    async incr(key) {
        return this.call("INCR", [
            key
        ]);
    }
    async decr(key) {
        return this.call("DECR", [
            key
        ]);
    }
    async expire(key, seconds) {
        return this.call("EXPIRE", [
            key,
            seconds
        ]);
    }
    async ttl(key) {
        return this.call("TTL", [
            key
        ]);
    }
    async hmset(key, values) {
        const args = Array.isArray(values) ? values : Object.entries(values).flatMap(([field, value])=>[
                field,
                value
            ]);
        return this.call("HMSET", [
            key,
            ...args
        ]);
    }
    async hmget(key, fields) {
        return this.call("HMGET", [
            key,
            fields
        ]);
    }
    async hget(key, field) {
        return this.call("HGET", [
            key,
            field
        ]);
    }
    async hincrby(key, field, value) {
        return this.call("HINCRBY", [
            key,
            field,
            value
        ]);
    }
    async hincrbyfloat(key, field, value) {
        return this.call("HINCRBYFLOAT", [
            key,
            field,
            value
        ]);
    }
    async sadd(key, value) {
        return this.call("SADD", [
            key,
            value
        ]);
    }
    async srem(key, value) {
        return this.call("SREM", [
            key,
            value
        ]);
    }
    async sismember(key, value) {
        return this.call("SISMEMBER", [
            key,
            value
        ]);
    }
    async smembers(key) {
        return this.call("SMEMBERS", [
            key
        ]);
    }
    async srandmember(key) {
        return this.call("SRANDMEMBER", [
            key
        ]);
    }
    async spop(key) {
        return this.call("SPOP", [
            key
        ]);
    }
}
const redis = new RedisClient();
function installRedis() {
    globalThis.__dekaRedis = {
        redis,
        RedisClient
    };
}
function resolveModulePath1(referrer, specifier) {
    if (specifier.startsWith("/") || specifier.startsWith("http")) {
        return specifier;
    }
    if (!referrer || !specifier.startsWith(".")) {
        return specifier;
    }
    const base = referrer.split("/").slice(0, -1);
    const parts = specifier.split("/");
    const combined = [
        ...base,
        ...parts
    ];
    const resolved = [];
    for (const part of combined){
        if (!part || part === ".") continue;
        if (part === "..") {
            resolved.pop();
            continue;
        }
        resolved.push(part);
    }
    return `/${resolved.join("/")}`;
}
function normalizePath2(path) {
    const parts = path.split("/");
    const stack = [];
    for (const part of parts){
        if (!part || part === ".") continue;
        if (part === "..") {
            stack.pop();
            continue;
        }
        stack.push(part);
    }
    return `/${stack.join("/")}`;
}
function dirname2(path) {
    const parts = path.split("/");
    parts.pop();
    const dir = parts.join("/");
    return dir || "/";
}
function resolvePathFrom1(baseDir, relativePath) {
    if (relativePath.startsWith("/")) return normalizePath2(relativePath);
    return normalizePath2(`${baseDir}/${relativePath}`);
}
function getCwd1() {
    return globalThis.process?.env?.PWD || globalThis.process?.env?.INIT_CWD || "/";
}
function splitNodePath1(value) {
    if (!value) return [];
    const delimiter = value.includes(";") ? ";" : ":";
    return value.split(delimiter).map((entry)=>entry.trim()).filter(Boolean);
}
function isBareSpecifier1(specifier) {
    return !!specifier && !specifier.startsWith(".") && !specifier.startsWith("/") && !specifier.startsWith("http") && !specifier.startsWith("#");
}
function isImportsSpecifier1(specifier) {
    return !!specifier && specifier.startsWith("#");
}
function hasExtension1(path) {
    return /\.[^/]+$/.test(path);
}
function extensionOf1(path) {
    const match = path.match(/(\.[^/.]+)$/);
    return match ? match[1].toLowerCase() : "";
}
function readModuleSource1(path) {
    return op_read_module_source2(path);
}
const TEXT_TYPES = {
    ".html": "text/html; charset=utf-8",
    ".css": "text/css; charset=utf-8",
    ".js": "application/javascript; charset=utf-8",
    ".mjs": "application/javascript; charset=utf-8",
    ".json": "application/json; charset=utf-8",
    ".map": "application/json; charset=utf-8",
    ".svg": "image/svg+xml; charset=utf-8",
    ".txt": "text/plain; charset=utf-8"
};
async function buildHtmlBundle(entryPath, assetsRoot) {
    const resolvedEntry = resolvePathFrom1(getCwd1(), entryPath);
    const source = readModuleSource1(resolvedEntry).source;
    const baseDir = dirname2(resolvedEntry);
    const scripts = extractScriptSources(source);
    const styles = extractStylesheetLinks(source);
    let html = source;
    const bundleAssets = new Map();
    const cssBundleParts = [];
    for (const script of scripts){
        const resolved = resolvePathFrom1(baseDir, script);
        const bundle = op_bundle_browser_assets2(resolved);
        const code = bundle.code;
        const hash = hashString(code);
        const assetName = `${fileStem(script)}-${hash}.js`;
        const assetPath = `${assetsRoot}/${assetName}`;
        bundleAssets.set(assetPath, {
            body: code,
            contentType: TEXT_TYPES[".js"]
        });
        if (bundle.css) {
            const handled = applyCssAssets({
                code: bundle.css,
                assets: bundle.assets
            }, assetsRoot, bundleAssets);
            cssBundleParts.push(handled);
        }
        html = html.replaceAll(script, assetPath);
    }
    if (styles.length > 0) {
        for (const style of styles){
            const resolved = resolvePathFrom1(baseDir, style);
            const cssSource = readModuleSource1(resolved).source;
            const bundleOptions = {
                css_modules: false,
                minify: true
            };
            if (requiresTailwind(cssSource)) {
                const contentPaths = [
                    resolvedEntry,
                    ...scripts.map((script)=>resolvePathFrom1(baseDir, script)),
                    `${baseDir}/**/*.{ts,tsx,js,jsx,html}`
                ];
                const tailwindCss = await op_tailwind_process2(cssSource, contentPaths, baseDir);
                const transformed = op_transform_css2(tailwindCss, resolved, bundleOptions);
                const handled = applyCssAssets(transformed, assetsRoot, bundleAssets);
                cssBundleParts.push(handled);
            } else {
                const bundled = op_bundle_css2(resolved, bundleOptions);
                const handled = applyCssAssets(bundled, assetsRoot, bundleAssets);
                cssBundleParts.push(handled);
            }
        }
    }
    const cssBundle = cssBundleParts.join("\n");
    if (cssBundle.trim().length > 0) {
        const hash = hashString(cssBundle);
        const assetName = `${fileStem(entryPath)}-${hash}.css`;
        const assetPath = `${assetsRoot}/${assetName}`;
        bundleAssets.set(assetPath, {
            body: cssBundle,
            contentType: TEXT_TYPES[".css"]
        });
        if (styles.length > 0) {
            for (const style of styles){
                html = html.replaceAll(style, assetPath);
            }
        } else {
            html = injectStylesheetLink(html, assetPath);
        }
    }
    return {
        html,
        assets: bundleAssets
    };
}
function extractScriptSources(html) {
    const sources = [];
    const regex = /<script\s+[^>]*src=["']([^"']+)["'][^>]*><\/script>/gi;
    let match;
    while(match = regex.exec(html)){
        const src = match[1];
        if (src && !src.startsWith("http") && !src.startsWith("//")) {
            sources.push(src);
        }
    }
    return sources;
}
function extractStylesheetLinks(html) {
    const sources = [];
    const regex = /<link\s+[^>]*rel=["']stylesheet["'][^>]*href=["']([^"']+)["'][^>]*>/gi;
    let match;
    while(match = regex.exec(html)){
        const href = match[1];
        if (href && !href.startsWith("http") && !href.startsWith("//")) {
            sources.push(href);
        }
    }
    return sources;
}
function fileStem(path) {
    const part = path.split("/").pop() || "index";
    const idx = part.lastIndexOf(".");
    return idx > 0 ? part.slice(0, idx) : part;
}
function hashString(value) {
    let hash = 5381;
    for(let i = 0; i < value.length; i += 1){
        hash = (hash << 5) + hash + value.charCodeAt(i) >>> 0;
    }
    return hash.toString(36);
}
function requiresTailwind(css) {
    return /@tailwind\s+(base|components|utilities)/.test(css) || /@apply\s+/.test(css) || /@import\s+["']tailwindcss(?:\/[^"']+)?["']/.test(css);
}
function injectStylesheetLink(html, href) {
    const link = `<link rel="stylesheet" href="${href}">`;
    if (html.includes("</head>")) {
        return html.replace("</head>", `  ${link}\n</head>`);
    }
    if (html.includes("</body>")) {
        return html.replace("</body>", `  ${link}\n</body>`);
    }
    return `${link}\n${html}`;
}
function applyCssAssets(result, assetsRoot, assets) {
    let css = result.code;
    const entries = result.assets || [];
    for (const asset of entries){
        const assetPath = `${assetsRoot}/${asset.file_name}`;
        css = css.replaceAll(asset.placeholder, assetPath);
        assets.set(assetPath, {
            body: decodeBase64(asset.body_base64),
            contentType: asset.content_type
        });
    }
    return css;
}
function decodeBase64(value) {
    if (typeof atob === "function") {
        const binary = atob(value);
        const bytes = new Uint8Array(binary.length);
        for(let i = 0; i < binary.length; i += 1){
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
    }
    return decodeBase64Manual(value);
}
function decodeBase64Manual(value) {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const clean = value.replace(/[^A-Za-z0-9+/=]/g, "");
    let buffer = 0;
    let bits = 0;
    const bytes = [];
    for(let i = 0; i < clean.length; i += 1){
        const __char = clean[i];
        if (__char === "=") break;
        const idx = alphabet.indexOf(__char);
        if (idx < 0) continue;
        buffer = buffer << 6 | idx;
        bits += 6;
        if (bits >= 8) {
            bits -= 8;
            bytes.push(buffer >> bits & 0xff);
        }
    }
    return new Uint8Array(bytes);
}
function wrapRead1(path) {
    return readModuleSource1(path);
}
function readPackageJson1(pkgRoot) {
    const info = wrapRead1(`${pkgRoot}/package.json`);
    return JSON.parse(info.source);
}
function parsePackageSpecifier1(specifier) {
    const parts = specifier.split("/");
    if (specifier.startsWith("@")) {
        return {
            name: parts.slice(0, 2).join("/"),
            subpath: parts.slice(2).join("/")
        };
    }
    return {
        name: parts[0],
        subpath: parts.slice(1).join("/")
    };
}
function resolveExportsTarget1(target, mode) {
    if (typeof target === "string") return target;
    if (Array.isArray(target)) {
        for (const entry of target){
            const resolved = resolveExportsTarget1(entry, mode);
            if (resolved) return resolved;
        }
        return null;
    }
    if (target && typeof target === "object") {
        const keys = [
            "bun",
            mode === "require" ? "require" : "import",
            "default"
        ];
        for (const key of keys){
            if (Object.prototype.hasOwnProperty.call(target, key)) {
                const resolved = resolveExportsTarget1(target[key], mode);
                if (resolved) return resolved;
            }
        }
    }
    return null;
}
function applyExportPattern1(pattern, subpath) {
    if (!pattern.includes("*")) return pattern;
    const [prefix, suffix] = pattern.split("*");
    if (!subpath.startsWith(prefix) || !subpath.endsWith(suffix)) return null;
    return subpath.slice(prefix.length, subpath.length - suffix.length);
}
function resolveExportsForSubpath1(exportsField, subpath, mode) {
    if (typeof exportsField === "string" || Array.isArray(exportsField)) {
        if (subpath !== ".") return null;
        return resolveExportsTarget1(exportsField, mode);
    }
    if (!exportsField || typeof exportsField !== "object") return null;
    const exportKeys = Object.keys(exportsField);
    const hasSubpathKeys = exportKeys.some((key)=>key.startsWith("."));
    if (!hasSubpathKeys) {
        if (subpath !== ".") return null;
        return resolveExportsTarget1(exportsField, mode);
    }
    const direct = exportsField[subpath];
    if (direct !== undefined) {
        return resolveExportsTarget1(direct, mode);
    }
    for (const key of exportKeys){
        if (!key.includes("*")) continue;
        const capture = applyExportPattern1(key, subpath);
        if (capture === null) continue;
        const target = resolveExportsTarget1(exportsField[key], mode);
        if (typeof target === "string") {
            return target.replace("*", capture);
        }
    }
    return null;
}
function resolvePackageEntry1(pkgRoot, pkgJson, mode, subpath) {
    if (subpath) {
        return resolvePathFrom1(pkgRoot, subpath);
    }
    if (mode === "import" && typeof pkgJson.module === "string") {
        return resolvePathFrom1(pkgRoot, pkgJson.module);
    }
    if (typeof pkgJson.main === "string") {
        return resolvePathFrom1(pkgRoot, pkgJson.main);
    }
    return resolvePathFrom1(pkgRoot, "index");
}
function resolvePackageSpecifier1(specifier, referrer, mode) {
    if (specifier.startsWith("@rollup/rollup-") && !globalThis.process?.env?.DEKA_ROLLUP_NATIVE) {
        specifier = "@rollup/wasm-node";
    }
    const { name, subpath } = parsePackageSpecifier1(specifier);
    const searchDirs = [];
    const nodePathEntries = splitNodePath1(globalThis.process?.env?.NODE_PATH);
    const cwd = getCwd1();
    for (const entry of nodePathEntries){
        const dir = entry.startsWith("/") ? entry : resolvePathFrom1(cwd, entry);
        searchDirs.push(dir);
    }
    const startDir = referrer ? dirname2(referrer) : cwd;
    let current = startDir;
    while(true){
        searchDirs.push(`${current}/node_modules`);
        if (current === "/") break;
        current = dirname2(current);
    }
    for (const base of searchDirs){
        const pkgRoot = `${base}/${name}`;
        let pkgJson;
        try {
            pkgJson = readPackageJson1(pkgRoot);
        } catch (error) {
            continue;
        }
        if (pkgJson.exports) {
            const subpathKey = subpath ? `./${subpath}` : ".";
            const target = resolveExportsForSubpath1(pkgJson.exports, subpathKey, mode);
            if (!target) {
                throw new Error(`Package subpath "${specifier}" is not exported by ${name}`);
            }
            return resolvePathFrom1(pkgRoot, target.replace(/^\.\//, ""));
        }
        return resolvePackageEntry1(pkgRoot, pkgJson, mode, subpath);
    }
    return null;
}
function resolveImportsSpecifier1(specifier, referrer, mode) {
    const startDir = referrer ? dirname2(referrer) : getCwd1();
    let current = startDir;
    while(true){
        let pkgJson;
        try {
            pkgJson = readPackageJson1(current);
        } catch (error) {}
        if (pkgJson?.imports) {
            const target = resolveExportsForSubpath1(pkgJson.imports, specifier, mode);
            if (target) {
                return resolvePathFrom1(current, target.replace(/^\.\//, ""));
            }
        }
        if (current === "/") break;
        current = dirname2(current);
    }
    return null;
}
function resolveWithExtensions1(path, context = {}) {
    let base = path;
    if (base.length > 1 && base.endsWith("/")) {
        base = base.slice(0, -1);
    }
    const attempts = [];
    try {
        return readModuleSource1(base);
    } catch (error) {
        attempts.push(base);
    }
    if (hasExtension1(base)) {
        const ext = extensionOf1(base);
        const candidates = [
            base
        ];
        if (ext === ".js") {
            candidates.push(base.slice(0, -3) + ".ts");
        } else if (ext === ".jsx") {
            candidates.push(base.slice(0, -4) + ".tsx");
        }
        for (const candidate of candidates){
            try {
                return readModuleSource1(candidate);
            } catch (error) {
                attempts.push(candidate);
            }
        }
        const spec = context.specifier || base;
        const ref = context.referrer ? ` from "${context.referrer}"` : "";
        throw new Error(`Unable to resolve module "${spec}"${ref}\nTried:\n- ${attempts.join("\n- ")}`);
    }
    const candidates = [
        ".tsx",
        ".jsx",
        ".ts",
        ".mjs",
        ".js",
        ".cjs",
        ".node",
        ".wasm",
        ".json",
        ".jsonc",
        ".toml",
        ".yaml",
        ".yml",
        ".txt",
        ".html",
        ".css"
    ];
    for (const ext of candidates){
        try {
            return readModuleSource1(`${base}${ext}`);
        } catch (error) {
            attempts.push(`${base}${ext}`);
        }
    }
    for (const ext of candidates){
        try {
            return readModuleSource1(`${base}/index${ext}`);
        } catch (error) {
            attempts.push(`${base}/index${ext}`);
        }
    }
    try {
        return readModuleSource1(base);
    } catch (error) {
        attempts.push(base);
    }
    const spec = context.specifier || base;
    const ref = context.referrer ? ` from "${context.referrer}"` : "";
    throw new Error(`Unable to resolve module "${spec}"${ref}\nTried:\n- ${attempts.join("\n- ")}`);
}
const moduleCache1 = new Map();
let mainModule1 = null;
let dekaImportInstalled1 = false;
const requireExtensions1 = Object.create(null);
requireExtensions1[".js"] = (mod, filename)=>{
    const info = readModuleSource1(filename);
    const source = stripShebang1(info.source);
    mod._compile(source, filename);
};
requireExtensions1[".cjs"] = requireExtensions1[".js"];
requireExtensions1[".json"] = (mod, filename)=>{
    const info = readModuleSource1(filename);
    mod.exports = JSON.parse(info.source);
};
requireExtensions1[".mjs"] = ()=>{
    throw new Error("Cannot require ES module");
};
requireExtensions1[".node"] = (mod, filename)=>{
    const createBuffer = globalThis.__dekaNapiCreateBuffer || ((data)=>Buffer.from(data));
    const reportError = globalThis.__dekaNapiReportError || ((error)=>{
        throw error;
    });
    mod.exports = op_napi_open2(filename, globalThis, createBuffer, reportError);
};
function waitForPromise1(promise) {
    const sab = new SharedArrayBuffer(4);
    const view = new Int32Array(sab);
    let done = false;
    let result;
    let error;
    promise.then((value)=>{
        result = value;
        done = true;
        Atomics.store(view, 0, 1);
        Atomics.notify(view, 0, 1);
    }, (err)=>{
        error = err;
        done = true;
        Atomics.store(view, 0, 1);
        Atomics.notify(view, 0, 1);
    });
    while(!done){
        Atomics.wait(view, 0, 0, 100);
    }
    if (error) {
        throw error;
    }
    return result;
}
function stripShebang1(source) {
    if (!source.startsWith("#!")) return source;
    const newline = source.indexOf("\n");
    if (newline === -1) return "";
    return `//${source.slice(2, newline)}\n${source.slice(newline + 1)}`;
}
function installDekaImport1() {
    if (dekaImportInstalled1) return;
    dekaImportInstalled1 = true;
    if (typeof globalThis.__dekaImportSync !== "function") {
        globalThis.__dekaImportSync = (specifier, referrer)=>{
            return loadModuleExportsInternal1(specifier, referrer || null, "import", false);
        };
    }
    if (typeof globalThis.__dekaImportAsync !== "function") {
        globalThis.__dekaImportAsync = (specifier, referrer)=>{
            return Promise.resolve(loadModuleExportsInternal1(specifier, referrer || null, "import", true));
        };
    }
    if (typeof globalThis.__dekaImport !== "function") {
        globalThis.__dekaImport = globalThis.__dekaImportSync;
    }
}
function findPackageType1(path) {
    let current = path;
    let stopAt = "/";
    const marker = "/node_modules/";
    const markerIndex = path.lastIndexOf(marker);
    if (markerIndex !== -1) {
        const after = path.slice(markerIndex + marker.length);
        const parts = after.split("/").filter(Boolean);
        if (parts.length > 0) {
            const pkgName = parts[0].startsWith("@") && parts.length > 1 ? `${parts[0]}/${parts[1]}` : parts[0];
            stopAt = path.slice(0, markerIndex + marker.length + pkgName.length);
        }
    }
    for(let i = 0; i < 100; i++){
        const parent = dirname2(current);
        if (!parent || parent === current) break;
        current = parent;
        try {
            const info = readModuleSource1(`${current}/package.json`);
            const parsed = JSON.parse(info.source);
            const type = parsed?.type;
            if (type === "module" || type === "commonjs") {
                return type;
            }
        } catch  {}
        if (current === stopAt || current === "/") break;
    }
    return null;
}
function detectModuleKind1(path, source) {
    const lower = path.toLowerCase();
    if (lower.endsWith(".cjs")) return "cjs";
    if (lower.endsWith(".mjs")) return "esm";
    if (lower.endsWith(".ts") || lower.endsWith(".tsx") || lower.endsWith(".jsx")) {
        return "esm";
    }
    const pkgType = findPackageType1(path);
    if (pkgType === "module") return "esm";
    if (pkgType === "commonjs") return "cjs";
    if (/\bmodule\.exports\b/.test(source) || /\bexports\./.test(source) || /\brequire\(/.test(source)) {
        return "cjs";
    }
    if (/\bimport\.meta\b/.test(source) || /^\s*import\s/m.test(source) || /^\s*export\s/m.test(source)) {
        return "esm";
    }
    return "cjs";
}
function toFileUrl1(path) {
    if (path.startsWith("file://")) return path;
    const normalized = path.startsWith("/") ? path : `/${path}`;
    return `file://${normalized}`;
}
function fromFileUrl1(path) {
    if (!path) return null;
    if (!path.startsWith("file://")) return path;
    return path.replace(/^file:\/\//, "");
}
function isDekaExitError1(error) {
    const message = error?.message || String(error);
    return message.includes("DekaExit:");
}
function wrapCjsExports1(exportsValue) {
    if (exportsValue && typeof exportsValue === "object") {
        if (exportsValue.__esModule && "default" in exportsValue) {
            return exportsValue;
        }
        return {
            default: exportsValue,
            ...exportsValue
        };
    }
    if (typeof exportsValue === "function") {
        const wrapped = {
            default: exportsValue
        };
        for (const key of Object.keys(exportsValue)){
            wrapped[key] = exportsValue[key];
        }
        return wrapped;
    }
    return {
        default: exportsValue
    };
}
function debugPrint1(message) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_RUN_DEBUG) return;
    const op = globalThis.__dekaOps;
    if (op?.op_stdout_write) {
        op.op_stdout_write(new TextEncoder().encode(`${message}\n`));
    }
}
function verbosePrint1(message) {
    const env = globalThis.process?.env;
    if (!env?.DEKA_VERBOSE) return;
    const op = globalThis.__dekaOps;
    if (op?.op_stdout_write) {
        op.op_stdout_write(new TextEncoder().encode(`${message}\n`));
    }
}
function depsAreFresh1(entry) {
    if (!entry.deps) return true;
    for (const dep of entry.deps){
        let info;
        try {
            info = readModuleSource1(dep.path);
        } catch (error) {
            return false;
        }
        if (info.modified_ms !== dep.modifiedMs) {
            return false;
        }
    }
    return true;
}
function createRequire2(referrer) {
    const requireFn = function require1(specifier) {
        verbosePrint1(`[verbose] require ${specifier} from ${referrer || "<root>"}`);
        return loadModuleExports1(specifier, referrer, "require");
    };
    requireFn.resolve = (specifier)=>{
        if (isBareSpecifier1(specifier)) {
            const resolved = resolvePackageSpecifier1(specifier, referrer, "require");
            if (!resolved) {
                throw new Error(`Unable to resolve package "${specifier}"`);
            }
            return resolved;
        }
        const resolved = resolveModulePath1(referrer, specifier);
        const info = resolveWithExtensions1(resolved, {
            referrer: referrer || undefined,
            specifier
        });
        return info.path;
    };
    requireFn.cache = Object.create(null);
    requireFn.main = mainModule1 || undefined;
    requireFn.extensions = requireExtensions1;
    return requireFn;
}
globalThis.__dekaCreateRequire = createRequire2;
globalThis.__dekaRequireExtensions = requireExtensions1;
function loadCjsModule1(info, mode, isMain) {
    const cacheKey = info.path;
    const entry = moduleCache1.get(cacheKey);
    if (entry && entry.modifiedMs === info.modified_ms) {
        return mode === "require" ? entry.exports : wrapCjsExports1(entry.exports);
    }
    installDekaImport1();
    verbosePrint1(`[verbose] exec cjs ${info.path}`);
    debugPrint1(`[deka-run] load ${info.path}`);
    const module1 = {
        id: info.path,
        filename: info.path,
        loaded: false,
        exports: {},
        require: undefined,
        parent: null,
        children: [],
        paths: [],
        path: info.path.split("/").slice(0, -1).join("/") || "/"
    };
    const localRequire = createRequire2(info.path);
    module1.require = localRequire;
    if (isMain) {
        mainModule1 = module1;
        localRequire.main = module1;
    }
    const dirname = info.path.split("/").slice(0, -1).join("/") || "/";
    const source = info.source.replace(/\bimport\s*\(/g, "__dekaImportAsync(");
    const wrapper = new Function("require", "module", "exports", "__filename", "__dirname", "__dekaImport", "__dekaImportAsync", source);
    moduleCache1.set(cacheKey, {
        exports: module1.exports,
        modifiedMs: info.modified_ms,
        deps: [],
        kind: "cjs",
        loading: true
    });
    try {
        const localImport = (specifier)=>globalThis.__dekaImport(specifier, info.path);
        const localImportAsync = (specifier)=>Promise.resolve(loadModuleExportsInternal1(specifier, info.path, "import", true));
        wrapper(localRequire, module1, module1.exports, info.path, dirname, localImport, localImportAsync);
        debugPrint1(`[deka-run] executed ${info.path}`);
        verbosePrint1(`[verbose] done cjs ${info.path}`);
    } catch (error) {
        if (isDekaExitError1(error)) {
            throw error;
        }
        const message = error?.stack || error?.message || String(error);
        throw new Error(`Module execution failed for ${info.path}\n\n${message}`);
    }
    module1.loaded = true;
    const cached = moduleCache1.get(cacheKey);
    if (cached) {
        cached.exports = module1.exports;
        cached.modifiedMs = info.modified_ms;
        cached.deps = [];
        cached.kind = "cjs";
        cached.loading = false;
    } else {
        moduleCache1.set(cacheKey, {
            exports: module1.exports,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs",
            loading: false
        });
    }
    return mode === "require" ? module1.exports : wrapCjsExports1(module1.exports);
}
function loadTextModule1(info, mode) {
    const cacheKey = info.path;
    const value = info.source;
    if (mode === "require") {
        moduleCache1.set(cacheKey, {
            exports: value,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs"
        });
        return value;
    }
    const exports = wrapCjsExports1(value);
    moduleCache1.set(cacheKey, {
        exports,
        modifiedMs: info.modified_ms,
        deps: []
    });
    return exports;
}
function loadHtmlModule1(info, mode) {
    const cacheKey = info.path;
    const value = new String(info.source);
    value.__dekaHtml = true;
    value.__dekaHtmlPath = info.path;
    if (mode === "require") {
        moduleCache1.set(cacheKey, {
            exports: value,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs"
        });
        return value;
    }
    const exports = wrapCjsExports1(value);
    moduleCache1.set(cacheKey, {
        exports,
        modifiedMs: info.modified_ms,
        deps: []
    });
    return exports;
}
function stripJsonc1(input) {
    const withoutBlock = input.replace(/\/\*[\s\S]*?\*\//g, "");
    const withoutLine = withoutBlock.replace(/^\s*\/\/.*$/gm, "");
    return withoutLine.replace(/,\s*([}\]])/g, "$1");
}
function loadJsoncModule1(info, mode) {
    let parsed;
    try {
        parsed = JSON.parse(stripJsonc1(info.source));
    } catch (error) {
        const message = error?.message ? error.message : String(error);
        throw new Error(`Failed to parse JSONC module ${info.path}\\n\\n${message}`);
    }
    if (mode === "require") {
        moduleCache1.set(info.path, {
            exports: parsed,
            modifiedMs: info.modified_ms,
            deps: [],
            kind: "cjs"
        });
        return parsed;
    }
    const exports = wrapCjsExports1(parsed);
    moduleCache1.set(info.path, {
        exports,
        modifiedMs: info.modified_ms,
        deps: []
    });
    return exports;
}
function loadModuleExportsInternal1(specifier, referrer, mode, asyncMode) {
    referrer = fromFileUrl1(referrer);
    specifier = fromFileUrl1(specifier) || specifier;
    if (specifier === "#module-sync-enabled") {
        return mode === "require" ? false : {
            default: false
        };
    }
    verbosePrint1(`[verbose] ${mode} ${specifier} from ${referrer || "<root>"} async=${asyncMode ? "1" : "0"}`);
    if (specifier === "node:worker_threads" || specifier === "worker_threads") {
        const raw = globalThis.process?.env?.DEKA_WORKER_THREADS;
        const enabled = raw === undefined || raw === "" || raw === "1" || raw === "true" || raw === "yes" || raw === "on";
        if (!enabled) {
            throw new Error("worker_threads disabled");
        }
    }
    if (specifier.includes("/rollup/dist/native.js") || specifier.endsWith("rollup/dist/native.js")) {
        return loadModuleExportsInternal1("@rollup/wasm-node/dist/native.js", referrer, mode, asyncMode);
    }
    const builtin = getBuiltinModule1(specifier);
    if (builtin) {
        return mode === "require" ? builtin : {
            default: builtin,
            ...builtin
        };
    }
    if (specifier === "fsevents") {
        const err = new Error("Cannot find module 'fsevents'");
        err.code = "MODULE_NOT_FOUND";
        throw err;
    }
    if (isImportsSpecifier1(specifier)) {
        const resolved = resolveImportsSpecifier1(specifier, referrer, mode);
        if (!resolved) {
            throw new Error(`Unable to resolve import map specifier "${specifier}"`);
        }
        return loadModuleExportsInternal1(resolved, referrer, mode, asyncMode);
    }
    if (isBareSpecifier1(specifier)) {
        const resolved = resolvePackageSpecifier1(specifier, referrer, mode);
        if (!resolved) {
            throw new Error(`Unable to resolve package "${specifier}"`);
        }
        return loadModuleExportsInternal1(resolved, referrer, mode, asyncMode);
    }
    const resolved = resolveModulePath1(referrer, specifier);
    if (resolved.includes("/rollup/dist/native.js") || resolved.endsWith("rollup/dist/native.js")) {
        return loadModuleExportsInternal1("@rollup/wasm-node/dist/native.js", referrer, mode, asyncMode);
    }
    const info = resolveWithExtensions1(resolved, {
        referrer: referrer || undefined,
        specifier
    });
    verbosePrint1(`[verbose] resolved ${specifier} -> ${info.path}`);
    debugPrint1(`[deka-run] load ${info.path}`);
    if (info.source.startsWith("#!")) {
        info.source = stripShebang1(info.source);
    }
    const cacheKey = info.path;
    const entry = moduleCache1.get(cacheKey);
    if (entry && entry.modifiedMs === info.modified_ms && depsAreFresh1(entry)) {
        if (entry.kind === "cjs") {
            return mode === "require" ? entry.exports : wrapCjsExports1(entry.exports);
        }
        return entry.exports;
    }
    let moduleKind = detectModuleKind1(info.path, info.source);
    if (info.path.endsWith("bindings_wasm.js")) {
        const cjsModule = /\bmodule\.exports\b/.test(info.source);
        const cjsExports = /\bexports\./.test(info.source);
        const cjsRequire = /\brequire\(/.test(info.source);
        if (cjsModule || cjsExports || cjsRequire) {
            moduleKind = "cjs";
        }
        debugPrint1(`[deka-run] module-kind ${moduleKind} for ${info.path}`);
        debugPrint1(`[deka-run] bindings_wasm cjs flags module=${cjsModule} exports=${cjsExports} require=${cjsRequire}`);
    }
    if (info.path.endsWith(".node")) {
        const isMain = referrer === null;
        return loadCjsModule1(info, mode, isMain);
    }
    if (moduleKind === "cjs") {
        const isMain = referrer === null;
        return loadCjsModule1(info, mode, isMain);
    }
    if (info.path.endsWith(".jsonc")) {
        return loadJsoncModule1(info, mode);
    }
    if (info.path.endsWith(".json")) {
        let parsed;
        try {
            parsed = JSON.parse(info.source);
        } catch (error) {
            const message = error?.message ? error.message : String(error);
            throw new Error(`Failed to parse JSON module ${info.path}\n\n${message}`);
        }
        if (mode === "require") {
            moduleCache1.set(cacheKey, {
                exports: parsed,
                modifiedMs: info.modified_ms,
                deps: [],
                kind: "cjs"
            });
            return parsed;
        }
        const exports = wrapCjsExports1(parsed);
        moduleCache1.set(cacheKey, {
            exports,
            modifiedMs: info.modified_ms,
            deps: []
        });
        return exports;
    }
    if (info.path.endsWith(".html")) {
        return loadHtmlModule1(info, mode);
    }
    if (info.path.endsWith(".module.css")) {
        const bundled = op_bundle_css2(info.path, {
            css_modules: true,
            minify: true
        });
        const exports = bundled.exports || {};
        if (mode === "require") {
            moduleCache1.set(cacheKey, {
                exports,
                modifiedMs: info.modified_ms,
                deps: [],
                kind: "cjs"
            });
            return exports;
        }
        const wrapped = wrapCjsExports1(exports);
        moduleCache1.set(cacheKey, {
            exports: wrapped,
            modifiedMs: info.modified_ms,
            deps: []
        });
        return wrapped;
    }
    if (info.path.endsWith(".txt") || info.path.endsWith(".css") || info.path.endsWith(".toml") || info.path.endsWith(".yaml") || info.path.endsWith(".yml")) {
        return loadTextModule1(info, mode);
    }
    let transformed;
    try {
        transformed = op_transform_module2(info.path, info.source);
    } catch (error) {
        const message = error?.message ? error.message : String(error);
        if (message.includes("Validation Error")) {
            throw new Error(message);
        }
        throw new Error(`Module transform failed for ${info.path}\n\n${message}`);
    }
    if (mode === "require" && transformed.top_level_await) {
        throw new Error(`Cannot require() ${info.path} because it uses top-level await.\n` + "Use import() or static import instead.");
    }
    const exports = {};
    const module1 = {
        exports
    };
    const deps = transformed.deps.filter((spec)=>spec.startsWith(".") || spec.startsWith("/")).map((spec)=>{
        const depPath = resolveModulePath1(info.path, spec);
        const depInfo = resolveWithExtensions1(depPath, {
            referrer: info.path,
            specifier: spec
        });
        return {
            path: depInfo.path,
            modifiedMs: depInfo.modified_ms
        };
    });
    const importMeta = {
        url: toFileUrl1(info.path)
    };
    const hasTopLevelAwait = transformed.top_level_await;
    const rewrittenCode = transformed.code.replace(/\bimport\s*\(/g, "__dekaImportAsync(");
    const wrappedCode = hasTopLevelAwait ? `return (async () => {\n${rewrittenCode}\n})()` : rewrittenCode;
    const wrapper = new Function("exports", "module", "__dekaImport", "__dekaImportAsync", "require", "__dekaImportMeta", wrappedCode);
    moduleCache1.set(cacheKey, {
        exports: module1.exports,
        modifiedMs: info.modified_ms,
        deps
    });
    try {
        verbosePrint1(`[verbose] exec esm ${info.path}`);
        const result = wrapper(module1.exports, module1, (spec)=>loadModuleExportsInternal1(spec, info.path, "import", false), (spec)=>Promise.resolve(loadModuleExportsInternal1(spec, info.path, "import", true)), createRequire2(info.path), importMeta);
        if (result && typeof result.then === "function") {
            if (asyncMode) {
                return result.then(()=>{
                    if (module1.exports.default === undefined && globalThis.app !== undefined) {
                        module1.exports.default = globalThis.app;
                    }
                    return module1.exports;
                });
            }
            waitForPromise1(result);
        }
        verbosePrint1(`[verbose] done esm ${info.path}`);
    } catch (error) {
        if (isDekaExitError1(error)) {
            throw error;
        }
        const message = error?.stack || error?.message || String(error);
        throw new Error(`Module execution failed for ${info.path}\n\n${message}`);
    }
    if (module1.exports.default === undefined && globalThis.app !== undefined) {
        module1.exports.default = globalThis.app;
    }
    return module1.exports;
}
function loadModuleExports1(specifier, referrer, mode = "import") {
    return loadModuleExportsInternal1(specifier, referrer, mode, false);
}
function loadModule(specifier) {
    installDekaImport1();
    const exports = loadModuleExportsInternal1(specifier, null, "import", false);
    return exports.default || exports;
}
async function loadModuleAsync(specifier) {
    installDekaImport1();
    const exports = await loadModuleExportsInternal1(specifier, null, "import", true);
    return exports.default || exports;
}
function getBuiltinModule1(specifier) {
    if (specifier === "deka") return globalThis.__deka;
    if (specifier === "node:buffer" || specifier === "buffer") {
        return {
            Buffer: globalThis.Buffer
        };
    }
    if (specifier === "esbuild") {
        const env = globalThis.process?.env || {};
        if (env.DEKA_ESBUILD_SHIM === "1" || env.DEKA_ESBUILD_SHIM === "true") {
            return globalThis.__dekaEsbuild;
        }
        return undefined;
    }
    if (specifier === "node:assert" || specifier === "assert") {
        return globalThis.__dekaNodeAssert;
    }
    if (specifier === "node:console" || specifier === "console") {
        return globalThis.__dekaNodeConsole || {
            console: globalThis.console
        };
    }
    if (specifier === "node:events" || specifier === "events") {
        return globalThis.__dekaNodeEvents;
    }
    if (specifier === "node:process" || specifier === "process") {
        return globalThis.process;
    }
    if (specifier === "node:timers" || specifier === "timers") {
        return globalThis.__dekaNodeTimers;
    }
    if (specifier === "node:timers/promises" || specifier === "timers/promises") {
        return globalThis.__dekaNodeTimersPromises;
    }
    if (specifier === "node:util" || specifier === "util") {
        return globalThis.__dekaNodeUtil;
    }
    if (specifier === "node:util/types" || specifier === "util/types") {
        return globalThis.__dekaNodeUtil?.types;
    }
    if (specifier === "node:os" || specifier === "os") {
        return globalThis.__dekaNodeOs;
    }
    if (specifier === "node:fs" || specifier === "fs") {
        return globalThis.__dekaNodeFs;
    }
    if (specifier === "node:fs/promises" || specifier === "fs/promises") {
        return globalThis.__dekaNodeFs?.promises;
    }
    if (specifier === "node:path" || specifier === "path") {
        return globalThis.__dekaNodePath;
    }
    if (specifier === "node:constants" || specifier === "constants") {
        return globalThis.__dekaNodeConstants;
    }
    if (specifier === "node:path/posix" || specifier === "path/posix") {
        return globalThis.__dekaNodePath?.posix;
    }
    if (specifier === "node:path/win32" || specifier === "path/win32") {
        return globalThis.__dekaNodePath?.win32;
    }
    if (specifier === "node:string_decoder" || specifier === "string_decoder") {
        return globalThis.__dekaNodeStringDecoder;
    }
    if (specifier === "node:querystring" || specifier === "querystring") {
        return globalThis.__dekaNodeQuerystring;
    }
    if (specifier === "node:crypto" || specifier === "crypto") {
        return globalThis.__dekaNodeCrypto;
    }
    if (specifier === "node:stream/web" || specifier === "stream/web") {
        return globalThis.__dekaNodeStreamWeb || globalThis;
    }
    if (specifier === "node:stream" || specifier === "stream") {
        return globalThis.__dekaNodeStream;
    }
    if (specifier === "node:stream/promises" || specifier === "stream/promises") {
        return globalThis.__dekaNodeStreamPromises;
    }
    if (specifier === "node:url" || specifier === "url") {
        return globalThis.__dekaNodeUrl;
    }
    if (specifier === "node:tty" || specifier === "tty") {
        return globalThis.__dekaNodeTty;
    }
    if (specifier === "node:punycode" || specifier === "punycode") {
        return globalThis.__dekaNodePunycode;
    }
    if (specifier === "node:diagnostics_channel" || specifier === "diagnostics_channel") {
        return globalThis.__dekaNodeDiagnosticsChannel;
    }
    if (specifier === "node:async_hooks" || specifier === "async_hooks") {
        return globalThis.__dekaNodeAsyncHooks;
    }
    if (specifier === "node:perf_hooks" || specifier === "perf_hooks") {
        return globalThis.__dekaNodePerfHooks;
    }
    if (specifier === "node:http" || specifier === "http") {
        return globalThis.__dekaNodeHttp;
    }
    if (specifier === "node:https" || specifier === "https") {
        return globalThis.__dekaNodeHttps;
    }
    if (specifier === "node:tls" || specifier === "tls") {
        return globalThis.__dekaNodeTls;
    }
    if (specifier === "node:sqlite" || specifier === "sqlite") {
        return globalThis.__dekaNodeSqlite;
    }
    if (specifier === "node:test" || specifier === "test") {
        return globalThis.__dekaNodeTest;
    }
    if (specifier === "node:readline" || specifier === "readline") {
        return globalThis.__dekaNodeReadline;
    }
    if (specifier === "node:domain" || specifier === "domain") {
        return globalThis.__dekaNodeDomain;
    }
    if (specifier === "node:http2" || specifier === "http2") {
        return globalThis.__dekaNodeHttp2;
    }
    if (specifier === "node:module" || specifier === "module") {
        return globalThis.__dekaNodeModule;
    }
    if (specifier === "node:trace_events" || specifier === "trace_events") {
        return globalThis.__dekaNodeTraceEvents;
    }
    if (specifier === "node:inspector" || specifier === "inspector") {
        return globalThis.__dekaNodeInspector;
    }
    if (specifier === "node:dgram" || specifier === "dgram") {
        return globalThis.__dekaNodeDgram;
    }
    if (specifier === "node:dns" || specifier === "dns") {
        return globalThis.__dekaNodeDns;
    }
    if (specifier === "node:dns/promises" || specifier === "dns/promises") {
        return globalThis.__dekaNodeDns?.promises;
    }
    if (specifier === "node:net" || specifier === "net") {
        return globalThis.__dekaNodeNet;
    }
    if (specifier === "node:zlib" || specifier === "zlib") {
        return globalThis.__dekaNodeZlib;
    }
    if (specifier === "node:child_process" || specifier === "child_process") {
        return globalThis.__dekaNodeChildProcess;
    }
    if (specifier === "node:cluster" || specifier === "cluster") {
        return globalThis.__dekaNodeCluster;
    }
    if (specifier === "node:sys" || specifier === "sys") {
        return globalThis.__dekaNodeSys;
    }
    if (specifier === "node:v8" || specifier === "v8") {
        return globalThis.__dekaNodeV8;
    }
    if (specifier === "node:vm" || specifier === "vm") {
        return globalThis.__dekaNodeVm;
    }
    if (specifier === "node:wasi" || specifier === "wasi") {
        return globalThis.__dekaNodeWasi;
    }
    if (specifier === "node:worker_threads" || specifier === "worker_threads") {
        return globalThis.__dekaNodeWorkerThreads;
    }
    if (specifier === "node:repl" || specifier === "repl") {
        return globalThis.__dekaNodeRepl;
    }
    if (specifier === "node:ws" || specifier === "ws") {
        return globalThis.__dekaWs;
    }
    if (!specifier.startsWith("deka/")) return null;
    switch(specifier){
        case "deka/router":
            return globalThis.__dekaRouter;
        case "deka/sqlite":
            return globalThis.__dekaSqlite;
        case "deka/t4":
            return globalThis.__dekaT4;
        case "deka/postgres":
            return globalThis.__dekaPostgres;
        case "deka/docker":
            return globalThis.__dekaDocker;
        case "deka/redis":
            return globalThis.__dekaRedis;
        case "deka/jsx-runtime":
            return globalThis.__dekaJsxRuntime;
        case "deka/jsx-dev-runtime":
            return globalThis.__dekaJsxDevRuntime;
        default:
            return null;
    }
}
function installModuleLoader() {
    installDekaImport1();
    globalThis.__dekaLoadModule = loadModule;
    globalThis.__dekaLoadModuleAsync = loadModuleAsync;
}
function resolveHandlerPath(path) {
    if (!path || typeof path !== "string") {
        return path;
    }
    if (path.startsWith("/")) {
        return path;
    }
    const base = globalThis.process?.env?.HANDLER_PATH;
    if (base) {
        const normalized = path.startsWith("./") ? path.slice(2) : path;
        const slash = base.lastIndexOf("/");
        if (slash >= 0) {
            return `${base.slice(0, slash + 1)}${normalized}`;
        }
    }
    return path;
}
async function build1(options) {
    const entrypoints = Array.isArray(options.entrypoints) ? options.entrypoints : [
        options.entrypoints
    ];
    const outdir = resolvePathFrom1(getCwd1(), options.outdir || "./dist");
    const outputs = [];
    for (const entry of entrypoints){
        if (entry.toLowerCase().endsWith(".html")) {
            await buildHtmlEntry(entry, outdir, outputs);
            continue;
        }
        const resolvedEntry = resolvePathFrom1(getCwd1(), entry);
        let serverModule = null;
        try {
            const moduleExports = loadModuleExports1(resolvedEntry, null);
            serverModule = moduleExports?.default ?? moduleExports;
        } catch  {
            serverModule = null;
        }
        const htmlEntries = collectHtmlRoutes(serverModule);
        if (htmlEntries.length > 0) {
            for (const htmlEntry of htmlEntries){
                await buildHtmlEntry(htmlEntry, outdir, outputs);
            }
            continue;
        }
        const bundle = op_bundle_browser_assets2(resolvedEntry);
        const code = bundle.code;
        const hash = hashString1(code);
        const assetName = `${fileStem1(entry)}-${hash}.js`;
        const jsOut = resolvePathFrom1(outdir, assetName);
        op_write_file2(jsOut, code);
        outputs.push(jsOut);
        let cssName = null;
        if (bundle.css) {
            const assetRouteRoot = "/assets";
            const assetDirRoot = "assets";
            const cssWithAssets = applyCssAssets1(bundle.css, bundle.assets || [], assetRouteRoot);
            const cssHash = hashString1(cssWithAssets);
            cssName = `${fileStem1(entry)}-${cssHash}.css`;
            const cssOut = resolvePathFrom1(outdir, cssName);
            op_write_file2(cssOut, cssWithAssets);
            outputs.push(cssOut);
            for (const asset of bundle.assets || []){
                const assetOut = resolvePathFrom1(outdir, `${assetDirRoot}/${asset.file_name}`);
                op_write_file_base642(assetOut, asset.body_base64);
                outputs.push(assetOut);
            }
        }
        const htmlName = `${fileStem1(entry)}.html`;
        const htmlOut = resolvePathFrom1(outdir, htmlName);
        const html = buildHtmlWrapper(assetName, cssName);
        op_write_file2(htmlOut, html);
        outputs.push(htmlOut);
    }
    return {
        outdir,
        outputs
    };
}
async function buildHtmlEntry(entry, outdir, outputs) {
    const bundle = await buildHtmlBundle(entry, "/assets");
    const htmlOut = resolvePathFrom1(outdir, fileName(entry));
    op_write_file2(htmlOut, bundle.html);
    outputs.push(htmlOut);
    for (const [assetPath, asset] of bundle.assets){
        const normalizedAsset = assetPath.startsWith("/") ? assetPath.slice(1) : assetPath;
        const assetOut = resolvePathFrom1(outdir, normalizedAsset);
        if (asset.body instanceof Uint8Array) {
            const encoded = encodeBase64(asset.body);
            op_write_file_base642(assetOut, encoded);
        } else {
            op_write_file2(assetOut, asset.body);
        }
        outputs.push(assetOut);
    }
}
function collectHtmlRoutes(server) {
    if (!server || typeof server !== "object") return [];
    if (server.__dekaServer !== true) return [];
    const routes = server.__dekaRoutes;
    if (!routes) return [];
    const entries = [];
    for (const value of Object.values(routes)){
        if (isHtmlRoute(value)) {
            entries.push(value.__dekaHtmlPath || "");
        }
    }
    return entries.filter(Boolean);
}
function isHtmlRoute(value) {
    return !!value && typeof value === "object" && value.__dekaHtml === true;
}
function fileName(path) {
    const part = path.split("/").pop() || "index.html";
    return part;
}
function fileStem1(path) {
    const name = fileName(path);
    const idx = name.lastIndexOf(".");
    return idx > 0 ? name.slice(0, idx) : name;
}
function hashString1(value) {
    let hash = 5381;
    for(let i = 0; i < value.length; i += 1){
        hash = (hash << 5) + hash + value.charCodeAt(i) >>> 0;
    }
    return hash.toString(36);
}
function buildHtmlWrapper(scriptName, cssName) {
    const cssLink = cssName ? `    <link rel="stylesheet" href="./${cssName}">` : "";
    return `<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Deka App</title>
${cssLink}
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./${scriptName}"></script>
  </body>
</html>
`;
}
function applyCssAssets1(css, assets, assetsRoot) {
    let output = css;
    for (const asset of assets){
        const assetPath = `${assetsRoot}/${asset.file_name}`;
        output = output.replaceAll(asset.placeholder, assetPath);
    }
    return output;
}
function encodeBase64(bytes) {
    if (typeof btoa === "function") {
        let binary = "";
        for(let i = 0; i < bytes.length; i += 1){
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
    return encodeBase64Manual(bytes);
}
function encodeBase64Manual(bytes) {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let output = "";
    for(let i = 0; i < bytes.length; i += 3){
        const a = bytes[i];
        const b = i + 1 < bytes.length ? bytes[i + 1] : 0;
        const c = i + 2 < bytes.length ? bytes[i + 2] : 0;
        const triple = a << 16 | b << 8 | c;
        output += alphabet[triple >> 18 & 63];
        output += alphabet[triple >> 12 & 63];
        output += i + 1 < bytes.length ? alphabet[triple >> 6 & 63] : "=";
        output += i + 2 < bytes.length ? alphabet[triple & 63] : "=";
    }
    return output;
}
function decodeCookieValue(value) {
    try {
        return decodeURIComponent(value);
    } catch  {
        return value;
    }
}
function encodeCookieValue(value) {
    try {
        return encodeURIComponent(value);
    } catch  {
        return value;
    }
}
function parseCookieHeader(header) {
    const map = {};
    if (!header) return map;
    const parts = header.split(";");
    for (const part of parts){
        const [name, ...rest] = part.trim().split("=");
        if (!name) continue;
        map[name] = decodeCookieValue(rest.join("=") || "");
    }
    return map;
}
function formatExpires(expires) {
    if (expires instanceof Date) {
        return expires.toUTCString();
    }
    return new Date(expires).toUTCString();
}
function normalizeSameSite(value) {
    if (!value) return undefined;
    const normalized = String(value).toLowerCase();
    if (normalized === "strict") return "Strict";
    if (normalized === "lax") return "Lax";
    if (normalized === "none") return "None";
    return undefined;
}
function serializeCookie(name, value, options = {}) {
    const encoded = encodeCookieValue(value);
    const parts = [
        `${name}=${encoded}`
    ];
    if (options.maxAge !== undefined) parts.push(`Max-Age=${Math.floor(options.maxAge)}`);
    if (options.domain) parts.push(`Domain=${options.domain}`);
    if (options.path) parts.push(`Path=${options.path}`);
    if (options.expires) parts.push(`Expires=${formatExpires(options.expires)}`);
    if (options.httpOnly) parts.push("HttpOnly");
    if (options.secure) parts.push("Secure");
    const sameSite = normalizeSameSite(options.sameSite);
    if (sameSite) parts.push(`SameSite=${sameSite}`);
    return parts.join("; ");
}
class CookieMap {
    cookies;
    changes;
    constructor(header){
        this.cookies = parseCookieHeader(header || "");
        this.changes = [];
    }
    get(name) {
        return this.cookies[name];
    }
    has(name) {
        return Object.prototype.hasOwnProperty.call(this.cookies, name);
    }
    set(name, value, options = {}) {
        this.cookies[name] = value;
        this.changes.push(serializeCookie(name, value, options));
    }
    delete(name, options = {}) {
        delete this.cookies[name];
        this.changes.push(serializeCookie(name, "", {
            ...options,
            maxAge: 0
        }));
    }
    toHeaderValues() {
        return this.changes.slice();
    }
}
function getHeaderValue(headers, name) {
    const lower = name.toLowerCase();
    for (const [key, value] of Object.entries(headers || {})){
        if (key.toLowerCase() === lower) return value;
    }
    return undefined;
}
function applyCookiesToHeaders(headers, cookies) {
    const values = cookies.toHeaderValues();
    if (!values.length) return headers;
    const existing = getHeaderValue(headers, "set-cookie");
    const merged = existing ? [
        existing,
        ...values
    ] : values;
    return {
        ...headers,
        "Set-Cookie": merged.join("\n")
    };
}
function normalizeRequest(request, params) {
    if (!request || typeof request !== "object") {
        return {
            url: "",
            method: "GET",
            headers: new Headers1(),
            body: "",
            params: {},
            cookies: new CookieMap(),
            async json () {
                return null;
            },
            async text () {
                return "";
            }
        };
    }
    const body = request.body ?? "";
    const resolvedParams = params ?? request.params ?? {};
    const headersInput = request.headers && typeof request.headers === "object" ? request.headers : {};
    const headerObj = headersInput instanceof Headers1 ? headersToObject1(headersInput) : headersInput;
    const cookieHeader = getHeaderValue(headerObj, "cookie");
    const headers = headersInput instanceof Headers1 ? headersInput : new Headers1(headersInput);
    const cookies = new CookieMap(cookieHeader);
    return {
        ...request,
        url: request.url || "",
        method: request.method || "GET",
        headers,
        body,
        params: resolvedParams,
        cookies,
        async json () {
            if (!body) return null;
            return JSON.parse(body);
        },
        async text () {
            return body;
        }
    };
}
function serializeRequest(request, context) {
    const headersInput = request?.headers && typeof request.headers === "object" ? request.headers : {};
    const headers = headersInput instanceof Headers1 ? headersToObject1(headersInput) : headersInput;
    return {
        url: request?.url || "",
        method: request?.method || "GET",
        headers,
        body: request?.body ?? "",
        params: request?.params || {},
        context: context || {}
    };
}
function compileMatcher(pattern) {
    if (pattern.includes("*")) {
        const prefix = pattern.split("*")[0];
        return (path)=>path.startsWith(prefix) ? {} : null;
    }
    if (!pattern.includes(":")) {
        return (path)=>path === pattern ? {} : null;
    }
    const parts = pattern.split("/").filter(Boolean);
    return (path)=>{
        const pathParts = path.split("/").filter(Boolean);
        if (parts.length !== pathParts.length) return null;
        const params = {};
        for(let i = 0; i < parts.length; i += 1){
            const part = parts[i];
            const value = pathParts[i];
            if (part.startsWith(":")) {
                params[part.slice(1)] = value;
            } else if (part !== value) {
                return null;
            }
        }
        return params;
    };
}
function scoreRoute(pattern, method) {
    const hasWildcard = pattern.includes("*");
    const parts = pattern.split("/").filter(Boolean);
    let staticCount = 0;
    let paramCount = 0;
    for (const part of parts){
        if (part === "*") continue;
        if (part.startsWith(":")) {
            paramCount += 1;
        } else {
            staticCount += 1;
        }
    }
    const lengthScore = parts.length;
    const wildcardPenalty = hasWildcard ? -5 : 0;
    const methodBonus = method ? 1 : 0;
    return staticCount * 10 + paramCount * 2 + lengthScore + wildcardPenalty + methodBonus;
}
function compileRoutes(routes = {}) {
    const compiled = [];
    for (const [path, handler] of Object.entries(routes)){
        const match = compileMatcher(path);
        if (typeof handler === "function" || handler?.status !== undefined) {
            compiled.push({
                match,
                handler,
                method: null,
                score: scoreRoute(path, null)
            });
            continue;
        }
        if (handler && typeof handler === "object") {
            for (const [method, methodHandler] of Object.entries(handler)){
                const upper = method.toUpperCase();
                const resolvedMethod = upper === "ALL" || upper === "*" ? null : upper;
                compiled.push({
                    match,
                    handler: methodHandler,
                    method: resolvedMethod,
                    score: scoreRoute(path, resolvedMethod)
                });
            }
        }
    }
    return compiled.sort((a, b)=>b.score - a.score);
}
function pickRoute(compiled, request) {
    const url = new URL(request.url || "http://localhost/");
    const path = url.pathname;
    const method = (request.method || "GET").toUpperCase();
    for (const route of compiled){
        const params = route.match(path);
        if (!params) continue;
        if (route.method && route.method !== method) continue;
        return {
            handler: route.handler,
            params
        };
    }
    return null;
}
class Router {
    _compiled;
    constructor(routes = {}){
        this._compiled = [];
        if (routes && typeof routes === "object") {
            this.addRoutes(routes);
        }
    }
    addRoutes(routes = {}) {
        const compiled = compileRoutes(routes);
        this._compiled = this._compiled.concat(compiled).sort((a, b)=>b.score - a.score);
        return this;
    }
    on(method, path, handler) {
        const routes = {
            [path]: {
                [method]: handler
            }
        };
        return this.addRoutes(routes);
    }
    all(path, handler) {
        return this.on("ALL", path, handler);
    }
    get(path, handler) {
        return this.on("GET", path, handler);
    }
    post(path, handler) {
        return this.on("POST", path, handler);
    }
    put(path, handler) {
        return this.on("PUT", path, handler);
    }
    patch(path, handler) {
        return this.on("PATCH", path, handler);
    }
    delete(path, handler) {
        return this.on("DELETE", path, handler);
    }
    options(path, handler) {
        return this.on("OPTIONS", path, handler);
    }
    handle(request) {
        const route = pickRoute(this._compiled, request);
        if (!route) return null;
        const req = normalizeRequest(request, route.params);
        if (typeof route.handler === "function") {
            return route.handler(req);
        }
        return route.handler;
    }
    async fetch(request) {
        const response = await this.handle(request);
        if (response) return response;
        return new Response1("Not Found", {
            status: 404
        });
    }
}
function serve(options = {}) {
    const router = new Router(options.routes || {});
    const fallback = options.fetch;
    const port = Number(options.port ?? globalThis.process?.env?.PORT) || 8530;
    const url = options.unix ? `unix:${options.unix}` : options.tcp ? `tcp://${options.tcp}` : options.udp ? `udp://${options.udp}` : options.dns ? `dns://${options.dns}` : options.ws ? `ws://localhost:${options.ws}` : options.redis ? `redis://${options.redis}` : `http://localhost:${port}`;
    const introspect = options.introspect;
    const websocket = options.websocket;
    const watchEnabled = isWatchEnabled();
    if (websocket) {
        globalThis.__dekaWebsocket = websocket;
    }
    if (introspect) {
        const config = typeof introspect === "object" ? introspect : {};
        const prefix = config.prefix || "/_introspect";
        const profiling = config.profiling;
        if (profiling !== undefined) {
            op_set_introspect_profiling2(profiling ? 1 : 0);
        }
        const truthy = (value)=>[
                "1",
                "true",
                "yes",
                "on"
            ].includes(String(value || "").toLowerCase());
        const getQuery = (req)=>new URL(req.url || "http://localhost/").searchParams;
        router.get(`${prefix}/health`, ()=>Response1.json({
                status: "ok",
                runtime: "deka-runtime",
                version: "0.1.0"
            }));
        router.get(`${prefix}/stats`, async ()=>Response1.json(await op_introspect_stats2()));
        router.post(`${prefix}/evict`, async ()=>Response1.json(await op_introspect_evict2()));
        router.get(`${prefix}/debug/top`, async (req)=>{
            const params = getQuery(req);
            const sort = params.get("sort") || "cpu";
            const limit = Number(params.get("limit") || "10");
            return Response1.json(await op_introspect_top2(sort, limit));
        });
        router.get(`${prefix}/debug/workers`, async ()=>Response1.json(await op_introspect_workers2()));
        router.get(`${prefix}/debug/isolate/:handler`, async (req)=>{
            const metrics = await op_introspect_isolate2(req.params?.handler);
            if (!metrics) return Response1.json({
                status: "not_found"
            });
            return Response1.json({
                status: "ok",
                metrics
            });
        });
        router.delete(`${prefix}/debug/isolate/:handler`, async (req)=>Response1.json(await op_introspect_kill_isolate2(req.params?.handler)));
        router.get(`${prefix}/debug/requests`, async (req)=>{
            const params = getQuery(req);
            const limit = Number(params.get("limit") || "200");
            const archive = truthy(params.get("archive") || "");
            return Response1.json(await op_introspect_requests2(limit, archive ? 1 : 0));
        });
    }
    const htmlBundles = new Map();
    const assetRoutes = new Map();
    const server = {
        url,
        websocket,
        upgrade (request, options) {
            if (!websocket) return false;
            request.__dekaUpgrade = {
                data: options?.data
            };
            return true;
        },
        async fetch (request) {
            const normalized = normalizeRequest(request);
            const asset = assetRoutes.get(new URL(normalized.url || "http://localhost/").pathname);
            if (asset) {
                return new Response1(asset.body, {
                    status: 200,
                    headers: {
                        "Content-Type": asset.contentType
                    }
                });
            }
            const response = await router.handle(normalized);
            if (normalized.__dekaUpgrade) {
                return {
                    status: 101,
                    headers: {},
                    body: "",
                    upgrade: normalized.__dekaUpgrade
                };
            }
            if (response) {
                if (isHtmlRoute1(response)) {
                    const html = await readHtmlResponse(response, htmlBundles, assetRoutes, watchEnabled);
                    return applyCookieHeaders(html, normalized);
                }
                return applyCookieHeaders(response, normalized);
            }
            if (fallback) {
                const req = normalizeRequest(request);
                const fallbackResponse = await fallback(req);
                if (req.__dekaUpgrade) {
                    return {
                        status: 101,
                        headers: {},
                        body: "",
                        upgrade: req.__dekaUpgrade
                    };
                }
                if (isHtmlRoute1(fallbackResponse)) {
                    const html = await readHtmlResponse(fallbackResponse, htmlBundles, assetRoutes, watchEnabled);
                    return applyCookieHeaders(html, req);
                }
                return applyCookieHeaders(fallbackResponse, req);
            }
            return new Response1("Not Found", {
                status: 404
            });
        }
    };
    server.__dekaServer = true;
    server.__dekaRoutes = options.routes || {};
    globalThis.app = server;
    return server;
}
function isHtmlRoute1(value) {
    return !!value && typeof value === "object" && value.__dekaHtml === true;
}
async function readHtmlResponse(value, bundles, assets, watchEnabled) {
    const entryPath = value.__dekaHtmlPath;
    if (entryPath) {
        const bundle = await ensureHtmlBundle(entryPath, bundles, assets, watchEnabled);
        return new Response1(bundle.html, {
            status: 200,
            headers: {
                "Content-Type": "text/html; charset=utf-8"
            }
        });
    }
    return new Response1(String(value), {
        status: 200,
        headers: {
            "Content-Type": "text/html; charset=utf-8"
        }
    });
}
async function ensureHtmlBundle(entryPath, bundles, assets, watchEnabled) {
    if (!watchEnabled) {
        const cached = bundles.get(entryPath);
        if (cached) return cached;
    } else {
        bundles.delete(entryPath);
        assets.clear();
    }
    const bundle = await buildHtmlBundle(entryPath, "/_deka/assets");
    for (const [route, asset] of bundle.assets){
        assets.set(route, asset);
    }
    bundles.set(entryPath, bundle);
    return bundle;
}
function applyCookieHeaders(response, request) {
    if (!response || typeof response !== "object") return response;
    const cookies = request.cookies;
    if (!cookies || cookies.toHeaderValues().length === 0) return response;
    const responseObj = response;
    const headers = responseObj.headers || {};
    const merged = applyCookiesToHeaders(headers, cookies);
    responseObj.headers = merged;
    return responseObj;
}
function isWatchEnabled() {
    const raw = globalThis.process?.env?.DEKA_WATCH || "";
    return [
        "1",
        "true",
        "yes",
        "on"
    ].includes(String(raw).toLowerCase());
}
const TEXT_TYPES1 = {
    ".html": "text/html; charset=utf-8",
    ".css": "text/css; charset=utf-8",
    ".js": "application/javascript; charset=utf-8",
    ".mjs": "application/javascript; charset=utf-8",
    ".json": "application/json; charset=utf-8",
    ".map": "application/json; charset=utf-8",
    ".svg": "image/svg+xml; charset=utf-8",
    ".txt": "text/plain; charset=utf-8"
};
function toAbsolute(path) {
    if (!path) return path;
    if (path.startsWith("/")) return normalizePath2(path);
    return resolvePathFrom1(getCwd1(), path);
}
function readText(path) {
    const info = readModuleSource1(path);
    return info.source;
}
function contentType(path) {
    const ext = extensionOf1(path);
    return TEXT_TYPES1[ext] || "text/plain; charset=utf-8";
}
function respondText(body, path, status = 200) {
    return new Response1(body, {
        status,
        headers: {
            "Content-Type": contentType(path)
        }
    });
}
function serveIndexHtml(entryPath, options = {}) {
    const entry = toAbsolute(entryPath);
    const root = dirname2(entry);
    const spa = options.spa !== false;
    const value = new String(readText(entry));
    value.__dekaHtml = true;
    value.__dekaHtmlPath = entry;
    return serve({
        routes: {
            "/": value
        },
        async fetch (req) {
            if (!spa) {
                return new Response1("Not Found", {
                    status: 404
                });
            }
            const url = new URL(req.url || "http://localhost/");
            let pathname = url.pathname || "/";
            if (!pathname.startsWith("/")) pathname = `/${pathname}`;
            if (!hasExtension1(pathname)) {
                return value;
            }
            const filePath = resolvePathFrom1(root, pathname);
            if (!filePath.startsWith(root)) {
                return new Response1("Not Found", {
                    status: 404
                });
            }
            const ext = extensionOf1(filePath);
            if (ext && !TEXT_TYPES1[ext]) {
                return new Response1("Unsupported asset type", {
                    status: 415
                });
            }
            try {
                const body = readText(filePath);
                return respondText(body, filePath);
            } catch (_error) {
                return new Response1("Not Found", {
                    status: 404
                });
            }
        }
    });
}
const MIME_TYPES = {
    ".html": "text/html; charset=utf-8",
    ".htm": "text/html; charset=utf-8",
    ".css": "text/css; charset=utf-8",
    ".js": "application/javascript; charset=utf-8",
    ".mjs": "application/javascript; charset=utf-8",
    ".json": "application/json; charset=utf-8",
    ".map": "application/json; charset=utf-8",
    ".svg": "image/svg+xml; charset=utf-8",
    ".txt": "text/plain; charset=utf-8",
    ".xml": "application/xml; charset=utf-8",
    ".pdf": "application/pdf",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".png": "image/png",
    ".gif": "image/gif",
    ".webp": "image/webp",
    ".ico": "image/x-icon",
    ".woff": "font/woff",
    ".woff2": "font/woff2",
    ".ttf": "font/ttf",
    ".eot": "application/vnd.ms-fontobject",
    ".otf": "font/otf"
};
function toAbsolute1(path) {
    if (!path) return path;
    if (path.startsWith("/")) return normalizePath2(path);
    return resolvePathFrom1(getCwd1(), path);
}
function readText1(path) {
    try {
        const info = readModuleSource1(path);
        return info.source;
    } catch  {
        return null;
    }
}
function contentType1(path) {
    const ext = extensionOf1(path).toLowerCase();
    return MIME_TYPES[ext] || "application/octet-stream";
}
function respondText1(body, path, status = 200) {
    return new Response1(body, {
        status,
        headers: {
            "Content-Type": contentType1(path)
        }
    });
}
function isTextFile(path) {
    const ext = extensionOf1(path).toLowerCase();
    return ext in MIME_TYPES && (ext === ".html" || ext === ".htm" || ext === ".css" || ext === ".js" || ext === ".mjs" || ext === ".json" || ext === ".txt" || ext === ".xml" || ext === ".svg" || ext === ".map");
}
function generateDirectoryListing(dirPath, urlPath) {
    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Index of ${urlPath}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 900px;
      margin: 40px auto;
      padding: 0 20px;
      line-height: 1.6;
    }
    h1 {
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 10px;
    }
    ul {
      list-style: none;
      padding: 0;
    }
    li {
      padding: 8px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    a {
      color: #0066cc;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    .parent {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Index of ${urlPath}</h1>
  <ul>
    <li class="parent"><a href="../">../</a></li>
  </ul>
  <hr>
  <p><em>Directory listing disabled or not implemented</em></p>
</body>
</html>`;
}
function serveStaticDirectory(directoryPath, options = {}) {
    const rootDir = toAbsolute1(directoryPath);
    const directoryListing = options.directory_listing !== false;
    return serve({
        async fetch (req) {
            const url = new URL(req.url || "http://localhost/");
            let pathname = url.pathname || "/";
            if (!pathname.startsWith("/")) pathname = `/${pathname}`;
            const cleanPath = pathname.length > 1 && pathname.endsWith("/") ? pathname.slice(0, -1) : pathname;
            const filePath = resolvePathFrom1(rootDir, cleanPath.slice(1));
            if (!filePath.startsWith(rootDir)) {
                return new Response1("Forbidden", {
                    status: 403
                });
            }
            if (isTextFile(filePath)) {
                const content = readText1(filePath);
                if (content !== null) {
                    return respondText1(content, filePath);
                }
            }
            if (directoryListing && pathname.endsWith("/")) {
                const listing = generateDirectoryListing(filePath, pathname);
                return new Response1(listing, {
                    status: 200,
                    headers: {
                        "Content-Type": "text/html; charset=utf-8"
                    }
                });
            }
            return new Response1("Not Found", {
                status: 404
            });
        }
    });
}
let __dekaIdCounter = 0;
function nextId(prefix) {
    __dekaIdCounter += 1;
    const suffix = `${Date.now().toString(36)}_${__dekaIdCounter}`;
    return prefix ? `${prefix}_${suffix}` : suffix;
}
class Mesh {
    options;
    id;
    connected;
    constructor(options = {}){
        this.options = options;
        this.id = options.id || nextId("mesh");
        this.connected = true;
    }
}
class IsolatePool {
    mesh;
    options;
    id;
    context;
    constructor(mesh, options = {}){
        this.mesh = mesh || new Mesh();
        this.options = options;
        this.id = options.id || nextId(`pool_${this.mesh.id}`);
        this.context = options.context || {};
    }
}
class Isolate {
    pool;
    code;
    context;
    constructor(pool, code, context = {}){
        this.pool = pool;
        this.code = code;
        this.context = context;
    }
    async run(request) {
        const normalized = normalizeRequest(request);
        const poolContext = this.pool?.context || {};
        const payload = serializeRequest(normalized, {
            ...poolContext,
            ...this.context
        });
        const resolved = resolveHandlerPath(this.code);
        const handlerKey = this.pool?.id ? `${this.pool.id}:${resolved}` : resolved;
        const response = await op_execute_isolate2(resolved, payload, handlerKey);
        const body = response.body_base64 ? decodeBase641(response.body_base64) : response.body ?? "";
        return new Response1(body, {
            status: response.status || 200,
            headers: response.headers || {}
        });
    }
}
function decodeBase641(value) {
    if (typeof atob === "function") {
        const binary = atob(value);
        const bytes = new Uint8Array(binary.length);
        for(let i = 0; i < binary.length; i += 1){
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
    }
    return decodeBase64Manual1(value);
}
function decodeBase64Manual1(value) {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const clean = value.replace(/[^A-Za-z0-9+/=]/g, "");
    let buffer = 0;
    let bits = 0;
    const bytes = [];
    for(let i = 0; i < clean.length; i += 1){
        const __char = clean[i];
        if (__char === "=") break;
        const idx = alphabet.indexOf(__char);
        if (idx < 0) continue;
        buffer = buffer << 6 | idx;
        bits += 6;
        if (bits >= 8) {
            bits -= 8;
            bytes.push(buffer >> bits & 0xff);
        }
    }
    return new Uint8Array(bytes);
}
installModuleLoader();
installJsxRuntime();
installRedis();
if (typeof globalThis.fs === "undefined" && globalThis.__dekaNodeFs) {
    globalThis.fs = globalThis.__dekaNodeFs;
}
if (typeof globalThis.path === "undefined" && globalThis.__dekaNodePath) {
    globalThis.path = globalThis.__dekaNodePath;
}
const dekaRouter = globalThis.__dekaRouter || {};
const dekaSqlite = globalThis.__dekaSqlite || {};
const dekaT4 = globalThis.__dekaT4 || {};
const dekaPostgres = globalThis.__dekaPostgres || {};
const dekaDocker = globalThis.__dekaDocker || {};
const Router1 = dekaRouter.Router;
const Context = dekaRouter.Context;
const cors = dekaRouter.cors;
const logger = dekaRouter.logger;
const basicAuth = dekaRouter.basicAuth;
const bearerAuth = dekaRouter.bearerAuth;
const rateLimit = dekaRouter.rateLimit;
const prettyJSON = dekaRouter.prettyJSON;
const Database1 = dekaSqlite.Database;
const Statement = dekaSqlite.Statement;
const t4 = dekaT4.t4;
const T4Client = dekaT4.T4Client;
const T4File = dekaT4.T4File;
const write1 = dekaT4.write;
const query = dekaPostgres.query;
const execute = dekaPostgres.execute;
const listContainers = dekaDocker.listContainers;
const createContainer = dekaDocker.createContainer;
const testApi = ()=>globalThis.__dekaTest;
const ensureTestApi = (name)=>{
    const api = testApi();
    if (!api || typeof api[name] !== "function") {
        throw new Error("Deka test runner not installed. Use `deka test` to run tests.");
    }
    return api;
};
const test1 = (...args)=>ensureTestApi("test").test(...args);
const it1 = (...args)=>ensureTestApi("it").it(...args);
const describe1 = (...args)=>ensureTestApi("describe").describe(...args);
const beforeAll = (...args)=>ensureTestApi("beforeAll").beforeAll(...args);
const afterAll = (...args)=>ensureTestApi("afterAll").afterAll(...args);
const beforeEach1 = (...args)=>ensureTestApi("beforeEach").beforeEach(...args);
const afterEach1 = (...args)=>ensureTestApi("afterEach").afterEach(...args);
const expect = (...args)=>ensureTestApi("expect").expect(...args);
globalThis.__deka = {
    Mesh,
    IsolatePool,
    Isolate,
    Router: Router1,
    Context,
    cors,
    logger,
    basicAuth,
    bearerAuth,
    rateLimit,
    prettyJSON,
    Database: Database1,
    Statement,
    t4,
    T4Client,
    T4File,
    write: write1,
    query,
    execute,
    listContainers,
    createContainer,
    jsx,
    jsxs,
    jsxDEV,
    Fragment,
    createElement,
    test: test1,
    it: it1,
    describe: describe1,
    beforeAll,
    afterAll,
    beforeEach: beforeEach1,
    afterEach: afterEach1,
    expect,
    serveIndexHtml,
    serveStaticDirectory,
    build: build1,
    RedisClient,
    redis,
    serve
};
globalThis.Deka = globalThis.__deka;
export { Mesh as Mesh, IsolatePool as IsolatePool, Isolate as Isolate, Router1 as Router, Context as Context, cors as cors, logger as logger, basicAuth as basicAuth, bearerAuth as bearerAuth, rateLimit as rateLimit, prettyJSON as prettyJSON, Database1 as Database, Statement as Statement, t4 as t4, T4Client as T4Client, T4File as T4File, write1 as write, query as query, execute as execute, listContainers as listContainers, createContainer as createContainer, jsx as jsx, jsxs as jsxs, jsxDEV as jsxDEV, Fragment as Fragment, createElement as createElement, test1 as test, it1 as it, describe1 as describe, beforeAll as beforeAll, afterAll as afterAll, beforeEach1 as beforeEach, afterEach1 as afterEach, expect as expect, serveIndexHtml as serveIndexHtml, serveStaticDirectory as serveStaticDirectory, build1 as build, RedisClient as RedisClient, redis as redis, serve as serve,  };
